// Generated code!
#![no_std]
#![allow(unused, clippy::let_and_return, clippy::eq_op)]

//! Message definitions from file `"Model3CAN.dbc"`
//!
//! - Version: `Version("")`

use bitvec::prelude::{BitField, BitStore, BitView, LocalBits};
#[cfg(feature = "arb")]
use arbitrary::{Arbitrary, Unstructured};

/// All messages
#[derive(Clone)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Messages {
    /// ID00CUI_status
    Id00cuiStatus(Id00cuiStatus),
    /// ID353UI_status
    Id353uiStatus(Id353uiStatus),
    /// ID016DI_bmsRequest
    Id016diBmsRequest(Id016diBmsRequest),
    /// ID082UI_tripPlanning
    Id082uiTripPlanning(Id082uiTripPlanning),
    /// ID101RCM_inertial1
    Id101rcmInertial1(Id101rcmInertial1),
    /// ID111RCM_inertial2
    Id111rcmInertial2(Id111rcmInertial2),
    /// RCM_inertial2New
    RcmInertial2New(RcmInertial2New),
    /// ID102VCLEFT_doorStatus
    Id102vcleftDoorStatus(Id102vcleftDoorStatus),
    /// ID103VCRIGHT_doorStatus
    Id103vcrightDoorStatus(Id103vcrightDoorStatus),
    /// ID113GTW_bmpDebug
    Id113gtwBmpDebug(Id113gtwBmpDebug),
    /// ID119VCSEC_windowRequests
    Id119vcsecWindowRequests(Id119vcsecWindowRequests),
    /// ID122VCLEFT_doorStatus2
    Id122vcleftDoorStatus2(Id122vcleftDoorStatus2),
    /// ID123UI_alertMatrix1
    Id123uiAlertMatrix1(Id123uiAlertMatrix1),
    /// ID142VCLEFT_liftgateStatus
    Id142vcleftLiftgateStatus(Id142vcleftLiftgateStatus),
    /// ID145ESP_status
    Id145espStatus(Id145espStatus),
    /// ID1D6DI_limits
    Id1d6diLimits(Id1d6diLimits),
    /// ID20AHVP_contactorState
    Id20ahvpContactorState(Id20ahvpContactorState),
    /// ID20EPARK_sdiFront
    Id20eparkSdiFront(Id20eparkSdiFront),
    /// ID219VCSEC_TPMSData
    Id219vcsecTpmsData(Id219vcsecTpmsData),
    /// ID204PCS_chgStatus
    Id204pcsChgStatus(Id204pcsChgStatus),
    /// ID22AHVP_pcsControl
    Id22ahvpPcsControl(Id22ahvpPcsControl),
    /// ID232BMS_contactorRequest
    Id232bmsContactorRequest(Id232bmsContactorRequest),
    /// ID273UI_vehicleControl
    Id273uiVehicleControl(Id273uiVehicleControl),
    /// ID27DCP_dcChargeLimits
    Id27dcpDcChargeLimits(Id27dcpDcChargeLimits),
    /// ID2BDCP_dcPowerLimits
    Id2bdcpDcPowerLimits(Id2bdcpDcPowerLimits),
    /// ID42AVCSEC_TPMSConnectionData
    Id42avcsecTpmsConnectionData(Id42avcsecTpmsConnectionData),
    /// ID22EPARK_sdiRear
    Id22eparkSdiRear(Id22eparkSdiRear),
    /// ID238UI_driverAssistMapData
    Id238uiDriverAssistMapData(Id238uiDriverAssistMapData),
    /// ID239DAS_lanes
    Id239dasLanes(Id239dasLanes),
    /// ID24ADAS_visualDebug
    Id24adasVisualDebug(Id24adasVisualDebug),
    /// ID25BAPP_environment
    Id25bappEnvironment(Id25bappEnvironment),
    /// ID25DCP_status
    Id25dcpStatus(Id25dcpStatus),
    /// ID29DCP_dcChargeStatus
    Id29dcpDcChargeStatus(Id29dcpDcChargeStatus),
    /// ID2B4PCS_dcdcRailStatus
    Id2b4pcsDcdcRailStatus(Id2b4pcsDcdcRailStatus),
    /// ID2B9DAS_control
    Id2b9dasControl(Id2b9dasControl),
    /// ID2D3UI_solarData
    Id2d3uiSolarData(Id2d3uiSolarData),
    /// ID309DAS_object
    Id309dasObject(Id309dasObject),
    /// ID389DAS_status2
    Id389dasStatus2(Id389dasStatus2),
    /// ID399DAS_status
    Id399dasStatus(Id399dasStatus),
    /// ID39DIBST_status
    Id39dibstStatus(Id39dibstStatus),
    /// ID3A1VCFRONT_vehicleStatus
    Id3a1vcfrontVehicleStatus(Id3a1vcfrontVehicleStatus),
    /// ID3D9UI_gpsVehicleSpeed
    Id3d9uiGpsVehicleSpeed(Id3d9uiGpsVehicleSpeed),
    /// ID3E2VCLEFT_lightStatus
    Id3e2vcleftLightStatus(Id3e2vcleftLightStatus),
    /// ID3E9DAS_bodyControls
    Id3e9dasBodyControls(Id3e9dasBodyControls),
    /// ID3F3UI_odo
    Id3f3uiOdo(Id3f3uiOdo),
    /// ID3F5VCFRONT_lighting
    Id3f5vcfrontLighting(Id3f5vcfrontLighting),
    /// ID3F8UI_driverAssistControl
    Id3f8uiDriverAssistControl(Id3f8uiDriverAssistControl),
    /// ID3FDUI_autopilotControl
    Id3fduiAutopilotControl(Id3fduiAutopilotControl),
    /// ID267DI_vehicleEstimates
    Id267diVehicleEstimates(Id267diVehicleEstimates),
    /// ID282VCLEFT_hvacBlowerFeedback
    Id282vcleftHvacBlowerFeedback(Id282vcleftHvacBlowerFeedback),
    /// ID2F3UI_hvacRequest
    Id2f3uiHvacRequest(Id2f3uiHvacRequest),
    /// ID313UI_trackModeSettings
    Id313uiTrackModeSettings(Id313uiTrackModeSettings),
    /// ID335RearDIinfo
    Id335RearDIinfo(Id335RearDIinfo),
    /// ID383VCRIGHT_thsStatus
    Id383vcrightThsStatus(Id383vcrightThsStatus),
    /// ID3B3UI_vehicleControl2
    Id3b3uiVehicleControl2(Id3b3uiVehicleControl2),
    /// ID3C3VCRIGHT_switchStatus
    Id3c3vcrightSwitchStatus(Id3c3vcrightSwitchStatus),
    /// ID3E3VCRIGHT_lightStatus
    Id3e3vcrightLightStatus(Id3e3vcrightLightStatus),
    /// ID656FrontDIinfo
    Id656FrontDIinfo(Id656FrontDIinfo),
    /// ID300BMS_info
    Id300bmsInfo(Id300bmsInfo),
    /// ID212BMS_status
    Id212bmsStatus(Id212bmsStatus),
    /// ID31CCC_chgStatus
    Id31cccChgStatus(Id31cccChgStatus),
    /// ID23DCP_chargeStatus
    Id23dcpChargeStatus(Id23dcpChargeStatus),
    /// ID13DCP_chargeStatus
    Id13dcpChargeStatus(Id13dcpChargeStatus),
    /// ID43DCP_chargeStatusLog
    Id43dcpChargeStatusLog(Id43dcpChargeStatusLog),
    /// ID21DCP_evseStatus
    Id21dcpEvseStatus(Id21dcpEvseStatus),
    /// ID743VCRIGHT_recallStatus
    Id743vcrightRecallStatus(Id743vcrightRecallStatus),
    /// ID75DCP_sensorData
    Id75dcpSensorData(Id75dcpSensorData),
    /// ID287PTCcabinHeatSensorStatus
    Id287ptCcabinHeatSensorStatus(Id287ptCcabinHeatSensorStatus),
    /// ID333UI_chargeRequest
    Id333uiChargeRequest(Id333uiChargeRequest),
    /// ID334UI_powertrainControl
    Id334uiPowertrainControl(Id334uiPowertrainControl),
    /// ID33AUI_rangeSOC
    Id33auiRangeSoc(Id33auiRangeSoc),
    /// ID241VCFRONT_coolant
    Id241vcfrontCoolant(Id241vcfrontCoolant),
    /// ID3BBUI_power
    Id3bbuiPower(Id3bbuiPower),
    /// ID5D5RearDItemps
    Id5d5RearDItemps(Id5d5RearDItemps),
    /// ID556FrontDItemps
    Id556FrontDItemps(Id556FrontDItemps),
    /// ID557FrontThermalControl
    Id557FrontThermalControl(Id557FrontThermalControl),
    /// ID5D7RearThermalControl
    Id5d7RearThermalControl(Id5d7RearThermalControl),
    /// ID7D5DIR_debug
    Id7d5dirDebug(Id7d5dirDebug),
    /// ID757DIF_debug
    Id757difDebug(Id757difDebug),
    /// ID2B6DI_chassisControlStatus
    Id2b6diChassisControlStatus(Id2b6diChassisControlStatus),
    /// ID284UIvehicleModes
    Id284uIvehicleModes(Id284uIvehicleModes),
    /// ID221VCFRONT_LVPowerState
    Id221vcfrontLvPowerState(Id221vcfrontLvPowerState),
    /// ID225VCRIGHT_LVPowerState
    Id225vcrightLvPowerState(Id225vcrightLvPowerState),
    /// ID2F1VCFRONT_eFuseDebugStatus
    Id2f1vcfrontEFuseDebugStatus(Id2f1vcfrontEFuseDebugStatus),
    /// ID242VCLEFT_LVPowerState
    Id242vcleftLvPowerState(Id242vcleftLvPowerState),
    /// ID243VCRIGHT_hvacStatus
    Id243vcrightHvacStatus(Id243vcrightHvacStatus),
    /// ID20CVCRIGHT_hvacRequest
    Id20cvcrightHvacRequest(Id20cvcrightHvacRequest),
    /// ID2E1VCFRONT_status
    Id2e1vcfrontStatus(Id2e1vcfrontStatus),
    /// ID381VCFRONT_logging1Hz
    Id381vcfrontLogging1Hz(Id381vcfrontLogging1Hz),
    /// ID318SystemTimeUTC
    Id318SystemTimeUtc(Id318SystemTimeUtc),
    /// ID528UnixTime
    Id528UnixTime(Id528UnixTime),
    /// ID229GearLever
    Id229GearLever(Id229GearLever),
    /// ID249SCCMLeftStalk
    Id249sccmLeftStalk(Id249sccmLeftStalk),
    /// ID186DIF_torque
    Id186difTorque(Id186difTorque),
    /// ID396FrontOilPump
    Id396FrontOilPump(Id396FrontOilPump),
    /// ID395DIR_oilPump
    Id395dirOilPump(Id395dirOilPump),
    /// ID1D8RearTorque
    Id1d8RearTorque(Id1d8RearTorque),
    /// ID155WheelAngles
    Id155WheelAngles(Id155WheelAngles),
    /// ID175WheelSpeed
    Id175WheelSpeed(Id175WheelSpeed),
    /// ID185ESP_brakeTorque
    Id185espBrakeTorque(Id185espBrakeTorque),
    /// ID1D4FrontTorqueOld
    Id1d4FrontTorqueOld(Id1d4FrontTorqueOld),
    /// ID1D5FrontTorque
    Id1d5FrontTorque(Id1d5FrontTorque),
    /// ID281VCFRONT_CMPRequest
    Id281vcfrontCmpRequest(Id281vcfrontCmpRequest),
    /// ID3C2VCLEFT_switchStatus
    Id3c2vcleftSwitchStatus(Id3c2vcleftSwitchStatus),
    /// ID336MaxPowerRating
    Id336MaxPowerRating(Id336MaxPowerRating),
    /// ID293UI_chassisControl
    Id293uiChassisControl(Id293uiChassisControl),
    /// ID268SystemPower
    Id268SystemPower(Id268SystemPower),
    /// ID04FGPSLatLong
    Id04fgpsLatLong(Id04fgpsLatLong),
    /// ID3D2TotalChargeDischarge
    Id3d2TotalChargeDischarge(Id3d2TotalChargeDischarge),
    /// ID3F2BMSCounters
    Id3f2bmsCounters(Id3f2bmsCounters),
    /// ID2D2BMSVAlimits
    Id2d2bmsvAlimits(Id2d2bmsvAlimits),
    /// ID541FastChargeMaxLimits
    Id541FastChargeMaxLimits(Id541FastChargeMaxLimits),
    /// ID244FastChargeLimits
    Id244FastChargeLimits(Id244FastChargeLimits),
    /// ID214FastChargeVA
    Id214FastChargeVa(Id214FastChargeVa),
    /// ID215FCisolation
    Id215fCisolation(Id215fCisolation),
    /// ID217FC_status3
    Id217fcStatus3(Id217fcStatus3),
    /// ID321VCFRONT_sensors
    Id321vcfrontSensors(Id321vcfrontSensors),
    /// ID301VCFRONT_info
    Id301vcfrontInfo(Id301vcfrontInfo),
    /// ID201VCFRONT_loggingAndVitals10H
    Id201vcfrontLoggingAndVitals10H(Id201vcfrontLoggingAndVitals10H),
    /// ID3D8Elevation
    Id3d8Elevation(Id3d8Elevation),
    /// ID261_12vBattStatus
    Id26112vBattStatus(Id26112vBattStatus),
    /// ID129SteeringAngle
    Id129SteeringAngle(Id129SteeringAngle),
    /// ID264ChargeLineStatus
    Id264ChargeLineStatus(Id264ChargeLineStatus),
    /// ID224PCSDCDCstatus
    Id224pcsdcdCstatus(Id224pcsdcdCstatus),
    /// ID227CMP_state
    Id227cmpState(Id227cmpState),
    /// ID118DriveSystemStatus
    Id118DriveSystemStatus(Id118DriveSystemStatus),
    /// ID352BMS_energyStatus
    Id352bmsEnergyStatus(Id352bmsEnergyStatus),
    /// ID37DCP_thermalStatus
    Id37dcpThermalStatus(Id37dcpThermalStatus),
    /// ID392BMS_packConfig
    Id392bmsPackConfig(Id392bmsPackConfig),
    /// ID252BMS_powerAvailable
    Id252bmsPowerAvailable(Id252bmsPowerAvailable),
    /// ID312BMSthermal
    Id312bmSthermal(Id312bmSthermal),
    /// ID292BMS_SOC
    Id292bmsSoc(Id292bmsSoc),
    /// ID257DIspeed
    Id257dIspeed(Id257dIspeed),
    /// ID2A8CMPD_state
    Id2a8cmpdState(Id2a8cmpdState),
    /// ID405VIN
    Id405vin(Id405vin),
    /// ID51EFC_info
    Id51efcInfo(Id51efcInfo),
    /// ID376FrontInverterTemps
    Id376FrontInverterTemps(Id376FrontInverterTemps),
    /// ID315RearInverterTemps
    Id315RearInverterTemps(Id315RearInverterTemps),
    /// ID154RearTorqueOld
    Id154RearTorqueOld(Id154RearTorqueOld),
    /// ID3B6odometer
    Id3b6odometer(Id3b6odometer),
    /// ID266RearInverterPower
    Id266RearInverterPower(Id266RearInverterPower),
    /// ID2E5FrontInverterPower
    Id2e5FrontInverterPower(Id2e5FrontInverterPower),
    /// ID2E6PlaidFrontPower
    Id2e6PlaidFrontPower(Id2e6PlaidFrontPower),
    /// ID269LeftRearPower
    Id269LeftRearPower(Id269LeftRearPower),
    /// ID27CRightRearPower
    Id27cRightRearPower(Id27cRightRearPower),
    /// ID108DIR_torque
    Id108dirTorque(Id108dirTorque),
    /// ID132HVBattAmpVolt
    Id132hvBattAmpVolt(Id132hvBattAmpVolt),
    /// ID126RearHVStatus
    Id126RearHvStatus(Id126RearHvStatus),
    /// ID1A5FrontHVStatus
    Id1a5FrontHvStatus(Id1a5FrontHvStatus),
    /// ID127LeftRearHVStatus
    Id127LeftRearHvStatus(Id127LeftRearHvStatus),
    /// ID12ARightRearHVStatus
    Id12aRightRearHvStatus(Id12aRightRearHvStatus),
    /// ID31FTPMSsensors
    Id31ftpmSsensors(Id31ftpmSsensors),
    /// ID3FEbrakeTemps
    Id3fEbrakeTemps(Id3fEbrakeTemps),
    /// ID228EPBrightStatus
    Id228epBrightStatus(Id228epBrightStatus),
    /// ID288EPBleftStatus
    Id288epBleftStatus(Id288epBleftStatus),
    /// ID72ABMS_serialNumber
    Id72abmsSerialNumber(Id72abmsSerialNumber),
    /// ID7FFcarConfig
    Id7fFcarConfig(Id7fFcarConfig),
    /// ID332BattBrickMinMax
    Id332BattBrickMinMax(Id332BattBrickMinMax),
    /// ID401BrickVoltages
    Id401BrickVoltages(Id401BrickVoltages),
}

impl Messages {
    /// Read message from CAN frame
    #[inline(never)]
    pub fn from_can_message(id: u32, payload: &[u8]) -> Result<Self, CanError> {
        use core::convert::TryFrom;
        
        let res = match id {
            12 => Messages::Id00cuiStatus(Id00cuiStatus::try_from(payload)?),
            851 => Messages::Id353uiStatus(Id353uiStatus::try_from(payload)?),
            22 => Messages::Id016diBmsRequest(Id016diBmsRequest::try_from(payload)?),
            130 => Messages::Id082uiTripPlanning(Id082uiTripPlanning::try_from(payload)?),
            257 => Messages::Id101rcmInertial1(Id101rcmInertial1::try_from(payload)?),
            273 => Messages::Id111rcmInertial2(Id111rcmInertial2::try_from(payload)?),
            278 => Messages::RcmInertial2New(RcmInertial2New::try_from(payload)?),
            258 => Messages::Id102vcleftDoorStatus(Id102vcleftDoorStatus::try_from(payload)?),
            259 => Messages::Id103vcrightDoorStatus(Id103vcrightDoorStatus::try_from(payload)?),
            275 => Messages::Id113gtwBmpDebug(Id113gtwBmpDebug::try_from(payload)?),
            281 => Messages::Id119vcsecWindowRequests(Id119vcsecWindowRequests::try_from(payload)?),
            290 => Messages::Id122vcleftDoorStatus2(Id122vcleftDoorStatus2::try_from(payload)?),
            291 => Messages::Id123uiAlertMatrix1(Id123uiAlertMatrix1::try_from(payload)?),
            322 => Messages::Id142vcleftLiftgateStatus(Id142vcleftLiftgateStatus::try_from(payload)?),
            325 => Messages::Id145espStatus(Id145espStatus::try_from(payload)?),
            470 => Messages::Id1d6diLimits(Id1d6diLimits::try_from(payload)?),
            522 => Messages::Id20ahvpContactorState(Id20ahvpContactorState::try_from(payload)?),
            526 => Messages::Id20eparkSdiFront(Id20eparkSdiFront::try_from(payload)?),
            537 => Messages::Id219vcsecTpmsData(Id219vcsecTpmsData::try_from(payload)?),
            516 => Messages::Id204pcsChgStatus(Id204pcsChgStatus::try_from(payload)?),
            554 => Messages::Id22ahvpPcsControl(Id22ahvpPcsControl::try_from(payload)?),
            562 => Messages::Id232bmsContactorRequest(Id232bmsContactorRequest::try_from(payload)?),
            627 => Messages::Id273uiVehicleControl(Id273uiVehicleControl::try_from(payload)?),
            637 => Messages::Id27dcpDcChargeLimits(Id27dcpDcChargeLimits::try_from(payload)?),
            701 => Messages::Id2bdcpDcPowerLimits(Id2bdcpDcPowerLimits::try_from(payload)?),
            1066 => Messages::Id42avcsecTpmsConnectionData(Id42avcsecTpmsConnectionData::try_from(payload)?),
            558 => Messages::Id22eparkSdiRear(Id22eparkSdiRear::try_from(payload)?),
            568 => Messages::Id238uiDriverAssistMapData(Id238uiDriverAssistMapData::try_from(payload)?),
            569 => Messages::Id239dasLanes(Id239dasLanes::try_from(payload)?),
            586 => Messages::Id24adasVisualDebug(Id24adasVisualDebug::try_from(payload)?),
            603 => Messages::Id25bappEnvironment(Id25bappEnvironment::try_from(payload)?),
            605 => Messages::Id25dcpStatus(Id25dcpStatus::try_from(payload)?),
            669 => Messages::Id29dcpDcChargeStatus(Id29dcpDcChargeStatus::try_from(payload)?),
            692 => Messages::Id2b4pcsDcdcRailStatus(Id2b4pcsDcdcRailStatus::try_from(payload)?),
            697 => Messages::Id2b9dasControl(Id2b9dasControl::try_from(payload)?),
            723 => Messages::Id2d3uiSolarData(Id2d3uiSolarData::try_from(payload)?),
            777 => Messages::Id309dasObject(Id309dasObject::try_from(payload)?),
            905 => Messages::Id389dasStatus2(Id389dasStatus2::try_from(payload)?),
            921 => Messages::Id399dasStatus(Id399dasStatus::try_from(payload)?),
            925 => Messages::Id39dibstStatus(Id39dibstStatus::try_from(payload)?),
            929 => Messages::Id3a1vcfrontVehicleStatus(Id3a1vcfrontVehicleStatus::try_from(payload)?),
            985 => Messages::Id3d9uiGpsVehicleSpeed(Id3d9uiGpsVehicleSpeed::try_from(payload)?),
            994 => Messages::Id3e2vcleftLightStatus(Id3e2vcleftLightStatus::try_from(payload)?),
            1001 => Messages::Id3e9dasBodyControls(Id3e9dasBodyControls::try_from(payload)?),
            1011 => Messages::Id3f3uiOdo(Id3f3uiOdo::try_from(payload)?),
            1013 => Messages::Id3f5vcfrontLighting(Id3f5vcfrontLighting::try_from(payload)?),
            1016 => Messages::Id3f8uiDriverAssistControl(Id3f8uiDriverAssistControl::try_from(payload)?),
            1021 => Messages::Id3fduiAutopilotControl(Id3fduiAutopilotControl::try_from(payload)?),
            615 => Messages::Id267diVehicleEstimates(Id267diVehicleEstimates::try_from(payload)?),
            642 => Messages::Id282vcleftHvacBlowerFeedback(Id282vcleftHvacBlowerFeedback::try_from(payload)?),
            755 => Messages::Id2f3uiHvacRequest(Id2f3uiHvacRequest::try_from(payload)?),
            787 => Messages::Id313uiTrackModeSettings(Id313uiTrackModeSettings::try_from(payload)?),
            821 => Messages::Id335RearDIinfo(Id335RearDIinfo::try_from(payload)?),
            899 => Messages::Id383vcrightThsStatus(Id383vcrightThsStatus::try_from(payload)?),
            947 => Messages::Id3b3uiVehicleControl2(Id3b3uiVehicleControl2::try_from(payload)?),
            963 => Messages::Id3c3vcrightSwitchStatus(Id3c3vcrightSwitchStatus::try_from(payload)?),
            995 => Messages::Id3e3vcrightLightStatus(Id3e3vcrightLightStatus::try_from(payload)?),
            1622 => Messages::Id656FrontDIinfo(Id656FrontDIinfo::try_from(payload)?),
            768 => Messages::Id300bmsInfo(Id300bmsInfo::try_from(payload)?),
            530 => Messages::Id212bmsStatus(Id212bmsStatus::try_from(payload)?),
            796 => Messages::Id31cccChgStatus(Id31cccChgStatus::try_from(payload)?),
            573 => Messages::Id23dcpChargeStatus(Id23dcpChargeStatus::try_from(payload)?),
            317 => Messages::Id13dcpChargeStatus(Id13dcpChargeStatus::try_from(payload)?),
            1085 => Messages::Id43dcpChargeStatusLog(Id43dcpChargeStatusLog::try_from(payload)?),
            541 => Messages::Id21dcpEvseStatus(Id21dcpEvseStatus::try_from(payload)?),
            1859 => Messages::Id743vcrightRecallStatus(Id743vcrightRecallStatus::try_from(payload)?),
            1885 => Messages::Id75dcpSensorData(Id75dcpSensorData::try_from(payload)?),
            647 => Messages::Id287ptCcabinHeatSensorStatus(Id287ptCcabinHeatSensorStatus::try_from(payload)?),
            819 => Messages::Id333uiChargeRequest(Id333uiChargeRequest::try_from(payload)?),
            820 => Messages::Id334uiPowertrainControl(Id334uiPowertrainControl::try_from(payload)?),
            826 => Messages::Id33auiRangeSoc(Id33auiRangeSoc::try_from(payload)?),
            577 => Messages::Id241vcfrontCoolant(Id241vcfrontCoolant::try_from(payload)?),
            955 => Messages::Id3bbuiPower(Id3bbuiPower::try_from(payload)?),
            1493 => Messages::Id5d5RearDItemps(Id5d5RearDItemps::try_from(payload)?),
            1366 => Messages::Id556FrontDItemps(Id556FrontDItemps::try_from(payload)?),
            1367 => Messages::Id557FrontThermalControl(Id557FrontThermalControl::try_from(payload)?),
            1495 => Messages::Id5d7RearThermalControl(Id5d7RearThermalControl::try_from(payload)?),
            2005 => Messages::Id7d5dirDebug(Id7d5dirDebug::try_from(payload)?),
            1879 => Messages::Id757difDebug(Id757difDebug::try_from(payload)?),
            694 => Messages::Id2b6diChassisControlStatus(Id2b6diChassisControlStatus::try_from(payload)?),
            644 => Messages::Id284uIvehicleModes(Id284uIvehicleModes::try_from(payload)?),
            545 => Messages::Id221vcfrontLvPowerState(Id221vcfrontLvPowerState::try_from(payload)?),
            549 => Messages::Id225vcrightLvPowerState(Id225vcrightLvPowerState::try_from(payload)?),
            753 => Messages::Id2f1vcfrontEFuseDebugStatus(Id2f1vcfrontEFuseDebugStatus::try_from(payload)?),
            578 => Messages::Id242vcleftLvPowerState(Id242vcleftLvPowerState::try_from(payload)?),
            579 => Messages::Id243vcrightHvacStatus(Id243vcrightHvacStatus::try_from(payload)?),
            524 => Messages::Id20cvcrightHvacRequest(Id20cvcrightHvacRequest::try_from(payload)?),
            737 => Messages::Id2e1vcfrontStatus(Id2e1vcfrontStatus::try_from(payload)?),
            897 => Messages::Id381vcfrontLogging1Hz(Id381vcfrontLogging1Hz::try_from(payload)?),
            792 => Messages::Id318SystemTimeUtc(Id318SystemTimeUtc::try_from(payload)?),
            1320 => Messages::Id528UnixTime(Id528UnixTime::try_from(payload)?),
            553 => Messages::Id229GearLever(Id229GearLever::try_from(payload)?),
            585 => Messages::Id249sccmLeftStalk(Id249sccmLeftStalk::try_from(payload)?),
            390 => Messages::Id186difTorque(Id186difTorque::try_from(payload)?),
            918 => Messages::Id396FrontOilPump(Id396FrontOilPump::try_from(payload)?),
            917 => Messages::Id395dirOilPump(Id395dirOilPump::try_from(payload)?),
            472 => Messages::Id1d8RearTorque(Id1d8RearTorque::try_from(payload)?),
            341 => Messages::Id155WheelAngles(Id155WheelAngles::try_from(payload)?),
            373 => Messages::Id175WheelSpeed(Id175WheelSpeed::try_from(payload)?),
            389 => Messages::Id185espBrakeTorque(Id185espBrakeTorque::try_from(payload)?),
            468 => Messages::Id1d4FrontTorqueOld(Id1d4FrontTorqueOld::try_from(payload)?),
            469 => Messages::Id1d5FrontTorque(Id1d5FrontTorque::try_from(payload)?),
            641 => Messages::Id281vcfrontCmpRequest(Id281vcfrontCmpRequest::try_from(payload)?),
            962 => Messages::Id3c2vcleftSwitchStatus(Id3c2vcleftSwitchStatus::try_from(payload)?),
            822 => Messages::Id336MaxPowerRating(Id336MaxPowerRating::try_from(payload)?),
            659 => Messages::Id293uiChassisControl(Id293uiChassisControl::try_from(payload)?),
            616 => Messages::Id268SystemPower(Id268SystemPower::try_from(payload)?),
            79 => Messages::Id04fgpsLatLong(Id04fgpsLatLong::try_from(payload)?),
            978 => Messages::Id3d2TotalChargeDischarge(Id3d2TotalChargeDischarge::try_from(payload)?),
            1010 => Messages::Id3f2bmsCounters(Id3f2bmsCounters::try_from(payload)?),
            722 => Messages::Id2d2bmsvAlimits(Id2d2bmsvAlimits::try_from(payload)?),
            1345 => Messages::Id541FastChargeMaxLimits(Id541FastChargeMaxLimits::try_from(payload)?),
            580 => Messages::Id244FastChargeLimits(Id244FastChargeLimits::try_from(payload)?),
            532 => Messages::Id214FastChargeVa(Id214FastChargeVa::try_from(payload)?),
            533 => Messages::Id215fCisolation(Id215fCisolation::try_from(payload)?),
            535 => Messages::Id217fcStatus3(Id217fcStatus3::try_from(payload)?),
            801 => Messages::Id321vcfrontSensors(Id321vcfrontSensors::try_from(payload)?),
            769 => Messages::Id301vcfrontInfo(Id301vcfrontInfo::try_from(payload)?),
            513 => Messages::Id201vcfrontLoggingAndVitals10H(Id201vcfrontLoggingAndVitals10H::try_from(payload)?),
            984 => Messages::Id3d8Elevation(Id3d8Elevation::try_from(payload)?),
            609 => Messages::Id26112vBattStatus(Id26112vBattStatus::try_from(payload)?),
            297 => Messages::Id129SteeringAngle(Id129SteeringAngle::try_from(payload)?),
            612 => Messages::Id264ChargeLineStatus(Id264ChargeLineStatus::try_from(payload)?),
            548 => Messages::Id224pcsdcdCstatus(Id224pcsdcdCstatus::try_from(payload)?),
            551 => Messages::Id227cmpState(Id227cmpState::try_from(payload)?),
            280 => Messages::Id118DriveSystemStatus(Id118DriveSystemStatus::try_from(payload)?),
            850 => Messages::Id352bmsEnergyStatus(Id352bmsEnergyStatus::try_from(payload)?),
            893 => Messages::Id37dcpThermalStatus(Id37dcpThermalStatus::try_from(payload)?),
            914 => Messages::Id392bmsPackConfig(Id392bmsPackConfig::try_from(payload)?),
            594 => Messages::Id252bmsPowerAvailable(Id252bmsPowerAvailable::try_from(payload)?),
            786 => Messages::Id312bmSthermal(Id312bmSthermal::try_from(payload)?),
            658 => Messages::Id292bmsSoc(Id292bmsSoc::try_from(payload)?),
            599 => Messages::Id257dIspeed(Id257dIspeed::try_from(payload)?),
            680 => Messages::Id2a8cmpdState(Id2a8cmpdState::try_from(payload)?),
            1029 => Messages::Id405vin(Id405vin::try_from(payload)?),
            1310 => Messages::Id51efcInfo(Id51efcInfo::try_from(payload)?),
            886 => Messages::Id376FrontInverterTemps(Id376FrontInverterTemps::try_from(payload)?),
            789 => Messages::Id315RearInverterTemps(Id315RearInverterTemps::try_from(payload)?),
            340 => Messages::Id154RearTorqueOld(Id154RearTorqueOld::try_from(payload)?),
            950 => Messages::Id3b6odometer(Id3b6odometer::try_from(payload)?),
            614 => Messages::Id266RearInverterPower(Id266RearInverterPower::try_from(payload)?),
            741 => Messages::Id2e5FrontInverterPower(Id2e5FrontInverterPower::try_from(payload)?),
            742 => Messages::Id2e6PlaidFrontPower(Id2e6PlaidFrontPower::try_from(payload)?),
            617 => Messages::Id269LeftRearPower(Id269LeftRearPower::try_from(payload)?),
            636 => Messages::Id27cRightRearPower(Id27cRightRearPower::try_from(payload)?),
            264 => Messages::Id108dirTorque(Id108dirTorque::try_from(payload)?),
            306 => Messages::Id132hvBattAmpVolt(Id132hvBattAmpVolt::try_from(payload)?),
            294 => Messages::Id126RearHvStatus(Id126RearHvStatus::try_from(payload)?),
            421 => Messages::Id1a5FrontHvStatus(Id1a5FrontHvStatus::try_from(payload)?),
            295 => Messages::Id127LeftRearHvStatus(Id127LeftRearHvStatus::try_from(payload)?),
            298 => Messages::Id12aRightRearHvStatus(Id12aRightRearHvStatus::try_from(payload)?),
            799 => Messages::Id31ftpmSsensors(Id31ftpmSsensors::try_from(payload)?),
            1022 => Messages::Id3fEbrakeTemps(Id3fEbrakeTemps::try_from(payload)?),
            552 => Messages::Id228epBrightStatus(Id228epBrightStatus::try_from(payload)?),
            648 => Messages::Id288epBleftStatus(Id288epBleftStatus::try_from(payload)?),
            1834 => Messages::Id72abmsSerialNumber(Id72abmsSerialNumber::try_from(payload)?),
            2047 => Messages::Id7fFcarConfig(Id7fFcarConfig::try_from(payload)?),
            818 => Messages::Id332BattBrickMinMax(Id332BattBrickMinMax::try_from(payload)?),
            1025 => Messages::Id401BrickVoltages(Id401BrickVoltages::try_from(payload)?),
            n => return Err(CanError::UnknownMessageId(n)),
        };
        Ok(res)
    }
}

/// ID00CUI_status
///
/// - ID: 12 (0xc)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id00cuiStatus {
    raw: [u8; 8],
}

impl Id00cuiStatus {
    pub const MESSAGE_ID: u32 = 12;
    
    /// Construct new ID00CUI_status from values
    pub fn new(ui_audio_active: bool, ui_autopilot_trial: u8, ui_bluetooth_active: bool, ui_camera_active: bool, ui_cell_active: bool, ui_cell_connected: bool, ui_cell_network_technology: u8, ui_cell_receiver_power: f32, ui_cell_signal_bars: u8, ui_cpu_temperature: f32, ui_development_car: bool, ui_display_on: bool, ui_display_ready: bool, ui_factory_reset: u8, ui_false_touch_counter: u8, ui_gps_active: bool, ui_pcb_temperature: f32, ui_radio_active: bool, ui_ready_for_drive: bool, ui_screenshot_active: bool, ui_system_active: bool, ui_touch_active: bool, ui_vpn_active: bool, ui_wifi_active: bool, ui_wifi_connected: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_audio_active(ui_audio_active)?;
        res.set_ui_autopilot_trial(ui_autopilot_trial)?;
        res.set_ui_bluetooth_active(ui_bluetooth_active)?;
        res.set_ui_camera_active(ui_camera_active)?;
        res.set_ui_cell_active(ui_cell_active)?;
        res.set_ui_cell_connected(ui_cell_connected)?;
        res.set_ui_cell_network_technology(ui_cell_network_technology)?;
        res.set_ui_cell_receiver_power(ui_cell_receiver_power)?;
        res.set_ui_cell_signal_bars(ui_cell_signal_bars)?;
        res.set_ui_cpu_temperature(ui_cpu_temperature)?;
        res.set_ui_development_car(ui_development_car)?;
        res.set_ui_display_on(ui_display_on)?;
        res.set_ui_display_ready(ui_display_ready)?;
        res.set_ui_factory_reset(ui_factory_reset)?;
        res.set_ui_false_touch_counter(ui_false_touch_counter)?;
        res.set_ui_gps_active(ui_gps_active)?;
        res.set_ui_pcb_temperature(ui_pcb_temperature)?;
        res.set_ui_radio_active(ui_radio_active)?;
        res.set_ui_ready_for_drive(ui_ready_for_drive)?;
        res.set_ui_screenshot_active(ui_screenshot_active)?;
        res.set_ui_system_active(ui_system_active)?;
        res.set_ui_touch_active(ui_touch_active)?;
        res.set_ui_vpn_active(ui_vpn_active)?;
        res.set_ui_wifi_active(ui_wifi_active)?;
        res.set_ui_wifi_connected(ui_wifi_connected)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_audioActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_audio_active(&self) -> bool {
        self.ui_audio_active_raw()
    }
    
    /// Get raw value of UI_audioActive
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_audio_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_audioActive
    #[inline(always)]
    pub fn set_ui_audio_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_autopilotTrial
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_autopilot_trial(&self) -> Id00cuiStatusUiAutopilotTrial {
        match self.ui_autopilot_trial_raw() {
            3 => Id00cuiStatusUiAutopilotTrial::Active,
            0 => Id00cuiStatusUiAutopilotTrial::None,
            1 => Id00cuiStatusUiAutopilotTrial::Start,
            2 => Id00cuiStatusUiAutopilotTrial::Stop,
            x => Id00cuiStatusUiAutopilotTrial::Other(x),
        }
    }
    
    /// Get raw value of UI_autopilotTrial
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_autopilot_trial_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_autopilotTrial
    #[inline(always)]
    pub fn set_ui_autopilot_trial(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// UI_bluetoothActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_bluetooth_active(&self) -> bool {
        self.ui_bluetooth_active_raw()
    }
    
    /// Get raw value of UI_bluetoothActive
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_bluetooth_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_bluetoothActive
    #[inline(always)]
    pub fn set_ui_bluetooth_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UI_cameraActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_camera_active(&self) -> bool {
        self.ui_camera_active_raw()
    }
    
    /// Get raw value of UI_cameraActive
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_camera_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cameraActive
    #[inline(always)]
    pub fn set_ui_camera_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// UI_cellActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_active(&self) -> bool {
        self.ui_cell_active_raw()
    }
    
    /// Get raw value of UI_cellActive
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cellActive
    #[inline(always)]
    pub fn set_ui_cell_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_cellConnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_connected(&self) -> bool {
        self.ui_cell_connected_raw()
    }
    
    /// Get raw value of UI_cellConnected
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_connected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cellConnected
    #[inline(always)]
    pub fn set_ui_cell_connected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// UI_cellNetworkTechnology
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_network_technology(&self) -> Id00cuiStatusUiCellNetworkTechnology {
        match self.ui_cell_network_technology_raw() {
            9 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkCdma,
            2 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkEdge,
            1 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkGprs,
            8 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkGsm,
            4 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkHsdpa,
            6 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkHspa,
            5 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkHsupa,
            7 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkLte,
            0 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkNone,
            15 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkSna,
            3 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkUmts,
            10 => Id00cuiStatusUiCellNetworkTechnology::CellNetworkWcdma,
            x => Id00cuiStatusUiCellNetworkTechnology::Other(x),
        }
    }
    
    /// Get raw value of UI_cellNetworkTechnology
    ///
    /// - Start bit: 19
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_network_technology_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[19..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_cellNetworkTechnology
    #[inline(always)]
    pub fn set_ui_cell_network_technology(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        self.raw.view_bits_mut::<LocalBits>()[19..23].store_le(value);
        Ok(())
    }
    
    /// UI_cellReceiverPower
    ///
    /// - Min: -128
    /// - Max: 127
    /// - Unit: "dB"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_receiver_power(&self) -> f32 {
        self.ui_cell_receiver_power_raw()
    }
    
    /// Get raw value of UI_cellReceiverPower
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -128
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_receiver_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -128_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_cellReceiverPower
    #[inline(always)]
    pub fn set_ui_cell_receiver_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        let factor = 1_f32;
        let offset = -128_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// UI_cellSignalBars
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_signal_bars(&self) -> Id00cuiStatusUiCellSignalBars {
        match self.ui_cell_signal_bars_raw() {
            5 => Id00cuiStatusUiCellSignalBars::Five,
            4 => Id00cuiStatusUiCellSignalBars::Four,
            1 => Id00cuiStatusUiCellSignalBars::One,
            7 => Id00cuiStatusUiCellSignalBars::Sna,
            3 => Id00cuiStatusUiCellSignalBars::Three,
            2 => Id00cuiStatusUiCellSignalBars::Two,
            0 => Id00cuiStatusUiCellSignalBars::Zero,
            x => Id00cuiStatusUiCellSignalBars::Other(x),
        }
    }
    
    /// Get raw value of UI_cellSignalBars
    ///
    /// - Start bit: 42
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_signal_bars_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_cellSignalBars
    #[inline(always)]
    pub fn set_ui_cell_signal_bars(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..45].store_le(value);
        Ok(())
    }
    
    /// UI_cpuTemperature
    ///
    /// - Min: -20
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cpu_temperature(&self) -> f32 {
        self.ui_cpu_temperature_raw()
    }
    
    /// Get raw value of UI_cpuTemperature
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_cpu_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_cpuTemperature
    #[inline(always)]
    pub fn set_ui_cpu_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        let factor = 1_f32;
        let offset = 40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// UI_developmentCar
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_development_car(&self) -> bool {
        self.ui_development_car_raw()
    }
    
    /// Get raw value of UI_developmentCar
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_development_car_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_developmentCar
    #[inline(always)]
    pub fn set_ui_development_car(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// UI_displayOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_display_on(&self) -> bool {
        self.ui_display_on_raw()
    }
    
    /// Get raw value of UI_displayOn
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_display_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_displayOn
    #[inline(always)]
    pub fn set_ui_display_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// UI_displayReady
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_display_ready(&self) -> bool {
        self.ui_display_ready_raw()
    }
    
    /// Get raw value of UI_displayReady
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_display_ready_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_displayReady
    #[inline(always)]
    pub fn set_ui_display_ready(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_factoryReset
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_factory_reset(&self) -> Id00cuiStatusUiFactoryReset {
        match self.ui_factory_reset_raw() {
            3 => Id00cuiStatusUiFactoryReset::Customer,
            1 => Id00cuiStatusUiFactoryReset::Developer,
            2 => Id00cuiStatusUiFactoryReset::Diagnostic,
            0 => Id00cuiStatusUiFactoryReset::NoneSna,
            x => Id00cuiStatusUiFactoryReset::Other(x),
        }
    }
    
    /// Get raw value of UI_factoryReset
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_factory_reset_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_factoryReset
    #[inline(always)]
    pub fn set_ui_factory_reset(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// UI_falseTouchCounter
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_false_touch_counter(&self) -> u8 {
        self.ui_false_touch_counter_raw()
    }
    
    /// Get raw value of UI_falseTouchCounter
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_false_touch_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_falseTouchCounter
    #[inline(always)]
    pub fn set_ui_false_touch_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// UI_gpsActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_active(&self) -> bool {
        self.ui_gps_active_raw()
    }
    
    /// Get raw value of UI_gpsActive
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_gpsActive
    #[inline(always)]
    pub fn set_ui_gps_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// UI_pcbTemperature
    ///
    /// - Min: -20
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_pcb_temperature(&self) -> f32 {
        self.ui_pcb_temperature_raw()
    }
    
    /// Get raw value of UI_pcbTemperature
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_pcb_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_pcbTemperature
    #[inline(always)]
    pub fn set_ui_pcb_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 12 }); }
        let factor = 1_f32;
        let offset = 40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// UI_radioActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_radio_active(&self) -> bool {
        self.ui_radio_active_raw()
    }
    
    /// Get raw value of UI_radioActive
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_radio_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_radioActive
    #[inline(always)]
    pub fn set_ui_radio_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// UI_readyForDrive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ready_for_drive(&self) -> bool {
        self.ui_ready_for_drive_raw()
    }
    
    /// Get raw value of UI_readyForDrive
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ready_for_drive_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_readyForDrive
    #[inline(always)]
    pub fn set_ui_ready_for_drive(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// UI_screenshotActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_screenshot_active(&self) -> bool {
        self.ui_screenshot_active_raw()
    }
    
    /// Get raw value of UI_screenshotActive
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_screenshot_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_screenshotActive
    #[inline(always)]
    pub fn set_ui_screenshot_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// UI_systemActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_system_active(&self) -> bool {
        self.ui_system_active_raw()
    }
    
    /// Get raw value of UI_systemActive
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_system_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_systemActive
    #[inline(always)]
    pub fn set_ui_system_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// UI_touchActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_touch_active(&self) -> bool {
        self.ui_touch_active_raw()
    }
    
    /// Get raw value of UI_touchActive
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_touch_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_touchActive
    #[inline(always)]
    pub fn set_ui_touch_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_vpnActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_vpn_active(&self) -> bool {
        self.ui_vpn_active_raw()
    }
    
    /// Get raw value of UI_vpnActive
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_vpn_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_vpnActive
    #[inline(always)]
    pub fn set_ui_vpn_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// UI_wifiActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wifi_active(&self) -> bool {
        self.ui_wifi_active_raw()
    }
    
    /// Get raw value of UI_wifiActive
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wifi_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_wifiActive
    #[inline(always)]
    pub fn set_ui_wifi_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// UI_wifiConnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wifi_connected(&self) -> bool {
        self.ui_wifi_connected_raw()
    }
    
    /// Get raw value of UI_wifiConnected
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wifi_connected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_wifiConnected
    #[inline(always)]
    pub fn set_ui_wifi_connected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id00cuiStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id00cuiStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_audio_active = u.int_in_range(0..=1)? == 1;
        let ui_autopilot_trial = u.int_in_range(0..=3)?;
        let ui_bluetooth_active = u.int_in_range(0..=1)? == 1;
        let ui_camera_active = u.int_in_range(0..=1)? == 1;
        let ui_cell_active = u.int_in_range(0..=1)? == 1;
        let ui_cell_connected = u.int_in_range(0..=1)? == 1;
        let ui_cell_network_technology = u.int_in_range(0..=15)?;
        let ui_cell_receiver_power = -128_f32;
        let ui_cell_signal_bars = u.int_in_range(0..=7)?;
        let ui_cpu_temperature = -20_f32;
        let ui_development_car = u.int_in_range(0..=1)? == 1;
        let ui_display_on = u.int_in_range(0..=1)? == 1;
        let ui_display_ready = u.int_in_range(0..=1)? == 1;
        let ui_factory_reset = u.int_in_range(0..=3)?;
        let ui_false_touch_counter = u.int_in_range(0..=255)?;
        let ui_gps_active = u.int_in_range(0..=1)? == 1;
        let ui_pcb_temperature = -20_f32;
        let ui_radio_active = u.int_in_range(0..=1)? == 1;
        let ui_ready_for_drive = u.int_in_range(0..=1)? == 1;
        let ui_screenshot_active = u.int_in_range(0..=1)? == 1;
        let ui_system_active = u.int_in_range(0..=1)? == 1;
        let ui_touch_active = u.int_in_range(0..=1)? == 1;
        let ui_vpn_active = u.int_in_range(0..=1)? == 1;
        let ui_wifi_active = u.int_in_range(0..=1)? == 1;
        let ui_wifi_connected = u.int_in_range(0..=1)? == 1;
        Id00cuiStatus::new(ui_audio_active,ui_autopilot_trial,ui_bluetooth_active,ui_camera_active,ui_cell_active,ui_cell_connected,ui_cell_network_technology,ui_cell_receiver_power,ui_cell_signal_bars,ui_cpu_temperature,ui_development_car,ui_display_on,ui_display_ready,ui_factory_reset,ui_false_touch_counter,ui_gps_active,ui_pcb_temperature,ui_radio_active,ui_ready_for_drive,ui_screenshot_active,ui_system_active,ui_touch_active,ui_vpn_active,ui_wifi_active,ui_wifi_connected).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_autopilotTrial
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id00cuiStatusUiAutopilotTrial {
    Active,
    None,
    Start,
    Stop,
    Other(u8),
}
/// Defined values for UI_cellNetworkTechnology
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id00cuiStatusUiCellNetworkTechnology {
    CellNetworkCdma,
    CellNetworkEdge,
    CellNetworkGprs,
    CellNetworkGsm,
    CellNetworkHsdpa,
    CellNetworkHspa,
    CellNetworkHsupa,
    CellNetworkLte,
    CellNetworkNone,
    CellNetworkSna,
    CellNetworkUmts,
    CellNetworkWcdma,
    Other(u8),
}
/// Defined values for UI_cellSignalBars
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id00cuiStatusUiCellSignalBars {
    Five,
    Four,
    One,
    Sna,
    Three,
    Two,
    Zero,
    Other(u8),
}
/// Defined values for UI_factoryReset
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id00cuiStatusUiFactoryReset {
    Customer,
    Developer,
    Diagnostic,
    NoneSna,
    Other(u8),
}

/// ID353UI_status
///
/// - ID: 851 (0x353)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id353uiStatus {
    raw: [u8; 8],
}

impl Id353uiStatus {
    pub const MESSAGE_ID: u32 = 851;
    
    /// Construct new ID353UI_status from values
    pub fn new(ui_audio_active: bool, ui_autopilot_trial: u8, ui_bluetooth_active: bool, ui_camera_active: bool, ui_cell_active: bool, ui_cell_connected: bool, ui_cell_network_technology: u8, ui_cell_receiver_power: f32, ui_cell_signal_bars: u8, ui_cpu_temperature: f32, ui_development_car: bool, ui_display_on: bool, ui_display_ready: bool, ui_factory_reset: u8, ui_false_touch_counter: u8, ui_gps_active: bool, ui_pcb_temperature: f32, ui_radio_active: bool, ui_ready_for_drive: bool, ui_screenshot_active: bool, ui_system_active: bool, ui_touch_active: bool, ui_vpn_active: bool, ui_wifi_active: bool, ui_wifi_connected: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_audio_active(ui_audio_active)?;
        res.set_ui_autopilot_trial(ui_autopilot_trial)?;
        res.set_ui_bluetooth_active(ui_bluetooth_active)?;
        res.set_ui_camera_active(ui_camera_active)?;
        res.set_ui_cell_active(ui_cell_active)?;
        res.set_ui_cell_connected(ui_cell_connected)?;
        res.set_ui_cell_network_technology(ui_cell_network_technology)?;
        res.set_ui_cell_receiver_power(ui_cell_receiver_power)?;
        res.set_ui_cell_signal_bars(ui_cell_signal_bars)?;
        res.set_ui_cpu_temperature(ui_cpu_temperature)?;
        res.set_ui_development_car(ui_development_car)?;
        res.set_ui_display_on(ui_display_on)?;
        res.set_ui_display_ready(ui_display_ready)?;
        res.set_ui_factory_reset(ui_factory_reset)?;
        res.set_ui_false_touch_counter(ui_false_touch_counter)?;
        res.set_ui_gps_active(ui_gps_active)?;
        res.set_ui_pcb_temperature(ui_pcb_temperature)?;
        res.set_ui_radio_active(ui_radio_active)?;
        res.set_ui_ready_for_drive(ui_ready_for_drive)?;
        res.set_ui_screenshot_active(ui_screenshot_active)?;
        res.set_ui_system_active(ui_system_active)?;
        res.set_ui_touch_active(ui_touch_active)?;
        res.set_ui_vpn_active(ui_vpn_active)?;
        res.set_ui_wifi_active(ui_wifi_active)?;
        res.set_ui_wifi_connected(ui_wifi_connected)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_audioActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_audio_active(&self) -> bool {
        self.ui_audio_active_raw()
    }
    
    /// Get raw value of UI_audioActive
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_audio_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_audioActive
    #[inline(always)]
    pub fn set_ui_audio_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_autopilotTrial
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_autopilot_trial(&self) -> u8 {
        self.ui_autopilot_trial_raw()
    }
    
    /// Get raw value of UI_autopilotTrial
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_autopilot_trial_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_autopilotTrial
    #[inline(always)]
    pub fn set_ui_autopilot_trial(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// UI_bluetoothActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_bluetooth_active(&self) -> bool {
        self.ui_bluetooth_active_raw()
    }
    
    /// Get raw value of UI_bluetoothActive
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_bluetooth_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_bluetoothActive
    #[inline(always)]
    pub fn set_ui_bluetooth_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UI_cameraActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_camera_active(&self) -> bool {
        self.ui_camera_active_raw()
    }
    
    /// Get raw value of UI_cameraActive
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_camera_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cameraActive
    #[inline(always)]
    pub fn set_ui_camera_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// UI_cellActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_active(&self) -> bool {
        self.ui_cell_active_raw()
    }
    
    /// Get raw value of UI_cellActive
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cellActive
    #[inline(always)]
    pub fn set_ui_cell_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_cellConnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_connected(&self) -> bool {
        self.ui_cell_connected_raw()
    }
    
    /// Get raw value of UI_cellConnected
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_connected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cellConnected
    #[inline(always)]
    pub fn set_ui_cell_connected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// UI_cellNetworkTechnology
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_network_technology(&self) -> u8 {
        self.ui_cell_network_technology_raw()
    }
    
    /// Get raw value of UI_cellNetworkTechnology
    ///
    /// - Start bit: 19
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_network_technology_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[19..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_cellNetworkTechnology
    #[inline(always)]
    pub fn set_ui_cell_network_technology(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        self.raw.view_bits_mut::<LocalBits>()[19..23].store_le(value);
        Ok(())
    }
    
    /// UI_cellReceiverPower
    ///
    /// - Min: -128
    /// - Max: 127
    /// - Unit: "dB"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_receiver_power(&self) -> f32 {
        self.ui_cell_receiver_power_raw()
    }
    
    /// Get raw value of UI_cellReceiverPower
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -128
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_receiver_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -128_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_cellReceiverPower
    #[inline(always)]
    pub fn set_ui_cell_receiver_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        let factor = 1_f32;
        let offset = -128_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// UI_cellSignalBars
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cell_signal_bars(&self) -> u8 {
        self.ui_cell_signal_bars_raw()
    }
    
    /// Get raw value of UI_cellSignalBars
    ///
    /// - Start bit: 42
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cell_signal_bars_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_cellSignalBars
    #[inline(always)]
    pub fn set_ui_cell_signal_bars(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..45].store_le(value);
        Ok(())
    }
    
    /// UI_cpuTemperature
    ///
    /// - Min: -20
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cpu_temperature(&self) -> f32 {
        self.ui_cpu_temperature_raw()
    }
    
    /// Get raw value of UI_cpuTemperature
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_cpu_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_cpuTemperature
    #[inline(always)]
    pub fn set_ui_cpu_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        let factor = 1_f32;
        let offset = 40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// UI_developmentCar
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_development_car(&self) -> bool {
        self.ui_development_car_raw()
    }
    
    /// Get raw value of UI_developmentCar
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_development_car_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_developmentCar
    #[inline(always)]
    pub fn set_ui_development_car(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// UI_displayOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_display_on(&self) -> bool {
        self.ui_display_on_raw()
    }
    
    /// Get raw value of UI_displayOn
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_display_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_displayOn
    #[inline(always)]
    pub fn set_ui_display_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// UI_displayReady
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_display_ready(&self) -> bool {
        self.ui_display_ready_raw()
    }
    
    /// Get raw value of UI_displayReady
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_display_ready_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_displayReady
    #[inline(always)]
    pub fn set_ui_display_ready(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_factoryReset
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_factory_reset(&self) -> u8 {
        self.ui_factory_reset_raw()
    }
    
    /// Get raw value of UI_factoryReset
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_factory_reset_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_factoryReset
    #[inline(always)]
    pub fn set_ui_factory_reset(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// UI_falseTouchCounter
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_false_touch_counter(&self) -> u8 {
        self.ui_false_touch_counter_raw()
    }
    
    /// Get raw value of UI_falseTouchCounter
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_false_touch_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_falseTouchCounter
    #[inline(always)]
    pub fn set_ui_false_touch_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// UI_gpsActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_active(&self) -> bool {
        self.ui_gps_active_raw()
    }
    
    /// Get raw value of UI_gpsActive
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_gpsActive
    #[inline(always)]
    pub fn set_ui_gps_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// UI_pcbTemperature
    ///
    /// - Min: -20
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_pcb_temperature(&self) -> f32 {
        self.ui_pcb_temperature_raw()
    }
    
    /// Get raw value of UI_pcbTemperature
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_pcb_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_pcbTemperature
    #[inline(always)]
    pub fn set_ui_pcb_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 851 }); }
        let factor = 1_f32;
        let offset = 40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// UI_radioActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_radio_active(&self) -> bool {
        self.ui_radio_active_raw()
    }
    
    /// Get raw value of UI_radioActive
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_radio_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_radioActive
    #[inline(always)]
    pub fn set_ui_radio_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// UI_readyForDrive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ready_for_drive(&self) -> bool {
        self.ui_ready_for_drive_raw()
    }
    
    /// Get raw value of UI_readyForDrive
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ready_for_drive_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_readyForDrive
    #[inline(always)]
    pub fn set_ui_ready_for_drive(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// UI_screenshotActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_screenshot_active(&self) -> bool {
        self.ui_screenshot_active_raw()
    }
    
    /// Get raw value of UI_screenshotActive
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_screenshot_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_screenshotActive
    #[inline(always)]
    pub fn set_ui_screenshot_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// UI_systemActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_system_active(&self) -> bool {
        self.ui_system_active_raw()
    }
    
    /// Get raw value of UI_systemActive
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_system_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_systemActive
    #[inline(always)]
    pub fn set_ui_system_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// UI_touchActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_touch_active(&self) -> bool {
        self.ui_touch_active_raw()
    }
    
    /// Get raw value of UI_touchActive
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_touch_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_touchActive
    #[inline(always)]
    pub fn set_ui_touch_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_vpnActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_vpn_active(&self) -> bool {
        self.ui_vpn_active_raw()
    }
    
    /// Get raw value of UI_vpnActive
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_vpn_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_vpnActive
    #[inline(always)]
    pub fn set_ui_vpn_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// UI_wifiActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wifi_active(&self) -> bool {
        self.ui_wifi_active_raw()
    }
    
    /// Get raw value of UI_wifiActive
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wifi_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_wifiActive
    #[inline(always)]
    pub fn set_ui_wifi_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// UI_wifiConnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wifi_connected(&self) -> bool {
        self.ui_wifi_connected_raw()
    }
    
    /// Get raw value of UI_wifiConnected
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wifi_connected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_wifiConnected
    #[inline(always)]
    pub fn set_ui_wifi_connected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id353uiStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id353uiStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_audio_active = u.int_in_range(0..=1)? == 1;
        let ui_autopilot_trial = u.int_in_range(0..=3)?;
        let ui_bluetooth_active = u.int_in_range(0..=1)? == 1;
        let ui_camera_active = u.int_in_range(0..=1)? == 1;
        let ui_cell_active = u.int_in_range(0..=1)? == 1;
        let ui_cell_connected = u.int_in_range(0..=1)? == 1;
        let ui_cell_network_technology = u.int_in_range(0..=15)?;
        let ui_cell_receiver_power = -128_f32;
        let ui_cell_signal_bars = u.int_in_range(0..=7)?;
        let ui_cpu_temperature = -20_f32;
        let ui_development_car = u.int_in_range(0..=1)? == 1;
        let ui_display_on = u.int_in_range(0..=1)? == 1;
        let ui_display_ready = u.int_in_range(0..=1)? == 1;
        let ui_factory_reset = u.int_in_range(0..=3)?;
        let ui_false_touch_counter = u.int_in_range(0..=255)?;
        let ui_gps_active = u.int_in_range(0..=1)? == 1;
        let ui_pcb_temperature = -20_f32;
        let ui_radio_active = u.int_in_range(0..=1)? == 1;
        let ui_ready_for_drive = u.int_in_range(0..=1)? == 1;
        let ui_screenshot_active = u.int_in_range(0..=1)? == 1;
        let ui_system_active = u.int_in_range(0..=1)? == 1;
        let ui_touch_active = u.int_in_range(0..=1)? == 1;
        let ui_vpn_active = u.int_in_range(0..=1)? == 1;
        let ui_wifi_active = u.int_in_range(0..=1)? == 1;
        let ui_wifi_connected = u.int_in_range(0..=1)? == 1;
        Id353uiStatus::new(ui_audio_active,ui_autopilot_trial,ui_bluetooth_active,ui_camera_active,ui_cell_active,ui_cell_connected,ui_cell_network_technology,ui_cell_receiver_power,ui_cell_signal_bars,ui_cpu_temperature,ui_development_car,ui_display_on,ui_display_ready,ui_factory_reset,ui_false_touch_counter,ui_gps_active,ui_pcb_temperature,ui_radio_active,ui_ready_for_drive,ui_screenshot_active,ui_system_active,ui_touch_active,ui_vpn_active,ui_wifi_active,ui_wifi_connected).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID016DI_bmsRequest
///
/// - ID: 22 (0x16)
/// - Size: 1 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id016diBmsRequest {
    raw: [u8; 1],
}

impl Id016diBmsRequest {
    pub const MESSAGE_ID: u32 = 22;
    
    /// Construct new ID016DI_bmsRequest from values
    pub fn new(di_bms_open_contactors_request: bool, di_bms_request_interface_version: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 1] };
        res.set_di_bms_open_contactors_request(di_bms_open_contactors_request)?;
        res.set_di_bms_request_interface_version(di_bms_request_interface_version)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DI_bmsOpenContactorsRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_bms_open_contactors_request(&self) -> bool {
        self.di_bms_open_contactors_request_raw()
    }
    
    /// Get raw value of DI_bmsOpenContactorsRequest
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_bms_open_contactors_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_bmsOpenContactorsRequest
    #[inline(always)]
    pub fn set_di_bms_open_contactors_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// DI_bmsRequestInterfaceVersion
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_bms_request_interface_version(&self) -> u8 {
        self.di_bms_request_interface_version_raw()
    }
    
    /// Get raw value of DI_bmsRequestInterfaceVersion
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_bms_request_interface_version_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DI_bmsRequestInterfaceVersion
    #[inline(always)]
    pub fn set_di_bms_request_interface_version(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 22 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..4].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id016diBmsRequest {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 1 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 1];
        raw.copy_from_slice(&payload[..1]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id016diBmsRequest
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let di_bms_open_contactors_request = u.int_in_range(0..=1)? == 1;
        let di_bms_request_interface_version = u.int_in_range(0..=15)?;
        Id016diBmsRequest::new(di_bms_open_contactors_request,di_bms_request_interface_version).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID082UI_tripPlanning
///
/// - ID: 130 (0x82)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id082uiTripPlanning {
    raw: [u8; 8],
}

impl Id082uiTripPlanning {
    pub const MESSAGE_ID: u32 = 130;
    
    /// Construct new ID082UI_tripPlanning from values
    pub fn new(ui_energy_at_destination: f32, ui_hindsight_energy: f32, ui_nav_to_supercharger: bool, ui_predicted_energy: f32, ui_request_active_battery_heating: bool, ui_trip_planning_active: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_energy_at_destination(ui_energy_at_destination)?;
        res.set_ui_hindsight_energy(ui_hindsight_energy)?;
        res.set_ui_nav_to_supercharger(ui_nav_to_supercharger)?;
        res.set_ui_predicted_energy(ui_predicted_energy)?;
        res.set_ui_request_active_battery_heating(ui_request_active_battery_heating)?;
        res.set_ui_trip_planning_active(ui_trip_planning_active)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_energyAtDestination
    ///
    /// - Min: -327.67
    /// - Max: 327.67
    /// - Unit: "kWh"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_energy_at_destination(&self) -> Id082uiTripPlanningUiEnergyAtDestination {
        match self.ui_energy_at_destination_raw() {
            32768 => Id082uiTripPlanningUiEnergyAtDestination::Sna,
            32767 => Id082uiTripPlanningUiEnergyAtDestination::TripTooLong,
            x => Id082uiTripPlanningUiEnergyAtDestination::Other(x),
        }
    }
    
    /// Get raw value of UI_energyAtDestination
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_energy_at_destination_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_energyAtDestination
    #[inline(always)]
    pub fn set_ui_energy_at_destination(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -327.67_f32 || 327.67_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 130 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// UI_hindsightEnergy
    ///
    /// - Min: -327.67
    /// - Max: 327.67
    /// - Unit: "kWh"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hindsight_energy(&self) -> Id082uiTripPlanningUiHindsightEnergy {
        match self.ui_hindsight_energy_raw() {
            32768 => Id082uiTripPlanningUiHindsightEnergy::Sna,
            32767 => Id082uiTripPlanningUiHindsightEnergy::TripTooLong,
            x => Id082uiTripPlanningUiHindsightEnergy::Other(x),
        }
    }
    
    /// Get raw value of UI_hindsightEnergy
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_hindsight_energy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_hindsightEnergy
    #[inline(always)]
    pub fn set_ui_hindsight_energy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -327.67_f32 || 327.67_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 130 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// UI_navToSupercharger
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_nav_to_supercharger(&self) -> bool {
        self.ui_nav_to_supercharger_raw()
    }
    
    /// Get raw value of UI_navToSupercharger
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_nav_to_supercharger_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_navToSupercharger
    #[inline(always)]
    pub fn set_ui_nav_to_supercharger(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_predictedEnergy
    ///
    /// - Min: -327.67
    /// - Max: 327.67
    /// - Unit: "kWh"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_predicted_energy(&self) -> Id082uiTripPlanningUiPredictedEnergy {
        match self.ui_predicted_energy_raw() {
            32768 => Id082uiTripPlanningUiPredictedEnergy::Sna,
            32767 => Id082uiTripPlanningUiPredictedEnergy::TripTooLong,
            x => Id082uiTripPlanningUiPredictedEnergy::Other(x),
        }
    }
    
    /// Get raw value of UI_predictedEnergy
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_predicted_energy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_predictedEnergy
    #[inline(always)]
    pub fn set_ui_predicted_energy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -327.67_f32 || 327.67_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 130 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// UI_requestActiveBatteryHeating
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_request_active_battery_heating(&self) -> bool {
        self.ui_request_active_battery_heating_raw()
    }
    
    /// Get raw value of UI_requestActiveBatteryHeating
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_request_active_battery_heating_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_requestActiveBatteryHeating
    #[inline(always)]
    pub fn set_ui_request_active_battery_heating(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UI_tripPlanningActive
    ///
    /// Navigation Active
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_trip_planning_active(&self) -> bool {
        self.ui_trip_planning_active_raw()
    }
    
    /// Get raw value of UI_tripPlanningActive
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_trip_planning_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_tripPlanningActive
    #[inline(always)]
    pub fn set_ui_trip_planning_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id082uiTripPlanning {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id082uiTripPlanning
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_energy_at_destination = -327.67_f32;
        let ui_hindsight_energy = -327.67_f32;
        let ui_nav_to_supercharger = u.int_in_range(0..=1)? == 1;
        let ui_predicted_energy = -327.67_f32;
        let ui_request_active_battery_heating = u.int_in_range(0..=1)? == 1;
        let ui_trip_planning_active = u.int_in_range(0..=1)? == 1;
        Id082uiTripPlanning::new(ui_energy_at_destination,ui_hindsight_energy,ui_nav_to_supercharger,ui_predicted_energy,ui_request_active_battery_heating,ui_trip_planning_active).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_energyAtDestination
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id082uiTripPlanningUiEnergyAtDestination {
    Sna,
    TripTooLong,
    Other(f32),
}
/// Defined values for UI_hindsightEnergy
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id082uiTripPlanningUiHindsightEnergy {
    Sna,
    TripTooLong,
    Other(f32),
}
/// Defined values for UI_predictedEnergy
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id082uiTripPlanningUiPredictedEnergy {
    Sna,
    TripTooLong,
    Other(f32),
}

/// ID101RCM_inertial1
///
/// - ID: 257 (0x101)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id101rcmInertial1 {
    raw: [u8; 8],
}

impl Id101rcmInertial1 {
    pub const MESSAGE_ID: u32 = 257;
    
    /// Construct new ID101RCM_inertial1 from values
    pub fn new(rcm_inertial1_checksum: u8, rcm_inertial1_counter: u8, rcm_pitch_rate: f32, rcm_pitch_rate_qf: u8, rcm_roll_rate: f32, rcm_roll_rate_qf: u8, rcm_yaw_rate: f32, rcm_yaw_rate_qf: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_rcm_inertial1_checksum(rcm_inertial1_checksum)?;
        res.set_rcm_inertial1_counter(rcm_inertial1_counter)?;
        res.set_rcm_pitch_rate(rcm_pitch_rate)?;
        res.set_rcm_pitch_rate_qf(rcm_pitch_rate_qf)?;
        res.set_rcm_roll_rate(rcm_roll_rate)?;
        res.set_rcm_roll_rate_qf(rcm_roll_rate_qf)?;
        res.set_rcm_yaw_rate(rcm_yaw_rate)?;
        res.set_rcm_yaw_rate_qf(rcm_yaw_rate_qf)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// RCM_inertial1Checksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_inertial1_checksum(&self) -> u8 {
        self.rcm_inertial1_checksum_raw()
    }
    
    /// Get raw value of RCM_inertial1Checksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_inertial1_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_inertial1Checksum
    #[inline(always)]
    pub fn set_rcm_inertial1_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// RCM_inertial1Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_inertial1_counter(&self) -> u8 {
        self.rcm_inertial1_counter_raw()
    }
    
    /// Get raw value of RCM_inertial1Counter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_inertial1_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_inertial1Counter
    #[inline(always)]
    pub fn set_rcm_inertial1_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// RCM_pitchRate
    ///
    /// Pitch
    ///
    /// - Min: -4.096
    /// - Max: 4.09575
    /// - Unit: "rad/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_pitch_rate(&self) -> Id101rcmInertial1RcmPitchRate {
        match self.rcm_pitch_rate_raw() {
            16384 => Id101rcmInertial1RcmPitchRate::Sna,
            x => Id101rcmInertial1RcmPitchRate::Other(x),
        }
    }
    
    /// Get raw value of RCM_pitchRate
    ///
    /// - Start bit: 16
    /// - Signal size: 15 bits
    /// - Factor: 0.00025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_pitch_rate_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..31].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_pitchRate
    #[inline(always)]
    pub fn set_rcm_pitch_rate(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4.096_f32 || 4.09575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        let factor = 0.00025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..31].store_le(value);
        Ok(())
    }
    
    /// RCM_pitchRateQF
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_pitch_rate_qf(&self) -> Id101rcmInertial1RcmPitchRateQf {
        match self.rcm_pitch_rate_qf_raw() {
            3 => Id101rcmInertial1RcmPitchRateQf::Faulted,
            0 => Id101rcmInertial1RcmPitchRateQf::Init,
            2 => Id101rcmInertial1RcmPitchRateQf::TempInvalid,
            1 => Id101rcmInertial1RcmPitchRateQf::Valid,
            x => Id101rcmInertial1RcmPitchRateQf::Other(x),
        }
    }
    
    /// Get raw value of RCM_pitchRateQF
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_pitch_rate_qf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_pitchRateQF
    #[inline(always)]
    pub fn set_rcm_pitch_rate_qf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..52].store_le(value);
        Ok(())
    }
    
    /// RCM_rollRate
    ///
    /// Roll
    ///
    /// - Min: -4.096
    /// - Max: 4.09575
    /// - Unit: "rad/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_roll_rate(&self) -> Id101rcmInertial1RcmRollRate {
        match self.rcm_roll_rate_raw() {
            16384 => Id101rcmInertial1RcmRollRate::Sna,
            x => Id101rcmInertial1RcmRollRate::Other(x),
        }
    }
    
    /// Get raw value of RCM_rollRate
    ///
    /// - Start bit: 31
    /// - Signal size: 15 bits
    /// - Factor: 0.00025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_roll_rate_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..46].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_rollRate
    #[inline(always)]
    pub fn set_rcm_roll_rate(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4.096_f32 || 4.09575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        let factor = 0.00025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[31..46].store_le(value);
        Ok(())
    }
    
    /// RCM_rollRateQF
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_roll_rate_qf(&self) -> Id101rcmInertial1RcmRollRateQf {
        match self.rcm_roll_rate_qf_raw() {
            3 => Id101rcmInertial1RcmRollRateQf::Faulted,
            0 => Id101rcmInertial1RcmRollRateQf::Init,
            2 => Id101rcmInertial1RcmRollRateQf::TempInvalid,
            1 => Id101rcmInertial1RcmRollRateQf::Valid,
            x => Id101rcmInertial1RcmRollRateQf::Other(x),
        }
    }
    
    /// Get raw value of RCM_rollRateQF
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_roll_rate_qf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_rollRateQF
    #[inline(always)]
    pub fn set_rcm_roll_rate_qf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..48].store_le(value);
        Ok(())
    }
    
    /// RCM_yawRate
    ///
    /// Yaw
    ///
    /// - Min: -3.2766
    /// - Max: 3.2766
    /// - Unit: "rad/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_yaw_rate(&self) -> Id101rcmInertial1RcmYawRate {
        match self.rcm_yaw_rate_raw() {
            32768 => Id101rcmInertial1RcmYawRate::Sna,
            x => Id101rcmInertial1RcmYawRate::Other(x),
        }
    }
    
    /// Get raw value of RCM_yawRate
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_yaw_rate_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_yawRate
    #[inline(always)]
    pub fn set_rcm_yaw_rate(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.2766_f32 || 3.2766_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 257 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[0..16].store_le(value);
        Ok(())
    }
    
    /// RCM_yawRateQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_yaw_rate_qf(&self) -> Id101rcmInertial1RcmYawRateQf {
        match self.rcm_yaw_rate_qf_raw() {
            false => Id101rcmInertial1RcmYawRateQf::Faulted,
            true => Id101rcmInertial1RcmYawRateQf::NotFaulted,
            x => Id101rcmInertial1RcmYawRateQf::Other(x),
        }
    }
    
    /// Get raw value of RCM_yawRateQF
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_yaw_rate_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_yawRateQF
    #[inline(always)]
    pub fn set_rcm_yaw_rate_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id101rcmInertial1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id101rcmInertial1
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let rcm_inertial1_checksum = u.int_in_range(0..=255)?;
        let rcm_inertial1_counter = u.int_in_range(0..=15)?;
        let rcm_pitch_rate = -4.096_f32;
        let rcm_pitch_rate_qf = u.int_in_range(0..=3)?;
        let rcm_roll_rate = -4.096_f32;
        let rcm_roll_rate_qf = u.int_in_range(0..=3)?;
        let rcm_yaw_rate = -3.2766_f32;
        let rcm_yaw_rate_qf = u.int_in_range(0..=1)? == 1;
        Id101rcmInertial1::new(rcm_inertial1_checksum,rcm_inertial1_counter,rcm_pitch_rate,rcm_pitch_rate_qf,rcm_roll_rate,rcm_roll_rate_qf,rcm_yaw_rate,rcm_yaw_rate_qf).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for RCM_pitchRate
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id101rcmInertial1RcmPitchRate {
    Sna,
    Other(f32),
}
/// Defined values for RCM_pitchRateQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id101rcmInertial1RcmPitchRateQf {
    Faulted,
    Init,
    TempInvalid,
    Valid,
    Other(u8),
}
/// Defined values for RCM_rollRate
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id101rcmInertial1RcmRollRate {
    Sna,
    Other(f32),
}
/// Defined values for RCM_rollRateQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id101rcmInertial1RcmRollRateQf {
    Faulted,
    Init,
    TempInvalid,
    Valid,
    Other(u8),
}
/// Defined values for RCM_yawRate
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id101rcmInertial1RcmYawRate {
    Sna,
    Other(f32),
}
/// Defined values for RCM_yawRateQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id101rcmInertial1RcmYawRateQf {
    Faulted,
    NotFaulted,
    Other(bool),
}

/// ID111RCM_inertial2
///
/// - ID: 273 (0x111)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id111rcmInertial2 {
    raw: [u8; 8],
}

impl Id111rcmInertial2 {
    pub const MESSAGE_ID: u32 = 273;
    
    /// Construct new ID111RCM_inertial2 from values
    pub fn new(rcm_inertial2_checksum: u8, rcm_inertial2_counter: u8, rcm_lateral_accel: f32, rcm_lateral_accel_qf: bool, rcm_longitudinal_accel: f32, rcm_longitudinal_accel_qf: bool, rcm_vertical_accel: f32, rcm_vertical_accel_qf: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_rcm_inertial2_checksum(rcm_inertial2_checksum)?;
        res.set_rcm_inertial2_counter(rcm_inertial2_counter)?;
        res.set_rcm_lateral_accel(rcm_lateral_accel)?;
        res.set_rcm_lateral_accel_qf(rcm_lateral_accel_qf)?;
        res.set_rcm_longitudinal_accel(rcm_longitudinal_accel)?;
        res.set_rcm_longitudinal_accel_qf(rcm_longitudinal_accel_qf)?;
        res.set_rcm_vertical_accel(rcm_vertical_accel)?;
        res.set_rcm_vertical_accel_qf(rcm_vertical_accel_qf)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// RCM_inertial2Checksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_inertial2_checksum(&self) -> u8 {
        self.rcm_inertial2_checksum_raw()
    }
    
    /// Get raw value of RCM_inertial2Checksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_inertial2_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_inertial2Checksum
    #[inline(always)]
    pub fn set_rcm_inertial2_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 273 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// RCM_inertial2Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_inertial2_counter(&self) -> u8 {
        self.rcm_inertial2_counter_raw()
    }
    
    /// Get raw value of RCM_inertial2Counter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_inertial2_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_inertial2Counter
    #[inline(always)]
    pub fn set_rcm_inertial2_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 273 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// RCM_lateralAccel
    ///
    /// L/R Acceleration
    ///
    /// - Min: -40.9575
    /// - Max: 40.9575
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_lateral_accel(&self) -> Id111rcmInertial2RcmLateralAccel {
        match self.rcm_lateral_accel_raw() {
            32768 => Id111rcmInertial2RcmLateralAccel::Sna,
            x => Id111rcmInertial2RcmLateralAccel::Other(x),
        }
    }
    
    /// Get raw value of RCM_lateralAccel
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.00125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_lateral_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_lateralAccel
    #[inline(always)]
    pub fn set_rcm_lateral_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.9575_f32 || 40.9575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 273 }); }
        let factor = 0.00125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// RCM_lateralAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_lateral_accel_qf(&self) -> Id111rcmInertial2RcmLateralAccelQf {
        match self.rcm_lateral_accel_qf_raw() {
            false => Id111rcmInertial2RcmLateralAccelQf::Faulted,
            true => Id111rcmInertial2RcmLateralAccelQf::NotFaulted,
            x => Id111rcmInertial2RcmLateralAccelQf::Other(x),
        }
    }
    
    /// Get raw value of RCM_lateralAccelQF
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_lateral_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_lateralAccelQF
    #[inline(always)]
    pub fn set_rcm_lateral_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// RCM_longitudinalAccel
    ///
    /// F/B Acceleration
    ///
    /// - Min: -40.9575
    /// - Max: 40.9575
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_longitudinal_accel(&self) -> Id111rcmInertial2RcmLongitudinalAccel {
        match self.rcm_longitudinal_accel_raw() {
            32768 => Id111rcmInertial2RcmLongitudinalAccel::Sna,
            x => Id111rcmInertial2RcmLongitudinalAccel::Other(x),
        }
    }
    
    /// Get raw value of RCM_longitudinalAccel
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.00125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_longitudinal_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_longitudinalAccel
    #[inline(always)]
    pub fn set_rcm_longitudinal_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.9575_f32 || 40.9575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 273 }); }
        let factor = 0.00125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[0..16].store_le(value);
        Ok(())
    }
    
    /// RCM_longitudinalAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_longitudinal_accel_qf(&self) -> Id111rcmInertial2RcmLongitudinalAccelQf {
        match self.rcm_longitudinal_accel_qf_raw() {
            false => Id111rcmInertial2RcmLongitudinalAccelQf::Faulted,
            true => Id111rcmInertial2RcmLongitudinalAccelQf::NotFaulted,
            x => Id111rcmInertial2RcmLongitudinalAccelQf::Other(x),
        }
    }
    
    /// Get raw value of RCM_longitudinalAccelQF
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_longitudinal_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_longitudinalAccelQF
    #[inline(always)]
    pub fn set_rcm_longitudinal_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// RCM_verticalAccel
    ///
    /// Vertical Acceleration
    ///
    /// - Min: -40.9575
    /// - Max: 40.9575
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_vertical_accel(&self) -> Id111rcmInertial2RcmVerticalAccel {
        match self.rcm_vertical_accel_raw() {
            32768 => Id111rcmInertial2RcmVerticalAccel::Sna,
            x => Id111rcmInertial2RcmVerticalAccel::Other(x),
        }
    }
    
    /// Get raw value of RCM_verticalAccel
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.00125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_vertical_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_verticalAccel
    #[inline(always)]
    pub fn set_rcm_vertical_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.9575_f32 || 40.9575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 273 }); }
        let factor = 0.00125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// RCM_verticalAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_vertical_accel_qf(&self) -> Id111rcmInertial2RcmVerticalAccelQf {
        match self.rcm_vertical_accel_qf_raw() {
            false => Id111rcmInertial2RcmVerticalAccelQf::Faulted,
            true => Id111rcmInertial2RcmVerticalAccelQf::NotFaulted,
            x => Id111rcmInertial2RcmVerticalAccelQf::Other(x),
        }
    }
    
    /// Get raw value of RCM_verticalAccelQF
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_vertical_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_verticalAccelQF
    #[inline(always)]
    pub fn set_rcm_vertical_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id111rcmInertial2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id111rcmInertial2
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let rcm_inertial2_checksum = u.int_in_range(0..=255)?;
        let rcm_inertial2_counter = u.int_in_range(0..=15)?;
        let rcm_lateral_accel = -40.9575_f32;
        let rcm_lateral_accel_qf = u.int_in_range(0..=1)? == 1;
        let rcm_longitudinal_accel = -40.9575_f32;
        let rcm_longitudinal_accel_qf = u.int_in_range(0..=1)? == 1;
        let rcm_vertical_accel = -40.9575_f32;
        let rcm_vertical_accel_qf = u.int_in_range(0..=1)? == 1;
        Id111rcmInertial2::new(rcm_inertial2_checksum,rcm_inertial2_counter,rcm_lateral_accel,rcm_lateral_accel_qf,rcm_longitudinal_accel,rcm_longitudinal_accel_qf,rcm_vertical_accel,rcm_vertical_accel_qf).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for RCM_lateralAccel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id111rcmInertial2RcmLateralAccel {
    Sna,
    Other(f32),
}
/// Defined values for RCM_lateralAccelQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id111rcmInertial2RcmLateralAccelQf {
    Faulted,
    NotFaulted,
    Other(bool),
}
/// Defined values for RCM_longitudinalAccel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id111rcmInertial2RcmLongitudinalAccel {
    Sna,
    Other(f32),
}
/// Defined values for RCM_longitudinalAccelQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id111rcmInertial2RcmLongitudinalAccelQf {
    Faulted,
    NotFaulted,
    Other(bool),
}
/// Defined values for RCM_verticalAccel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id111rcmInertial2RcmVerticalAccel {
    Sna,
    Other(f32),
}
/// Defined values for RCM_verticalAccelQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id111rcmInertial2RcmVerticalAccelQf {
    Faulted,
    NotFaulted,
    Other(bool),
}

/// RCM_inertial2New
///
/// - ID: 278 (0x116)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct RcmInertial2New {
    raw: [u8; 8],
}

impl RcmInertial2New {
    pub const MESSAGE_ID: u32 = 278;
    
    /// Construct new RCM_inertial2New from values
    pub fn new(rcm_inertial2_checksum: u8, rcm_inertial2_counter: u8, rcm_lateral_accel: f32, rcm_lateral_accel_qf: bool, rcm_longitudinal_accel: f32, rcm_longitudinal_accel_qf: bool, rcm_vertical_accel: f32, rcm_vertical_accel_qf: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_rcm_inertial2_checksum(rcm_inertial2_checksum)?;
        res.set_rcm_inertial2_counter(rcm_inertial2_counter)?;
        res.set_rcm_lateral_accel(rcm_lateral_accel)?;
        res.set_rcm_lateral_accel_qf(rcm_lateral_accel_qf)?;
        res.set_rcm_longitudinal_accel(rcm_longitudinal_accel)?;
        res.set_rcm_longitudinal_accel_qf(rcm_longitudinal_accel_qf)?;
        res.set_rcm_vertical_accel(rcm_vertical_accel)?;
        res.set_rcm_vertical_accel_qf(rcm_vertical_accel_qf)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// RCM_inertial2Checksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_inertial2_checksum(&self) -> u8 {
        self.rcm_inertial2_checksum_raw()
    }
    
    /// Get raw value of RCM_inertial2Checksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_inertial2_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_inertial2Checksum
    #[inline(always)]
    pub fn set_rcm_inertial2_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 278 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// RCM_inertial2Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_inertial2_counter(&self) -> u8 {
        self.rcm_inertial2_counter_raw()
    }
    
    /// Get raw value of RCM_inertial2Counter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_inertial2_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RCM_inertial2Counter
    #[inline(always)]
    pub fn set_rcm_inertial2_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 278 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// RCM_lateralAccel
    ///
    /// - Min: -40.9575
    /// - Max: 40.9575
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_lateral_accel(&self) -> f32 {
        self.rcm_lateral_accel_raw()
    }
    
    /// Get raw value of RCM_lateralAccel
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.00125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_lateral_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_lateralAccel
    #[inline(always)]
    pub fn set_rcm_lateral_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.9575_f32 || 40.9575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 278 }); }
        let factor = 0.00125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// RCM_lateralAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_lateral_accel_qf(&self) -> bool {
        self.rcm_lateral_accel_qf_raw()
    }
    
    /// Get raw value of RCM_lateralAccelQF
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_lateral_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_lateralAccelQF
    #[inline(always)]
    pub fn set_rcm_lateral_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// RCM_longitudinalAccel
    ///
    /// - Min: -40.9575
    /// - Max: 40.9575
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_longitudinal_accel(&self) -> f32 {
        self.rcm_longitudinal_accel_raw()
    }
    
    /// Get raw value of RCM_longitudinalAccel
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.00125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_longitudinal_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_longitudinalAccel
    #[inline(always)]
    pub fn set_rcm_longitudinal_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.9575_f32 || 40.9575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 278 }); }
        let factor = 0.00125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[0..16].store_le(value);
        Ok(())
    }
    
    /// RCM_longitudinalAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_longitudinal_accel_qf(&self) -> bool {
        self.rcm_longitudinal_accel_qf_raw()
    }
    
    /// Get raw value of RCM_longitudinalAccelQF
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_longitudinal_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_longitudinalAccelQF
    #[inline(always)]
    pub fn set_rcm_longitudinal_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// RCM_verticalAccel
    ///
    /// - Min: -40.9575
    /// - Max: 40.9575
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_vertical_accel(&self) -> f32 {
        self.rcm_vertical_accel_raw()
    }
    
    /// Get raw value of RCM_verticalAccel
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.00125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rcm_vertical_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RCM_verticalAccel
    #[inline(always)]
    pub fn set_rcm_vertical_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.9575_f32 || 40.9575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 278 }); }
        let factor = 0.00125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// RCM_verticalAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn rcm_vertical_accel_qf(&self) -> bool {
        self.rcm_vertical_accel_qf_raw()
    }
    
    /// Get raw value of RCM_verticalAccelQF
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcm_vertical_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCM_verticalAccelQF
    #[inline(always)]
    pub fn set_rcm_vertical_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RcmInertial2New {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for RcmInertial2New
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let rcm_inertial2_checksum = u.int_in_range(0..=255)?;
        let rcm_inertial2_counter = u.int_in_range(0..=15)?;
        let rcm_lateral_accel = -40.9575_f32;
        let rcm_lateral_accel_qf = u.int_in_range(0..=1)? == 1;
        let rcm_longitudinal_accel = -40.9575_f32;
        let rcm_longitudinal_accel_qf = u.int_in_range(0..=1)? == 1;
        let rcm_vertical_accel = -40.9575_f32;
        let rcm_vertical_accel_qf = u.int_in_range(0..=1)? == 1;
        RcmInertial2New::new(rcm_inertial2_checksum,rcm_inertial2_counter,rcm_lateral_accel,rcm_lateral_accel_qf,rcm_longitudinal_accel,rcm_longitudinal_accel_qf,rcm_vertical_accel,rcm_vertical_accel_qf).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID102VCLEFT_doorStatus
///
/// - ID: 258 (0x102)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id102vcleftDoorStatus {
    raw: [u8; 8],
}

impl Id102vcleftDoorStatus {
    pub const MESSAGE_ID: u32 = 258;
    
    /// Construct new ID102VCLEFT_doorStatus from values
    pub fn new(vcleft_front_handle_pwm: u8, vcleft_front_handle_pulled: bool, vcleft_front_handle_pulled_persist: bool, vcleft_front_int_switch_pressed: bool, vcleft_front_latch_status: u8, vcleft_front_latch_switch: bool, vcleft_front_rel_actuator_switch: bool, vcleft_mirror_dipped: bool, vcleft_mirror_fold_state: u8, vcleft_mirror_heat_state: u8, vcleft_mirror_recall_state: u8, vcleft_mirror_state: u8, vcleft_mirror_tilt_x_position: f32, vcleft_mirror_tilt_y_position: f32, vcleft_rear_handle_pwm: u8, vcleft_rear_handle_pulled: bool, vcleft_rear_int_switch_pressed: bool, vcleft_rear_latch_status: u8, vcleft_rear_latch_switch: bool, vcleft_rear_rel_actuator_switch: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcleft_front_handle_pwm(vcleft_front_handle_pwm)?;
        res.set_vcleft_front_handle_pulled(vcleft_front_handle_pulled)?;
        res.set_vcleft_front_handle_pulled_persist(vcleft_front_handle_pulled_persist)?;
        res.set_vcleft_front_int_switch_pressed(vcleft_front_int_switch_pressed)?;
        res.set_vcleft_front_latch_status(vcleft_front_latch_status)?;
        res.set_vcleft_front_latch_switch(vcleft_front_latch_switch)?;
        res.set_vcleft_front_rel_actuator_switch(vcleft_front_rel_actuator_switch)?;
        res.set_vcleft_mirror_dipped(vcleft_mirror_dipped)?;
        res.set_vcleft_mirror_fold_state(vcleft_mirror_fold_state)?;
        res.set_vcleft_mirror_heat_state(vcleft_mirror_heat_state)?;
        res.set_vcleft_mirror_recall_state(vcleft_mirror_recall_state)?;
        res.set_vcleft_mirror_state(vcleft_mirror_state)?;
        res.set_vcleft_mirror_tilt_x_position(vcleft_mirror_tilt_x_position)?;
        res.set_vcleft_mirror_tilt_y_position(vcleft_mirror_tilt_y_position)?;
        res.set_vcleft_rear_handle_pwm(vcleft_rear_handle_pwm)?;
        res.set_vcleft_rear_handle_pulled(vcleft_rear_handle_pulled)?;
        res.set_vcleft_rear_int_switch_pressed(vcleft_rear_int_switch_pressed)?;
        res.set_vcleft_rear_latch_status(vcleft_rear_latch_status)?;
        res.set_vcleft_rear_latch_switch(vcleft_rear_latch_switch)?;
        res.set_vcleft_rear_rel_actuator_switch(vcleft_rear_rel_actuator_switch)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCLEFT_frontHandlePWM
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_handle_pwm(&self) -> u8 {
        self.vcleft_front_handle_pwm_raw()
    }
    
    /// Get raw value of VCLEFT_frontHandlePWM
    ///
    /// - Start bit: 16
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_handle_pwm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_frontHandlePWM
    #[inline(always)]
    pub fn set_vcleft_front_handle_pwm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..23].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontHandlePulled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_handle_pulled(&self) -> bool {
        self.vcleft_front_handle_pulled_raw()
    }
    
    /// Get raw value of VCLEFT_frontHandlePulled
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_handle_pulled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_frontHandlePulled
    #[inline(always)]
    pub fn set_vcleft_front_handle_pulled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontHandlePulledPersist
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_handle_pulled_persist(&self) -> bool {
        self.vcleft_front_handle_pulled_persist_raw()
    }
    
    /// Get raw value of VCLEFT_frontHandlePulledPersist
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_handle_pulled_persist_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_frontHandlePulledPersist
    #[inline(always)]
    pub fn set_vcleft_front_handle_pulled_persist(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontIntSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_int_switch_pressed(&self) -> bool {
        self.vcleft_front_int_switch_pressed_raw()
    }
    
    /// Get raw value of VCLEFT_frontIntSwitchPressed
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_int_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_frontIntSwitchPressed
    #[inline(always)]
    pub fn set_vcleft_front_int_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontLatchStatus
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_latch_status(&self) -> Id102vcleftDoorStatusVcleftFrontLatchStatus {
        match self.vcleft_front_latch_status_raw() {
            5 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchAjar,
            2 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchClosed,
            3 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchClosing,
            7 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchDefault,
            8 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchFault,
            1 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchOpened,
            4 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchOpening,
            0 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchSna,
            6 => Id102vcleftDoorStatusVcleftFrontLatchStatus::LatchTimeout,
            x => Id102vcleftDoorStatusVcleftFrontLatchStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_frontLatchStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_latch_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_frontLatchStatus
    #[inline(always)]
    pub fn set_vcleft_front_latch_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..4].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontLatchSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_latch_switch(&self) -> bool {
        self.vcleft_front_latch_switch_raw()
    }
    
    /// Get raw value of VCLEFT_frontLatchSwitch
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_latch_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_frontLatchSwitch
    #[inline(always)]
    pub fn set_vcleft_front_latch_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontRelActuatorSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_rel_actuator_switch(&self) -> bool {
        self.vcleft_front_rel_actuator_switch_raw()
    }
    
    /// Get raw value of VCLEFT_frontRelActuatorSwitch
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_rel_actuator_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_frontRelActuatorSwitch
    #[inline(always)]
    pub fn set_vcleft_front_rel_actuator_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorDipped
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_dipped(&self) -> bool {
        self.vcleft_mirror_dipped_raw()
    }
    
    /// Get raw value of VCLEFT_mirrorDipped
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_dipped_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_mirrorDipped
    #[inline(always)]
    pub fn set_vcleft_mirror_dipped(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorFoldState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_fold_state(&self) -> Id102vcleftDoorStatusVcleftMirrorFoldState {
        match self.vcleft_mirror_fold_state_raw() {
            1 => Id102vcleftDoorStatusVcleftMirrorFoldState::MirrorFoldStateFolded,
            3 => Id102vcleftDoorStatusVcleftMirrorFoldState::MirrorFoldStateFolding,
            2 => Id102vcleftDoorStatusVcleftMirrorFoldState::MirrorFoldStateUnfolded,
            4 => Id102vcleftDoorStatusVcleftMirrorFoldState::MirrorFoldStateUnfolding,
            0 => Id102vcleftDoorStatusVcleftMirrorFoldState::MirrorFoldStateUnknown,
            x => Id102vcleftDoorStatusVcleftMirrorFoldState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_mirrorFoldState
    ///
    /// - Start bit: 52
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_fold_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..55].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_mirrorFoldState
    #[inline(always)]
    pub fn set_vcleft_mirror_fold_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..55].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorHeatState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_heat_state(&self) -> Id102vcleftDoorStatusVcleftMirrorHeatState {
        match self.vcleft_mirror_heat_state_raw() {
            4 => Id102vcleftDoorStatusVcleftMirrorHeatState::HeaterStateFault,
            2 => Id102vcleftDoorStatusVcleftMirrorHeatState::HeaterStateOff,
            3 => Id102vcleftDoorStatusVcleftMirrorHeatState::HeaterStateOffUnavailable,
            1 => Id102vcleftDoorStatusVcleftMirrorHeatState::HeaterStateOn,
            0 => Id102vcleftDoorStatusVcleftMirrorHeatState::HeaterStateSna,
            x => Id102vcleftDoorStatusVcleftMirrorHeatState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_mirrorHeatState
    ///
    /// - Start bit: 58
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_heat_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_mirrorHeatState
    #[inline(always)]
    pub fn set_vcleft_mirror_heat_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..61].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorRecallState
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_recall_state(&self) -> Id102vcleftDoorStatusVcleftMirrorRecallState {
        match self.vcleft_mirror_recall_state_raw() {
            0 => Id102vcleftDoorStatusVcleftMirrorRecallState::MirrorRecallStateInit,
            1 => Id102vcleftDoorStatusVcleftMirrorRecallState::MirrorRecallStateRecallingAxis1,
            2 => Id102vcleftDoorStatusVcleftMirrorRecallState::MirrorRecallStateRecallingAxis2,
            3 => Id102vcleftDoorStatusVcleftMirrorRecallState::MirrorRecallStateRecallingComplete,
            4 => Id102vcleftDoorStatusVcleftMirrorRecallState::MirrorRecallStateRecallingFailed,
            5 => Id102vcleftDoorStatusVcleftMirrorRecallState::MirrorRecallStateRecallingStopped,
            x => Id102vcleftDoorStatusVcleftMirrorRecallState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_mirrorRecallState
    ///
    /// - Start bit: 55
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_recall_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[55..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_mirrorRecallState
    #[inline(always)]
    pub fn set_vcleft_mirror_recall_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[55..58].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_state(&self) -> Id102vcleftDoorStatusVcleftMirrorState {
        match self.vcleft_mirror_state_raw() {
            3 => Id102vcleftDoorStatusVcleftMirrorState::MirrorStateFoldUnfold,
            0 => Id102vcleftDoorStatusVcleftMirrorState::MirrorStateIdle,
            4 => Id102vcleftDoorStatusVcleftMirrorState::MirrorStateRecall,
            1 => Id102vcleftDoorStatusVcleftMirrorState::MirrorStateTiltX,
            2 => Id102vcleftDoorStatusVcleftMirrorState::MirrorStateTiltY,
            x => Id102vcleftDoorStatusVcleftMirrorState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_mirrorState
    ///
    /// - Start bit: 49
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[49..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_mirrorState
    #[inline(always)]
    pub fn set_vcleft_mirror_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..52].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorTiltXPosition
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_tilt_x_position(&self) -> f32 {
        self.vcleft_mirror_tilt_x_position_raw()
    }
    
    /// Get raw value of VCLEFT_mirrorTiltXPosition
    ///
    /// - Start bit: 33
    /// - Signal size: 8 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_tilt_x_position_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[33..41].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_mirrorTiltXPosition
    #[inline(always)]
    pub fn set_vcleft_mirror_tilt_x_position(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[33..41].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorTiltYPosition
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_tilt_y_position(&self) -> f32 {
        self.vcleft_mirror_tilt_y_position_raw()
    }
    
    /// Get raw value of VCLEFT_mirrorTiltYPosition
    ///
    /// - Start bit: 41
    /// - Signal size: 8 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_mirror_tilt_y_position_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[41..49].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_mirrorTiltYPosition
    #[inline(always)]
    pub fn set_vcleft_mirror_tilt_y_position(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[41..49].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearHandlePWM
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_handle_pwm(&self) -> u8 {
        self.vcleft_rear_handle_pwm_raw()
    }
    
    /// Get raw value of VCLEFT_rearHandlePWM
    ///
    /// - Start bit: 24
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_handle_pwm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rearHandlePWM
    #[inline(always)]
    pub fn set_vcleft_rear_handle_pwm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..31].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearHandlePulled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_handle_pulled(&self) -> bool {
        self.vcleft_rear_handle_pulled_raw()
    }
    
    /// Get raw value of VCLEFT_rearHandlePulled
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_handle_pulled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_rearHandlePulled
    #[inline(always)]
    pub fn set_vcleft_rear_handle_pulled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearIntSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_int_switch_pressed(&self) -> bool {
        self.vcleft_rear_int_switch_pressed_raw()
    }
    
    /// Get raw value of VCLEFT_rearIntSwitchPressed
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_int_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_rearIntSwitchPressed
    #[inline(always)]
    pub fn set_vcleft_rear_int_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearLatchStatus
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_latch_status(&self) -> Id102vcleftDoorStatusVcleftRearLatchStatus {
        match self.vcleft_rear_latch_status_raw() {
            5 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchAjar,
            2 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchClosed,
            3 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchClosing,
            7 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchDefault,
            8 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchFault,
            1 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchOpened,
            4 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchOpening,
            0 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchSna,
            6 => Id102vcleftDoorStatusVcleftRearLatchStatus::LatchTimeout,
            x => Id102vcleftDoorStatusVcleftRearLatchStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rearLatchStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_latch_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rearLatchStatus
    #[inline(always)]
    pub fn set_vcleft_rear_latch_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 258 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..8].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearLatchSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_latch_switch(&self) -> bool {
        self.vcleft_rear_latch_switch_raw()
    }
    
    /// Get raw value of VCLEFT_rearLatchSwitch
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_latch_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_rearLatchSwitch
    #[inline(always)]
    pub fn set_vcleft_rear_latch_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearRelActuatorSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_rel_actuator_switch(&self) -> bool {
        self.vcleft_rear_rel_actuator_switch_raw()
    }
    
    /// Get raw value of VCLEFT_rearRelActuatorSwitch
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_rel_actuator_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_rearRelActuatorSwitch
    #[inline(always)]
    pub fn set_vcleft_rear_rel_actuator_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id102vcleftDoorStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id102vcleftDoorStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcleft_front_handle_pwm = u.int_in_range(0..=100)?;
        let vcleft_front_handle_pulled = u.int_in_range(0..=1)? == 1;
        let vcleft_front_handle_pulled_persist = u.int_in_range(0..=1)? == 1;
        let vcleft_front_int_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcleft_front_latch_status = u.int_in_range(0..=8)?;
        let vcleft_front_latch_switch = u.int_in_range(0..=1)? == 1;
        let vcleft_front_rel_actuator_switch = u.int_in_range(0..=1)? == 1;
        let vcleft_mirror_dipped = u.int_in_range(0..=1)? == 1;
        let vcleft_mirror_fold_state = u.int_in_range(0..=4)?;
        let vcleft_mirror_heat_state = u.int_in_range(0..=4)?;
        let vcleft_mirror_recall_state = u.int_in_range(0..=5)?;
        let vcleft_mirror_state = u.int_in_range(0..=4)?;
        let vcleft_mirror_tilt_x_position = 0_f32;
        let vcleft_mirror_tilt_y_position = 0_f32;
        let vcleft_rear_handle_pwm = u.int_in_range(0..=100)?;
        let vcleft_rear_handle_pulled = u.int_in_range(0..=1)? == 1;
        let vcleft_rear_int_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcleft_rear_latch_status = u.int_in_range(0..=8)?;
        let vcleft_rear_latch_switch = u.int_in_range(0..=1)? == 1;
        let vcleft_rear_rel_actuator_switch = u.int_in_range(0..=1)? == 1;
        Id102vcleftDoorStatus::new(vcleft_front_handle_pwm,vcleft_front_handle_pulled,vcleft_front_handle_pulled_persist,vcleft_front_int_switch_pressed,vcleft_front_latch_status,vcleft_front_latch_switch,vcleft_front_rel_actuator_switch,vcleft_mirror_dipped,vcleft_mirror_fold_state,vcleft_mirror_heat_state,vcleft_mirror_recall_state,vcleft_mirror_state,vcleft_mirror_tilt_x_position,vcleft_mirror_tilt_y_position,vcleft_rear_handle_pwm,vcleft_rear_handle_pulled,vcleft_rear_int_switch_pressed,vcleft_rear_latch_status,vcleft_rear_latch_switch,vcleft_rear_rel_actuator_switch).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCLEFT_frontLatchStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id102vcleftDoorStatusVcleftFrontLatchStatus {
    LatchAjar,
    LatchClosed,
    LatchClosing,
    LatchDefault,
    LatchFault,
    LatchOpened,
    LatchOpening,
    LatchSna,
    LatchTimeout,
    Other(u8),
}
/// Defined values for VCLEFT_mirrorFoldState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id102vcleftDoorStatusVcleftMirrorFoldState {
    MirrorFoldStateFolded,
    MirrorFoldStateFolding,
    MirrorFoldStateUnfolded,
    MirrorFoldStateUnfolding,
    MirrorFoldStateUnknown,
    Other(u8),
}
/// Defined values for VCLEFT_mirrorHeatState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id102vcleftDoorStatusVcleftMirrorHeatState {
    HeaterStateFault,
    HeaterStateOff,
    HeaterStateOffUnavailable,
    HeaterStateOn,
    HeaterStateSna,
    Other(u8),
}
/// Defined values for VCLEFT_mirrorRecallState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id102vcleftDoorStatusVcleftMirrorRecallState {
    MirrorRecallStateInit,
    MirrorRecallStateRecallingAxis1,
    MirrorRecallStateRecallingAxis2,
    MirrorRecallStateRecallingComplete,
    MirrorRecallStateRecallingFailed,
    MirrorRecallStateRecallingStopped,
    Other(u8),
}
/// Defined values for VCLEFT_mirrorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id102vcleftDoorStatusVcleftMirrorState {
    MirrorStateFoldUnfold,
    MirrorStateIdle,
    MirrorStateRecall,
    MirrorStateTiltX,
    MirrorStateTiltY,
    Other(u8),
}
/// Defined values for VCLEFT_rearLatchStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id102vcleftDoorStatusVcleftRearLatchStatus {
    LatchAjar,
    LatchClosed,
    LatchClosing,
    LatchDefault,
    LatchFault,
    LatchOpened,
    LatchOpening,
    LatchSna,
    LatchTimeout,
    Other(u8),
}

/// ID103VCRIGHT_doorStatus
///
/// - ID: 259 (0x103)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id103vcrightDoorStatus {
    raw: [u8; 8],
}

impl Id103vcrightDoorStatus {
    pub const MESSAGE_ID: u32 = 259;
    
    /// Construct new ID103VCRIGHT_doorStatus from values
    pub fn new(vcright_front_handle_pwm: u8, vcright_front_handle_pulled: bool, vcright_front_handle_pulled_persist: bool, vcright_front_int_switch_pressed: bool, vcright_front_latch_status: u8, vcright_front_latch_switch: bool, vcright_front_rel_actuator_switch: bool, vcright_mirror_dipped: bool, vcright_mirror_fold_state: u8, vcright_mirror_recall_state: u8, vcright_mirror_state: u8, vcright_mirror_tilt_x_position: f32, vcright_mirror_tilt_y_position: f32, vcright_rear_handle_pwm: u8, vcright_rear_handle_pulled: bool, vcright_rear_int_switch_pressed: bool, vcright_rear_latch_status: u8, vcright_rear_latch_switch: bool, vcright_rear_rel_actuator_switch: bool, vcright_reserved_for_back_compat: u8, vcright_trunk_latch_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcright_front_handle_pwm(vcright_front_handle_pwm)?;
        res.set_vcright_front_handle_pulled(vcright_front_handle_pulled)?;
        res.set_vcright_front_handle_pulled_persist(vcright_front_handle_pulled_persist)?;
        res.set_vcright_front_int_switch_pressed(vcright_front_int_switch_pressed)?;
        res.set_vcright_front_latch_status(vcright_front_latch_status)?;
        res.set_vcright_front_latch_switch(vcright_front_latch_switch)?;
        res.set_vcright_front_rel_actuator_switch(vcright_front_rel_actuator_switch)?;
        res.set_vcright_mirror_dipped(vcright_mirror_dipped)?;
        res.set_vcright_mirror_fold_state(vcright_mirror_fold_state)?;
        res.set_vcright_mirror_recall_state(vcright_mirror_recall_state)?;
        res.set_vcright_mirror_state(vcright_mirror_state)?;
        res.set_vcright_mirror_tilt_x_position(vcright_mirror_tilt_x_position)?;
        res.set_vcright_mirror_tilt_y_position(vcright_mirror_tilt_y_position)?;
        res.set_vcright_rear_handle_pwm(vcright_rear_handle_pwm)?;
        res.set_vcright_rear_handle_pulled(vcright_rear_handle_pulled)?;
        res.set_vcright_rear_int_switch_pressed(vcright_rear_int_switch_pressed)?;
        res.set_vcright_rear_latch_status(vcright_rear_latch_status)?;
        res.set_vcright_rear_latch_switch(vcright_rear_latch_switch)?;
        res.set_vcright_rear_rel_actuator_switch(vcright_rear_rel_actuator_switch)?;
        res.set_vcright_reserved_for_back_compat(vcright_reserved_for_back_compat)?;
        res.set_vcright_trunk_latch_status(vcright_trunk_latch_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_frontHandlePWM
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_handle_pwm(&self) -> u8 {
        self.vcright_front_handle_pwm_raw()
    }
    
    /// Get raw value of VCRIGHT_frontHandlePWM
    ///
    /// - Start bit: 14
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_handle_pwm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontHandlePWM
    #[inline(always)]
    pub fn set_vcright_front_handle_pwm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..21].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontHandlePulled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_handle_pulled(&self) -> bool {
        self.vcright_front_handle_pulled_raw()
    }
    
    /// Get raw value of VCRIGHT_frontHandlePulled
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_handle_pulled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_frontHandlePulled
    #[inline(always)]
    pub fn set_vcright_front_handle_pulled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontHandlePulledPersist
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_handle_pulled_persist(&self) -> bool {
        self.vcright_front_handle_pulled_persist_raw()
    }
    
    /// Get raw value of VCRIGHT_frontHandlePulledPersist
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_handle_pulled_persist_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_frontHandlePulledPersist
    #[inline(always)]
    pub fn set_vcright_front_handle_pulled_persist(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontIntSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_int_switch_pressed(&self) -> bool {
        self.vcright_front_int_switch_pressed_raw()
    }
    
    /// Get raw value of VCRIGHT_frontIntSwitchPressed
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_int_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_frontIntSwitchPressed
    #[inline(always)]
    pub fn set_vcright_front_int_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontLatchStatus
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_latch_status(&self) -> Id103vcrightDoorStatusVcrightFrontLatchStatus {
        match self.vcright_front_latch_status_raw() {
            5 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchAjar,
            2 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchClosed,
            3 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchClosing,
            7 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchDefault,
            8 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchFault,
            1 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchOpened,
            4 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchOpening,
            0 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchSna,
            6 => Id103vcrightDoorStatusVcrightFrontLatchStatus::LatchTimeout,
            x => Id103vcrightDoorStatusVcrightFrontLatchStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontLatchStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_latch_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontLatchStatus
    #[inline(always)]
    pub fn set_vcright_front_latch_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..4].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontLatchSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_latch_switch(&self) -> bool {
        self.vcright_front_latch_switch_raw()
    }
    
    /// Get raw value of VCRIGHT_frontLatchSwitch
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_latch_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_frontLatchSwitch
    #[inline(always)]
    pub fn set_vcright_front_latch_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontRelActuatorSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_rel_actuator_switch(&self) -> bool {
        self.vcright_front_rel_actuator_switch_raw()
    }
    
    /// Get raw value of VCRIGHT_frontRelActuatorSwitch
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_rel_actuator_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_frontRelActuatorSwitch
    #[inline(always)]
    pub fn set_vcright_front_rel_actuator_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_mirrorDipped
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_dipped(&self) -> bool {
        self.vcright_mirror_dipped_raw()
    }
    
    /// Get raw value of VCRIGHT_mirrorDipped
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_dipped_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_mirrorDipped
    #[inline(always)]
    pub fn set_vcright_mirror_dipped(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_mirrorFoldState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_fold_state(&self) -> Id103vcrightDoorStatusVcrightMirrorFoldState {
        match self.vcright_mirror_fold_state_raw() {
            1 => Id103vcrightDoorStatusVcrightMirrorFoldState::MirrorFoldStateFolded,
            3 => Id103vcrightDoorStatusVcrightMirrorFoldState::MirrorFoldStateFolding,
            2 => Id103vcrightDoorStatusVcrightMirrorFoldState::MirrorFoldStateUnfolded,
            4 => Id103vcrightDoorStatusVcrightMirrorFoldState::MirrorFoldStateUnfolding,
            0 => Id103vcrightDoorStatusVcrightMirrorFoldState::MirrorFoldStateUnknown,
            x => Id103vcrightDoorStatusVcrightMirrorFoldState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_mirrorFoldState
    ///
    /// - Start bit: 52
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_fold_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..55].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_mirrorFoldState
    #[inline(always)]
    pub fn set_vcright_mirror_fold_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..55].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_mirrorRecallState
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_recall_state(&self) -> Id103vcrightDoorStatusVcrightMirrorRecallState {
        match self.vcright_mirror_recall_state_raw() {
            0 => Id103vcrightDoorStatusVcrightMirrorRecallState::MirrorRecallStateInit,
            1 => Id103vcrightDoorStatusVcrightMirrorRecallState::MirrorRecallStateRecallingAxis1,
            2 => Id103vcrightDoorStatusVcrightMirrorRecallState::MirrorRecallStateRecallingAxis2,
            3 => Id103vcrightDoorStatusVcrightMirrorRecallState::MirrorRecallStateRecallingComplete,
            4 => Id103vcrightDoorStatusVcrightMirrorRecallState::MirrorRecallStateRecallingFailed,
            5 => Id103vcrightDoorStatusVcrightMirrorRecallState::MirrorRecallStateRecallingStopped,
            x => Id103vcrightDoorStatusVcrightMirrorRecallState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_mirrorRecallState
    ///
    /// - Start bit: 60
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_recall_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[60..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_mirrorRecallState
    #[inline(always)]
    pub fn set_vcright_mirror_recall_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[60..63].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_mirrorState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_state(&self) -> Id103vcrightDoorStatusVcrightMirrorState {
        match self.vcright_mirror_state_raw() {
            3 => Id103vcrightDoorStatusVcrightMirrorState::MirrorStateFoldUnfold,
            0 => Id103vcrightDoorStatusVcrightMirrorState::MirrorStateIdle,
            4 => Id103vcrightDoorStatusVcrightMirrorState::MirrorStateRecall,
            1 => Id103vcrightDoorStatusVcrightMirrorState::MirrorStateTiltX,
            2 => Id103vcrightDoorStatusVcrightMirrorState::MirrorStateTiltY,
            x => Id103vcrightDoorStatusVcrightMirrorState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_mirrorState
    ///
    /// - Start bit: 49
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[49..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_mirrorState
    #[inline(always)]
    pub fn set_vcright_mirror_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..52].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_mirrorTiltXPosition
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_tilt_x_position(&self) -> f32 {
        self.vcright_mirror_tilt_x_position_raw()
    }
    
    /// Get raw value of VCRIGHT_mirrorTiltXPosition
    ///
    /// - Start bit: 33
    /// - Signal size: 8 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_tilt_x_position_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[33..41].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_mirrorTiltXPosition
    #[inline(always)]
    pub fn set_vcright_mirror_tilt_x_position(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[33..41].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_mirrorTiltYPosition
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_tilt_y_position(&self) -> f32 {
        self.vcright_mirror_tilt_y_position_raw()
    }
    
    /// Get raw value of VCRIGHT_mirrorTiltYPosition
    ///
    /// - Start bit: 41
    /// - Signal size: 8 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_tilt_y_position_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[41..49].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_mirrorTiltYPosition
    #[inline(always)]
    pub fn set_vcright_mirror_tilt_y_position(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[41..49].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearHandlePWM
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_handle_pwm(&self) -> u8 {
        self.vcright_rear_handle_pwm_raw()
    }
    
    /// Get raw value of VCRIGHT_rearHandlePWM
    ///
    /// - Start bit: 21
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_handle_pwm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rearHandlePWM
    #[inline(always)]
    pub fn set_vcright_rear_handle_pwm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..28].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearHandlePulled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_handle_pulled(&self) -> bool {
        self.vcright_rear_handle_pulled_raw()
    }
    
    /// Get raw value of VCRIGHT_rearHandlePulled
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_handle_pulled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_rearHandlePulled
    #[inline(always)]
    pub fn set_vcright_rear_handle_pulled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearIntSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_int_switch_pressed(&self) -> bool {
        self.vcright_rear_int_switch_pressed_raw()
    }
    
    /// Get raw value of VCRIGHT_rearIntSwitchPressed
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_int_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_rearIntSwitchPressed
    #[inline(always)]
    pub fn set_vcright_rear_int_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearLatchStatus
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_latch_status(&self) -> Id103vcrightDoorStatusVcrightRearLatchStatus {
        match self.vcright_rear_latch_status_raw() {
            5 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchAjar,
            2 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchClosed,
            3 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchClosing,
            7 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchDefault,
            8 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchFault,
            1 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchOpened,
            4 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchOpening,
            0 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchSna,
            6 => Id103vcrightDoorStatusVcrightRearLatchStatus::LatchTimeout,
            x => Id103vcrightDoorStatusVcrightRearLatchStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_rearLatchStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_latch_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rearLatchStatus
    #[inline(always)]
    pub fn set_vcright_rear_latch_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..8].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearLatchSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_latch_switch(&self) -> bool {
        self.vcright_rear_latch_switch_raw()
    }
    
    /// Get raw value of VCRIGHT_rearLatchSwitch
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_latch_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_rearLatchSwitch
    #[inline(always)]
    pub fn set_vcright_rear_latch_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearRelActuatorSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_rel_actuator_switch(&self) -> bool {
        self.vcright_rear_rel_actuator_switch_raw()
    }
    
    /// Get raw value of VCRIGHT_rearRelActuatorSwitch
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_rel_actuator_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_rearRelActuatorSwitch
    #[inline(always)]
    pub fn set_vcright_rear_rel_actuator_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_reservedForBackCompat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_reserved_for_back_compat(&self) -> u8 {
        self.vcright_reserved_for_back_compat_raw()
    }
    
    /// Get raw value of VCRIGHT_reservedForBackCompat
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_reserved_for_back_compat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_reservedForBackCompat
    #[inline(always)]
    pub fn set_vcright_reserved_for_back_compat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..30].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_trunkLatchStatus
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_trunk_latch_status(&self) -> Id103vcrightDoorStatusVcrightTrunkLatchStatus {
        match self.vcright_trunk_latch_status_raw() {
            5 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchAjar,
            2 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchClosed,
            3 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchClosing,
            7 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchDefault,
            8 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchFault,
            1 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchOpened,
            4 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchOpening,
            0 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchSna,
            6 => Id103vcrightDoorStatusVcrightTrunkLatchStatus::LatchTimeout,
            x => Id103vcrightDoorStatusVcrightTrunkLatchStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_trunkLatchStatus
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_trunk_latch_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_trunkLatchStatus
    #[inline(always)]
    pub fn set_vcright_trunk_latch_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 259 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..60].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id103vcrightDoorStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id103vcrightDoorStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_front_handle_pwm = u.int_in_range(0..=100)?;
        let vcright_front_handle_pulled = u.int_in_range(0..=1)? == 1;
        let vcright_front_handle_pulled_persist = u.int_in_range(0..=1)? == 1;
        let vcright_front_int_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcright_front_latch_status = u.int_in_range(0..=8)?;
        let vcright_front_latch_switch = u.int_in_range(0..=1)? == 1;
        let vcright_front_rel_actuator_switch = u.int_in_range(0..=1)? == 1;
        let vcright_mirror_dipped = u.int_in_range(0..=1)? == 1;
        let vcright_mirror_fold_state = u.int_in_range(0..=4)?;
        let vcright_mirror_recall_state = u.int_in_range(0..=5)?;
        let vcright_mirror_state = u.int_in_range(0..=4)?;
        let vcright_mirror_tilt_x_position = 0_f32;
        let vcright_mirror_tilt_y_position = 0_f32;
        let vcright_rear_handle_pwm = u.int_in_range(0..=100)?;
        let vcright_rear_handle_pulled = u.int_in_range(0..=1)? == 1;
        let vcright_rear_int_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcright_rear_latch_status = u.int_in_range(0..=8)?;
        let vcright_rear_latch_switch = u.int_in_range(0..=1)? == 1;
        let vcright_rear_rel_actuator_switch = u.int_in_range(0..=1)? == 1;
        let vcright_reserved_for_back_compat = u.int_in_range(0..=3)?;
        let vcright_trunk_latch_status = u.int_in_range(0..=8)?;
        Id103vcrightDoorStatus::new(vcright_front_handle_pwm,vcright_front_handle_pulled,vcright_front_handle_pulled_persist,vcright_front_int_switch_pressed,vcright_front_latch_status,vcright_front_latch_switch,vcright_front_rel_actuator_switch,vcright_mirror_dipped,vcright_mirror_fold_state,vcright_mirror_recall_state,vcright_mirror_state,vcright_mirror_tilt_x_position,vcright_mirror_tilt_y_position,vcright_rear_handle_pwm,vcright_rear_handle_pulled,vcright_rear_int_switch_pressed,vcright_rear_latch_status,vcright_rear_latch_switch,vcright_rear_rel_actuator_switch,vcright_reserved_for_back_compat,vcright_trunk_latch_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_frontLatchStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id103vcrightDoorStatusVcrightFrontLatchStatus {
    LatchAjar,
    LatchClosed,
    LatchClosing,
    LatchDefault,
    LatchFault,
    LatchOpened,
    LatchOpening,
    LatchSna,
    LatchTimeout,
    Other(u8),
}
/// Defined values for VCRIGHT_mirrorFoldState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id103vcrightDoorStatusVcrightMirrorFoldState {
    MirrorFoldStateFolded,
    MirrorFoldStateFolding,
    MirrorFoldStateUnfolded,
    MirrorFoldStateUnfolding,
    MirrorFoldStateUnknown,
    Other(u8),
}
/// Defined values for VCRIGHT_mirrorRecallState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id103vcrightDoorStatusVcrightMirrorRecallState {
    MirrorRecallStateInit,
    MirrorRecallStateRecallingAxis1,
    MirrorRecallStateRecallingAxis2,
    MirrorRecallStateRecallingComplete,
    MirrorRecallStateRecallingFailed,
    MirrorRecallStateRecallingStopped,
    Other(u8),
}
/// Defined values for VCRIGHT_mirrorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id103vcrightDoorStatusVcrightMirrorState {
    MirrorStateFoldUnfold,
    MirrorStateIdle,
    MirrorStateRecall,
    MirrorStateTiltX,
    MirrorStateTiltY,
    Other(u8),
}
/// Defined values for VCRIGHT_rearLatchStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id103vcrightDoorStatusVcrightRearLatchStatus {
    LatchAjar,
    LatchClosed,
    LatchClosing,
    LatchDefault,
    LatchFault,
    LatchOpened,
    LatchOpening,
    LatchSna,
    LatchTimeout,
    Other(u8),
}
/// Defined values for VCRIGHT_trunkLatchStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id103vcrightDoorStatusVcrightTrunkLatchStatus {
    LatchAjar,
    LatchClosed,
    LatchClosing,
    LatchDefault,
    LatchFault,
    LatchOpened,
    LatchOpening,
    LatchSna,
    LatchTimeout,
    Other(u8),
}

/// ID113GTW_bmpDebug
///
/// - ID: 275 (0x113)
/// - Size: 3 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id113gtwBmpDebug {
    raw: [u8; 3],
}

impl Id113gtwBmpDebug {
    pub const MESSAGE_ID: u32 = 275;
    
    /// Construct new ID113GTW_bmpDebug from values
    pub fn new(gtw_bmp_awake_pin: bool, gtw_bmp_gtw_pmic_error: bool, gtw_bmp_gtw_pmic_on: bool, gtw_bmp_gtw_pmic_thermtrip: bool, gtw_bmp_gtw_soc_pwrok: bool, gtw_bmp_gtw_n_suspwr: bool, gtw_bmp_periph_n_rst_3v3_pin: bool, gtw_bmp_pgood_pin: bool, gtw_bmp_pmic_pwr_on: bool, gtw_bmp_state: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_gtw_bmp_awake_pin(gtw_bmp_awake_pin)?;
        res.set_gtw_bmp_gtw_pmic_error(gtw_bmp_gtw_pmic_error)?;
        res.set_gtw_bmp_gtw_pmic_on(gtw_bmp_gtw_pmic_on)?;
        res.set_gtw_bmp_gtw_pmic_thermtrip(gtw_bmp_gtw_pmic_thermtrip)?;
        res.set_gtw_bmp_gtw_soc_pwrok(gtw_bmp_gtw_soc_pwrok)?;
        res.set_gtw_bmp_gtw_n_suspwr(gtw_bmp_gtw_n_suspwr)?;
        res.set_gtw_bmp_periph_n_rst_3v3_pin(gtw_bmp_periph_n_rst_3v3_pin)?;
        res.set_gtw_bmp_pgood_pin(gtw_bmp_pgood_pin)?;
        res.set_gtw_bmp_pmic_pwr_on(gtw_bmp_pmic_pwr_on)?;
        res.set_gtw_bmp_state(gtw_bmp_state)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// GTW_BMP_AWAKE_PIN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_awake_pin(&self) -> bool {
        self.gtw_bmp_awake_pin_raw()
    }
    
    /// Get raw value of GTW_BMP_AWAKE_PIN
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_awake_pin_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_AWAKE_PIN
    #[inline(always)]
    pub fn set_gtw_bmp_awake_pin(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_GTW_PMIC_ERROR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_gtw_pmic_error(&self) -> bool {
        self.gtw_bmp_gtw_pmic_error_raw()
    }
    
    /// Get raw value of GTW_BMP_GTW_PMIC_ERROR
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_gtw_pmic_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_GTW_PMIC_ERROR
    #[inline(always)]
    pub fn set_gtw_bmp_gtw_pmic_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_GTW_PMIC_ON
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_gtw_pmic_on(&self) -> bool {
        self.gtw_bmp_gtw_pmic_on_raw()
    }
    
    /// Get raw value of GTW_BMP_GTW_PMIC_ON
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_gtw_pmic_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_GTW_PMIC_ON
    #[inline(always)]
    pub fn set_gtw_bmp_gtw_pmic_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_GTW_PMIC_THERMTRIP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_gtw_pmic_thermtrip(&self) -> bool {
        self.gtw_bmp_gtw_pmic_thermtrip_raw()
    }
    
    /// Get raw value of GTW_BMP_GTW_PMIC_THERMTRIP
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_gtw_pmic_thermtrip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_GTW_PMIC_THERMTRIP
    #[inline(always)]
    pub fn set_gtw_bmp_gtw_pmic_thermtrip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_GTW_SOC_PWROK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_gtw_soc_pwrok(&self) -> bool {
        self.gtw_bmp_gtw_soc_pwrok_raw()
    }
    
    /// Get raw value of GTW_BMP_GTW_SOC_PWROK
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_gtw_soc_pwrok_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_GTW_SOC_PWROK
    #[inline(always)]
    pub fn set_gtw_bmp_gtw_soc_pwrok(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_GTW_nSUSPWR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_gtw_n_suspwr(&self) -> bool {
        self.gtw_bmp_gtw_n_suspwr_raw()
    }
    
    /// Get raw value of GTW_BMP_GTW_nSUSPWR
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_gtw_n_suspwr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_GTW_nSUSPWR
    #[inline(always)]
    pub fn set_gtw_bmp_gtw_n_suspwr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_PERIPH_nRST_3V3_PIN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_periph_n_rst_3v3_pin(&self) -> bool {
        self.gtw_bmp_periph_n_rst_3v3_pin_raw()
    }
    
    /// Get raw value of GTW_BMP_PERIPH_nRST_3V3_PIN
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_periph_n_rst_3v3_pin_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_PERIPH_nRST_3V3_PIN
    #[inline(always)]
    pub fn set_gtw_bmp_periph_n_rst_3v3_pin(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_PGOOD_PIN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_pgood_pin(&self) -> bool {
        self.gtw_bmp_pgood_pin_raw()
    }
    
    /// Get raw value of GTW_BMP_PGOOD_PIN
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_pgood_pin_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_PGOOD_PIN
    #[inline(always)]
    pub fn set_gtw_bmp_pgood_pin(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// GTW_BMP_PMIC_PWR_ON
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_pmic_pwr_on(&self) -> bool {
        self.gtw_bmp_pmic_pwr_on_raw()
    }
    
    /// Get raw value of GTW_BMP_PMIC_PWR_ON
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_pmic_pwr_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GTW_BMP_PMIC_PWR_ON
    #[inline(always)]
    pub fn set_gtw_bmp_pmic_pwr_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// GTW_bmpState
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn gtw_bmp_state(&self) -> Id113gtwBmpDebugGtwBmpState {
        match self.gtw_bmp_state_raw() {
            2 => Id113gtwBmpDebugGtwBmpState::BmpStateAsleep,
            3 => Id113gtwBmpDebugGtwBmpState::BmpStateMia,
            0 => Id113gtwBmpDebugGtwBmpState::BmpStateOff,
            1 => Id113gtwBmpDebugGtwBmpState::BmpStateOn,
            5 => Id113gtwBmpDebugGtwBmpState::BmpStatePowerCycle,
            4 => Id113gtwBmpDebugGtwBmpState::BmpStateReset,
            255 => Id113gtwBmpDebugGtwBmpState::Dummy,
            x => Id113gtwBmpDebugGtwBmpState::Other(x),
        }
    }
    
    /// Get raw value of GTW_bmpState
    ///
    /// - Start bit: 7
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gtw_bmp_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_be::<u8>();
        
        signal
    }
    
    /// Set value of GTW_bmpState
    #[inline(always)]
    pub fn set_gtw_bmp_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 275 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id113gtwBmpDebug {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id113gtwBmpDebug
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let gtw_bmp_awake_pin = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_gtw_pmic_error = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_gtw_pmic_on = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_gtw_pmic_thermtrip = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_gtw_soc_pwrok = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_gtw_n_suspwr = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_periph_n_rst_3v3_pin = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_pgood_pin = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_pmic_pwr_on = u.int_in_range(0..=1)? == 1;
        let gtw_bmp_state = u.int_in_range(0..=255)?;
        Id113gtwBmpDebug::new(gtw_bmp_awake_pin,gtw_bmp_gtw_pmic_error,gtw_bmp_gtw_pmic_on,gtw_bmp_gtw_pmic_thermtrip,gtw_bmp_gtw_soc_pwrok,gtw_bmp_gtw_n_suspwr,gtw_bmp_periph_n_rst_3v3_pin,gtw_bmp_pgood_pin,gtw_bmp_pmic_pwr_on,gtw_bmp_state).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for GTW_bmpState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id113gtwBmpDebugGtwBmpState {
    BmpStateAsleep,
    BmpStateMia,
    BmpStateOff,
    BmpStateOn,
    BmpStatePowerCycle,
    BmpStateReset,
    Dummy,
    Other(u8),
}

/// ID119VCSEC_windowRequests
///
/// - ID: 281 (0x119)
/// - Size: 2 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id119vcsecWindowRequests {
    raw: [u8; 2],
}

impl Id119vcsecWindowRequests {
    pub const MESSAGE_ID: u32 = 281;
    
    /// Construct new ID119VCSEC_windowRequests from values
    pub fn new(vcsec_hvac_run_screen_protect_only: bool, vcsec_window_request_lf: bool, vcsec_window_request_lr: bool, vcsec_window_request_percent: u8, vcsec_window_request_rf: bool, vcsec_window_request_rr: bool, vcsec_window_request_type: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_vcsec_hvac_run_screen_protect_only(vcsec_hvac_run_screen_protect_only)?;
        res.set_vcsec_window_request_lf(vcsec_window_request_lf)?;
        res.set_vcsec_window_request_lr(vcsec_window_request_lr)?;
        res.set_vcsec_window_request_percent(vcsec_window_request_percent)?;
        res.set_vcsec_window_request_rf(vcsec_window_request_rf)?;
        res.set_vcsec_window_request_rr(vcsec_window_request_rr)?;
        res.set_vcsec_window_request_type(vcsec_window_request_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCSEC_hvacRunScreenProtectOnly
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_hvac_run_screen_protect_only(&self) -> bool {
        self.vcsec_hvac_run_screen_protect_only_raw()
    }
    
    /// Get raw value of VCSEC_hvacRunScreenProtectOnly
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_hvac_run_screen_protect_only_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCSEC_hvacRunScreenProtectOnly
    #[inline(always)]
    pub fn set_vcsec_hvac_run_screen_protect_only(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// VCSEC_windowRequestLF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_window_request_lf(&self) -> bool {
        self.vcsec_window_request_lf_raw()
    }
    
    /// Get raw value of VCSEC_windowRequestLF
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_window_request_lf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCSEC_windowRequestLF
    #[inline(always)]
    pub fn set_vcsec_window_request_lf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// VCSEC_windowRequestLR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_window_request_lr(&self) -> bool {
        self.vcsec_window_request_lr_raw()
    }
    
    /// Get raw value of VCSEC_windowRequestLR
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_window_request_lr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCSEC_windowRequestLR
    #[inline(always)]
    pub fn set_vcsec_window_request_lr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// VCSEC_windowRequestPercent
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_window_request_percent(&self) -> Id119vcsecWindowRequestsVcsecWindowRequestPercent {
        match self.vcsec_window_request_percent_raw() {
            127 => Id119vcsecWindowRequestsVcsecWindowRequestPercent::Sna,
            x => Id119vcsecWindowRequestsVcsecWindowRequestPercent::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_windowRequestPercent
    ///
    /// - Start bit: 8
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_window_request_percent_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_windowRequestPercent
    #[inline(always)]
    pub fn set_vcsec_window_request_percent(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 281 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..15].store_le(value);
        Ok(())
    }
    
    /// VCSEC_windowRequestRF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_window_request_rf(&self) -> bool {
        self.vcsec_window_request_rf_raw()
    }
    
    /// Get raw value of VCSEC_windowRequestRF
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_window_request_rf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCSEC_windowRequestRF
    #[inline(always)]
    pub fn set_vcsec_window_request_rf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// VCSEC_windowRequestRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_window_request_rr(&self) -> bool {
        self.vcsec_window_request_rr_raw()
    }
    
    /// Get raw value of VCSEC_windowRequestRR
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_window_request_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCSEC_windowRequestRR
    #[inline(always)]
    pub fn set_vcsec_window_request_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// VCSEC_windowRequestType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_window_request_type(&self) -> Id119vcsecWindowRequestsVcsecWindowRequestType {
        match self.vcsec_window_request_type_raw() {
            3 => Id119vcsecWindowRequestsVcsecWindowRequestType::WindowRequestGotoClosed,
            2 => Id119vcsecWindowRequestsVcsecWindowRequestType::WindowRequestGotoCracked,
            1 => Id119vcsecWindowRequestsVcsecWindowRequestType::WindowRequestGotoPercent,
            0 => Id119vcsecWindowRequestsVcsecWindowRequestType::WindowRequestIdle,
            x => Id119vcsecWindowRequestsVcsecWindowRequestType::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_windowRequestType
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_window_request_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_windowRequestType
    #[inline(always)]
    pub fn set_vcsec_window_request_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 281 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id119vcsecWindowRequests {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id119vcsecWindowRequests
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcsec_hvac_run_screen_protect_only = u.int_in_range(0..=1)? == 1;
        let vcsec_window_request_lf = u.int_in_range(0..=1)? == 1;
        let vcsec_window_request_lr = u.int_in_range(0..=1)? == 1;
        let vcsec_window_request_percent = u.int_in_range(0..=127)?;
        let vcsec_window_request_rf = u.int_in_range(0..=1)? == 1;
        let vcsec_window_request_rr = u.int_in_range(0..=1)? == 1;
        let vcsec_window_request_type = u.int_in_range(0..=3)?;
        Id119vcsecWindowRequests::new(vcsec_hvac_run_screen_protect_only,vcsec_window_request_lf,vcsec_window_request_lr,vcsec_window_request_percent,vcsec_window_request_rf,vcsec_window_request_rr,vcsec_window_request_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCSEC_windowRequestPercent
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id119vcsecWindowRequestsVcsecWindowRequestPercent {
    Sna,
    Other(u8),
}
/// Defined values for VCSEC_windowRequestType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id119vcsecWindowRequestsVcsecWindowRequestType {
    WindowRequestGotoClosed,
    WindowRequestGotoCracked,
    WindowRequestGotoPercent,
    WindowRequestIdle,
    Other(u8),
}

/// ID122VCLEFT_doorStatus2
///
/// - ID: 290 (0x122)
/// - Size: 6 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id122vcleftDoorStatus2 {
    raw: [u8; 6],
}

impl Id122vcleftDoorStatus2 {
    pub const MESSAGE_ID: u32 = 290;
    
    /// Construct new ID122VCLEFT_doorStatus2 from values
    pub fn new(vcleft_front_door_state: u8, vcleft_front_handle5v_enable: bool, vcleft_front_handle_debounce_status: u8, vcleft_front_handle_raw_status: u8, vcleft_front_latch_rel_duty: u8, vcleft_mirror_fold_max_current: f32, vcleft_rear_door_state: u8, vcleft_rear_handle5v_enable: bool, vcleft_rear_handle_debounce_status: u8, vcleft_rear_handle_raw_status: u8, vcleft_rear_latch_rel_duty: u8, vcleft_vehicle_in_motion: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_vcleft_front_door_state(vcleft_front_door_state)?;
        res.set_vcleft_front_handle5v_enable(vcleft_front_handle5v_enable)?;
        res.set_vcleft_front_handle_debounce_status(vcleft_front_handle_debounce_status)?;
        res.set_vcleft_front_handle_raw_status(vcleft_front_handle_raw_status)?;
        res.set_vcleft_front_latch_rel_duty(vcleft_front_latch_rel_duty)?;
        res.set_vcleft_mirror_fold_max_current(vcleft_mirror_fold_max_current)?;
        res.set_vcleft_rear_door_state(vcleft_rear_door_state)?;
        res.set_vcleft_rear_handle5v_enable(vcleft_rear_handle5v_enable)?;
        res.set_vcleft_rear_handle_debounce_status(vcleft_rear_handle_debounce_status)?;
        res.set_vcleft_rear_handle_raw_status(vcleft_rear_handle_raw_status)?;
        res.set_vcleft_rear_latch_rel_duty(vcleft_rear_latch_rel_duty)?;
        res.set_vcleft_vehicle_in_motion(vcleft_vehicle_in_motion)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCLEFT_frontDoorState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_door_state(&self) -> Id122vcleftDoorStatus2VcleftFrontDoorState {
        match self.vcleft_front_door_state_raw() {
            1 => Id122vcleftDoorStatus2VcleftFrontDoorState::DoorStateClosed,
            4 => Id122vcleftDoorStatus2VcleftFrontDoorState::DoorStateOpenOrAjar,
            3 => Id122vcleftDoorStatus2VcleftFrontDoorState::DoorStateReleasingLatch,
            0 => Id122vcleftDoorStatus2VcleftFrontDoorState::DoorStateUnknown,
            2 => Id122vcleftDoorStatus2VcleftFrontDoorState::DoorStateWaitForShortDrop,
            x => Id122vcleftDoorStatus2VcleftFrontDoorState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_frontDoorState
    ///
    /// - Start bit: 17
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_door_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[17..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_frontDoorState
    #[inline(always)]
    pub fn set_vcleft_front_door_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[17..20].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontHandle5vEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_handle5v_enable(&self) -> bool {
        self.vcleft_front_handle5v_enable_raw()
    }
    
    /// Get raw value of VCLEFT_frontHandle5vEnable
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_handle5v_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_frontHandle5vEnable
    #[inline(always)]
    pub fn set_vcleft_front_handle5v_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontHandleDebounceStatus
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_handle_debounce_status(&self) -> Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus {
        match self.vcleft_front_handle_debounce_status_raw() {
            3 => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::ExteriorHandleStatusActive,
            4 => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::ExteriorHandleStatusDisconnected,
            5 => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::ExteriorHandleStatusFault,
            1 => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::ExteriorHandleStatusIndeterminate,
            2 => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::ExteriorHandleStatusNotActive,
            0 => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::ExteriorHandleStatusSna,
            x => Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_frontHandleDebounceStatus
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_handle_debounce_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_frontHandleDebounceStatus
    #[inline(always)]
    pub fn set_vcleft_front_handle_debounce_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..35].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontHandleRawStatus
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_handle_raw_status(&self) -> Id122vcleftDoorStatus2VcleftFrontHandleRawStatus {
        match self.vcleft_front_handle_raw_status_raw() {
            3 => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::ExteriorHandleStatusActive,
            4 => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::ExteriorHandleStatusDisconnected,
            5 => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::ExteriorHandleStatusFault,
            1 => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::ExteriorHandleStatusIndeterminate,
            2 => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::ExteriorHandleStatusNotActive,
            0 => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::ExteriorHandleStatusSna,
            x => Id122vcleftDoorStatus2VcleftFrontHandleRawStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_frontHandleRawStatus
    ///
    /// - Start bit: 24
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_handle_raw_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_frontHandleRawStatus
    #[inline(always)]
    pub fn set_vcleft_front_handle_raw_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..27].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontLatchRelDuty
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_latch_rel_duty(&self) -> u8 {
        self.vcleft_front_latch_rel_duty_raw()
    }
    
    /// Get raw value of VCLEFT_frontLatchRelDuty
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_front_latch_rel_duty_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_frontLatchRelDuty
    #[inline(always)]
    pub fn set_vcleft_front_latch_rel_duty(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_mirrorFoldMaxCurrent
    ///
    /// - Min: -2.944
    /// - Max: 2.898
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_mirror_fold_max_current(&self) -> f32 {
        self.vcleft_mirror_fold_max_current_raw()
    }
    
    /// Get raw value of VCLEFT_mirrorFoldMaxCurrent
    ///
    /// - Start bit: 40
    /// - Signal size: 7 bits
    /// - Factor: 0.046
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_mirror_fold_max_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..47].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.046_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_mirrorFoldMaxCurrent
    #[inline(always)]
    pub fn set_vcleft_mirror_fold_max_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -2.944_f32 || 2.898_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        let factor = 0.046_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..47].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearDoorState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_door_state(&self) -> Id122vcleftDoorStatus2VcleftRearDoorState {
        match self.vcleft_rear_door_state_raw() {
            1 => Id122vcleftDoorStatus2VcleftRearDoorState::DoorStateClosed,
            4 => Id122vcleftDoorStatus2VcleftRearDoorState::DoorStateOpenOrAjar,
            3 => Id122vcleftDoorStatus2VcleftRearDoorState::DoorStateReleasingLatch,
            0 => Id122vcleftDoorStatus2VcleftRearDoorState::DoorStateUnknown,
            2 => Id122vcleftDoorStatus2VcleftRearDoorState::DoorStateWaitForShortDrop,
            x => Id122vcleftDoorStatus2VcleftRearDoorState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rearDoorState
    ///
    /// - Start bit: 20
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_door_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rearDoorState
    #[inline(always)]
    pub fn set_vcleft_rear_door_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..23].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearHandle5vEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_handle5v_enable(&self) -> bool {
        self.vcleft_rear_handle5v_enable_raw()
    }
    
    /// Get raw value of VCLEFT_rearHandle5vEnable
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_handle5v_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_rearHandle5vEnable
    #[inline(always)]
    pub fn set_vcleft_rear_handle5v_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearHandleDebounceStatus
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_handle_debounce_status(&self) -> Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus {
        match self.vcleft_rear_handle_debounce_status_raw() {
            3 => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::ExteriorHandleStatusActive,
            4 => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::ExteriorHandleStatusDisconnected,
            5 => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::ExteriorHandleStatusFault,
            1 => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::ExteriorHandleStatusIndeterminate,
            2 => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::ExteriorHandleStatusNotActive,
            0 => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::ExteriorHandleStatusSna,
            x => Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rearHandleDebounceStatus
    ///
    /// - Start bit: 35
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_handle_debounce_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[35..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rearHandleDebounceStatus
    #[inline(always)]
    pub fn set_vcleft_rear_handle_debounce_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[35..38].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearHandleRawStatus
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_handle_raw_status(&self) -> Id122vcleftDoorStatus2VcleftRearHandleRawStatus {
        match self.vcleft_rear_handle_raw_status_raw() {
            3 => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::ExteriorHandleStatusActive,
            4 => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::ExteriorHandleStatusDisconnected,
            5 => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::ExteriorHandleStatusFault,
            1 => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::ExteriorHandleStatusIndeterminate,
            2 => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::ExteriorHandleStatusNotActive,
            0 => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::ExteriorHandleStatusSna,
            x => Id122vcleftDoorStatus2VcleftRearHandleRawStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rearHandleRawStatus
    ///
    /// - Start bit: 27
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_handle_raw_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rearHandleRawStatus
    #[inline(always)]
    pub fn set_vcleft_rear_handle_raw_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..30].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearLatchRelDuty
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_latch_rel_duty(&self) -> u8 {
        self.vcleft_rear_latch_rel_duty_raw()
    }
    
    /// Get raw value of VCLEFT_rearLatchRelDuty
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rear_latch_rel_duty_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rearLatchRelDuty
    #[inline(always)]
    pub fn set_vcleft_rear_latch_rel_duty(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 290 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_vehicleInMotion
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_vehicle_in_motion(&self) -> bool {
        self.vcleft_vehicle_in_motion_raw()
    }
    
    /// Get raw value of VCLEFT_vehicleInMotion
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_vehicle_in_motion_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_vehicleInMotion
    #[inline(always)]
    pub fn set_vcleft_vehicle_in_motion(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id122vcleftDoorStatus2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id122vcleftDoorStatus2
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcleft_front_door_state = u.int_in_range(0..=4)?;
        let vcleft_front_handle5v_enable = u.int_in_range(0..=1)? == 1;
        let vcleft_front_handle_debounce_status = u.int_in_range(0..=5)?;
        let vcleft_front_handle_raw_status = u.int_in_range(0..=5)?;
        let vcleft_front_latch_rel_duty = u.int_in_range(0..=255)?;
        let vcleft_mirror_fold_max_current = -2.944_f32;
        let vcleft_rear_door_state = u.int_in_range(0..=4)?;
        let vcleft_rear_handle5v_enable = u.int_in_range(0..=1)? == 1;
        let vcleft_rear_handle_debounce_status = u.int_in_range(0..=5)?;
        let vcleft_rear_handle_raw_status = u.int_in_range(0..=5)?;
        let vcleft_rear_latch_rel_duty = u.int_in_range(0..=255)?;
        let vcleft_vehicle_in_motion = u.int_in_range(0..=1)? == 1;
        Id122vcleftDoorStatus2::new(vcleft_front_door_state,vcleft_front_handle5v_enable,vcleft_front_handle_debounce_status,vcleft_front_handle_raw_status,vcleft_front_latch_rel_duty,vcleft_mirror_fold_max_current,vcleft_rear_door_state,vcleft_rear_handle5v_enable,vcleft_rear_handle_debounce_status,vcleft_rear_handle_raw_status,vcleft_rear_latch_rel_duty,vcleft_vehicle_in_motion).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCLEFT_frontDoorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id122vcleftDoorStatus2VcleftFrontDoorState {
    DoorStateClosed,
    DoorStateOpenOrAjar,
    DoorStateReleasingLatch,
    DoorStateUnknown,
    DoorStateWaitForShortDrop,
    Other(u8),
}
/// Defined values for VCLEFT_frontHandleDebounceStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id122vcleftDoorStatus2VcleftFrontHandleDebounceStatus {
    ExteriorHandleStatusActive,
    ExteriorHandleStatusDisconnected,
    ExteriorHandleStatusFault,
    ExteriorHandleStatusIndeterminate,
    ExteriorHandleStatusNotActive,
    ExteriorHandleStatusSna,
    Other(u8),
}
/// Defined values for VCLEFT_frontHandleRawStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id122vcleftDoorStatus2VcleftFrontHandleRawStatus {
    ExteriorHandleStatusActive,
    ExteriorHandleStatusDisconnected,
    ExteriorHandleStatusFault,
    ExteriorHandleStatusIndeterminate,
    ExteriorHandleStatusNotActive,
    ExteriorHandleStatusSna,
    Other(u8),
}
/// Defined values for VCLEFT_rearDoorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id122vcleftDoorStatus2VcleftRearDoorState {
    DoorStateClosed,
    DoorStateOpenOrAjar,
    DoorStateReleasingLatch,
    DoorStateUnknown,
    DoorStateWaitForShortDrop,
    Other(u8),
}
/// Defined values for VCLEFT_rearHandleDebounceStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id122vcleftDoorStatus2VcleftRearHandleDebounceStatus {
    ExteriorHandleStatusActive,
    ExteriorHandleStatusDisconnected,
    ExteriorHandleStatusFault,
    ExteriorHandleStatusIndeterminate,
    ExteriorHandleStatusNotActive,
    ExteriorHandleStatusSna,
    Other(u8),
}
/// Defined values for VCLEFT_rearHandleRawStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id122vcleftDoorStatus2VcleftRearHandleRawStatus {
    ExteriorHandleStatusActive,
    ExteriorHandleStatusDisconnected,
    ExteriorHandleStatusFault,
    ExteriorHandleStatusIndeterminate,
    ExteriorHandleStatusNotActive,
    ExteriorHandleStatusSna,
    Other(u8),
}

/// ID123UI_alertMatrix1
///
/// - ID: 291 (0x123)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id123uiAlertMatrix1 {
    raw: [u8; 8],
}

impl Id123uiAlertMatrix1 {
    pub const MESSAGE_ID: u32 = 291;
    
    /// Construct new ID123UI_alertMatrix1 from values
    pub fn new(ui_a001_driver_door_open: bool, ui_a002_door_open: bool, ui_a003_trunk_open: bool, ui_a004_frunk_open: bool, ui_a005_headlights_on_door_open: bool, ui_a006_remote_service_alert: bool, ui_a007_soft_pack_config_mismatch: bool, ui_a008_touch_screen_error: bool, ui_a009_squashfs_error: bool, ui_a010_maps_missing: bool, ui_a011_incorrect_map: bool, ui_a012_not_on_private_property: bool, ui_a013_tpms_hard_warning: bool, ui_a014_tpms_soft_warning: bool, ui_a015_tpms_over_pressure_warning: bool, ui_a016_tpms_temperature_warning: bool, ui_a017_tpms_system_fault: bool, ui_a018_slip_start_on: bool, ui_a019_park_brake_fault: bool, ui_a020_steering_reduced: bool, ui_a021_rear_seatbelt_unbuckled: bool, ui_a022_ape_fuses_etc: bool, ui_a023_cell_internet_check_failed: bool, ui_a024_wifi_internet_check_failed: bool, ui_a025_wifi_online_check_failed: bool, ui_a026_modem_reset_loop_detected: bool, ui_a027_auto_steer_mia: bool, ui_a028_front_trunk_popup_closed: bool, ui_a029_modem_mia: bool, ui_a030_modem_vm_crash: bool, ui_a031_brake_fluid_low: bool, ui_a032_cell_modem_recovery_resets: bool, ui_a033_ap_trial_expired: bool, ui_a034_wakeup_problem: bool, ui_a035_audio_watchdog_kernel_error: bool, ui_a036_audio_watchdog_hfp_error: bool, ui_a037_audio_watchdog_xrun_storm_er: bool, ui_a038_audio_watchdog_a2b_i2c_locku: bool, ui_a039_audio_a2b_need_rediscovery: bool, ui_a040_homelink_transmit: bool, ui_a041_audio_dmesg_xrun: bool, ui_a042_audio_dmesg_rt_throttling: bool, ui_a043_invalid_map_data_override: bool, ui_a044_audio_dmesg_dsp_exception: bool, ui_a045_e_call_needs_service: bool, ui_a046_backup_camera_stream_error: bool, ui_a047_cell_roaming_disallowed: bool, ui_a048_audio_premium_amp_check_fail: bool, ui_a049_brake_shift_required: bool, ui_a050_backup_camera_ipu_timeout: bool, ui_a051_backup_camera_frame_timeout: bool, ui_a052_kernel_panic_reported: bool, ui_a053_qt_car_exit_error: bool, ui_a054_audio_boost_power_bad: bool, ui_a055_manual_e_call_disabled: bool, ui_a056_manual_e_call_button_disconn: bool, ui_a057_cell_antenna_disconnected: bool, ui_a058_gps_antenna_disconnected: bool, ui_a059_e_call_speaker_disconnected: bool, ui_a060_e_call_mic_disconnected: bool, ui_a061_sim_test_failed: bool, ui_a062_ens_test_failed: bool, ui_a063_cellular_test_failed: bool, ui_a064_modem_firmware_test_failed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_a001_driver_door_open(ui_a001_driver_door_open)?;
        res.set_ui_a002_door_open(ui_a002_door_open)?;
        res.set_ui_a003_trunk_open(ui_a003_trunk_open)?;
        res.set_ui_a004_frunk_open(ui_a004_frunk_open)?;
        res.set_ui_a005_headlights_on_door_open(ui_a005_headlights_on_door_open)?;
        res.set_ui_a006_remote_service_alert(ui_a006_remote_service_alert)?;
        res.set_ui_a007_soft_pack_config_mismatch(ui_a007_soft_pack_config_mismatch)?;
        res.set_ui_a008_touch_screen_error(ui_a008_touch_screen_error)?;
        res.set_ui_a009_squashfs_error(ui_a009_squashfs_error)?;
        res.set_ui_a010_maps_missing(ui_a010_maps_missing)?;
        res.set_ui_a011_incorrect_map(ui_a011_incorrect_map)?;
        res.set_ui_a012_not_on_private_property(ui_a012_not_on_private_property)?;
        res.set_ui_a013_tpms_hard_warning(ui_a013_tpms_hard_warning)?;
        res.set_ui_a014_tpms_soft_warning(ui_a014_tpms_soft_warning)?;
        res.set_ui_a015_tpms_over_pressure_warning(ui_a015_tpms_over_pressure_warning)?;
        res.set_ui_a016_tpms_temperature_warning(ui_a016_tpms_temperature_warning)?;
        res.set_ui_a017_tpms_system_fault(ui_a017_tpms_system_fault)?;
        res.set_ui_a018_slip_start_on(ui_a018_slip_start_on)?;
        res.set_ui_a019_park_brake_fault(ui_a019_park_brake_fault)?;
        res.set_ui_a020_steering_reduced(ui_a020_steering_reduced)?;
        res.set_ui_a021_rear_seatbelt_unbuckled(ui_a021_rear_seatbelt_unbuckled)?;
        res.set_ui_a022_ape_fuses_etc(ui_a022_ape_fuses_etc)?;
        res.set_ui_a023_cell_internet_check_failed(ui_a023_cell_internet_check_failed)?;
        res.set_ui_a024_wifi_internet_check_failed(ui_a024_wifi_internet_check_failed)?;
        res.set_ui_a025_wifi_online_check_failed(ui_a025_wifi_online_check_failed)?;
        res.set_ui_a026_modem_reset_loop_detected(ui_a026_modem_reset_loop_detected)?;
        res.set_ui_a027_auto_steer_mia(ui_a027_auto_steer_mia)?;
        res.set_ui_a028_front_trunk_popup_closed(ui_a028_front_trunk_popup_closed)?;
        res.set_ui_a029_modem_mia(ui_a029_modem_mia)?;
        res.set_ui_a030_modem_vm_crash(ui_a030_modem_vm_crash)?;
        res.set_ui_a031_brake_fluid_low(ui_a031_brake_fluid_low)?;
        res.set_ui_a032_cell_modem_recovery_resets(ui_a032_cell_modem_recovery_resets)?;
        res.set_ui_a033_ap_trial_expired(ui_a033_ap_trial_expired)?;
        res.set_ui_a034_wakeup_problem(ui_a034_wakeup_problem)?;
        res.set_ui_a035_audio_watchdog_kernel_error(ui_a035_audio_watchdog_kernel_error)?;
        res.set_ui_a036_audio_watchdog_hfp_error(ui_a036_audio_watchdog_hfp_error)?;
        res.set_ui_a037_audio_watchdog_xrun_storm_er(ui_a037_audio_watchdog_xrun_storm_er)?;
        res.set_ui_a038_audio_watchdog_a2b_i2c_locku(ui_a038_audio_watchdog_a2b_i2c_locku)?;
        res.set_ui_a039_audio_a2b_need_rediscovery(ui_a039_audio_a2b_need_rediscovery)?;
        res.set_ui_a040_homelink_transmit(ui_a040_homelink_transmit)?;
        res.set_ui_a041_audio_dmesg_xrun(ui_a041_audio_dmesg_xrun)?;
        res.set_ui_a042_audio_dmesg_rt_throttling(ui_a042_audio_dmesg_rt_throttling)?;
        res.set_ui_a043_invalid_map_data_override(ui_a043_invalid_map_data_override)?;
        res.set_ui_a044_audio_dmesg_dsp_exception(ui_a044_audio_dmesg_dsp_exception)?;
        res.set_ui_a045_e_call_needs_service(ui_a045_e_call_needs_service)?;
        res.set_ui_a046_backup_camera_stream_error(ui_a046_backup_camera_stream_error)?;
        res.set_ui_a047_cell_roaming_disallowed(ui_a047_cell_roaming_disallowed)?;
        res.set_ui_a048_audio_premium_amp_check_fail(ui_a048_audio_premium_amp_check_fail)?;
        res.set_ui_a049_brake_shift_required(ui_a049_brake_shift_required)?;
        res.set_ui_a050_backup_camera_ipu_timeout(ui_a050_backup_camera_ipu_timeout)?;
        res.set_ui_a051_backup_camera_frame_timeout(ui_a051_backup_camera_frame_timeout)?;
        res.set_ui_a052_kernel_panic_reported(ui_a052_kernel_panic_reported)?;
        res.set_ui_a053_qt_car_exit_error(ui_a053_qt_car_exit_error)?;
        res.set_ui_a054_audio_boost_power_bad(ui_a054_audio_boost_power_bad)?;
        res.set_ui_a055_manual_e_call_disabled(ui_a055_manual_e_call_disabled)?;
        res.set_ui_a056_manual_e_call_button_disconn(ui_a056_manual_e_call_button_disconn)?;
        res.set_ui_a057_cell_antenna_disconnected(ui_a057_cell_antenna_disconnected)?;
        res.set_ui_a058_gps_antenna_disconnected(ui_a058_gps_antenna_disconnected)?;
        res.set_ui_a059_e_call_speaker_disconnected(ui_a059_e_call_speaker_disconnected)?;
        res.set_ui_a060_e_call_mic_disconnected(ui_a060_e_call_mic_disconnected)?;
        res.set_ui_a061_sim_test_failed(ui_a061_sim_test_failed)?;
        res.set_ui_a062_ens_test_failed(ui_a062_ens_test_failed)?;
        res.set_ui_a063_cellular_test_failed(ui_a063_cellular_test_failed)?;
        res.set_ui_a064_modem_firmware_test_failed(ui_a064_modem_firmware_test_failed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_a001_DriverDoorOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a001_driver_door_open(&self) -> bool {
        self.ui_a001_driver_door_open_raw()
    }
    
    /// Get raw value of UI_a001_DriverDoorOpen
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a001_driver_door_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a001_DriverDoorOpen
    #[inline(always)]
    pub fn set_ui_a001_driver_door_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_a002_DoorOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a002_door_open(&self) -> bool {
        self.ui_a002_door_open_raw()
    }
    
    /// Get raw value of UI_a002_DoorOpen
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a002_door_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a002_DoorOpen
    #[inline(always)]
    pub fn set_ui_a002_door_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_a003_TrunkOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a003_trunk_open(&self) -> bool {
        self.ui_a003_trunk_open_raw()
    }
    
    /// Get raw value of UI_a003_TrunkOpen
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a003_trunk_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a003_TrunkOpen
    #[inline(always)]
    pub fn set_ui_a003_trunk_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UI_a004_FrunkOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a004_frunk_open(&self) -> bool {
        self.ui_a004_frunk_open_raw()
    }
    
    /// Get raw value of UI_a004_FrunkOpen
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a004_frunk_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a004_FrunkOpen
    #[inline(always)]
    pub fn set_ui_a004_frunk_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_a005_HeadlightsOnDoorOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a005_headlights_on_door_open(&self) -> bool {
        self.ui_a005_headlights_on_door_open_raw()
    }
    
    /// Get raw value of UI_a005_HeadlightsOnDoorOpen
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a005_headlights_on_door_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a005_HeadlightsOnDoorOpen
    #[inline(always)]
    pub fn set_ui_a005_headlights_on_door_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_a006_RemoteServiceAlert
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a006_remote_service_alert(&self) -> bool {
        self.ui_a006_remote_service_alert_raw()
    }
    
    /// Get raw value of UI_a006_RemoteServiceAlert
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a006_remote_service_alert_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a006_RemoteServiceAlert
    #[inline(always)]
    pub fn set_ui_a006_remote_service_alert(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// UI_a007_SoftPackConfigMismatch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a007_soft_pack_config_mismatch(&self) -> bool {
        self.ui_a007_soft_pack_config_mismatch_raw()
    }
    
    /// Get raw value of UI_a007_SoftPackConfigMismatch
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a007_soft_pack_config_mismatch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a007_SoftPackConfigMismatch
    #[inline(always)]
    pub fn set_ui_a007_soft_pack_config_mismatch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// UI_a008_TouchScreenError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a008_touch_screen_error(&self) -> bool {
        self.ui_a008_touch_screen_error_raw()
    }
    
    /// Get raw value of UI_a008_TouchScreenError
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a008_touch_screen_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a008_TouchScreenError
    #[inline(always)]
    pub fn set_ui_a008_touch_screen_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// UI_a009_SquashfsError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a009_squashfs_error(&self) -> bool {
        self.ui_a009_squashfs_error_raw()
    }
    
    /// Get raw value of UI_a009_SquashfsError
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a009_squashfs_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a009_SquashfsError
    #[inline(always)]
    pub fn set_ui_a009_squashfs_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// UI_a010_MapsMissing
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a010_maps_missing(&self) -> bool {
        self.ui_a010_maps_missing_raw()
    }
    
    /// Get raw value of UI_a010_MapsMissing
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a010_maps_missing_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a010_MapsMissing
    #[inline(always)]
    pub fn set_ui_a010_maps_missing(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// UI_a011_IncorrectMap
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a011_incorrect_map(&self) -> bool {
        self.ui_a011_incorrect_map_raw()
    }
    
    /// Get raw value of UI_a011_IncorrectMap
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a011_incorrect_map_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a011_IncorrectMap
    #[inline(always)]
    pub fn set_ui_a011_incorrect_map(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// UI_a012_NotOnPrivateProperty
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a012_not_on_private_property(&self) -> bool {
        self.ui_a012_not_on_private_property_raw()
    }
    
    /// Get raw value of UI_a012_NotOnPrivateProperty
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a012_not_on_private_property_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a012_NotOnPrivateProperty
    #[inline(always)]
    pub fn set_ui_a012_not_on_private_property(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// UI_a013_TPMSHardWarning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a013_tpms_hard_warning(&self) -> bool {
        self.ui_a013_tpms_hard_warning_raw()
    }
    
    /// Get raw value of UI_a013_TPMSHardWarning
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a013_tpms_hard_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a013_TPMSHardWarning
    #[inline(always)]
    pub fn set_ui_a013_tpms_hard_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// UI_a014_TPMSSoftWarning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a014_tpms_soft_warning(&self) -> bool {
        self.ui_a014_tpms_soft_warning_raw()
    }
    
    /// Get raw value of UI_a014_TPMSSoftWarning
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a014_tpms_soft_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a014_TPMSSoftWarning
    #[inline(always)]
    pub fn set_ui_a014_tpms_soft_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// UI_a015_TPMSOverPressureWarning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a015_tpms_over_pressure_warning(&self) -> bool {
        self.ui_a015_tpms_over_pressure_warning_raw()
    }
    
    /// Get raw value of UI_a015_TPMSOverPressureWarning
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a015_tpms_over_pressure_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a015_TPMSOverPressureWarning
    #[inline(always)]
    pub fn set_ui_a015_tpms_over_pressure_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// UI_a016_TPMSTemperatureWarning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a016_tpms_temperature_warning(&self) -> bool {
        self.ui_a016_tpms_temperature_warning_raw()
    }
    
    /// Get raw value of UI_a016_TPMSTemperatureWarning
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a016_tpms_temperature_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a016_TPMSTemperatureWarning
    #[inline(always)]
    pub fn set_ui_a016_tpms_temperature_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// UI_a017_TPMSSystemFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a017_tpms_system_fault(&self) -> bool {
        self.ui_a017_tpms_system_fault_raw()
    }
    
    /// Get raw value of UI_a017_TPMSSystemFault
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a017_tpms_system_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a017_TPMSSystemFault
    #[inline(always)]
    pub fn set_ui_a017_tpms_system_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// UI_a018_SlipStartOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a018_slip_start_on(&self) -> bool {
        self.ui_a018_slip_start_on_raw()
    }
    
    /// Get raw value of UI_a018_SlipStartOn
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a018_slip_start_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a018_SlipStartOn
    #[inline(always)]
    pub fn set_ui_a018_slip_start_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// UI_a019_ParkBrakeFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a019_park_brake_fault(&self) -> bool {
        self.ui_a019_park_brake_fault_raw()
    }
    
    /// Get raw value of UI_a019_ParkBrakeFault
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a019_park_brake_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a019_ParkBrakeFault
    #[inline(always)]
    pub fn set_ui_a019_park_brake_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// UI_a020_SteeringReduced
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a020_steering_reduced(&self) -> bool {
        self.ui_a020_steering_reduced_raw()
    }
    
    /// Get raw value of UI_a020_SteeringReduced
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a020_steering_reduced_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a020_SteeringReduced
    #[inline(always)]
    pub fn set_ui_a020_steering_reduced(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
    /// UI_a021_RearSeatbeltUnbuckled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a021_rear_seatbelt_unbuckled(&self) -> bool {
        self.ui_a021_rear_seatbelt_unbuckled_raw()
    }
    
    /// Get raw value of UI_a021_RearSeatbeltUnbuckled
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a021_rear_seatbelt_unbuckled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a021_RearSeatbeltUnbuckled
    #[inline(always)]
    pub fn set_ui_a021_rear_seatbelt_unbuckled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// UI_a022_ApeFusesEtc
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a022_ape_fuses_etc(&self) -> bool {
        self.ui_a022_ape_fuses_etc_raw()
    }
    
    /// Get raw value of UI_a022_ApeFusesEtc
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a022_ape_fuses_etc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a022_ApeFusesEtc
    #[inline(always)]
    pub fn set_ui_a022_ape_fuses_etc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[21..22].store_le(value);
        Ok(())
    }
    
    /// UI_a023_CellInternetCheckFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a023_cell_internet_check_failed(&self) -> bool {
        self.ui_a023_cell_internet_check_failed_raw()
    }
    
    /// Get raw value of UI_a023_CellInternetCheckFailed
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a023_cell_internet_check_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a023_CellInternetCheckFailed
    #[inline(always)]
    pub fn set_ui_a023_cell_internet_check_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[22..23].store_le(value);
        Ok(())
    }
    
    /// UI_a024_WifiInternetCheckFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a024_wifi_internet_check_failed(&self) -> bool {
        self.ui_a024_wifi_internet_check_failed_raw()
    }
    
    /// Get raw value of UI_a024_WifiInternetCheckFailed
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a024_wifi_internet_check_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a024_WifiInternetCheckFailed
    #[inline(always)]
    pub fn set_ui_a024_wifi_internet_check_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// UI_a025_WifiOnlineCheckFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a025_wifi_online_check_failed(&self) -> bool {
        self.ui_a025_wifi_online_check_failed_raw()
    }
    
    /// Get raw value of UI_a025_WifiOnlineCheckFailed
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a025_wifi_online_check_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a025_WifiOnlineCheckFailed
    #[inline(always)]
    pub fn set_ui_a025_wifi_online_check_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// UI_a026_ModemResetLoopDetected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a026_modem_reset_loop_detected(&self) -> bool {
        self.ui_a026_modem_reset_loop_detected_raw()
    }
    
    /// Get raw value of UI_a026_ModemResetLoopDetected
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a026_modem_reset_loop_detected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a026_ModemResetLoopDetected
    #[inline(always)]
    pub fn set_ui_a026_modem_reset_loop_detected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// UI_a027_AutoSteerMIA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a027_auto_steer_mia(&self) -> bool {
        self.ui_a027_auto_steer_mia_raw()
    }
    
    /// Get raw value of UI_a027_AutoSteerMIA
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a027_auto_steer_mia_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a027_AutoSteerMIA
    #[inline(always)]
    pub fn set_ui_a027_auto_steer_mia(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// UI_a028_FrontTrunkPopupClosed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a028_front_trunk_popup_closed(&self) -> bool {
        self.ui_a028_front_trunk_popup_closed_raw()
    }
    
    /// Get raw value of UI_a028_FrontTrunkPopupClosed
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a028_front_trunk_popup_closed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a028_FrontTrunkPopupClosed
    #[inline(always)]
    pub fn set_ui_a028_front_trunk_popup_closed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// UI_a029_ModemMIA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a029_modem_mia(&self) -> bool {
        self.ui_a029_modem_mia_raw()
    }
    
    /// Get raw value of UI_a029_ModemMIA
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a029_modem_mia_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a029_ModemMIA
    #[inline(always)]
    pub fn set_ui_a029_modem_mia(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// UI_a030_ModemVMCrash
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a030_modem_vm_crash(&self) -> bool {
        self.ui_a030_modem_vm_crash_raw()
    }
    
    /// Get raw value of UI_a030_ModemVMCrash
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a030_modem_vm_crash_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a030_ModemVMCrash
    #[inline(always)]
    pub fn set_ui_a030_modem_vm_crash(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// UI_a031_BrakeFluidLow
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a031_brake_fluid_low(&self) -> bool {
        self.ui_a031_brake_fluid_low_raw()
    }
    
    /// Get raw value of UI_a031_BrakeFluidLow
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a031_brake_fluid_low_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a031_BrakeFluidLow
    #[inline(always)]
    pub fn set_ui_a031_brake_fluid_low(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// UI_a032_CellModemRecoveryResets
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a032_cell_modem_recovery_resets(&self) -> bool {
        self.ui_a032_cell_modem_recovery_resets_raw()
    }
    
    /// Get raw value of UI_a032_CellModemRecoveryResets
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a032_cell_modem_recovery_resets_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a032_CellModemRecoveryResets
    #[inline(always)]
    pub fn set_ui_a032_cell_modem_recovery_resets(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// UI_a033_ApTrialExpired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a033_ap_trial_expired(&self) -> bool {
        self.ui_a033_ap_trial_expired_raw()
    }
    
    /// Get raw value of UI_a033_ApTrialExpired
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a033_ap_trial_expired_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a033_ApTrialExpired
    #[inline(always)]
    pub fn set_ui_a033_ap_trial_expired(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// UI_a034_WakeupProblem
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a034_wakeup_problem(&self) -> bool {
        self.ui_a034_wakeup_problem_raw()
    }
    
    /// Get raw value of UI_a034_WakeupProblem
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a034_wakeup_problem_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a034_WakeupProblem
    #[inline(always)]
    pub fn set_ui_a034_wakeup_problem(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[33..34].store_le(value);
        Ok(())
    }
    
    /// UI_a035_AudioWatchdogKernelError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a035_audio_watchdog_kernel_error(&self) -> bool {
        self.ui_a035_audio_watchdog_kernel_error_raw()
    }
    
    /// Get raw value of UI_a035_AudioWatchdogKernelError
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a035_audio_watchdog_kernel_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a035_AudioWatchdogKernelError
    #[inline(always)]
    pub fn set_ui_a035_audio_watchdog_kernel_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[34..35].store_le(value);
        Ok(())
    }
    
    /// UI_a036_AudioWatchdogHfpError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a036_audio_watchdog_hfp_error(&self) -> bool {
        self.ui_a036_audio_watchdog_hfp_error_raw()
    }
    
    /// Get raw value of UI_a036_AudioWatchdogHfpError
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a036_audio_watchdog_hfp_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a036_AudioWatchdogHfpError
    #[inline(always)]
    pub fn set_ui_a036_audio_watchdog_hfp_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[35..36].store_le(value);
        Ok(())
    }
    
    /// UI_a037_AudioWatchdogXrunStormEr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a037_audio_watchdog_xrun_storm_er(&self) -> bool {
        self.ui_a037_audio_watchdog_xrun_storm_er_raw()
    }
    
    /// Get raw value of UI_a037_AudioWatchdogXrunStormEr
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a037_audio_watchdog_xrun_storm_er_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a037_AudioWatchdogXrunStormEr
    #[inline(always)]
    pub fn set_ui_a037_audio_watchdog_xrun_storm_er(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
    /// UI_a038_AudioWatchdogA2bI2cLocku
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a038_audio_watchdog_a2b_i2c_locku(&self) -> bool {
        self.ui_a038_audio_watchdog_a2b_i2c_locku_raw()
    }
    
    /// Get raw value of UI_a038_AudioWatchdogA2bI2cLocku
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a038_audio_watchdog_a2b_i2c_locku_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a038_AudioWatchdogA2bI2cLocku
    #[inline(always)]
    pub fn set_ui_a038_audio_watchdog_a2b_i2c_locku(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// UI_a039_AudioA2bNeedRediscovery
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a039_audio_a2b_need_rediscovery(&self) -> bool {
        self.ui_a039_audio_a2b_need_rediscovery_raw()
    }
    
    /// Get raw value of UI_a039_AudioA2bNeedRediscovery
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a039_audio_a2b_need_rediscovery_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a039_AudioA2bNeedRediscovery
    #[inline(always)]
    pub fn set_ui_a039_audio_a2b_need_rediscovery(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// UI_a040_HomelinkTransmit
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a040_homelink_transmit(&self) -> bool {
        self.ui_a040_homelink_transmit_raw()
    }
    
    /// Get raw value of UI_a040_HomelinkTransmit
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a040_homelink_transmit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a040_HomelinkTransmit
    #[inline(always)]
    pub fn set_ui_a040_homelink_transmit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// UI_a041_AudioDmesgXrun
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a041_audio_dmesg_xrun(&self) -> bool {
        self.ui_a041_audio_dmesg_xrun_raw()
    }
    
    /// Get raw value of UI_a041_AudioDmesgXrun
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a041_audio_dmesg_xrun_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a041_AudioDmesgXrun
    #[inline(always)]
    pub fn set_ui_a041_audio_dmesg_xrun(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// UI_a042_AudioDmesgRtThrottling
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a042_audio_dmesg_rt_throttling(&self) -> bool {
        self.ui_a042_audio_dmesg_rt_throttling_raw()
    }
    
    /// Get raw value of UI_a042_AudioDmesgRtThrottling
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a042_audio_dmesg_rt_throttling_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a042_AudioDmesgRtThrottling
    #[inline(always)]
    pub fn set_ui_a042_audio_dmesg_rt_throttling(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// UI_a043_InvalidMapDataOverride
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a043_invalid_map_data_override(&self) -> bool {
        self.ui_a043_invalid_map_data_override_raw()
    }
    
    /// Get raw value of UI_a043_InvalidMapDataOverride
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a043_invalid_map_data_override_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a043_InvalidMapDataOverride
    #[inline(always)]
    pub fn set_ui_a043_invalid_map_data_override(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// UI_a044_AudioDmesgDspException
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a044_audio_dmesg_dsp_exception(&self) -> bool {
        self.ui_a044_audio_dmesg_dsp_exception_raw()
    }
    
    /// Get raw value of UI_a044_AudioDmesgDspException
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a044_audio_dmesg_dsp_exception_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a044_AudioDmesgDspException
    #[inline(always)]
    pub fn set_ui_a044_audio_dmesg_dsp_exception(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// UI_a045_ECallNeedsService
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a045_e_call_needs_service(&self) -> bool {
        self.ui_a045_e_call_needs_service_raw()
    }
    
    /// Get raw value of UI_a045_ECallNeedsService
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a045_e_call_needs_service_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a045_ECallNeedsService
    #[inline(always)]
    pub fn set_ui_a045_e_call_needs_service(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[44..45].store_le(value);
        Ok(())
    }
    
    /// UI_a046_BackupCameraStreamError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a046_backup_camera_stream_error(&self) -> bool {
        self.ui_a046_backup_camera_stream_error_raw()
    }
    
    /// Get raw value of UI_a046_BackupCameraStreamError
    ///
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a046_backup_camera_stream_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[45..46].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a046_BackupCameraStreamError
    #[inline(always)]
    pub fn set_ui_a046_backup_camera_stream_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[45..46].store_le(value);
        Ok(())
    }
    
    /// UI_a047_CellRoamingDisallowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a047_cell_roaming_disallowed(&self) -> bool {
        self.ui_a047_cell_roaming_disallowed_raw()
    }
    
    /// Get raw value of UI_a047_CellRoamingDisallowed
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a047_cell_roaming_disallowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a047_CellRoamingDisallowed
    #[inline(always)]
    pub fn set_ui_a047_cell_roaming_disallowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[46..47].store_le(value);
        Ok(())
    }
    
    /// UI_a048_AudioPremiumAmpCheckFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a048_audio_premium_amp_check_fail(&self) -> bool {
        self.ui_a048_audio_premium_amp_check_fail_raw()
    }
    
    /// Get raw value of UI_a048_AudioPremiumAmpCheckFail
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a048_audio_premium_amp_check_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a048_AudioPremiumAmpCheckFail
    #[inline(always)]
    pub fn set_ui_a048_audio_premium_amp_check_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[47..48].store_le(value);
        Ok(())
    }
    
    /// UI_a049_BrakeShiftRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a049_brake_shift_required(&self) -> bool {
        self.ui_a049_brake_shift_required_raw()
    }
    
    /// Get raw value of UI_a049_BrakeShiftRequired
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a049_brake_shift_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a049_BrakeShiftRequired
    #[inline(always)]
    pub fn set_ui_a049_brake_shift_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// UI_a050_BackupCameraIPUTimeout
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a050_backup_camera_ipu_timeout(&self) -> bool {
        self.ui_a050_backup_camera_ipu_timeout_raw()
    }
    
    /// Get raw value of UI_a050_BackupCameraIPUTimeout
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a050_backup_camera_ipu_timeout_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a050_BackupCameraIPUTimeout
    #[inline(always)]
    pub fn set_ui_a050_backup_camera_ipu_timeout(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// UI_a051_BackupCameraFrameTimeout
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a051_backup_camera_frame_timeout(&self) -> bool {
        self.ui_a051_backup_camera_frame_timeout_raw()
    }
    
    /// Get raw value of UI_a051_BackupCameraFrameTimeout
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a051_backup_camera_frame_timeout_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a051_BackupCameraFrameTimeout
    #[inline(always)]
    pub fn set_ui_a051_backup_camera_frame_timeout(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
    /// UI_a052_KernelPanicReported
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a052_kernel_panic_reported(&self) -> bool {
        self.ui_a052_kernel_panic_reported_raw()
    }
    
    /// Get raw value of UI_a052_KernelPanicReported
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a052_kernel_panic_reported_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a052_KernelPanicReported
    #[inline(always)]
    pub fn set_ui_a052_kernel_panic_reported(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// UI_a053_QtCarExitError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a053_qt_car_exit_error(&self) -> bool {
        self.ui_a053_qt_car_exit_error_raw()
    }
    
    /// Get raw value of UI_a053_QtCarExitError
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a053_qt_car_exit_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a053_QtCarExitError
    #[inline(always)]
    pub fn set_ui_a053_qt_car_exit_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[52..53].store_le(value);
        Ok(())
    }
    
    /// UI_a054_AudioBoostPowerBad
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a054_audio_boost_power_bad(&self) -> bool {
        self.ui_a054_audio_boost_power_bad_raw()
    }
    
    /// Get raw value of UI_a054_AudioBoostPowerBad
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a054_audio_boost_power_bad_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a054_AudioBoostPowerBad
    #[inline(always)]
    pub fn set_ui_a054_audio_boost_power_bad(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[53..54].store_le(value);
        Ok(())
    }
    
    /// UI_a055_ManualECallDisabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a055_manual_e_call_disabled(&self) -> bool {
        self.ui_a055_manual_e_call_disabled_raw()
    }
    
    /// Get raw value of UI_a055_ManualECallDisabled
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a055_manual_e_call_disabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a055_ManualECallDisabled
    #[inline(always)]
    pub fn set_ui_a055_manual_e_call_disabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[54..55].store_le(value);
        Ok(())
    }
    
    /// UI_a056_ManualECallButtonDisconn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a056_manual_e_call_button_disconn(&self) -> bool {
        self.ui_a056_manual_e_call_button_disconn_raw()
    }
    
    /// Get raw value of UI_a056_ManualECallButtonDisconn
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a056_manual_e_call_button_disconn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a056_ManualECallButtonDisconn
    #[inline(always)]
    pub fn set_ui_a056_manual_e_call_button_disconn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[55..56].store_le(value);
        Ok(())
    }
    
    /// UI_a057_CellAntennaDisconnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a057_cell_antenna_disconnected(&self) -> bool {
        self.ui_a057_cell_antenna_disconnected_raw()
    }
    
    /// Get raw value of UI_a057_CellAntennaDisconnected
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a057_cell_antenna_disconnected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a057_CellAntennaDisconnected
    #[inline(always)]
    pub fn set_ui_a057_cell_antenna_disconnected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[56..57].store_le(value);
        Ok(())
    }
    
    /// UI_a058_GPSAntennaDisconnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a058_gps_antenna_disconnected(&self) -> bool {
        self.ui_a058_gps_antenna_disconnected_raw()
    }
    
    /// Get raw value of UI_a058_GPSAntennaDisconnected
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a058_gps_antenna_disconnected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a058_GPSAntennaDisconnected
    #[inline(always)]
    pub fn set_ui_a058_gps_antenna_disconnected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[57..58].store_le(value);
        Ok(())
    }
    
    /// UI_a059_ECallSpeakerDisconnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a059_e_call_speaker_disconnected(&self) -> bool {
        self.ui_a059_e_call_speaker_disconnected_raw()
    }
    
    /// Get raw value of UI_a059_ECallSpeakerDisconnected
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a059_e_call_speaker_disconnected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a059_ECallSpeakerDisconnected
    #[inline(always)]
    pub fn set_ui_a059_e_call_speaker_disconnected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[58..59].store_le(value);
        Ok(())
    }
    
    /// UI_a060_ECallMicDisconnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a060_e_call_mic_disconnected(&self) -> bool {
        self.ui_a060_e_call_mic_disconnected_raw()
    }
    
    /// Get raw value of UI_a060_ECallMicDisconnected
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a060_e_call_mic_disconnected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a060_ECallMicDisconnected
    #[inline(always)]
    pub fn set_ui_a060_e_call_mic_disconnected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[59..60].store_le(value);
        Ok(())
    }
    
    /// UI_a061_SIMTestFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a061_sim_test_failed(&self) -> bool {
        self.ui_a061_sim_test_failed_raw()
    }
    
    /// Get raw value of UI_a061_SIMTestFailed
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a061_sim_test_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a061_SIMTestFailed
    #[inline(always)]
    pub fn set_ui_a061_sim_test_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// UI_a062_ENSTestFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a062_ens_test_failed(&self) -> bool {
        self.ui_a062_ens_test_failed_raw()
    }
    
    /// Get raw value of UI_a062_ENSTestFailed
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a062_ens_test_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a062_ENSTestFailed
    #[inline(always)]
    pub fn set_ui_a062_ens_test_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// UI_a063_CellularTestFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a063_cellular_test_failed(&self) -> bool {
        self.ui_a063_cellular_test_failed_raw()
    }
    
    /// Get raw value of UI_a063_CellularTestFailed
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a063_cellular_test_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a063_CellularTestFailed
    #[inline(always)]
    pub fn set_ui_a063_cellular_test_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// UI_a064_ModemFirmwareTestFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_a064_modem_firmware_test_failed(&self) -> bool {
        self.ui_a064_modem_firmware_test_failed_raw()
    }
    
    /// Get raw value of UI_a064_ModemFirmwareTestFailed
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_a064_modem_firmware_test_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_a064_ModemFirmwareTestFailed
    #[inline(always)]
    pub fn set_ui_a064_modem_firmware_test_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id123uiAlertMatrix1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id123uiAlertMatrix1
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_a001_driver_door_open = u.int_in_range(0..=1)? == 1;
        let ui_a002_door_open = u.int_in_range(0..=1)? == 1;
        let ui_a003_trunk_open = u.int_in_range(0..=1)? == 1;
        let ui_a004_frunk_open = u.int_in_range(0..=1)? == 1;
        let ui_a005_headlights_on_door_open = u.int_in_range(0..=1)? == 1;
        let ui_a006_remote_service_alert = u.int_in_range(0..=1)? == 1;
        let ui_a007_soft_pack_config_mismatch = u.int_in_range(0..=1)? == 1;
        let ui_a008_touch_screen_error = u.int_in_range(0..=1)? == 1;
        let ui_a009_squashfs_error = u.int_in_range(0..=1)? == 1;
        let ui_a010_maps_missing = u.int_in_range(0..=1)? == 1;
        let ui_a011_incorrect_map = u.int_in_range(0..=1)? == 1;
        let ui_a012_not_on_private_property = u.int_in_range(0..=1)? == 1;
        let ui_a013_tpms_hard_warning = u.int_in_range(0..=1)? == 1;
        let ui_a014_tpms_soft_warning = u.int_in_range(0..=1)? == 1;
        let ui_a015_tpms_over_pressure_warning = u.int_in_range(0..=1)? == 1;
        let ui_a016_tpms_temperature_warning = u.int_in_range(0..=1)? == 1;
        let ui_a017_tpms_system_fault = u.int_in_range(0..=1)? == 1;
        let ui_a018_slip_start_on = u.int_in_range(0..=1)? == 1;
        let ui_a019_park_brake_fault = u.int_in_range(0..=1)? == 1;
        let ui_a020_steering_reduced = u.int_in_range(0..=1)? == 1;
        let ui_a021_rear_seatbelt_unbuckled = u.int_in_range(0..=1)? == 1;
        let ui_a022_ape_fuses_etc = u.int_in_range(0..=1)? == 1;
        let ui_a023_cell_internet_check_failed = u.int_in_range(0..=1)? == 1;
        let ui_a024_wifi_internet_check_failed = u.int_in_range(0..=1)? == 1;
        let ui_a025_wifi_online_check_failed = u.int_in_range(0..=1)? == 1;
        let ui_a026_modem_reset_loop_detected = u.int_in_range(0..=1)? == 1;
        let ui_a027_auto_steer_mia = u.int_in_range(0..=1)? == 1;
        let ui_a028_front_trunk_popup_closed = u.int_in_range(0..=1)? == 1;
        let ui_a029_modem_mia = u.int_in_range(0..=1)? == 1;
        let ui_a030_modem_vm_crash = u.int_in_range(0..=1)? == 1;
        let ui_a031_brake_fluid_low = u.int_in_range(0..=1)? == 1;
        let ui_a032_cell_modem_recovery_resets = u.int_in_range(0..=1)? == 1;
        let ui_a033_ap_trial_expired = u.int_in_range(0..=1)? == 1;
        let ui_a034_wakeup_problem = u.int_in_range(0..=1)? == 1;
        let ui_a035_audio_watchdog_kernel_error = u.int_in_range(0..=1)? == 1;
        let ui_a036_audio_watchdog_hfp_error = u.int_in_range(0..=1)? == 1;
        let ui_a037_audio_watchdog_xrun_storm_er = u.int_in_range(0..=1)? == 1;
        let ui_a038_audio_watchdog_a2b_i2c_locku = u.int_in_range(0..=1)? == 1;
        let ui_a039_audio_a2b_need_rediscovery = u.int_in_range(0..=1)? == 1;
        let ui_a040_homelink_transmit = u.int_in_range(0..=1)? == 1;
        let ui_a041_audio_dmesg_xrun = u.int_in_range(0..=1)? == 1;
        let ui_a042_audio_dmesg_rt_throttling = u.int_in_range(0..=1)? == 1;
        let ui_a043_invalid_map_data_override = u.int_in_range(0..=1)? == 1;
        let ui_a044_audio_dmesg_dsp_exception = u.int_in_range(0..=1)? == 1;
        let ui_a045_e_call_needs_service = u.int_in_range(0..=1)? == 1;
        let ui_a046_backup_camera_stream_error = u.int_in_range(0..=1)? == 1;
        let ui_a047_cell_roaming_disallowed = u.int_in_range(0..=1)? == 1;
        let ui_a048_audio_premium_amp_check_fail = u.int_in_range(0..=1)? == 1;
        let ui_a049_brake_shift_required = u.int_in_range(0..=1)? == 1;
        let ui_a050_backup_camera_ipu_timeout = u.int_in_range(0..=1)? == 1;
        let ui_a051_backup_camera_frame_timeout = u.int_in_range(0..=1)? == 1;
        let ui_a052_kernel_panic_reported = u.int_in_range(0..=1)? == 1;
        let ui_a053_qt_car_exit_error = u.int_in_range(0..=1)? == 1;
        let ui_a054_audio_boost_power_bad = u.int_in_range(0..=1)? == 1;
        let ui_a055_manual_e_call_disabled = u.int_in_range(0..=1)? == 1;
        let ui_a056_manual_e_call_button_disconn = u.int_in_range(0..=1)? == 1;
        let ui_a057_cell_antenna_disconnected = u.int_in_range(0..=1)? == 1;
        let ui_a058_gps_antenna_disconnected = u.int_in_range(0..=1)? == 1;
        let ui_a059_e_call_speaker_disconnected = u.int_in_range(0..=1)? == 1;
        let ui_a060_e_call_mic_disconnected = u.int_in_range(0..=1)? == 1;
        let ui_a061_sim_test_failed = u.int_in_range(0..=1)? == 1;
        let ui_a062_ens_test_failed = u.int_in_range(0..=1)? == 1;
        let ui_a063_cellular_test_failed = u.int_in_range(0..=1)? == 1;
        let ui_a064_modem_firmware_test_failed = u.int_in_range(0..=1)? == 1;
        Id123uiAlertMatrix1::new(ui_a001_driver_door_open,ui_a002_door_open,ui_a003_trunk_open,ui_a004_frunk_open,ui_a005_headlights_on_door_open,ui_a006_remote_service_alert,ui_a007_soft_pack_config_mismatch,ui_a008_touch_screen_error,ui_a009_squashfs_error,ui_a010_maps_missing,ui_a011_incorrect_map,ui_a012_not_on_private_property,ui_a013_tpms_hard_warning,ui_a014_tpms_soft_warning,ui_a015_tpms_over_pressure_warning,ui_a016_tpms_temperature_warning,ui_a017_tpms_system_fault,ui_a018_slip_start_on,ui_a019_park_brake_fault,ui_a020_steering_reduced,ui_a021_rear_seatbelt_unbuckled,ui_a022_ape_fuses_etc,ui_a023_cell_internet_check_failed,ui_a024_wifi_internet_check_failed,ui_a025_wifi_online_check_failed,ui_a026_modem_reset_loop_detected,ui_a027_auto_steer_mia,ui_a028_front_trunk_popup_closed,ui_a029_modem_mia,ui_a030_modem_vm_crash,ui_a031_brake_fluid_low,ui_a032_cell_modem_recovery_resets,ui_a033_ap_trial_expired,ui_a034_wakeup_problem,ui_a035_audio_watchdog_kernel_error,ui_a036_audio_watchdog_hfp_error,ui_a037_audio_watchdog_xrun_storm_er,ui_a038_audio_watchdog_a2b_i2c_locku,ui_a039_audio_a2b_need_rediscovery,ui_a040_homelink_transmit,ui_a041_audio_dmesg_xrun,ui_a042_audio_dmesg_rt_throttling,ui_a043_invalid_map_data_override,ui_a044_audio_dmesg_dsp_exception,ui_a045_e_call_needs_service,ui_a046_backup_camera_stream_error,ui_a047_cell_roaming_disallowed,ui_a048_audio_premium_amp_check_fail,ui_a049_brake_shift_required,ui_a050_backup_camera_ipu_timeout,ui_a051_backup_camera_frame_timeout,ui_a052_kernel_panic_reported,ui_a053_qt_car_exit_error,ui_a054_audio_boost_power_bad,ui_a055_manual_e_call_disabled,ui_a056_manual_e_call_button_disconn,ui_a057_cell_antenna_disconnected,ui_a058_gps_antenna_disconnected,ui_a059_e_call_speaker_disconnected,ui_a060_e_call_mic_disconnected,ui_a061_sim_test_failed,ui_a062_ens_test_failed,ui_a063_cellular_test_failed,ui_a064_modem_firmware_test_failed).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID142VCLEFT_liftgateStatus
///
/// - ID: 322 (0x142)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id142vcleftLiftgateStatus {
    raw: [u8; 8],
}

impl Id142vcleftLiftgateStatus {
    pub const MESSAGE_ID: u32 = 322;
    
    /// Construct new ID142VCLEFT_liftgateStatus from values
    pub fn new(vcleft_liftgate_status_index: u8, vcleft_liftgate_latch_request: u8, vcleft_liftgate_mvmnt_not_allowed_co: u8, vcleft_liftgate_physical_chime_requ: u8, vcleft_liftgate_position: f32, vcleft_liftgate_position_calibrate: bool, vcleft_liftgate_request_source: u8, vcleft_liftgate_speed: f32, vcleft_liftgate_state: u8, vcleft_liftgate_stopping_condition: u8, vcleft_liftgate_strut_current: f32, vcleft_liftgate_strut_duty_cycle: i8, vcleft_liftgate_ui_chime_request: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcleft_liftgate_status_index(vcleft_liftgate_status_index)?;
        res.set_vcleft_liftgate_latch_request(vcleft_liftgate_latch_request)?;
        res.set_vcleft_liftgate_mvmnt_not_allowed_co(vcleft_liftgate_mvmnt_not_allowed_co)?;
        res.set_vcleft_liftgate_physical_chime_requ(vcleft_liftgate_physical_chime_requ)?;
        res.set_vcleft_liftgate_position(vcleft_liftgate_position)?;
        res.set_vcleft_liftgate_position_calibrate(vcleft_liftgate_position_calibrate)?;
        res.set_vcleft_liftgate_request_source(vcleft_liftgate_request_source)?;
        res.set_vcleft_liftgate_speed(vcleft_liftgate_speed)?;
        res.set_vcleft_liftgate_state(vcleft_liftgate_state)?;
        res.set_vcleft_liftgate_stopping_condition(vcleft_liftgate_stopping_condition)?;
        res.set_vcleft_liftgate_strut_current(vcleft_liftgate_strut_current)?;
        res.set_vcleft_liftgate_strut_duty_cycle(vcleft_liftgate_strut_duty_cycle)?;
        res.set_vcleft_liftgate_ui_chime_request(vcleft_liftgate_ui_chime_request)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCLEFT_liftgateStatusIndex
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_status_index(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateStatusIndex {
        match self.vcleft_liftgate_status_index_raw() {
            0 => Id142vcleftLiftgateStatusVcleftLiftgateStatusIndex::LiftgateStatusIndex0,
            1 => Id142vcleftLiftgateStatusVcleftLiftgateStatusIndex::LiftgateStatusIndex1,
            2 => Id142vcleftLiftgateStatusVcleftLiftgateStatusIndex::LiftgateStatusIndexInvalid,
            x => Id142vcleftLiftgateStatusVcleftLiftgateStatusIndex::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateStatusIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_status_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateStatusIndex
    #[inline(always)]
    pub fn set_vcleft_liftgate_status_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateLatchRequest
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_latch_request(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest {
        match self.vcleft_liftgate_latch_request_raw() {
            1 => Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest::LatchRequestCinch,
            3 => Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest::LatchRequestForceRelease,
            0 => Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest::LatchRequestNone,
            2 => Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest::LatchRequestRelease,
            4 => Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest::LatchRequestReset,
            x => Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateLatchRequest
    ///
    /// - Start bit: 61
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_latch_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[61..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateLatchRequest
    #[inline(always)]
    pub fn set_vcleft_liftgate_latch_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[61..64].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateMvmntNotAllowedCo
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_mvmnt_not_allowed_co(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo {
        match self.vcleft_liftgate_mvmnt_not_allowed_co_raw() {
            4 => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::PlgMvmtNotAllowedExteriorPressAtMaxOpen,
            5 => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::PlgMvmtNotAllowedLocked,
            1 => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::PlgMvmtNotAllowedLow12v,
            0 => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::PlgMvmtNotAllowedNone,
            3 => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::PlgMvmtNotAllowedUncalibrated,
            2 => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::PlgMvmtNotAllowedVehicleAtSpeed,
            x => Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateMvmntNotAllowedCo
    ///
    /// - Start bit: 14
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_mvmnt_not_allowed_co_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..17].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateMvmntNotAllowedCo
    #[inline(always)]
    pub fn set_vcleft_liftgate_mvmnt_not_allowed_co(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..17].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgatePhysicalChimeRequ
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_physical_chime_requ(&self) -> Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ {
        match self.vcleft_liftgate_physical_chime_requ_raw() {
            0 => Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ::LiftgateChimeRequestNone,
            4 => Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ::LiftgateChimeRequestOneLong,
            1 => Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ::LiftgateChimeRequestOneShort,
            3 => Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ::LiftgateChimeRequestThreeShort,
            2 => Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ::LiftgateChimeRequestTwoShort,
            x => Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgatePhysicalChimeRequ
    ///
    /// - Start bit: 21
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_physical_chime_requ_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgatePhysicalChimeRequ
    #[inline(always)]
    pub fn set_vcleft_liftgate_physical_chime_requ(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..24].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgatePosition
    ///
    /// - Min: -5
    /// - Max: 95
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_position(&self) -> f32 {
        self.vcleft_liftgate_position_raw()
    }
    
    /// Get raw value of VCLEFT_liftgatePosition
    ///
    /// - Start bit: 21
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 46
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_liftgate_position_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[21..28].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 46_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_liftgatePosition
    #[inline(always)]
    pub fn set_vcleft_liftgate_position(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -5_f32 || 95_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        let factor = 1_f32;
        let offset = 46_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[21..28].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgatePositionCalibrate
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_position_calibrate(&self) -> bool {
        self.vcleft_liftgate_position_calibrate_raw()
    }
    
    /// Get raw value of VCLEFT_liftgatePositionCalibrate
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_position_calibrate_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_liftgatePositionCalibrate
    #[inline(always)]
    pub fn set_vcleft_liftgate_position_calibrate(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateRequestSource
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_request_source(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateRequestSource {
        match self.vcleft_liftgate_request_source_raw() {
            5 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceCloseAll,
            2 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceExterior,
            4 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceKeyTrunkButton,
            6 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceMcuClose,
            1 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceMcuSwitch,
            0 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceNone,
            3 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceShutface,
            7 => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::PlgRequestSourceUds,
            x => Id142vcleftLiftgateStatusVcleftLiftgateRequestSource::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateRequestSource
    ///
    /// - Start bit: 7
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_request_source_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[7..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateRequestSource
    #[inline(always)]
    pub fn set_vcleft_liftgate_request_source(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[7..10].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateSpeed
    ///
    /// - Min: -30
    /// - Max: 30
    /// - Unit: "deg/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_speed(&self) -> f32 {
        self.vcleft_liftgate_speed_raw()
    }
    
    /// Get raw value of VCLEFT_liftgateSpeed
    ///
    /// - Start bit: 28
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_liftgate_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..38].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_liftgateSpeed
    #[inline(always)]
    pub fn set_vcleft_liftgate_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 30_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[28..38].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateState
    ///
    /// - Min: 0
    /// - Max: 12
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_state(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateState {
        match self.vcleft_liftgate_state_raw() {
            2 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateBackoff,
            5 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateClosed,
            4 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateClosing,
            11 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateEndOfTravel,
            0 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateInit,
            7 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateLatchClosing,
            12 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateLatchEntry,
            10 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateLatchExit,
            6 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateLatchOpening,
            8 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateNotInstalled,
            1 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateOff,
            3 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateOpening,
            9 => Id142vcleftLiftgateStatusVcleftLiftgateState::PlgStateUnknown,
            x => Id142vcleftLiftgateStatusVcleftLiftgateState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateState
    ///
    /// - Start bit: 3
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateState
    #[inline(always)]
    pub fn set_vcleft_liftgate_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 12_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..7].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateStoppingCondition
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_stopping_condition(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition {
        match self.vcleft_liftgate_stopping_condition_raw() {
            11 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionCount,
            10 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionLatchFault,
            3 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionLow12v,
            0 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionNone,
            6 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionObstacleCurrent,
            2 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionObstacleStall,
            7 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionObstacleTrajPos,
            8 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionObstacleTrajVel,
            1 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionPinch,
            4 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionStateTimeout,
            9 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionUncalibrated,
            5 => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::PlgStoppingConditionVehicleAtSpeed,
            x => Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateStoppingCondition
    ///
    /// - Start bit: 10
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_stopping_condition_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateStoppingCondition
    #[inline(always)]
    pub fn set_vcleft_liftgate_stopping_condition(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..14].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateStrutCurrent
    ///
    /// - Min: -30
    /// - Max: 30
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_strut_current(&self) -> f32 {
        self.vcleft_liftgate_strut_current_raw()
    }
    
    /// Get raw value of VCLEFT_liftgateStrutCurrent
    ///
    /// - Start bit: 11
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_liftgate_strut_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[11..21].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_liftgateStrutCurrent
    #[inline(always)]
    pub fn set_vcleft_liftgate_strut_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 30_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[11..21].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateStrutDutyCycle
    ///
    /// - Min: -100
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_strut_duty_cycle(&self) -> i8 {
        self.vcleft_liftgate_strut_duty_cycle_raw()
    }
    
    /// Get raw value of VCLEFT_liftgateStrutDutyCycle
    ///
    /// - Start bit: 3
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_liftgate_strut_duty_cycle_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..11].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCLEFT_liftgateStrutDutyCycle
    #[inline(always)]
    pub fn set_vcleft_liftgate_strut_duty_cycle(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -100_i8 || 100_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[3..11].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_liftgateUIChimeRequest
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_liftgate_ui_chime_request(&self) -> Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest {
        match self.vcleft_liftgate_ui_chime_request_raw() {
            0 => Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest::LiftgateChimeRequestNone,
            4 => Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest::LiftgateChimeRequestOneLong,
            1 => Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest::LiftgateChimeRequestOneShort,
            3 => Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest::LiftgateChimeRequestThreeShort,
            2 => Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest::LiftgateChimeRequestTwoShort,
            x => Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_liftgateUIChimeRequest
    ///
    /// - Start bit: 18
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_liftgate_ui_chime_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_liftgateUIChimeRequest
    #[inline(always)]
    pub fn set_vcleft_liftgate_ui_chime_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 322 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..21].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id142vcleftLiftgateStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id142vcleftLiftgateStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcleft_liftgate_status_index = u.int_in_range(0..=2)?;
        let vcleft_liftgate_latch_request = u.int_in_range(0..=4)?;
        let vcleft_liftgate_mvmnt_not_allowed_co = u.int_in_range(0..=5)?;
        let vcleft_liftgate_physical_chime_requ = u.int_in_range(0..=4)?;
        let vcleft_liftgate_position = -5_f32;
        let vcleft_liftgate_position_calibrate = u.int_in_range(0..=1)? == 1;
        let vcleft_liftgate_request_source = u.int_in_range(0..=7)?;
        let vcleft_liftgate_speed = -30_f32;
        let vcleft_liftgate_state = u.int_in_range(0..=12)?;
        let vcleft_liftgate_stopping_condition = u.int_in_range(0..=11)?;
        let vcleft_liftgate_strut_current = -30_f32;
        let vcleft_liftgate_strut_duty_cycle = u.int_in_range(-100..=100)?;
        let vcleft_liftgate_ui_chime_request = u.int_in_range(0..=4)?;
        Id142vcleftLiftgateStatus::new(vcleft_liftgate_status_index,vcleft_liftgate_latch_request,vcleft_liftgate_mvmnt_not_allowed_co,vcleft_liftgate_physical_chime_requ,vcleft_liftgate_position,vcleft_liftgate_position_calibrate,vcleft_liftgate_request_source,vcleft_liftgate_speed,vcleft_liftgate_state,vcleft_liftgate_stopping_condition,vcleft_liftgate_strut_current,vcleft_liftgate_strut_duty_cycle,vcleft_liftgate_ui_chime_request).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCLEFT_liftgateStatusIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateStatusIndex {
    LiftgateStatusIndex0,
    LiftgateStatusIndex1,
    LiftgateStatusIndexInvalid,
    Other(u8),
}
/// Defined values for VCLEFT_liftgateLatchRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateLatchRequest {
    LatchRequestCinch,
    LatchRequestForceRelease,
    LatchRequestNone,
    LatchRequestRelease,
    LatchRequestReset,
    Other(u8),
}
/// Defined values for VCLEFT_liftgateMvmntNotAllowedCo
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateMvmntNotAllowedCo {
    PlgMvmtNotAllowedExteriorPressAtMaxOpen,
    PlgMvmtNotAllowedLocked,
    PlgMvmtNotAllowedLow12v,
    PlgMvmtNotAllowedNone,
    PlgMvmtNotAllowedUncalibrated,
    PlgMvmtNotAllowedVehicleAtSpeed,
    Other(u8),
}
/// Defined values for VCLEFT_liftgatePhysicalChimeRequ
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgatePhysicalChimeRequ {
    LiftgateChimeRequestNone,
    LiftgateChimeRequestOneLong,
    LiftgateChimeRequestOneShort,
    LiftgateChimeRequestThreeShort,
    LiftgateChimeRequestTwoShort,
    Other(u8),
}
/// Defined values for VCLEFT_liftgateRequestSource
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateRequestSource {
    PlgRequestSourceCloseAll,
    PlgRequestSourceExterior,
    PlgRequestSourceKeyTrunkButton,
    PlgRequestSourceMcuClose,
    PlgRequestSourceMcuSwitch,
    PlgRequestSourceNone,
    PlgRequestSourceShutface,
    PlgRequestSourceUds,
    Other(u8),
}
/// Defined values for VCLEFT_liftgateState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateState {
    PlgStateBackoff,
    PlgStateClosed,
    PlgStateClosing,
    PlgStateEndOfTravel,
    PlgStateInit,
    PlgStateLatchClosing,
    PlgStateLatchEntry,
    PlgStateLatchExit,
    PlgStateLatchOpening,
    PlgStateNotInstalled,
    PlgStateOff,
    PlgStateOpening,
    PlgStateUnknown,
    Other(u8),
}
/// Defined values for VCLEFT_liftgateStoppingCondition
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateStoppingCondition {
    PlgStoppingConditionCount,
    PlgStoppingConditionLatchFault,
    PlgStoppingConditionLow12v,
    PlgStoppingConditionNone,
    PlgStoppingConditionObstacleCurrent,
    PlgStoppingConditionObstacleStall,
    PlgStoppingConditionObstacleTrajPos,
    PlgStoppingConditionObstacleTrajVel,
    PlgStoppingConditionPinch,
    PlgStoppingConditionStateTimeout,
    PlgStoppingConditionUncalibrated,
    PlgStoppingConditionVehicleAtSpeed,
    Other(u8),
}
/// Defined values for VCLEFT_liftgateUIChimeRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id142vcleftLiftgateStatusVcleftLiftgateUiChimeRequest {
    LiftgateChimeRequestNone,
    LiftgateChimeRequestOneLong,
    LiftgateChimeRequestOneShort,
    LiftgateChimeRequestThreeShort,
    LiftgateChimeRequestTwoShort,
    Other(u8),
}

/// ID145ESP_status
///
/// - ID: 325 (0x145)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id145espStatus {
    raw: [u8; 8],
}

impl Id145espStatus {
    pub const MESSAGE_ID: u32 = 325;
    
    /// Construct new ID145ESP_status from values
    pub fn new(esp_abs_brake_event2: u8, esp_abs_fault_lamp: bool, esp_brake_apply: bool, esp_brake_disc_wiping_active: bool, esp_brake_lamp: bool, esp_brake_torque_target: f32, esp_btc_target_state: u8, esp_cdp_status: u8, esp_driver_brake_apply: u8, esp_ebd_fault_lamp: bool, esp_ebr_standstill_skid: bool, esp_ebr_status: u8, esp_esp_fault_lamp: bool, esp_esp_lamp_flash: bool, esp_esp_mode_active: u8, esp_hydraulic_boost_enabled: bool, esp_lateral_accel_qf: bool, esp_longitudinal_accel_qf: bool, esp_ptc_target_state: u8, esp_stability_control_sts2: u8, esp_status_checksum: u8, esp_status_counter: u8, esp_steering_angle_qf: bool, esp_yaw_rate_qf: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_esp_abs_brake_event2(esp_abs_brake_event2)?;
        res.set_esp_abs_fault_lamp(esp_abs_fault_lamp)?;
        res.set_esp_brake_apply(esp_brake_apply)?;
        res.set_esp_brake_disc_wiping_active(esp_brake_disc_wiping_active)?;
        res.set_esp_brake_lamp(esp_brake_lamp)?;
        res.set_esp_brake_torque_target(esp_brake_torque_target)?;
        res.set_esp_btc_target_state(esp_btc_target_state)?;
        res.set_esp_cdp_status(esp_cdp_status)?;
        res.set_esp_driver_brake_apply(esp_driver_brake_apply)?;
        res.set_esp_ebd_fault_lamp(esp_ebd_fault_lamp)?;
        res.set_esp_ebr_standstill_skid(esp_ebr_standstill_skid)?;
        res.set_esp_ebr_status(esp_ebr_status)?;
        res.set_esp_esp_fault_lamp(esp_esp_fault_lamp)?;
        res.set_esp_esp_lamp_flash(esp_esp_lamp_flash)?;
        res.set_esp_esp_mode_active(esp_esp_mode_active)?;
        res.set_esp_hydraulic_boost_enabled(esp_hydraulic_boost_enabled)?;
        res.set_esp_lateral_accel_qf(esp_lateral_accel_qf)?;
        res.set_esp_longitudinal_accel_qf(esp_longitudinal_accel_qf)?;
        res.set_esp_ptc_target_state(esp_ptc_target_state)?;
        res.set_esp_stability_control_sts2(esp_stability_control_sts2)?;
        res.set_esp_status_checksum(esp_status_checksum)?;
        res.set_esp_status_counter(esp_status_counter)?;
        res.set_esp_steering_angle_qf(esp_steering_angle_qf)?;
        res.set_esp_yaw_rate_qf(esp_yaw_rate_qf)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// ESP_absBrakeEvent2
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_abs_brake_event2(&self) -> Id145espStatusEspAbsBrakeEvent2 {
        match self.esp_abs_brake_event2_raw() {
            2 => Id145espStatusEspAbsBrakeEvent2::AbsEventActiveFront,
            1 => Id145espStatusEspAbsBrakeEvent2::AbsEventActiveFrontRear,
            3 => Id145espStatusEspAbsBrakeEvent2::AbsEventActiveRear,
            0 => Id145espStatusEspAbsBrakeEvent2::AbsEventNotActive,
            x => Id145espStatusEspAbsBrakeEvent2::Other(x),
        }
    }
    
    /// Get raw value of ESP_absBrakeEvent2
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_abs_brake_event2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_absBrakeEvent2
    #[inline(always)]
    pub fn set_esp_abs_brake_event2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// ESP_absFaultLamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_abs_fault_lamp(&self) -> Id145espStatusEspAbsFaultLamp {
        match self.esp_abs_fault_lamp_raw() {
            false => Id145espStatusEspAbsFaultLamp::AbsFaultLampOff,
            true => Id145espStatusEspAbsFaultLamp::AbsFaultLampOn,
            x => Id145espStatusEspAbsFaultLamp::Other(x),
        }
    }
    
    /// Get raw value of ESP_absFaultLamp
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_abs_fault_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_absFaultLamp
    #[inline(always)]
    pub fn set_esp_abs_fault_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// ESP_brakeApply
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_brake_apply(&self) -> Id145espStatusEspBrakeApply {
        match self.esp_brake_apply_raw() {
            true => Id145espStatusEspBrakeApply::BlsActive,
            false => Id145espStatusEspBrakeApply::BlsInactive,
            x => Id145espStatusEspBrakeApply::Other(x),
        }
    }
    
    /// Get raw value of ESP_brakeApply
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_brake_apply_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_brakeApply
    #[inline(always)]
    pub fn set_esp_brake_apply(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// ESP_brakeDiscWipingActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_brake_disc_wiping_active(&self) -> Id145espStatusEspBrakeDiscWipingActive {
        match self.esp_brake_disc_wiping_active_raw() {
            true => Id145espStatusEspBrakeDiscWipingActive::BdwActive,
            false => Id145espStatusEspBrakeDiscWipingActive::BdwInactive,
            x => Id145espStatusEspBrakeDiscWipingActive::Other(x),
        }
    }
    
    /// Get raw value of ESP_brakeDiscWipingActive
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_brake_disc_wiping_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_brakeDiscWipingActive
    #[inline(always)]
    pub fn set_esp_brake_disc_wiping_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// ESP_brakeLamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_brake_lamp(&self) -> Id145espStatusEspBrakeLamp {
        match self.esp_brake_lamp_raw() {
            false => Id145espStatusEspBrakeLamp::LampOff,
            true => Id145espStatusEspBrakeLamp::LampOn,
            x => Id145espStatusEspBrakeLamp::Other(x),
        }
    }
    
    /// Get raw value of ESP_brakeLamp
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_brake_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_brakeLamp
    #[inline(always)]
    pub fn set_esp_brake_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[21..22].store_le(value);
        Ok(())
    }
    
    /// ESP_brakeTorqueTarget
    ///
    /// - Min: 0
    /// - Max: 16382
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_brake_torque_target(&self) -> Id145espStatusEspBrakeTorqueTarget {
        match self.esp_brake_torque_target_raw() {
            8191 => Id145espStatusEspBrakeTorqueTarget::Sna,
            x => Id145espStatusEspBrakeTorqueTarget::Other(x),
        }
    }
    
    /// Get raw value of ESP_brakeTorqueTarget
    ///
    /// - Start bit: 51
    /// - Signal size: 13 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_brake_torque_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..64].load_le::<u16>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ESP_brakeTorqueTarget
    #[inline(always)]
    pub fn set_esp_brake_torque_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16382_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[51..64].store_le(value);
        Ok(())
    }
    
    /// ESP_btcTargetState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_btc_target_state(&self) -> Id145espStatusEspBtcTargetState {
        match self.esp_btc_target_state_raw() {
            1 => Id145espStatusEspBtcTargetState::Backup,
            0 => Id145espStatusEspBtcTargetState::Off,
            2 => Id145espStatusEspBtcTargetState::On,
            3 => Id145espStatusEspBtcTargetState::Sna,
            x => Id145espStatusEspBtcTargetState::Other(x),
        }
    }
    
    /// Get raw value of ESP_btcTargetState
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_btc_target_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_btcTargetState
    #[inline(always)]
    pub fn set_esp_btc_target_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// ESP_cdpStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_cdp_status(&self) -> Id145espStatusEspCdpStatus {
        match self.esp_cdp_status_raw() {
            2 => Id145espStatusEspCdpStatus::ActuatingEpbCdp,
            3 => Id145espStatusEspCdpStatus::CdpCommandInvalid,
            1 => Id145espStatusEspCdpStatus::CdpIsAvailable,
            0 => Id145espStatusEspCdpStatus::CdpIsNotAvailable,
            x => Id145espStatusEspCdpStatus::Other(x),
        }
    }
    
    /// Get raw value of ESP_cdpStatus
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_cdp_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_cdpStatus
    #[inline(always)]
    pub fn set_esp_cdp_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// ESP_driverBrakeApply
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_driver_brake_apply(&self) -> Id145espStatusEspDriverBrakeApply {
        match self.esp_driver_brake_apply_raw() {
            2 => Id145espStatusEspDriverBrakeApply::DriverApplyingBrakes,
            3 => Id145espStatusEspDriverBrakeApply::FaultySna,
            0 => Id145espStatusEspDriverBrakeApply::NotInitOrOff,
            1 => Id145espStatusEspDriverBrakeApply::NotApplied,
            x => Id145espStatusEspDriverBrakeApply::Other(x),
        }
    }
    
    /// Get raw value of ESP_driverBrakeApply
    ///
    /// - Start bit: 29
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_driver_brake_apply_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[29..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_driverBrakeApply
    #[inline(always)]
    pub fn set_esp_driver_brake_apply(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[29..31].store_le(value);
        Ok(())
    }
    
    /// ESP_ebdFaultLamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_ebd_fault_lamp(&self) -> Id145espStatusEspEbdFaultLamp {
        match self.esp_ebd_fault_lamp_raw() {
            false => Id145espStatusEspEbdFaultLamp::EbdFaultLampOff,
            true => Id145espStatusEspEbdFaultLamp::EbdFaultLampOn,
            x => Id145espStatusEspEbdFaultLamp::Other(x),
        }
    }
    
    /// Get raw value of ESP_ebdFaultLamp
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_ebd_fault_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_ebdFaultLamp
    #[inline(always)]
    pub fn set_esp_ebd_fault_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// ESP_ebrStandstillSkid
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_ebr_standstill_skid(&self) -> Id145espStatusEspEbrStandstillSkid {
        match self.esp_ebr_standstill_skid_raw() {
            false => Id145espStatusEspEbrStandstillSkid::NoStandstillSkid,
            true => Id145espStatusEspEbrStandstillSkid::StandstillSkidDetected,
            x => Id145espStatusEspEbrStandstillSkid::Other(x),
        }
    }
    
    /// Get raw value of ESP_ebrStandstillSkid
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_ebr_standstill_skid_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_ebrStandstillSkid
    #[inline(always)]
    pub fn set_esp_ebr_standstill_skid(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// ESP_ebrStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_ebr_status(&self) -> Id145espStatusEspEbrStatus {
        match self.esp_ebr_status_raw() {
            2 => Id145espStatusEspEbrStatus::ActuatingDiEbr,
            3 => Id145espStatusEspEbrStatus::EbrCommandInvalid,
            1 => Id145espStatusEspEbrStatus::EbrIsAvailable,
            0 => Id145espStatusEspEbrStatus::EbrIsNotAvailable,
            x => Id145espStatusEspEbrStatus::Other(x),
        }
    }
    
    /// Get raw value of ESP_ebrStatus
    ///
    /// - Start bit: 49
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_ebr_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[49..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_ebrStatus
    #[inline(always)]
    pub fn set_esp_ebr_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..51].store_le(value);
        Ok(())
    }
    
    /// ESP_espFaultLamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_esp_fault_lamp(&self) -> Id145espStatusEspEspFaultLamp {
        match self.esp_esp_fault_lamp_raw() {
            false => Id145espStatusEspEspFaultLamp::EspFaultLampOff,
            true => Id145espStatusEspEspFaultLamp::EspFaultLampOn,
            x => Id145espStatusEspEspFaultLamp::Other(x),
        }
    }
    
    /// Get raw value of ESP_espFaultLamp
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_esp_fault_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_espFaultLamp
    #[inline(always)]
    pub fn set_esp_esp_fault_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// ESP_espLampFlash
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_esp_lamp_flash(&self) -> Id145espStatusEspEspLampFlash {
        match self.esp_esp_lamp_flash_raw() {
            true => Id145espStatusEspEspLampFlash::EspLampFlash,
            false => Id145espStatusEspEspLampFlash::EspLampOff,
            x => Id145espStatusEspEspLampFlash::Other(x),
        }
    }
    
    /// Get raw value of ESP_espLampFlash
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_esp_lamp_flash_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_espLampFlash
    #[inline(always)]
    pub fn set_esp_esp_lamp_flash(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// ESP_espModeActive
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_esp_mode_active(&self) -> Id145espStatusEspEspModeActive {
        match self.esp_esp_mode_active_raw() {
            0 => Id145espStatusEspEspModeActive::EspMode00Normal,
            1 => Id145espStatusEspEspModeActive::EspMode01,
            2 => Id145espStatusEspEspModeActive::EspMode02,
            3 => Id145espStatusEspEspModeActive::EspMode03,
            x => Id145espStatusEspEspModeActive::Other(x),
        }
    }
    
    /// Get raw value of ESP_espModeActive
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_esp_mode_active_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_espModeActive
    #[inline(always)]
    pub fn set_esp_esp_mode_active(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// ESP_hydraulicBoostEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_hydraulic_boost_enabled(&self) -> bool {
        self.esp_hydraulic_boost_enabled_raw()
    }
    
    /// Get raw value of ESP_hydraulicBoostEnabled
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_hydraulic_boost_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_hydraulicBoostEnabled
    #[inline(always)]
    pub fn set_esp_hydraulic_boost_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
    /// ESP_lateralAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_lateral_accel_qf(&self) -> Id145espStatusEspLateralAccelQf {
        match self.esp_lateral_accel_qf_raw() {
            true => Id145espStatusEspLateralAccelQf::InSpec,
            false => Id145espStatusEspLateralAccelQf::UndefinableAccuracy,
            x => Id145espStatusEspLateralAccelQf::Other(x),
        }
    }
    
    /// Get raw value of ESP_lateralAccelQF
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_lateral_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_lateralAccelQF
    #[inline(always)]
    pub fn set_esp_lateral_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// ESP_longitudinalAccelQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_longitudinal_accel_qf(&self) -> Id145espStatusEspLongitudinalAccelQf {
        match self.esp_longitudinal_accel_qf_raw() {
            true => Id145espStatusEspLongitudinalAccelQf::InSpec,
            false => Id145espStatusEspLongitudinalAccelQf::UndefinableAccuracy,
            x => Id145espStatusEspLongitudinalAccelQf::Other(x),
        }
    }
    
    /// Get raw value of ESP_longitudinalAccelQF
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_longitudinal_accel_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_longitudinalAccelQF
    #[inline(always)]
    pub fn set_esp_longitudinal_accel_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// ESP_ptcTargetState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_ptc_target_state(&self) -> Id145espStatusEspPtcTargetState {
        match self.esp_ptc_target_state_raw() {
            1 => Id145espStatusEspPtcTargetState::Backup,
            0 => Id145espStatusEspPtcTargetState::Fault,
            2 => Id145espStatusEspPtcTargetState::On,
            3 => Id145espStatusEspPtcTargetState::Sna,
            x => Id145espStatusEspPtcTargetState::Other(x),
        }
    }
    
    /// Get raw value of ESP_ptcTargetState
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_ptc_target_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_ptcTargetState
    #[inline(always)]
    pub fn set_esp_ptc_target_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..38].store_le(value);
        Ok(())
    }
    
    /// ESP_stabilityControlSts2
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_stability_control_sts2(&self) -> Id145espStatusEspStabilityControlSts2 {
        match self.esp_stability_control_sts2_raw() {
            2 => Id145espStatusEspStabilityControlSts2::Engaged,
            3 => Id145espStatusEspStabilityControlSts2::Faulted,
            0 => Id145espStatusEspStabilityControlSts2::Init,
            1 => Id145espStatusEspStabilityControlSts2::On,
            x => Id145espStatusEspStabilityControlSts2::Other(x),
        }
    }
    
    /// Get raw value of ESP_stabilityControlSts2
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_stability_control_sts2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_stabilityControlSts2
    #[inline(always)]
    pub fn set_esp_stability_control_sts2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// ESP_statusChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_status_checksum(&self) -> u8 {
        self.esp_status_checksum_raw()
    }
    
    /// Get raw value of ESP_statusChecksum
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_status_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_statusChecksum
    #[inline(always)]
    pub fn set_esp_status_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// ESP_statusCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_status_counter(&self) -> u8 {
        self.esp_status_counter_raw()
    }
    
    /// Get raw value of ESP_statusCounter
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_status_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP_statusCounter
    #[inline(always)]
    pub fn set_esp_status_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 325 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// ESP_steeringAngleQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_steering_angle_qf(&self) -> Id145espStatusEspSteeringAngleQf {
        match self.esp_steering_angle_qf_raw() {
            true => Id145espStatusEspSteeringAngleQf::InSpec,
            false => Id145espStatusEspSteeringAngleQf::UndefinableAccuracy,
            x => Id145espStatusEspSteeringAngleQf::Other(x),
        }
    }
    
    /// Get raw value of ESP_steeringAngleQF
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_steering_angle_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_steeringAngleQF
    #[inline(always)]
    pub fn set_esp_steering_angle_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// ESP_yawRateQF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn esp_yaw_rate_qf(&self) -> Id145espStatusEspYawRateQf {
        match self.esp_yaw_rate_qf_raw() {
            true => Id145espStatusEspYawRateQf::InSpec,
            false => Id145espStatusEspYawRateQf::UndefinableAccuracy,
            x => Id145espStatusEspYawRateQf::Other(x),
        }
    }
    
    /// Get raw value of ESP_yawRateQF
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_yaw_rate_qf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_yawRateQF
    #[inline(always)]
    pub fn set_esp_yaw_rate_qf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id145espStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id145espStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let esp_abs_brake_event2 = u.int_in_range(0..=3)?;
        let esp_abs_fault_lamp = u.int_in_range(0..=1)? == 1;
        let esp_brake_apply = u.int_in_range(0..=1)? == 1;
        let esp_brake_disc_wiping_active = u.int_in_range(0..=1)? == 1;
        let esp_brake_lamp = u.int_in_range(0..=1)? == 1;
        let esp_brake_torque_target = 0_f32;
        let esp_btc_target_state = u.int_in_range(0..=3)?;
        let esp_cdp_status = u.int_in_range(0..=3)?;
        let esp_driver_brake_apply = u.int_in_range(0..=3)?;
        let esp_ebd_fault_lamp = u.int_in_range(0..=1)? == 1;
        let esp_ebr_standstill_skid = u.int_in_range(0..=1)? == 1;
        let esp_ebr_status = u.int_in_range(0..=3)?;
        let esp_esp_fault_lamp = u.int_in_range(0..=1)? == 1;
        let esp_esp_lamp_flash = u.int_in_range(0..=1)? == 1;
        let esp_esp_mode_active = u.int_in_range(0..=3)?;
        let esp_hydraulic_boost_enabled = u.int_in_range(0..=1)? == 1;
        let esp_lateral_accel_qf = u.int_in_range(0..=1)? == 1;
        let esp_longitudinal_accel_qf = u.int_in_range(0..=1)? == 1;
        let esp_ptc_target_state = u.int_in_range(0..=3)?;
        let esp_stability_control_sts2 = u.int_in_range(0..=3)?;
        let esp_status_checksum = u.int_in_range(0..=255)?;
        let esp_status_counter = u.int_in_range(0..=15)?;
        let esp_steering_angle_qf = u.int_in_range(0..=1)? == 1;
        let esp_yaw_rate_qf = u.int_in_range(0..=1)? == 1;
        Id145espStatus::new(esp_abs_brake_event2,esp_abs_fault_lamp,esp_brake_apply,esp_brake_disc_wiping_active,esp_brake_lamp,esp_brake_torque_target,esp_btc_target_state,esp_cdp_status,esp_driver_brake_apply,esp_ebd_fault_lamp,esp_ebr_standstill_skid,esp_ebr_status,esp_esp_fault_lamp,esp_esp_lamp_flash,esp_esp_mode_active,esp_hydraulic_boost_enabled,esp_lateral_accel_qf,esp_longitudinal_accel_qf,esp_ptc_target_state,esp_stability_control_sts2,esp_status_checksum,esp_status_counter,esp_steering_angle_qf,esp_yaw_rate_qf).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for ESP_absBrakeEvent2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspAbsBrakeEvent2 {
    AbsEventActiveFront,
    AbsEventActiveFrontRear,
    AbsEventActiveRear,
    AbsEventNotActive,
    Other(u8),
}
/// Defined values for ESP_absFaultLamp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspAbsFaultLamp {
    AbsFaultLampOff,
    AbsFaultLampOn,
    Other(bool),
}
/// Defined values for ESP_brakeApply
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspBrakeApply {
    BlsActive,
    BlsInactive,
    Other(bool),
}
/// Defined values for ESP_brakeDiscWipingActive
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspBrakeDiscWipingActive {
    BdwActive,
    BdwInactive,
    Other(bool),
}
/// Defined values for ESP_brakeLamp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspBrakeLamp {
    LampOff,
    LampOn,
    Other(bool),
}
/// Defined values for ESP_brakeTorqueTarget
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspBrakeTorqueTarget {
    Sna,
    Other(f32),
}
/// Defined values for ESP_btcTargetState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspBtcTargetState {
    Backup,
    Off,
    On,
    Sna,
    Other(u8),
}
/// Defined values for ESP_cdpStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspCdpStatus {
    ActuatingEpbCdp,
    CdpCommandInvalid,
    CdpIsAvailable,
    CdpIsNotAvailable,
    Other(u8),
}
/// Defined values for ESP_driverBrakeApply
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspDriverBrakeApply {
    DriverApplyingBrakes,
    FaultySna,
    NotInitOrOff,
    NotApplied,
    Other(u8),
}
/// Defined values for ESP_ebdFaultLamp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspEbdFaultLamp {
    EbdFaultLampOff,
    EbdFaultLampOn,
    Other(bool),
}
/// Defined values for ESP_ebrStandstillSkid
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspEbrStandstillSkid {
    NoStandstillSkid,
    StandstillSkidDetected,
    Other(bool),
}
/// Defined values for ESP_ebrStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspEbrStatus {
    ActuatingDiEbr,
    EbrCommandInvalid,
    EbrIsAvailable,
    EbrIsNotAvailable,
    Other(u8),
}
/// Defined values for ESP_espFaultLamp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspEspFaultLamp {
    EspFaultLampOff,
    EspFaultLampOn,
    Other(bool),
}
/// Defined values for ESP_espLampFlash
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspEspLampFlash {
    EspLampFlash,
    EspLampOff,
    Other(bool),
}
/// Defined values for ESP_espModeActive
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspEspModeActive {
    EspMode00Normal,
    EspMode01,
    EspMode02,
    EspMode03,
    Other(u8),
}
/// Defined values for ESP_lateralAccelQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspLateralAccelQf {
    InSpec,
    UndefinableAccuracy,
    Other(bool),
}
/// Defined values for ESP_longitudinalAccelQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspLongitudinalAccelQf {
    InSpec,
    UndefinableAccuracy,
    Other(bool),
}
/// Defined values for ESP_ptcTargetState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspPtcTargetState {
    Backup,
    Fault,
    On,
    Sna,
    Other(u8),
}
/// Defined values for ESP_stabilityControlSts2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspStabilityControlSts2 {
    Engaged,
    Faulted,
    Init,
    On,
    Other(u8),
}
/// Defined values for ESP_steeringAngleQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspSteeringAngleQf {
    InSpec,
    UndefinableAccuracy,
    Other(bool),
}
/// Defined values for ESP_yawRateQF
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id145espStatusEspYawRateQf {
    InSpec,
    UndefinableAccuracy,
    Other(bool),
}

/// ID1D6DI_limits
///
/// - ID: 470 (0x1d6)
/// - Size: 5 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id1d6diLimits {
    raw: [u8; 5],
}

impl Id1d6diLimits {
    pub const MESSAGE_ID: u32 = 470;
    
    /// Construct new ID1D6DI_limits from values
    pub fn new(di_limit_base_speed: bool, di_limit_clutch: bool, di_limit_dc_cap_temp: bool, di_limit_delta_fluid_temp: bool, di_limit_diff: bool, di_limit_discharge_power: bool, di_limit_drive_torque: bool, di_limit_graceful_power_off: bool, di_limit_i_bat: bool, di_limit_igbt_junct_temp: bool, di_limit_inverter_temp: bool, di_limit_limp_mode: bool, di_limit_motor_current: bool, di_limit_motor_speed: bool, di_limit_motor_voltage: bool, di_limit_obstacle_detection: bool, di_limit_oil_pump_fluid_temp: bool, di_limit_pcb_temp: bool, di_limit_pole_temp: bool, di_limit_regen_power: bool, di_limit_regen_torque: bool, di_limit_rotor_temp: bool, di_limit_shift: bool, di_limit_shock_torque: bool, di_limit_stator_frequency: bool, di_limit_stator_temp: bool, di_limit_tc_drive: bool, di_limit_tc_regen: bool, di_limit_v_bat_high: bool, di_limit_v_bat_low: bool, di_limit_vehicle_speed: bool, di_limitdc_link_cap_temp: bool, di_limithv_dc_cable_temp: bool, di_limitneg_dc_busbar_temp: bool, di_limitphase_out_bus_bar_weld_temp: bool, di_limitphase_out_busbar_temp: bool, di_limitphase_out_lug_temp: bool, di_limitpos_dc_busbar_temp: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_di_limit_base_speed(di_limit_base_speed)?;
        res.set_di_limit_clutch(di_limit_clutch)?;
        res.set_di_limit_dc_cap_temp(di_limit_dc_cap_temp)?;
        res.set_di_limit_delta_fluid_temp(di_limit_delta_fluid_temp)?;
        res.set_di_limit_diff(di_limit_diff)?;
        res.set_di_limit_discharge_power(di_limit_discharge_power)?;
        res.set_di_limit_drive_torque(di_limit_drive_torque)?;
        res.set_di_limit_graceful_power_off(di_limit_graceful_power_off)?;
        res.set_di_limit_i_bat(di_limit_i_bat)?;
        res.set_di_limit_igbt_junct_temp(di_limit_igbt_junct_temp)?;
        res.set_di_limit_inverter_temp(di_limit_inverter_temp)?;
        res.set_di_limit_limp_mode(di_limit_limp_mode)?;
        res.set_di_limit_motor_current(di_limit_motor_current)?;
        res.set_di_limit_motor_speed(di_limit_motor_speed)?;
        res.set_di_limit_motor_voltage(di_limit_motor_voltage)?;
        res.set_di_limit_obstacle_detection(di_limit_obstacle_detection)?;
        res.set_di_limit_oil_pump_fluid_temp(di_limit_oil_pump_fluid_temp)?;
        res.set_di_limit_pcb_temp(di_limit_pcb_temp)?;
        res.set_di_limit_pole_temp(di_limit_pole_temp)?;
        res.set_di_limit_regen_power(di_limit_regen_power)?;
        res.set_di_limit_regen_torque(di_limit_regen_torque)?;
        res.set_di_limit_rotor_temp(di_limit_rotor_temp)?;
        res.set_di_limit_shift(di_limit_shift)?;
        res.set_di_limit_shock_torque(di_limit_shock_torque)?;
        res.set_di_limit_stator_frequency(di_limit_stator_frequency)?;
        res.set_di_limit_stator_temp(di_limit_stator_temp)?;
        res.set_di_limit_tc_drive(di_limit_tc_drive)?;
        res.set_di_limit_tc_regen(di_limit_tc_regen)?;
        res.set_di_limit_v_bat_high(di_limit_v_bat_high)?;
        res.set_di_limit_v_bat_low(di_limit_v_bat_low)?;
        res.set_di_limit_vehicle_speed(di_limit_vehicle_speed)?;
        res.set_di_limitdc_link_cap_temp(di_limitdc_link_cap_temp)?;
        res.set_di_limithv_dc_cable_temp(di_limithv_dc_cable_temp)?;
        res.set_di_limitneg_dc_busbar_temp(di_limitneg_dc_busbar_temp)?;
        res.set_di_limitphase_out_bus_bar_weld_temp(di_limitphase_out_bus_bar_weld_temp)?;
        res.set_di_limitphase_out_busbar_temp(di_limitphase_out_busbar_temp)?;
        res.set_di_limitphase_out_lug_temp(di_limitphase_out_lug_temp)?;
        res.set_di_limitpos_dc_busbar_temp(di_limitpos_dc_busbar_temp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DI_limitBaseSpeed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_base_speed(&self) -> bool {
        self.di_limit_base_speed_raw()
    }
    
    /// Get raw value of DI_limitBaseSpeed
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_base_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitBaseSpeed
    #[inline(always)]
    pub fn set_di_limit_base_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// DI_limitClutch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_clutch(&self) -> bool {
        self.di_limit_clutch_raw()
    }
    
    /// Get raw value of DI_limitClutch
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_clutch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitClutch
    #[inline(always)]
    pub fn set_di_limit_clutch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// DI_limitDcCapTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_dc_cap_temp(&self) -> bool {
        self.di_limit_dc_cap_temp_raw()
    }
    
    /// Get raw value of DI_limitDcCapTemp
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_dc_cap_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitDcCapTemp
    #[inline(always)]
    pub fn set_di_limit_dc_cap_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// DI_limitDeltaFluidTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_delta_fluid_temp(&self) -> bool {
        self.di_limit_delta_fluid_temp_raw()
    }
    
    /// Get raw value of DI_limitDeltaFluidTemp
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_delta_fluid_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitDeltaFluidTemp
    #[inline(always)]
    pub fn set_di_limit_delta_fluid_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// DI_limitDiff
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_diff(&self) -> bool {
        self.di_limit_diff_raw()
    }
    
    /// Get raw value of DI_limitDiff
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_diff_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitDiff
    #[inline(always)]
    pub fn set_di_limit_diff(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[22..23].store_le(value);
        Ok(())
    }
    
    /// DI_limitDischargePower
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_discharge_power(&self) -> bool {
        self.di_limit_discharge_power_raw()
    }
    
    /// Get raw value of DI_limitDischargePower
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_discharge_power_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitDischargePower
    #[inline(always)]
    pub fn set_di_limit_discharge_power(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// DI_limitDriveTorque
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_drive_torque(&self) -> bool {
        self.di_limit_drive_torque_raw()
    }
    
    /// Get raw value of DI_limitDriveTorque
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_drive_torque_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitDriveTorque
    #[inline(always)]
    pub fn set_di_limit_drive_torque(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// DI_limitGracefulPowerOff
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_graceful_power_off(&self) -> bool {
        self.di_limit_graceful_power_off_raw()
    }
    
    /// Get raw value of DI_limitGracefulPowerOff
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_graceful_power_off_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitGracefulPowerOff
    #[inline(always)]
    pub fn set_di_limit_graceful_power_off(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// DI_limitIBat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_i_bat(&self) -> bool {
        self.di_limit_i_bat_raw()
    }
    
    /// Get raw value of DI_limitIBat
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_i_bat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitIBat
    #[inline(always)]
    pub fn set_di_limit_i_bat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// DI_limitIGBTJunctTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_igbt_junct_temp(&self) -> bool {
        self.di_limit_igbt_junct_temp_raw()
    }
    
    /// Get raw value of DI_limitIGBTJunctTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_igbt_junct_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitIGBTJunctTemp
    #[inline(always)]
    pub fn set_di_limit_igbt_junct_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// DI_limitInverterTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_inverter_temp(&self) -> bool {
        self.di_limit_inverter_temp_raw()
    }
    
    /// Get raw value of DI_limitInverterTemp
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_inverter_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitInverterTemp
    #[inline(always)]
    pub fn set_di_limit_inverter_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// DI_limitLimpMode
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_limp_mode(&self) -> bool {
        self.di_limit_limp_mode_raw()
    }
    
    /// Get raw value of DI_limitLimpMode
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_limp_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitLimpMode
    #[inline(always)]
    pub fn set_di_limit_limp_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// DI_limitMotorCurrent
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_motor_current(&self) -> bool {
        self.di_limit_motor_current_raw()
    }
    
    /// Get raw value of DI_limitMotorCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_motor_current_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitMotorCurrent
    #[inline(always)]
    pub fn set_di_limit_motor_current(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// DI_limitMotorSpeed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_motor_speed(&self) -> bool {
        self.di_limit_motor_speed_raw()
    }
    
    /// Get raw value of DI_limitMotorSpeed
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_motor_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitMotorSpeed
    #[inline(always)]
    pub fn set_di_limit_motor_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// DI_limitMotorVoltage
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_motor_voltage(&self) -> bool {
        self.di_limit_motor_voltage_raw()
    }
    
    /// Get raw value of DI_limitMotorVoltage
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_motor_voltage_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitMotorVoltage
    #[inline(always)]
    pub fn set_di_limit_motor_voltage(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// DI_limitObstacleDetection
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_obstacle_detection(&self) -> bool {
        self.di_limit_obstacle_detection_raw()
    }
    
    /// Get raw value of DI_limitObstacleDetection
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_obstacle_detection_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitObstacleDetection
    #[inline(always)]
    pub fn set_di_limit_obstacle_detection(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// DI_limitOilPumpFluidTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_oil_pump_fluid_temp(&self) -> bool {
        self.di_limit_oil_pump_fluid_temp_raw()
    }
    
    /// Get raw value of DI_limitOilPumpFluidTemp
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_oil_pump_fluid_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitOilPumpFluidTemp
    #[inline(always)]
    pub fn set_di_limit_oil_pump_fluid_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// DI_limitPCBTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_pcb_temp(&self) -> bool {
        self.di_limit_pcb_temp_raw()
    }
    
    /// Get raw value of DI_limitPCBTemp
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_pcb_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitPCBTemp
    #[inline(always)]
    pub fn set_di_limit_pcb_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// DI_limitPoleTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_pole_temp(&self) -> bool {
        self.di_limit_pole_temp_raw()
    }
    
    /// Get raw value of DI_limitPoleTemp
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_pole_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitPoleTemp
    #[inline(always)]
    pub fn set_di_limit_pole_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// DI_limitRegenPower
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_regen_power(&self) -> bool {
        self.di_limit_regen_power_raw()
    }
    
    /// Get raw value of DI_limitRegenPower
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_regen_power_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitRegenPower
    #[inline(always)]
    pub fn set_di_limit_regen_power(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// DI_limitRegenTorque
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_regen_torque(&self) -> bool {
        self.di_limit_regen_torque_raw()
    }
    
    /// Get raw value of DI_limitRegenTorque
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_regen_torque_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitRegenTorque
    #[inline(always)]
    pub fn set_di_limit_regen_torque(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// DI_limitRotorTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_rotor_temp(&self) -> bool {
        self.di_limit_rotor_temp_raw()
    }
    
    /// Get raw value of DI_limitRotorTemp
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_rotor_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitRotorTemp
    #[inline(always)]
    pub fn set_di_limit_rotor_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
    /// DI_limitShift
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_shift(&self) -> bool {
        self.di_limit_shift_raw()
    }
    
    /// Get raw value of DI_limitShift
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_shift_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitShift
    #[inline(always)]
    pub fn set_di_limit_shift(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// DI_limitShockTorque
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_shock_torque(&self) -> bool {
        self.di_limit_shock_torque_raw()
    }
    
    /// Get raw value of DI_limitShockTorque
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_shock_torque_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitShockTorque
    #[inline(always)]
    pub fn set_di_limit_shock_torque(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// DI_limitStatorFrequency
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_stator_frequency(&self) -> bool {
        self.di_limit_stator_frequency_raw()
    }
    
    /// Get raw value of DI_limitStatorFrequency
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_stator_frequency_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitStatorFrequency
    #[inline(always)]
    pub fn set_di_limit_stator_frequency(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// DI_limitStatorTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_stator_temp(&self) -> bool {
        self.di_limit_stator_temp_raw()
    }
    
    /// Get raw value of DI_limitStatorTemp
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_stator_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitStatorTemp
    #[inline(always)]
    pub fn set_di_limit_stator_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// DI_limitTCDrive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_tc_drive(&self) -> bool {
        self.di_limit_tc_drive_raw()
    }
    
    /// Get raw value of DI_limitTCDrive
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_tc_drive_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitTCDrive
    #[inline(always)]
    pub fn set_di_limit_tc_drive(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// DI_limitTCRegen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_tc_regen(&self) -> bool {
        self.di_limit_tc_regen_raw()
    }
    
    /// Get raw value of DI_limitTCRegen
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_tc_regen_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitTCRegen
    #[inline(always)]
    pub fn set_di_limit_tc_regen(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// DI_limitVBatHigh
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_v_bat_high(&self) -> bool {
        self.di_limit_v_bat_high_raw()
    }
    
    /// Get raw value of DI_limitVBatHigh
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_v_bat_high_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitVBatHigh
    #[inline(always)]
    pub fn set_di_limit_v_bat_high(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
    /// DI_limitVBatLow
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_v_bat_low(&self) -> bool {
        self.di_limit_v_bat_low_raw()
    }
    
    /// Get raw value of DI_limitVBatLow
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_v_bat_low_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitVBatLow
    #[inline(always)]
    pub fn set_di_limit_v_bat_low(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// DI_limitVehicleSpeed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limit_vehicle_speed(&self) -> bool {
        self.di_limit_vehicle_speed_raw()
    }
    
    /// Get raw value of DI_limitVehicleSpeed
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limit_vehicle_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitVehicleSpeed
    #[inline(always)]
    pub fn set_di_limit_vehicle_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[21..22].store_le(value);
        Ok(())
    }
    
    /// DI_limitdcLinkCapTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limitdc_link_cap_temp(&self) -> bool {
        self.di_limitdc_link_cap_temp_raw()
    }
    
    /// Get raw value of DI_limitdcLinkCapTemp
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limitdc_link_cap_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitdcLinkCapTemp
    #[inline(always)]
    pub fn set_di_limitdc_link_cap_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[33..34].store_le(value);
        Ok(())
    }
    
    /// DI_limithvDcCableTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limithv_dc_cable_temp(&self) -> bool {
        self.di_limithv_dc_cable_temp_raw()
    }
    
    /// Get raw value of DI_limithvDcCableTemp
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limithv_dc_cable_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limithvDcCableTemp
    #[inline(always)]
    pub fn set_di_limithv_dc_cable_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// DI_limitnegDcBusbarTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limitneg_dc_busbar_temp(&self) -> bool {
        self.di_limitneg_dc_busbar_temp_raw()
    }
    
    /// Get raw value of DI_limitnegDcBusbarTemp
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limitneg_dc_busbar_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitnegDcBusbarTemp
    #[inline(always)]
    pub fn set_di_limitneg_dc_busbar_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[34..35].store_le(value);
        Ok(())
    }
    
    /// DI_limitphaseOutBusBarWeldTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limitphase_out_bus_bar_weld_temp(&self) -> bool {
        self.di_limitphase_out_bus_bar_weld_temp_raw()
    }
    
    /// Get raw value of DI_limitphaseOutBusBarWeldTemp
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limitphase_out_bus_bar_weld_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitphaseOutBusBarWeldTemp
    #[inline(always)]
    pub fn set_di_limitphase_out_bus_bar_weld_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// DI_limitphaseOutBusbarTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limitphase_out_busbar_temp(&self) -> bool {
        self.di_limitphase_out_busbar_temp_raw()
    }
    
    /// Get raw value of DI_limitphaseOutBusbarTemp
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limitphase_out_busbar_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitphaseOutBusbarTemp
    #[inline(always)]
    pub fn set_di_limitphase_out_busbar_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// DI_limitphaseOutLugTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limitphase_out_lug_temp(&self) -> bool {
        self.di_limitphase_out_lug_temp_raw()
    }
    
    /// Get raw value of DI_limitphaseOutLugTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limitphase_out_lug_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitphaseOutLugTemp
    #[inline(always)]
    pub fn set_di_limitphase_out_lug_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// DI_limitposDcBusbarTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_limitpos_dc_busbar_temp(&self) -> bool {
        self.di_limitpos_dc_busbar_temp_raw()
    }
    
    /// Get raw value of DI_limitposDcBusbarTemp
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_limitpos_dc_busbar_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_limitposDcBusbarTemp
    #[inline(always)]
    pub fn set_di_limitpos_dc_busbar_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[35..36].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id1d6diLimits {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id1d6diLimits
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let di_limit_base_speed = u.int_in_range(0..=1)? == 1;
        let di_limit_clutch = u.int_in_range(0..=1)? == 1;
        let di_limit_dc_cap_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_delta_fluid_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_diff = u.int_in_range(0..=1)? == 1;
        let di_limit_discharge_power = u.int_in_range(0..=1)? == 1;
        let di_limit_drive_torque = u.int_in_range(0..=1)? == 1;
        let di_limit_graceful_power_off = u.int_in_range(0..=1)? == 1;
        let di_limit_i_bat = u.int_in_range(0..=1)? == 1;
        let di_limit_igbt_junct_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_inverter_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_limp_mode = u.int_in_range(0..=1)? == 1;
        let di_limit_motor_current = u.int_in_range(0..=1)? == 1;
        let di_limit_motor_speed = u.int_in_range(0..=1)? == 1;
        let di_limit_motor_voltage = u.int_in_range(0..=1)? == 1;
        let di_limit_obstacle_detection = u.int_in_range(0..=1)? == 1;
        let di_limit_oil_pump_fluid_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_pcb_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_pole_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_regen_power = u.int_in_range(0..=1)? == 1;
        let di_limit_regen_torque = u.int_in_range(0..=1)? == 1;
        let di_limit_rotor_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_shift = u.int_in_range(0..=1)? == 1;
        let di_limit_shock_torque = u.int_in_range(0..=1)? == 1;
        let di_limit_stator_frequency = u.int_in_range(0..=1)? == 1;
        let di_limit_stator_temp = u.int_in_range(0..=1)? == 1;
        let di_limit_tc_drive = u.int_in_range(0..=1)? == 1;
        let di_limit_tc_regen = u.int_in_range(0..=1)? == 1;
        let di_limit_v_bat_high = u.int_in_range(0..=1)? == 1;
        let di_limit_v_bat_low = u.int_in_range(0..=1)? == 1;
        let di_limit_vehicle_speed = u.int_in_range(0..=1)? == 1;
        let di_limitdc_link_cap_temp = u.int_in_range(0..=1)? == 1;
        let di_limithv_dc_cable_temp = u.int_in_range(0..=1)? == 1;
        let di_limitneg_dc_busbar_temp = u.int_in_range(0..=1)? == 1;
        let di_limitphase_out_bus_bar_weld_temp = u.int_in_range(0..=1)? == 1;
        let di_limitphase_out_busbar_temp = u.int_in_range(0..=1)? == 1;
        let di_limitphase_out_lug_temp = u.int_in_range(0..=1)? == 1;
        let di_limitpos_dc_busbar_temp = u.int_in_range(0..=1)? == 1;
        Id1d6diLimits::new(di_limit_base_speed,di_limit_clutch,di_limit_dc_cap_temp,di_limit_delta_fluid_temp,di_limit_diff,di_limit_discharge_power,di_limit_drive_torque,di_limit_graceful_power_off,di_limit_i_bat,di_limit_igbt_junct_temp,di_limit_inverter_temp,di_limit_limp_mode,di_limit_motor_current,di_limit_motor_speed,di_limit_motor_voltage,di_limit_obstacle_detection,di_limit_oil_pump_fluid_temp,di_limit_pcb_temp,di_limit_pole_temp,di_limit_regen_power,di_limit_regen_torque,di_limit_rotor_temp,di_limit_shift,di_limit_shock_torque,di_limit_stator_frequency,di_limit_stator_temp,di_limit_tc_drive,di_limit_tc_regen,di_limit_v_bat_high,di_limit_v_bat_low,di_limit_vehicle_speed,di_limitdc_link_cap_temp,di_limithv_dc_cable_temp,di_limitneg_dc_busbar_temp,di_limitphase_out_bus_bar_weld_temp,di_limitphase_out_busbar_temp,di_limitphase_out_lug_temp,di_limitpos_dc_busbar_temp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID20AHVP_contactorState
///
/// - ID: 522 (0x20a)
/// - Size: 6 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id20ahvpContactorState {
    raw: [u8; 6],
}

impl Id20ahvpContactorState {
    pub const MESSAGE_ID: u32 = 522;
    
    /// Construct new ID20AHVP_contactorState from values
    pub fn new(hvp_dc_link_allowed_to_energize: bool, hvp_fc_cont_negative_aux_open: bool, hvp_fc_cont_negative_state: u8, hvp_fc_cont_positive_aux_open: bool, hvp_fc_cont_positive_state: u8, hvp_fc_contactor_set_state: u8, hvp_fc_ctrs_closing_allowed: bool, hvp_fc_ctrs_open_now_requested: bool, hvp_fc_ctrs_open_requested: bool, hvp_fc_ctrs_request_status: u8, hvp_fc_ctrs_reset_request_required: bool, hvp_fc_link_allowed_to_energize: u8, hvp_hvil_status: u8, hvp_pack_cont_negative_state: u8, hvp_pack_cont_positive_state: u8, hvp_pack_contactor_set_state: u8, hvp_pack_ctrs_closing_allowed: bool, hvp_pack_ctrs_open_now_requested: bool, hvp_pack_ctrs_open_requested: bool, hvp_pack_ctrs_request_status: u8, hvp_pack_ctrs_reset_request_required: bool, hvp_pyro_test_in_progress: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_hvp_dc_link_allowed_to_energize(hvp_dc_link_allowed_to_energize)?;
        res.set_hvp_fc_cont_negative_aux_open(hvp_fc_cont_negative_aux_open)?;
        res.set_hvp_fc_cont_negative_state(hvp_fc_cont_negative_state)?;
        res.set_hvp_fc_cont_positive_aux_open(hvp_fc_cont_positive_aux_open)?;
        res.set_hvp_fc_cont_positive_state(hvp_fc_cont_positive_state)?;
        res.set_hvp_fc_contactor_set_state(hvp_fc_contactor_set_state)?;
        res.set_hvp_fc_ctrs_closing_allowed(hvp_fc_ctrs_closing_allowed)?;
        res.set_hvp_fc_ctrs_open_now_requested(hvp_fc_ctrs_open_now_requested)?;
        res.set_hvp_fc_ctrs_open_requested(hvp_fc_ctrs_open_requested)?;
        res.set_hvp_fc_ctrs_request_status(hvp_fc_ctrs_request_status)?;
        res.set_hvp_fc_ctrs_reset_request_required(hvp_fc_ctrs_reset_request_required)?;
        res.set_hvp_fc_link_allowed_to_energize(hvp_fc_link_allowed_to_energize)?;
        res.set_hvp_hvil_status(hvp_hvil_status)?;
        res.set_hvp_pack_cont_negative_state(hvp_pack_cont_negative_state)?;
        res.set_hvp_pack_cont_positive_state(hvp_pack_cont_positive_state)?;
        res.set_hvp_pack_contactor_set_state(hvp_pack_contactor_set_state)?;
        res.set_hvp_pack_ctrs_closing_allowed(hvp_pack_ctrs_closing_allowed)?;
        res.set_hvp_pack_ctrs_open_now_requested(hvp_pack_ctrs_open_now_requested)?;
        res.set_hvp_pack_ctrs_open_requested(hvp_pack_ctrs_open_requested)?;
        res.set_hvp_pack_ctrs_request_status(hvp_pack_ctrs_request_status)?;
        res.set_hvp_pack_ctrs_reset_request_required(hvp_pack_ctrs_reset_request_required)?;
        res.set_hvp_pyro_test_in_progress(hvp_pyro_test_in_progress)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// HVP_dcLinkAllowedToEnergize
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_dc_link_allowed_to_energize(&self) -> bool {
        self.hvp_dc_link_allowed_to_energize_raw()
    }
    
    /// Get raw value of HVP_dcLinkAllowedToEnergize
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_dc_link_allowed_to_energize_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_dcLinkAllowedToEnergize
    #[inline(always)]
    pub fn set_hvp_dc_link_allowed_to_energize(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
    /// HVP_fcContNegativeAuxOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_cont_negative_aux_open(&self) -> bool {
        self.hvp_fc_cont_negative_aux_open_raw()
    }
    
    /// Get raw value of HVP_fcContNegativeAuxOpen
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_cont_negative_aux_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_fcContNegativeAuxOpen
    #[inline(always)]
    pub fn set_hvp_fc_cont_negative_aux_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// HVP_fcContNegativeState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_cont_negative_state(&self) -> Id20ahvpContactorStateHvpFcContNegativeState {
        match self.hvp_fc_cont_negative_state_raw() {
            3 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStateBlocked,
            6 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStateEconomized,
            1 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStateOpen,
            5 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStateOpening,
            2 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStatePrecharge,
            4 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStatePulledIn,
            0 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStateSna,
            7 => Id20ahvpContactorStateHvpFcContNegativeState::ContactorStateWelded,
            x => Id20ahvpContactorStateHvpFcContNegativeState::Other(x),
        }
    }
    
    /// Get raw value of HVP_fcContNegativeState
    ///
    /// - Start bit: 12
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_cont_negative_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_fcContNegativeState
    #[inline(always)]
    pub fn set_hvp_fc_cont_negative_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..15].store_le(value);
        Ok(())
    }
    
    /// HVP_fcContPositiveAuxOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_cont_positive_aux_open(&self) -> bool {
        self.hvp_fc_cont_positive_aux_open_raw()
    }
    
    /// Get raw value of HVP_fcContPositiveAuxOpen
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_cont_positive_aux_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_fcContPositiveAuxOpen
    #[inline(always)]
    pub fn set_hvp_fc_cont_positive_aux_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// HVP_fcContPositiveState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_cont_positive_state(&self) -> Id20ahvpContactorStateHvpFcContPositiveState {
        match self.hvp_fc_cont_positive_state_raw() {
            3 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStateBlocked,
            6 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStateEconomized,
            1 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStateOpen,
            5 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStateOpening,
            2 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStatePrecharge,
            4 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStatePulledIn,
            0 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStateSna,
            7 => Id20ahvpContactorStateHvpFcContPositiveState::ContactorStateWelded,
            x => Id20ahvpContactorStateHvpFcContPositiveState::Other(x),
        }
    }
    
    /// Get raw value of HVP_fcContPositiveState
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_cont_positive_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_fcContPositiveState
    #[inline(always)]
    pub fn set_hvp_fc_cont_positive_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..19].store_le(value);
        Ok(())
    }
    
    /// HVP_fcContactorSetState
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_contactor_set_state(&self) -> Id20ahvpContactorStateHvpFcContactorSetState {
        match self.hvp_fc_contactor_set_state_raw() {
            3 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateBlocked,
            5 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateClosed,
            2 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateClosing,
            9 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateNegativeClosed,
            1 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateOpen,
            4 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateOpening,
            6 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStatePartialWeld,
            8 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStatePositiveClosed,
            0 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateSna,
            7 => Id20ahvpContactorStateHvpFcContactorSetState::ContactorSetStateWelded,
            x => Id20ahvpContactorStateHvpFcContactorSetState::Other(x),
        }
    }
    
    /// Get raw value of HVP_fcContactorSetState
    ///
    /// - Start bit: 19
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_contactor_set_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[19..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_fcContactorSetState
    #[inline(always)]
    pub fn set_hvp_fc_contactor_set_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[19..23].store_le(value);
        Ok(())
    }
    
    /// HVP_fcCtrsClosingAllowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_ctrs_closing_allowed(&self) -> bool {
        self.hvp_fc_ctrs_closing_allowed_raw()
    }
    
    /// Get raw value of HVP_fcCtrsClosingAllowed
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_ctrs_closing_allowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_fcCtrsClosingAllowed
    #[inline(always)]
    pub fn set_hvp_fc_ctrs_closing_allowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// HVP_fcCtrsOpenNowRequested
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_ctrs_open_now_requested(&self) -> bool {
        self.hvp_fc_ctrs_open_now_requested_raw()
    }
    
    /// Get raw value of HVP_fcCtrsOpenNowRequested
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_ctrs_open_now_requested_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_fcCtrsOpenNowRequested
    #[inline(always)]
    pub fn set_hvp_fc_ctrs_open_now_requested(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// HVP_fcCtrsOpenRequested
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_ctrs_open_requested(&self) -> bool {
        self.hvp_fc_ctrs_open_requested_raw()
    }
    
    /// Get raw value of HVP_fcCtrsOpenRequested
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_ctrs_open_requested_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_fcCtrsOpenRequested
    #[inline(always)]
    pub fn set_hvp_fc_ctrs_open_requested(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// HVP_fcCtrsRequestStatus
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_ctrs_request_status(&self) -> Id20ahvpContactorStateHvpFcCtrsRequestStatus {
        match self.hvp_fc_ctrs_request_status_raw() {
            1 => Id20ahvpContactorStateHvpFcCtrsRequestStatus::RequestActive,
            2 => Id20ahvpContactorStateHvpFcCtrsRequestStatus::RequestCompleted,
            0 => Id20ahvpContactorStateHvpFcCtrsRequestStatus::RequestNotActive,
            x => Id20ahvpContactorStateHvpFcCtrsRequestStatus::Other(x),
        }
    }
    
    /// Get raw value of HVP_fcCtrsRequestStatus
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_ctrs_request_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_fcCtrsRequestStatus
    #[inline(always)]
    pub fn set_hvp_fc_ctrs_request_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// HVP_fcCtrsResetRequestRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_ctrs_reset_request_required(&self) -> bool {
        self.hvp_fc_ctrs_reset_request_required_raw()
    }
    
    /// Get raw value of HVP_fcCtrsResetRequestRequired
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_ctrs_reset_request_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_fcCtrsResetRequestRequired
    #[inline(always)]
    pub fn set_hvp_fc_ctrs_reset_request_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// HVP_fcLinkAllowedToEnergize
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_fc_link_allowed_to_energize(&self) -> Id20ahvpContactorStateHvpFcLinkAllowedToEnergize {
        match self.hvp_fc_link_allowed_to_energize_raw() {
            1 => Id20ahvpContactorStateHvpFcLinkAllowedToEnergize::FcLinkEnergyAc,
            2 => Id20ahvpContactorStateHvpFcLinkAllowedToEnergize::FcLinkEnergyDc,
            0 => Id20ahvpContactorStateHvpFcLinkAllowedToEnergize::FcLinkEnergyNone,
            x => Id20ahvpContactorStateHvpFcLinkAllowedToEnergize::Other(x),
        }
    }
    
    /// Get raw value of HVP_fcLinkAllowedToEnergize
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_fc_link_allowed_to_energize_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_fcLinkAllowedToEnergize
    #[inline(always)]
    pub fn set_hvp_fc_link_allowed_to_energize(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
    /// HVP_hvilStatus
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_hvil_status(&self) -> Id20ahvpContactorStateHvpHvilStatus {
        match self.hvp_hvil_status_raw() {
            2 => Id20ahvpContactorStateHvpHvilStatus::CurrentSourceFault,
            3 => Id20ahvpContactorStateHvpHvilStatus::InternalOpenFault,
            8 => Id20ahvpContactorStateHvpHvilStatus::No12vSupply,
            5 => Id20ahvpContactorStateHvpHvilStatus::PenthouseLidOpenFault,
            1 => Id20ahvpContactorStateHvpHvilStatus::StatusOk,
            0 => Id20ahvpContactorStateHvpHvilStatus::Unknown,
            6 => Id20ahvpContactorStateHvpHvilStatus::UnknownLocationOpenFault,
            7 => Id20ahvpContactorStateHvpHvilStatus::VehicleNodeFault,
            4 => Id20ahvpContactorStateHvpHvilStatus::VehicleOpenFault,
            9 => Id20ahvpContactorStateHvpHvilStatus::VehicleOrPenthouseLidOpenFault,
            x => Id20ahvpContactorStateHvpHvilStatus::Other(x),
        }
    }
    
    /// Get raw value of HVP_hvilStatus
    ///
    /// - Start bit: 40
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_hvil_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_hvilStatus
    #[inline(always)]
    pub fn set_hvp_hvil_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..44].store_le(value);
        Ok(())
    }
    
    /// HVP_packContNegativeState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_cont_negative_state(&self) -> Id20ahvpContactorStateHvpPackContNegativeState {
        match self.hvp_pack_cont_negative_state_raw() {
            3 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStateBlocked,
            6 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStateEconomized,
            1 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStateOpen,
            5 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStateOpening,
            2 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStatePrecharge,
            4 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStatePulledIn,
            0 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStateSna,
            7 => Id20ahvpContactorStateHvpPackContNegativeState::ContactorStateWelded,
            x => Id20ahvpContactorStateHvpPackContNegativeState::Other(x),
        }
    }
    
    /// Get raw value of HVP_packContNegativeState
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_cont_negative_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_packContNegativeState
    #[inline(always)]
    pub fn set_hvp_pack_cont_negative_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// HVP_packContPositiveState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_cont_positive_state(&self) -> Id20ahvpContactorStateHvpPackContPositiveState {
        match self.hvp_pack_cont_positive_state_raw() {
            3 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStateBlocked,
            6 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStateEconomized,
            1 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStateOpen,
            5 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStateOpening,
            2 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStatePrecharge,
            4 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStatePulledIn,
            0 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStateSna,
            7 => Id20ahvpContactorStateHvpPackContPositiveState::ContactorStateWelded,
            x => Id20ahvpContactorStateHvpPackContPositiveState::Other(x),
        }
    }
    
    /// Get raw value of HVP_packContPositiveState
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_cont_positive_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_packContPositiveState
    #[inline(always)]
    pub fn set_hvp_pack_cont_positive_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// HVP_packContactorSetState
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_contactor_set_state(&self) -> Id20ahvpContactorStateHvpPackContactorSetState {
        match self.hvp_pack_contactor_set_state_raw() {
            3 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateBlocked,
            5 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateClosed,
            2 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateClosing,
            9 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateNegativeClosed,
            1 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateOpen,
            4 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateOpening,
            6 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStatePartialWeld,
            8 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStatePositiveClosed,
            0 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateSna,
            7 => Id20ahvpContactorStateHvpPackContactorSetState::ContactorSetStateWelded,
            x => Id20ahvpContactorStateHvpPackContactorSetState::Other(x),
        }
    }
    
    /// Get raw value of HVP_packContactorSetState
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_contactor_set_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_packContactorSetState
    #[inline(always)]
    pub fn set_hvp_pack_contactor_set_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// HVP_packCtrsClosingAllowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_ctrs_closing_allowed(&self) -> bool {
        self.hvp_pack_ctrs_closing_allowed_raw()
    }
    
    /// Get raw value of HVP_packCtrsClosingAllowed
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_ctrs_closing_allowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_packCtrsClosingAllowed
    #[inline(always)]
    pub fn set_hvp_pack_ctrs_closing_allowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[35..36].store_le(value);
        Ok(())
    }
    
    /// HVP_packCtrsOpenNowRequested
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_ctrs_open_now_requested(&self) -> bool {
        self.hvp_pack_ctrs_open_now_requested_raw()
    }
    
    /// Get raw value of HVP_packCtrsOpenNowRequested
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_ctrs_open_now_requested_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_packCtrsOpenNowRequested
    #[inline(always)]
    pub fn set_hvp_pack_ctrs_open_now_requested(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[33..34].store_le(value);
        Ok(())
    }
    
    /// HVP_packCtrsOpenRequested
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_ctrs_open_requested(&self) -> bool {
        self.hvp_pack_ctrs_open_requested_raw()
    }
    
    /// Get raw value of HVP_packCtrsOpenRequested
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_ctrs_open_requested_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_packCtrsOpenRequested
    #[inline(always)]
    pub fn set_hvp_pack_ctrs_open_requested(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[34..35].store_le(value);
        Ok(())
    }
    
    /// HVP_packCtrsRequestStatus
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_ctrs_request_status(&self) -> Id20ahvpContactorStateHvpPackCtrsRequestStatus {
        match self.hvp_pack_ctrs_request_status_raw() {
            1 => Id20ahvpContactorStateHvpPackCtrsRequestStatus::RequestActive,
            2 => Id20ahvpContactorStateHvpPackCtrsRequestStatus::RequestCompleted,
            0 => Id20ahvpContactorStateHvpPackCtrsRequestStatus::RequestNotActive,
            x => Id20ahvpContactorStateHvpPackCtrsRequestStatus::Other(x),
        }
    }
    
    /// Get raw value of HVP_packCtrsRequestStatus
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_ctrs_request_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_packCtrsRequestStatus
    #[inline(always)]
    pub fn set_hvp_pack_ctrs_request_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 522 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..32].store_le(value);
        Ok(())
    }
    
    /// HVP_packCtrsResetRequestRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pack_ctrs_reset_request_required(&self) -> bool {
        self.hvp_pack_ctrs_reset_request_required_raw()
    }
    
    /// Get raw value of HVP_packCtrsResetRequestRequired
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pack_ctrs_reset_request_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_packCtrsResetRequestRequired
    #[inline(always)]
    pub fn set_hvp_pack_ctrs_reset_request_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// HVP_pyroTestInProgress
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pyro_test_in_progress(&self) -> bool {
        self.hvp_pyro_test_in_progress_raw()
    }
    
    /// Get raw value of HVP_pyroTestInProgress
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pyro_test_in_progress_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_pyroTestInProgress
    #[inline(always)]
    pub fn set_hvp_pyro_test_in_progress(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id20ahvpContactorState {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id20ahvpContactorState
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hvp_dc_link_allowed_to_energize = u.int_in_range(0..=1)? == 1;
        let hvp_fc_cont_negative_aux_open = u.int_in_range(0..=1)? == 1;
        let hvp_fc_cont_negative_state = u.int_in_range(0..=7)?;
        let hvp_fc_cont_positive_aux_open = u.int_in_range(0..=1)? == 1;
        let hvp_fc_cont_positive_state = u.int_in_range(0..=7)?;
        let hvp_fc_contactor_set_state = u.int_in_range(0..=9)?;
        let hvp_fc_ctrs_closing_allowed = u.int_in_range(0..=1)? == 1;
        let hvp_fc_ctrs_open_now_requested = u.int_in_range(0..=1)? == 1;
        let hvp_fc_ctrs_open_requested = u.int_in_range(0..=1)? == 1;
        let hvp_fc_ctrs_request_status = u.int_in_range(0..=2)?;
        let hvp_fc_ctrs_reset_request_required = u.int_in_range(0..=1)? == 1;
        let hvp_fc_link_allowed_to_energize = u.int_in_range(0..=2)?;
        let hvp_hvil_status = u.int_in_range(0..=9)?;
        let hvp_pack_cont_negative_state = u.int_in_range(0..=7)?;
        let hvp_pack_cont_positive_state = u.int_in_range(0..=7)?;
        let hvp_pack_contactor_set_state = u.int_in_range(0..=9)?;
        let hvp_pack_ctrs_closing_allowed = u.int_in_range(0..=1)? == 1;
        let hvp_pack_ctrs_open_now_requested = u.int_in_range(0..=1)? == 1;
        let hvp_pack_ctrs_open_requested = u.int_in_range(0..=1)? == 1;
        let hvp_pack_ctrs_request_status = u.int_in_range(0..=2)?;
        let hvp_pack_ctrs_reset_request_required = u.int_in_range(0..=1)? == 1;
        let hvp_pyro_test_in_progress = u.int_in_range(0..=1)? == 1;
        Id20ahvpContactorState::new(hvp_dc_link_allowed_to_energize,hvp_fc_cont_negative_aux_open,hvp_fc_cont_negative_state,hvp_fc_cont_positive_aux_open,hvp_fc_cont_positive_state,hvp_fc_contactor_set_state,hvp_fc_ctrs_closing_allowed,hvp_fc_ctrs_open_now_requested,hvp_fc_ctrs_open_requested,hvp_fc_ctrs_request_status,hvp_fc_ctrs_reset_request_required,hvp_fc_link_allowed_to_energize,hvp_hvil_status,hvp_pack_cont_negative_state,hvp_pack_cont_positive_state,hvp_pack_contactor_set_state,hvp_pack_ctrs_closing_allowed,hvp_pack_ctrs_open_now_requested,hvp_pack_ctrs_open_requested,hvp_pack_ctrs_request_status,hvp_pack_ctrs_reset_request_required,hvp_pyro_test_in_progress).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for HVP_fcContNegativeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpFcContNegativeState {
    ContactorStateBlocked,
    ContactorStateEconomized,
    ContactorStateOpen,
    ContactorStateOpening,
    ContactorStatePrecharge,
    ContactorStatePulledIn,
    ContactorStateSna,
    ContactorStateWelded,
    Other(u8),
}
/// Defined values for HVP_fcContPositiveState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpFcContPositiveState {
    ContactorStateBlocked,
    ContactorStateEconomized,
    ContactorStateOpen,
    ContactorStateOpening,
    ContactorStatePrecharge,
    ContactorStatePulledIn,
    ContactorStateSna,
    ContactorStateWelded,
    Other(u8),
}
/// Defined values for HVP_fcContactorSetState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpFcContactorSetState {
    ContactorSetStateBlocked,
    ContactorSetStateClosed,
    ContactorSetStateClosing,
    ContactorSetStateNegativeClosed,
    ContactorSetStateOpen,
    ContactorSetStateOpening,
    ContactorSetStatePartialWeld,
    ContactorSetStatePositiveClosed,
    ContactorSetStateSna,
    ContactorSetStateWelded,
    Other(u8),
}
/// Defined values for HVP_fcCtrsRequestStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpFcCtrsRequestStatus {
    RequestActive,
    RequestCompleted,
    RequestNotActive,
    Other(u8),
}
/// Defined values for HVP_fcLinkAllowedToEnergize
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpFcLinkAllowedToEnergize {
    FcLinkEnergyAc,
    FcLinkEnergyDc,
    FcLinkEnergyNone,
    Other(u8),
}
/// Defined values for HVP_hvilStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpHvilStatus {
    CurrentSourceFault,
    InternalOpenFault,
    No12vSupply,
    PenthouseLidOpenFault,
    StatusOk,
    Unknown,
    UnknownLocationOpenFault,
    VehicleNodeFault,
    VehicleOpenFault,
    VehicleOrPenthouseLidOpenFault,
    Other(u8),
}
/// Defined values for HVP_packContNegativeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpPackContNegativeState {
    ContactorStateBlocked,
    ContactorStateEconomized,
    ContactorStateOpen,
    ContactorStateOpening,
    ContactorStatePrecharge,
    ContactorStatePulledIn,
    ContactorStateSna,
    ContactorStateWelded,
    Other(u8),
}
/// Defined values for HVP_packContPositiveState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpPackContPositiveState {
    ContactorStateBlocked,
    ContactorStateEconomized,
    ContactorStateOpen,
    ContactorStateOpening,
    ContactorStatePrecharge,
    ContactorStatePulledIn,
    ContactorStateSna,
    ContactorStateWelded,
    Other(u8),
}
/// Defined values for HVP_packContactorSetState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpPackContactorSetState {
    ContactorSetStateBlocked,
    ContactorSetStateClosed,
    ContactorSetStateClosing,
    ContactorSetStateNegativeClosed,
    ContactorSetStateOpen,
    ContactorSetStateOpening,
    ContactorSetStatePartialWeld,
    ContactorSetStatePositiveClosed,
    ContactorSetStateSna,
    ContactorSetStateWelded,
    Other(u8),
}
/// Defined values for HVP_packCtrsRequestStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20ahvpContactorStateHvpPackCtrsRequestStatus {
    RequestActive,
    RequestCompleted,
    RequestNotActive,
    Other(u8),
}

/// ID20EPARK_sdiFront
///
/// - ID: 526 (0x20e)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id20eparkSdiFront {
    raw: [u8; 8],
}

impl Id20eparkSdiFront {
    pub const MESSAGE_ID: u32 = 526;
    
    /// Construct new ID20EPARK_sdiFront from values
    pub fn new(park_sdi_front_checksum: u8, park_sdi_front_counter: u8, park_sdi_sensor1_raw_dist_data: u16, park_sdi_sensor2_raw_dist_data: u16, park_sdi_sensor3_raw_dist_data: u16, park_sdi_sensor4_raw_dist_data: u16, park_sdi_sensor5_raw_dist_data: u16, park_sdi_sensor6_raw_dist_data: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_park_sdi_front_checksum(park_sdi_front_checksum)?;
        res.set_park_sdi_front_counter(park_sdi_front_counter)?;
        res.set_park_sdi_sensor1_raw_dist_data(park_sdi_sensor1_raw_dist_data)?;
        res.set_park_sdi_sensor2_raw_dist_data(park_sdi_sensor2_raw_dist_data)?;
        res.set_park_sdi_sensor3_raw_dist_data(park_sdi_sensor3_raw_dist_data)?;
        res.set_park_sdi_sensor4_raw_dist_data(park_sdi_sensor4_raw_dist_data)?;
        res.set_park_sdi_sensor5_raw_dist_data(park_sdi_sensor5_raw_dist_data)?;
        res.set_park_sdi_sensor6_raw_dist_data(park_sdi_sensor6_raw_dist_data)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// PARK_sdiFrontChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_front_checksum(&self) -> u8 {
        self.park_sdi_front_checksum_raw()
    }
    
    /// Get raw value of PARK_sdiFrontChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_front_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PARK_sdiFrontChecksum
    #[inline(always)]
    pub fn set_park_sdi_front_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiFrontCounter
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_front_counter(&self) -> u8 {
        self.park_sdi_front_counter_raw()
    }
    
    /// Get raw value of PARK_sdiFrontCounter
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_front_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PARK_sdiFrontCounter
    #[inline(always)]
    pub fn set_park_sdi_front_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor1RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor1_raw_dist_data(&self) -> Id20eparkSdiFrontParkSdiSensor1RawDistData {
        match self.park_sdi_sensor1_raw_dist_data_raw() {
            0 => Id20eparkSdiFrontParkSdiSensor1RawDistData::Blocked,
            1 => Id20eparkSdiFrontParkSdiSensor1RawDistData::NearDetection,
            500 => Id20eparkSdiFrontParkSdiSensor1RawDistData::NoObjectDetected,
            511 => Id20eparkSdiFrontParkSdiSensor1RawDistData::Sna,
            x => Id20eparkSdiFrontParkSdiSensor1RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor1RawDistData
    ///
    /// - Start bit: 0
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor1_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[0..9].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor1RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor1_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..9].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor2RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor2_raw_dist_data(&self) -> Id20eparkSdiFrontParkSdiSensor2RawDistData {
        match self.park_sdi_sensor2_raw_dist_data_raw() {
            0 => Id20eparkSdiFrontParkSdiSensor2RawDistData::Blocked,
            1 => Id20eparkSdiFrontParkSdiSensor2RawDistData::NearDetection,
            500 => Id20eparkSdiFrontParkSdiSensor2RawDistData::NoObjectDetected,
            511 => Id20eparkSdiFrontParkSdiSensor2RawDistData::Sna,
            x => Id20eparkSdiFrontParkSdiSensor2RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor2RawDistData
    ///
    /// - Start bit: 9
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor2_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[9..18].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor2RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor2_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[9..18].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor3RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor3_raw_dist_data(&self) -> Id20eparkSdiFrontParkSdiSensor3RawDistData {
        match self.park_sdi_sensor3_raw_dist_data_raw() {
            0 => Id20eparkSdiFrontParkSdiSensor3RawDistData::Blocked,
            1 => Id20eparkSdiFrontParkSdiSensor3RawDistData::NearDetection,
            500 => Id20eparkSdiFrontParkSdiSensor3RawDistData::NoObjectDetected,
            511 => Id20eparkSdiFrontParkSdiSensor3RawDistData::Sna,
            x => Id20eparkSdiFrontParkSdiSensor3RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor3RawDistData
    ///
    /// - Start bit: 18
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor3_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[18..27].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor3RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor3_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..27].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor4RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor4_raw_dist_data(&self) -> Id20eparkSdiFrontParkSdiSensor4RawDistData {
        match self.park_sdi_sensor4_raw_dist_data_raw() {
            0 => Id20eparkSdiFrontParkSdiSensor4RawDistData::Blocked,
            1 => Id20eparkSdiFrontParkSdiSensor4RawDistData::NearDetection,
            500 => Id20eparkSdiFrontParkSdiSensor4RawDistData::NoObjectDetected,
            511 => Id20eparkSdiFrontParkSdiSensor4RawDistData::Sna,
            x => Id20eparkSdiFrontParkSdiSensor4RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor4RawDistData
    ///
    /// - Start bit: 27
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor4_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[27..36].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor4RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor4_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..36].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor5RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor5_raw_dist_data(&self) -> Id20eparkSdiFrontParkSdiSensor5RawDistData {
        match self.park_sdi_sensor5_raw_dist_data_raw() {
            0 => Id20eparkSdiFrontParkSdiSensor5RawDistData::Blocked,
            1 => Id20eparkSdiFrontParkSdiSensor5RawDistData::NearDetection,
            500 => Id20eparkSdiFrontParkSdiSensor5RawDistData::NoObjectDetected,
            511 => Id20eparkSdiFrontParkSdiSensor5RawDistData::Sna,
            x => Id20eparkSdiFrontParkSdiSensor5RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor5RawDistData
    ///
    /// - Start bit: 36
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor5_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[36..45].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor5RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor5_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..45].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor6RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor6_raw_dist_data(&self) -> Id20eparkSdiFrontParkSdiSensor6RawDistData {
        match self.park_sdi_sensor6_raw_dist_data_raw() {
            0 => Id20eparkSdiFrontParkSdiSensor6RawDistData::Blocked,
            1 => Id20eparkSdiFrontParkSdiSensor6RawDistData::NearDetection,
            500 => Id20eparkSdiFrontParkSdiSensor6RawDistData::NoObjectDetected,
            511 => Id20eparkSdiFrontParkSdiSensor6RawDistData::Sna,
            x => Id20eparkSdiFrontParkSdiSensor6RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor6RawDistData
    ///
    /// - Start bit: 45
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor6_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[45..54].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor6RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor6_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 526 }); }
        self.raw.view_bits_mut::<LocalBits>()[45..54].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id20eparkSdiFront {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id20eparkSdiFront
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let park_sdi_front_checksum = u.int_in_range(0..=255)?;
        let park_sdi_front_counter = u.int_in_range(0..=3)?;
        let park_sdi_sensor1_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor2_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor3_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor4_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor5_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor6_raw_dist_data = u.int_in_range(0..=511)?;
        Id20eparkSdiFront::new(park_sdi_front_checksum,park_sdi_front_counter,park_sdi_sensor1_raw_dist_data,park_sdi_sensor2_raw_dist_data,park_sdi_sensor3_raw_dist_data,park_sdi_sensor4_raw_dist_data,park_sdi_sensor5_raw_dist_data,park_sdi_sensor6_raw_dist_data).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for PARK_sdiSensor1RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20eparkSdiFrontParkSdiSensor1RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor2RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20eparkSdiFrontParkSdiSensor2RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor3RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20eparkSdiFrontParkSdiSensor3RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor4RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20eparkSdiFrontParkSdiSensor4RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor5RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20eparkSdiFrontParkSdiSensor5RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor6RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20eparkSdiFrontParkSdiSensor6RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}

/// ID219VCSEC_TPMSData
///
/// - ID: 537 (0x219)
/// - Size: 5 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id219vcsecTpmsData {
    raw: [u8; 5],
}

impl Id219vcsecTpmsData {
    pub const MESSAGE_ID: u32 = 537;
    
    /// Construct new ID219VCSEC_TPMSData from values
    pub fn new(vcsec_tpms_data_index: u8, vcsec_tpms_bat_voltage0: f32, vcsec_tpms_bat_voltage1: f32, vcsec_tpms_bat_voltage2: f32, vcsec_tpms_bat_voltage3: f32, vcsec_tpms_location0: u8, vcsec_tpms_location1: u8, vcsec_tpms_location2: u8, vcsec_tpms_location3: u8, vcsec_tpms_pressure0: f32, vcsec_tpms_pressure1: f32, vcsec_tpms_pressure2: f32, vcsec_tpms_pressure3: f32, vcsec_tpms_temperature0: f32, vcsec_tpms_temperature1: f32, vcsec_tpms_temperature2: f32, vcsec_tpms_temperature3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_vcsec_tpms_data_index(vcsec_tpms_data_index)?;
        res.set_vcsec_tpms_bat_voltage0(vcsec_tpms_bat_voltage0)?;
        res.set_vcsec_tpms_bat_voltage1(vcsec_tpms_bat_voltage1)?;
        res.set_vcsec_tpms_bat_voltage2(vcsec_tpms_bat_voltage2)?;
        res.set_vcsec_tpms_bat_voltage3(vcsec_tpms_bat_voltage3)?;
        res.set_vcsec_tpms_location0(vcsec_tpms_location0)?;
        res.set_vcsec_tpms_location1(vcsec_tpms_location1)?;
        res.set_vcsec_tpms_location2(vcsec_tpms_location2)?;
        res.set_vcsec_tpms_location3(vcsec_tpms_location3)?;
        res.set_vcsec_tpms_pressure0(vcsec_tpms_pressure0)?;
        res.set_vcsec_tpms_pressure1(vcsec_tpms_pressure1)?;
        res.set_vcsec_tpms_pressure2(vcsec_tpms_pressure2)?;
        res.set_vcsec_tpms_pressure3(vcsec_tpms_pressure3)?;
        res.set_vcsec_tpms_temperature0(vcsec_tpms_temperature0)?;
        res.set_vcsec_tpms_temperature1(vcsec_tpms_temperature1)?;
        res.set_vcsec_tpms_temperature2(vcsec_tpms_temperature2)?;
        res.set_vcsec_tpms_temperature3(vcsec_tpms_temperature3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCSEC_TPMSDataIndex
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_data_index(&self) -> Id219vcsecTpmsDataVcsecTpmsDataIndex {
        match self.vcsec_tpms_data_index_raw() {
            0 => Id219vcsecTpmsDataVcsecTpmsDataIndex::TpmsDataSensor0,
            1 => Id219vcsecTpmsDataVcsecTpmsDataIndex::TpmsDataSensor1,
            2 => Id219vcsecTpmsDataVcsecTpmsDataIndex::TpmsDataSensor2,
            3 => Id219vcsecTpmsDataVcsecTpmsDataIndex::TpmsDataSensor3,
            x => Id219vcsecTpmsDataVcsecTpmsDataIndex::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSDataIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_data_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSDataIndex
    #[inline(always)]
    pub fn set_vcsec_tpms_data_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSBatVoltage0
    ///
    /// - Min: 1.5
    /// - Max: 4.04
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage0(&self) -> Id219vcsecTpmsDataVcsecTpmsBatVoltage0 {
        match self.vcsec_tpms_bat_voltage0_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsBatVoltage0::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsBatVoltage0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSBatVoltage0
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 1.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage0_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSBatVoltage0
    #[inline(always)]
    pub fn set_vcsec_tpms_bat_voltage0(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 1.5_f32 || 4.04_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSBatVoltage1
    ///
    /// - Min: 1.5
    /// - Max: 4.04
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage1(&self) -> Id219vcsecTpmsDataVcsecTpmsBatVoltage1 {
        match self.vcsec_tpms_bat_voltage1_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsBatVoltage1::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsBatVoltage1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSBatVoltage1
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 1.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSBatVoltage1
    #[inline(always)]
    pub fn set_vcsec_tpms_bat_voltage1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 1.5_f32 || 4.04_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSBatVoltage2
    ///
    /// - Min: 1.5
    /// - Max: 4.04
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage2(&self) -> Id219vcsecTpmsDataVcsecTpmsBatVoltage2 {
        match self.vcsec_tpms_bat_voltage2_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsBatVoltage2::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsBatVoltage2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSBatVoltage2
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 1.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSBatVoltage2
    #[inline(always)]
    pub fn set_vcsec_tpms_bat_voltage2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 1.5_f32 || 4.04_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSBatVoltage3
    ///
    /// - Min: 1.5
    /// - Max: 4.04
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage3(&self) -> Id219vcsecTpmsDataVcsecTpmsBatVoltage3 {
        match self.vcsec_tpms_bat_voltage3_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsBatVoltage3::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsBatVoltage3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSBatVoltage3
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 1.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_bat_voltage3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSBatVoltage3
    #[inline(always)]
    pub fn set_vcsec_tpms_bat_voltage3(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 1.5_f32 || 4.04_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.01_f32;
        let offset = 1.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSLocation0
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_location0(&self) -> Id219vcsecTpmsDataVcsecTpmsLocation0 {
        match self.vcsec_tpms_location0_raw() {
            0 => Id219vcsecTpmsDataVcsecTpmsLocation0::LocationFl,
            1 => Id219vcsecTpmsDataVcsecTpmsLocation0::LocationFr,
            2 => Id219vcsecTpmsDataVcsecTpmsLocation0::LocationRl,
            3 => Id219vcsecTpmsDataVcsecTpmsLocation0::LocationRr,
            4 => Id219vcsecTpmsDataVcsecTpmsLocation0::LocationUnknown,
            x => Id219vcsecTpmsDataVcsecTpmsLocation0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSLocation0
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_location0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSLocation0
    #[inline(always)]
    pub fn set_vcsec_tpms_location0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..35].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSLocation1
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_location1(&self) -> Id219vcsecTpmsDataVcsecTpmsLocation1 {
        match self.vcsec_tpms_location1_raw() {
            0 => Id219vcsecTpmsDataVcsecTpmsLocation1::LocationFl,
            1 => Id219vcsecTpmsDataVcsecTpmsLocation1::LocationFr,
            2 => Id219vcsecTpmsDataVcsecTpmsLocation1::LocationRl,
            3 => Id219vcsecTpmsDataVcsecTpmsLocation1::LocationRr,
            4 => Id219vcsecTpmsDataVcsecTpmsLocation1::LocationUnknown,
            x => Id219vcsecTpmsDataVcsecTpmsLocation1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSLocation1
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_location1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSLocation1
    #[inline(always)]
    pub fn set_vcsec_tpms_location1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..35].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSLocation2
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_location2(&self) -> Id219vcsecTpmsDataVcsecTpmsLocation2 {
        match self.vcsec_tpms_location2_raw() {
            0 => Id219vcsecTpmsDataVcsecTpmsLocation2::LocationFl,
            1 => Id219vcsecTpmsDataVcsecTpmsLocation2::LocationFr,
            2 => Id219vcsecTpmsDataVcsecTpmsLocation2::LocationRl,
            3 => Id219vcsecTpmsDataVcsecTpmsLocation2::LocationRr,
            4 => Id219vcsecTpmsDataVcsecTpmsLocation2::LocationUnknown,
            x => Id219vcsecTpmsDataVcsecTpmsLocation2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSLocation2
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_location2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSLocation2
    #[inline(always)]
    pub fn set_vcsec_tpms_location2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..35].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSLocation3
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_location3(&self) -> Id219vcsecTpmsDataVcsecTpmsLocation3 {
        match self.vcsec_tpms_location3_raw() {
            0 => Id219vcsecTpmsDataVcsecTpmsLocation3::LocationFl,
            1 => Id219vcsecTpmsDataVcsecTpmsLocation3::LocationFr,
            2 => Id219vcsecTpmsDataVcsecTpmsLocation3::LocationRl,
            3 => Id219vcsecTpmsDataVcsecTpmsLocation3::LocationRr,
            4 => Id219vcsecTpmsDataVcsecTpmsLocation3::LocationUnknown,
            x => Id219vcsecTpmsDataVcsecTpmsLocation3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSLocation3
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_location3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSLocation3
    #[inline(always)]
    pub fn set_vcsec_tpms_location3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..35].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSPressure0
    ///
    /// - Min: 0
    /// - Max: 6.35
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_pressure0(&self) -> Id219vcsecTpmsDataVcsecTpmsPressure0 {
        match self.vcsec_tpms_pressure0_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsPressure0::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsPressure0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSPressure0
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_pressure0_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSPressure0
    #[inline(always)]
    pub fn set_vcsec_tpms_pressure0(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.35_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSPressure1
    ///
    /// - Min: 0
    /// - Max: 6.35
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_pressure1(&self) -> Id219vcsecTpmsDataVcsecTpmsPressure1 {
        match self.vcsec_tpms_pressure1_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsPressure1::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsPressure1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSPressure1
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_pressure1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSPressure1
    #[inline(always)]
    pub fn set_vcsec_tpms_pressure1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.35_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSPressure2
    ///
    /// - Min: 0
    /// - Max: 6.35
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_pressure2(&self) -> Id219vcsecTpmsDataVcsecTpmsPressure2 {
        match self.vcsec_tpms_pressure2_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsPressure2::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsPressure2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSPressure2
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_pressure2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSPressure2
    #[inline(always)]
    pub fn set_vcsec_tpms_pressure2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.35_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSPressure3
    ///
    /// - Min: 0
    /// - Max: 6.35
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_pressure3(&self) -> Id219vcsecTpmsDataVcsecTpmsPressure3 {
        match self.vcsec_tpms_pressure3_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsPressure3::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsPressure3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSPressure3
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_pressure3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSPressure3
    #[inline(always)]
    pub fn set_vcsec_tpms_pressure3(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.35_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSTemperature0
    ///
    /// - Min: -40
    /// - Max: 214
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_temperature0(&self) -> Id219vcsecTpmsDataVcsecTpmsTemperature0 {
        match self.vcsec_tpms_temperature0_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsTemperature0::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsTemperature0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSTemperature0
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_temperature0_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSTemperature0
    #[inline(always)]
    pub fn set_vcsec_tpms_temperature0(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 214_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSTemperature1
    ///
    /// - Min: -40
    /// - Max: 214
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_temperature1(&self) -> Id219vcsecTpmsDataVcsecTpmsTemperature1 {
        match self.vcsec_tpms_temperature1_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsTemperature1::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsTemperature1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSTemperature1
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_temperature1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSTemperature1
    #[inline(always)]
    pub fn set_vcsec_tpms_temperature1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 214_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSTemperature2
    ///
    /// - Min: -40
    /// - Max: 214
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_temperature2(&self) -> Id219vcsecTpmsDataVcsecTpmsTemperature2 {
        match self.vcsec_tpms_temperature2_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsTemperature2::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsTemperature2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSTemperature2
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_temperature2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSTemperature2
    #[inline(always)]
    pub fn set_vcsec_tpms_temperature2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 214_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSTemperature3
    ///
    /// - Min: -40
    /// - Max: 214
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_temperature3(&self) -> Id219vcsecTpmsDataVcsecTpmsTemperature3 {
        match self.vcsec_tpms_temperature3_raw() {
            255 => Id219vcsecTpmsDataVcsecTpmsTemperature3::Sna,
            x => Id219vcsecTpmsDataVcsecTpmsTemperature3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSTemperature3
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_temperature3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCSEC_TPMSTemperature3
    #[inline(always)]
    pub fn set_vcsec_tpms_temperature3(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 214_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 537 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id219vcsecTpmsData {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id219vcsecTpmsData
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcsec_tpms_data_index = u.int_in_range(0..=3)?;
        let vcsec_tpms_bat_voltage0 = 1.5_f32;
        let vcsec_tpms_bat_voltage1 = 1.5_f32;
        let vcsec_tpms_bat_voltage2 = 1.5_f32;
        let vcsec_tpms_bat_voltage3 = 1.5_f32;
        let vcsec_tpms_location0 = u.int_in_range(0..=4)?;
        let vcsec_tpms_location1 = u.int_in_range(0..=4)?;
        let vcsec_tpms_location2 = u.int_in_range(0..=4)?;
        let vcsec_tpms_location3 = u.int_in_range(0..=4)?;
        let vcsec_tpms_pressure0 = 0_f32;
        let vcsec_tpms_pressure1 = 0_f32;
        let vcsec_tpms_pressure2 = 0_f32;
        let vcsec_tpms_pressure3 = 0_f32;
        let vcsec_tpms_temperature0 = -40_f32;
        let vcsec_tpms_temperature1 = -40_f32;
        let vcsec_tpms_temperature2 = -40_f32;
        let vcsec_tpms_temperature3 = -40_f32;
        Id219vcsecTpmsData::new(vcsec_tpms_data_index,vcsec_tpms_bat_voltage0,vcsec_tpms_bat_voltage1,vcsec_tpms_bat_voltage2,vcsec_tpms_bat_voltage3,vcsec_tpms_location0,vcsec_tpms_location1,vcsec_tpms_location2,vcsec_tpms_location3,vcsec_tpms_pressure0,vcsec_tpms_pressure1,vcsec_tpms_pressure2,vcsec_tpms_pressure3,vcsec_tpms_temperature0,vcsec_tpms_temperature1,vcsec_tpms_temperature2,vcsec_tpms_temperature3).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCSEC_TPMSDataIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsDataIndex {
    TpmsDataSensor0,
    TpmsDataSensor1,
    TpmsDataSensor2,
    TpmsDataSensor3,
    Other(u8),
}
/// Defined values for VCSEC_TPMSBatVoltage0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsBatVoltage0 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSBatVoltage1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsBatVoltage1 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSBatVoltage2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsBatVoltage2 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSBatVoltage3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsBatVoltage3 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSLocation0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsLocation0 {
    LocationFl,
    LocationFr,
    LocationRl,
    LocationRr,
    LocationUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSLocation1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsLocation1 {
    LocationFl,
    LocationFr,
    LocationRl,
    LocationRr,
    LocationUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSLocation2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsLocation2 {
    LocationFl,
    LocationFr,
    LocationRl,
    LocationRr,
    LocationUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSLocation3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsLocation3 {
    LocationFl,
    LocationFr,
    LocationRl,
    LocationRr,
    LocationUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSPressure0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsPressure0 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSPressure1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsPressure1 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSPressure2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsPressure2 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSPressure3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsPressure3 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSTemperature0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsTemperature0 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSTemperature1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsTemperature1 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSTemperature2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsTemperature2 {
    Sna,
    Other(f32),
}
/// Defined values for VCSEC_TPMSTemperature3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id219vcsecTpmsDataVcsecTpmsTemperature3 {
    Sna,
    Other(f32),
}

/// ID204PCS_chgStatus
///
/// - ID: 516 (0x204)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id204pcsChgStatus {
    raw: [u8; 8],
}

impl Id204pcsChgStatus {
    pub const MESSAGE_ID: u32 = 516;
    
    /// Construct new ID204PCS_chgStatus from values
    pub fn new(pcs_charge_shutdown_request: u8, pcs_chg_instant_ac_power_available: f32, pcs_chg_main_state: u8, pcs_chg_max_ac_power_available: f32, pcs_chg_pha_enable: bool, pcs_chg_pha_line_current_request: f32, pcs_chg_phb_enable: bool, pcs_chg_phb_line_current_request: f32, pcs_chg_phc_enable: bool, pcs_chg_phc_line_current_request: f32, pcs_chg_pwm_enable_line: bool, pcs_grid_config: u8, pcs_hv_charge_status: u8, pcs_hw_variant_type: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_pcs_charge_shutdown_request(pcs_charge_shutdown_request)?;
        res.set_pcs_chg_instant_ac_power_available(pcs_chg_instant_ac_power_available)?;
        res.set_pcs_chg_main_state(pcs_chg_main_state)?;
        res.set_pcs_chg_max_ac_power_available(pcs_chg_max_ac_power_available)?;
        res.set_pcs_chg_pha_enable(pcs_chg_pha_enable)?;
        res.set_pcs_chg_pha_line_current_request(pcs_chg_pha_line_current_request)?;
        res.set_pcs_chg_phb_enable(pcs_chg_phb_enable)?;
        res.set_pcs_chg_phb_line_current_request(pcs_chg_phb_line_current_request)?;
        res.set_pcs_chg_phc_enable(pcs_chg_phc_enable)?;
        res.set_pcs_chg_phc_line_current_request(pcs_chg_phc_line_current_request)?;
        res.set_pcs_chg_pwm_enable_line(pcs_chg_pwm_enable_line)?;
        res.set_pcs_grid_config(pcs_grid_config)?;
        res.set_pcs_hv_charge_status(pcs_hv_charge_status)?;
        res.set_pcs_hw_variant_type(pcs_hw_variant_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// PCS_chargeShutdownRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_charge_shutdown_request(&self) -> Id204pcsChgStatusPcsChargeShutdownRequest {
        match self.pcs_charge_shutdown_request_raw() {
            2 => Id204pcsChgStatusPcsChargeShutdownRequest::EmergencyShutdownRequested,
            1 => Id204pcsChgStatusPcsChargeShutdownRequest::GracefulShutdownRequested,
            0 => Id204pcsChgStatusPcsChargeShutdownRequest::NoShutdownRequested,
            x => Id204pcsChgStatusPcsChargeShutdownRequest::Other(x),
        }
    }
    
    /// Get raw value of PCS_chargeShutdownRequest
    ///
    /// - Start bit: 57
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_charge_shutdown_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[57..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCS_chargeShutdownRequest
    #[inline(always)]
    pub fn set_pcs_charge_shutdown_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        self.raw.view_bits_mut::<LocalBits>()[57..59].store_le(value);
        Ok(())
    }
    
    /// PCS_chgInstantAcPowerAvailable
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_instant_ac_power_available(&self) -> f32 {
        self.pcs_chg_instant_ac_power_available_raw()
    }
    
    /// Get raw value of PCS_chgInstantAcPowerAvailable
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_instant_ac_power_available_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_chgInstantAcPowerAvailable
    #[inline(always)]
    pub fn set_pcs_chg_instant_ac_power_available(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// PCS_chgMainState
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_main_state(&self) -> Id204pcsChgStatusPcsChgMainState {
        match self.pcs_chg_main_state_raw() {
            9 => Id204pcsChgStatusPcsChgMainState::PcsChgStateClearFaults,
            6 => Id204pcsChgStatusPcsChgMainState::PcsChgStateEnable,
            8 => Id204pcsChgStatusPcsChgMainState::PcsChgStateFaulted,
            1 => Id204pcsChgStatusPcsChgMainState::PcsChgStateIdle,
            0 => Id204pcsChgStatusPcsChgMainState::PcsChgStateInit,
            4 => Id204pcsChgStatusPcsChgMainState::PcsChgStateQualifyLineConfig,
            7 => Id204pcsChgStatusPcsChgMainState::PcsChgStateShutdown,
            2 => Id204pcsChgStatusPcsChgMainState::PcsChgStateStartup,
            5 => Id204pcsChgStatusPcsChgMainState::PcsChgStateSystemConfig,
            3 => Id204pcsChgStatusPcsChgMainState::PcsChgStateWaitForLineVoltage,
            x => Id204pcsChgStatusPcsChgMainState::Other(x),
        }
    }
    
    /// Get raw value of PCS_chgMainState
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_main_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCS_chgMainState
    #[inline(always)]
    pub fn set_pcs_chg_main_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..4].store_le(value);
        Ok(())
    }
    
    /// PCS_chgMaxAcPowerAvailable
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_max_ac_power_available(&self) -> f32 {
        self.pcs_chg_max_ac_power_available_raw()
    }
    
    /// Get raw value of PCS_chgMaxAcPowerAvailable
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_max_ac_power_available_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_chgMaxAcPowerAvailable
    #[inline(always)]
    pub fn set_pcs_chg_max_ac_power_available(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPHAEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_pha_enable(&self) -> bool {
        self.pcs_chg_pha_enable_raw()
    }
    
    /// Get raw value of PCS_chgPHAEnable
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_pha_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PCS_chgPHAEnable
    #[inline(always)]
    pub fn set_pcs_chg_pha_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPHALineCurrentRequest
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_pha_line_current_request(&self) -> f32 {
        self.pcs_chg_pha_line_current_request_raw()
    }
    
    /// Get raw value of PCS_chgPHALineCurrentRequest
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_pha_line_current_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_chgPHALineCurrentRequest
    #[inline(always)]
    pub fn set_pcs_chg_pha_line_current_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPHBEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_phb_enable(&self) -> bool {
        self.pcs_chg_phb_enable_raw()
    }
    
    /// Get raw value of PCS_chgPHBEnable
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_phb_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PCS_chgPHBEnable
    #[inline(always)]
    pub fn set_pcs_chg_phb_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPHBLineCurrentRequest
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_phb_line_current_request(&self) -> f32 {
        self.pcs_chg_phb_line_current_request_raw()
    }
    
    /// Get raw value of PCS_chgPHBLineCurrentRequest
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_phb_line_current_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_chgPHBLineCurrentRequest
    #[inline(always)]
    pub fn set_pcs_chg_phb_line_current_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPHCEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_phc_enable(&self) -> bool {
        self.pcs_chg_phc_enable_raw()
    }
    
    /// Get raw value of PCS_chgPHCEnable
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_phc_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PCS_chgPHCEnable
    #[inline(always)]
    pub fn set_pcs_chg_phc_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPHCLineCurrentRequest
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_phc_line_current_request(&self) -> f32 {
        self.pcs_chg_phc_line_current_request_raw()
    }
    
    /// Get raw value of PCS_chgPHCLineCurrentRequest
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_phc_line_current_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_chgPHCLineCurrentRequest
    #[inline(always)]
    pub fn set_pcs_chg_phc_line_current_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// PCS_chgPwmEnableLine
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_chg_pwm_enable_line(&self) -> bool {
        self.pcs_chg_pwm_enable_line_raw()
    }
    
    /// Get raw value of PCS_chgPwmEnableLine
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_chg_pwm_enable_line_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PCS_chgPwmEnableLine
    #[inline(always)]
    pub fn set_pcs_chg_pwm_enable_line(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[56..57].store_le(value);
        Ok(())
    }
    
    /// PCS_gridConfig
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_grid_config(&self) -> Id204pcsChgStatusPcsGridConfig {
        match self.pcs_grid_config_raw() {
            1 => Id204pcsChgStatusPcsGridConfig::GridConfigSinglePhase,
            0 => Id204pcsChgStatusPcsGridConfig::GridConfigSna,
            2 => Id204pcsChgStatusPcsGridConfig::GridConfigThreePhase,
            3 => Id204pcsChgStatusPcsGridConfig::GridConfigThreePhaseDelta,
            x => Id204pcsChgStatusPcsGridConfig::Other(x),
        }
    }
    
    /// Get raw value of PCS_gridConfig
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_grid_config_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCS_gridConfig
    #[inline(always)]
    pub fn set_pcs_grid_config(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// PCS_hvChargeStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_hv_charge_status(&self) -> Id204pcsChgStatusPcsHvChargeStatus {
        match self.pcs_hv_charge_status_raw() {
            1 => Id204pcsChgStatusPcsHvChargeStatus::PcsChargeBlocked,
            2 => Id204pcsChgStatusPcsHvChargeStatus::PcsChargeEnabled,
            3 => Id204pcsChgStatusPcsHvChargeStatus::PcsChargeFaulted,
            0 => Id204pcsChgStatusPcsHvChargeStatus::PcsChargeStandby,
            x => Id204pcsChgStatusPcsHvChargeStatus::Other(x),
        }
    }
    
    /// Get raw value of PCS_hvChargeStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_hv_charge_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCS_hvChargeStatus
    #[inline(always)]
    pub fn set_pcs_hv_charge_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// PCS_hwVariantType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_hw_variant_type(&self) -> Id204pcsChgStatusPcsHwVariantType {
        match self.pcs_hw_variant_type_raw() {
            1 => Id204pcsChgStatusPcsHwVariantType::Pcs32aSinglePhaseVariant,
            0 => Id204pcsChgStatusPcsHwVariantType::Pcs48aSinglePhaseVariant,
            3 => Id204pcsChgStatusPcsHwVariantType::PcsHwVariantTypeSna,
            2 => Id204pcsChgStatusPcsHwVariantType::PcsThreePhasesVariant,
            x => Id204pcsChgStatusPcsHwVariantType::Other(x),
        }
    }
    
    /// Get raw value of PCS_hwVariantType
    ///
    /// - Start bit: 59
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_hw_variant_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[59..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCS_hwVariantType
    #[inline(always)]
    pub fn set_pcs_hw_variant_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 516 }); }
        self.raw.view_bits_mut::<LocalBits>()[59..61].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id204pcsChgStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id204pcsChgStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let pcs_charge_shutdown_request = u.int_in_range(0..=2)?;
        let pcs_chg_instant_ac_power_available = 0_f32;
        let pcs_chg_main_state = u.int_in_range(0..=9)?;
        let pcs_chg_max_ac_power_available = 0_f32;
        let pcs_chg_pha_enable = u.int_in_range(0..=1)? == 1;
        let pcs_chg_pha_line_current_request = 0_f32;
        let pcs_chg_phb_enable = u.int_in_range(0..=1)? == 1;
        let pcs_chg_phb_line_current_request = 0_f32;
        let pcs_chg_phc_enable = u.int_in_range(0..=1)? == 1;
        let pcs_chg_phc_line_current_request = 0_f32;
        let pcs_chg_pwm_enable_line = u.int_in_range(0..=1)? == 1;
        let pcs_grid_config = u.int_in_range(0..=3)?;
        let pcs_hv_charge_status = u.int_in_range(0..=3)?;
        let pcs_hw_variant_type = u.int_in_range(0..=3)?;
        Id204pcsChgStatus::new(pcs_charge_shutdown_request,pcs_chg_instant_ac_power_available,pcs_chg_main_state,pcs_chg_max_ac_power_available,pcs_chg_pha_enable,pcs_chg_pha_line_current_request,pcs_chg_phb_enable,pcs_chg_phb_line_current_request,pcs_chg_phc_enable,pcs_chg_phc_line_current_request,pcs_chg_pwm_enable_line,pcs_grid_config,pcs_hv_charge_status,pcs_hw_variant_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for PCS_chargeShutdownRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id204pcsChgStatusPcsChargeShutdownRequest {
    EmergencyShutdownRequested,
    GracefulShutdownRequested,
    NoShutdownRequested,
    Other(u8),
}
/// Defined values for PCS_chgMainState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id204pcsChgStatusPcsChgMainState {
    PcsChgStateClearFaults,
    PcsChgStateEnable,
    PcsChgStateFaulted,
    PcsChgStateIdle,
    PcsChgStateInit,
    PcsChgStateQualifyLineConfig,
    PcsChgStateShutdown,
    PcsChgStateStartup,
    PcsChgStateSystemConfig,
    PcsChgStateWaitForLineVoltage,
    Other(u8),
}
/// Defined values for PCS_gridConfig
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id204pcsChgStatusPcsGridConfig {
    GridConfigSinglePhase,
    GridConfigSna,
    GridConfigThreePhase,
    GridConfigThreePhaseDelta,
    Other(u8),
}
/// Defined values for PCS_hvChargeStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id204pcsChgStatusPcsHvChargeStatus {
    PcsChargeBlocked,
    PcsChargeEnabled,
    PcsChargeFaulted,
    PcsChargeStandby,
    Other(u8),
}
/// Defined values for PCS_hwVariantType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id204pcsChgStatusPcsHwVariantType {
    Pcs32aSinglePhaseVariant,
    Pcs48aSinglePhaseVariant,
    PcsHwVariantTypeSna,
    PcsThreePhasesVariant,
    Other(u8),
}

/// ID22AHVP_pcsControl
///
/// - ID: 554 (0x22a)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id22ahvpPcsControl {
    raw: [u8; 4],
}

impl Id22ahvpPcsControl {
    pub const MESSAGE_ID: u32 = 554;
    
    /// Construct new ID22AHVP_pcsControl from values
    pub fn new(hvp_dc_link_voltage_filtered: i16, hvp_dc_link_voltage_request: f32, hvp_pcs_charge_hw_enabled: bool, hvp_pcs_control_request: u8, hvp_pcs_dcdc_hw_enabled: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_hvp_dc_link_voltage_filtered(hvp_dc_link_voltage_filtered)?;
        res.set_hvp_dc_link_voltage_request(hvp_dc_link_voltage_request)?;
        res.set_hvp_pcs_charge_hw_enabled(hvp_pcs_charge_hw_enabled)?;
        res.set_hvp_pcs_control_request(hvp_pcs_control_request)?;
        res.set_hvp_pcs_dcdc_hw_enabled(hvp_pcs_dcdc_hw_enabled)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// HVP_dcLinkVoltageFiltered
    ///
    /// - Min: -550
    /// - Max: 550
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_dc_link_voltage_filtered(&self) -> Id22ahvpPcsControlHvpDcLinkVoltageFiltered {
        match self.hvp_dc_link_voltage_filtered_raw() {
            550 => Id22ahvpPcsControlHvpDcLinkVoltageFiltered::Sna,
            x => Id22ahvpPcsControlHvpDcLinkVoltageFiltered::Other(x),
        }
    }
    
    /// Get raw value of HVP_dcLinkVoltageFiltered
    ///
    /// - Start bit: 20
    /// - Signal size: 11 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn hvp_dc_link_voltage_filtered_raw(&self) -> i16 {
        let signal = self.raw.view_bits::<LocalBits>()[20..31].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of HVP_dcLinkVoltageFiltered
    #[inline(always)]
    pub fn set_hvp_dc_link_voltage_filtered(&mut self, value: i16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -550_i16 || 550_i16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 554 }); }
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[20..31].store_le(value);
        Ok(())
    }
    
    /// HVP_dcLinkVoltageRequest
    ///
    /// - Min: -550
    /// - Max: 550
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_dc_link_voltage_request(&self) -> f32 {
        self.hvp_dc_link_voltage_request_raw()
    }
    
    /// Get raw value of HVP_dcLinkVoltageRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn hvp_dc_link_voltage_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of HVP_dcLinkVoltageRequest
    #[inline(always)]
    pub fn set_hvp_dc_link_voltage_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -550_f32 || 550_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 554 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[0..16].store_le(value);
        Ok(())
    }
    
    /// HVP_pcsChargeHwEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pcs_charge_hw_enabled(&self) -> bool {
        self.hvp_pcs_charge_hw_enabled_raw()
    }
    
    /// Get raw value of HVP_pcsChargeHwEnabled
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pcs_charge_hw_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_pcsChargeHwEnabled
    #[inline(always)]
    pub fn set_hvp_pcs_charge_hw_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// HVP_pcsControlRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pcs_control_request(&self) -> Id22ahvpPcsControlHvpPcsControlRequest {
        match self.hvp_pcs_control_request_raw() {
            3 => Id22ahvpPcsControlHvpPcsControlRequest::Discharge,
            2 => Id22ahvpPcsControlHvpPcsControlRequest::Precharge,
            0 => Id22ahvpPcsControlHvpPcsControlRequest::Shutdown,
            1 => Id22ahvpPcsControlHvpPcsControlRequest::Support,
            x => Id22ahvpPcsControlHvpPcsControlRequest::Other(x),
        }
    }
    
    /// Get raw value of HVP_pcsControlRequest
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pcs_control_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HVP_pcsControlRequest
    #[inline(always)]
    pub fn set_hvp_pcs_control_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 554 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// HVP_pcsDcdcHwEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn hvp_pcs_dcdc_hw_enabled(&self) -> bool {
        self.hvp_pcs_dcdc_hw_enabled_raw()
    }
    
    /// Get raw value of HVP_pcsDcdcHwEnabled
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hvp_pcs_dcdc_hw_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HVP_pcsDcdcHwEnabled
    #[inline(always)]
    pub fn set_hvp_pcs_dcdc_hw_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id22ahvpPcsControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id22ahvpPcsControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hvp_dc_link_voltage_filtered = u.int_in_range(-550..=550)?;
        let hvp_dc_link_voltage_request = -550_f32;
        let hvp_pcs_charge_hw_enabled = u.int_in_range(0..=1)? == 1;
        let hvp_pcs_control_request = u.int_in_range(0..=3)?;
        let hvp_pcs_dcdc_hw_enabled = u.int_in_range(0..=1)? == 1;
        Id22ahvpPcsControl::new(hvp_dc_link_voltage_filtered,hvp_dc_link_voltage_request,hvp_pcs_charge_hw_enabled,hvp_pcs_control_request,hvp_pcs_dcdc_hw_enabled).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for HVP_dcLinkVoltageFiltered
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22ahvpPcsControlHvpDcLinkVoltageFiltered {
    Sna,
    Other(i16),
}
/// Defined values for HVP_pcsControlRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22ahvpPcsControlHvpPcsControlRequest {
    Discharge,
    Precharge,
    Shutdown,
    Support,
    Other(u8),
}

/// ID232BMS_contactorRequest
///
/// - ID: 562 (0x232)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id232bmsContactorRequest {
    raw: [u8; 8],
}

impl Id232bmsContactorRequest {
    pub const MESSAGE_ID: u32 = 562;
    
    /// Construct new ID232BMS_contactorRequest from values
    pub fn new(bms_ens_should_be_active_for_drive: bool, bms_fc_contactor_request: u8, bms_fc_link_ok_to_energize_request: u8, bms_gpo_has_completed: bool, bms_internal_hvil_sense_v: f32, bms_pack_contactor_request: u8, bms_pcs_pwm_disable: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_bms_ens_should_be_active_for_drive(bms_ens_should_be_active_for_drive)?;
        res.set_bms_fc_contactor_request(bms_fc_contactor_request)?;
        res.set_bms_fc_link_ok_to_energize_request(bms_fc_link_ok_to_energize_request)?;
        res.set_bms_gpo_has_completed(bms_gpo_has_completed)?;
        res.set_bms_internal_hvil_sense_v(bms_internal_hvil_sense_v)?;
        res.set_bms_pack_contactor_request(bms_pack_contactor_request)?;
        res.set_bms_pcs_pwm_disable(bms_pcs_pwm_disable)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// BMS_ensShouldBeActiveForDrive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_ens_should_be_active_for_drive(&self) -> bool {
        self.bms_ens_should_be_active_for_drive_raw()
    }
    
    /// Get raw value of BMS_ensShouldBeActiveForDrive
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_ens_should_be_active_for_drive_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_ensShouldBeActiveForDrive
    #[inline(always)]
    pub fn set_bms_ens_should_be_active_for_drive(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// BMS_fcContactorRequest
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_fc_contactor_request(&self) -> Id232bmsContactorRequestBmsFcContactorRequest {
        match self.bms_fc_contactor_request_raw() {
            1 => Id232bmsContactorRequestBmsFcContactorRequest::SetRequestClose,
            4 => Id232bmsContactorRequestBmsFcContactorRequest::SetRequestCloseNegativeOnly,
            5 => Id232bmsContactorRequestBmsFcContactorRequest::SetRequestClosePositiveOnly,
            2 => Id232bmsContactorRequestBmsFcContactorRequest::SetRequestOpen,
            3 => Id232bmsContactorRequestBmsFcContactorRequest::SetRequestOpenImmediately,
            0 => Id232bmsContactorRequestBmsFcContactorRequest::SetRequestSna,
            x => Id232bmsContactorRequestBmsFcContactorRequest::Other(x),
        }
    }
    
    /// Get raw value of BMS_fcContactorRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_fc_contactor_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_fcContactorRequest
    #[inline(always)]
    pub fn set_bms_fc_contactor_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 562 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// BMS_fcLinkOkToEnergizeRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_fc_link_ok_to_energize_request(&self) -> Id232bmsContactorRequestBmsFcLinkOkToEnergizeRequest {
        match self.bms_fc_link_ok_to_energize_request_raw() {
            1 => Id232bmsContactorRequestBmsFcLinkOkToEnergizeRequest::FcLinkEnergyAc,
            2 => Id232bmsContactorRequestBmsFcLinkOkToEnergizeRequest::FcLinkEnergyDc,
            0 => Id232bmsContactorRequestBmsFcLinkOkToEnergizeRequest::FcLinkEnergyNone,
            x => Id232bmsContactorRequestBmsFcLinkOkToEnergizeRequest::Other(x),
        }
    }
    
    /// Get raw value of BMS_fcLinkOkToEnergizeRequest
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_fc_link_ok_to_energize_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_fcLinkOkToEnergizeRequest
    #[inline(always)]
    pub fn set_bms_fc_link_ok_to_energize_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 562 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// BMS_gpoHasCompleted
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_gpo_has_completed(&self) -> bool {
        self.bms_gpo_has_completed_raw()
    }
    
    /// Get raw value of BMS_gpoHasCompleted
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_gpo_has_completed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_gpoHasCompleted
    #[inline(always)]
    pub fn set_bms_gpo_has_completed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// BMS_internalHvilSenseV
    ///
    /// - Min: 0
    /// - Max: 65.534
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_internal_hvil_sense_v(&self) -> Id232bmsContactorRequestBmsInternalHvilSenseV {
        match self.bms_internal_hvil_sense_v_raw() {
            65535 => Id232bmsContactorRequestBmsInternalHvilSenseV::Sna,
            x => Id232bmsContactorRequestBmsInternalHvilSenseV::Other(x),
        }
    }
    
    /// Get raw value of BMS_internalHvilSenseV
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_internal_hvil_sense_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BMS_internalHvilSenseV
    #[inline(always)]
    pub fn set_bms_internal_hvil_sense_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 65.534_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 562 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// BMS_packContactorRequest
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_pack_contactor_request(&self) -> Id232bmsContactorRequestBmsPackContactorRequest {
        match self.bms_pack_contactor_request_raw() {
            1 => Id232bmsContactorRequestBmsPackContactorRequest::SetRequestClose,
            4 => Id232bmsContactorRequestBmsPackContactorRequest::SetRequestCloseNegativeOnly,
            5 => Id232bmsContactorRequestBmsPackContactorRequest::SetRequestClosePositiveOnly,
            2 => Id232bmsContactorRequestBmsPackContactorRequest::SetRequestOpen,
            3 => Id232bmsContactorRequestBmsPackContactorRequest::SetRequestOpenImmediately,
            0 => Id232bmsContactorRequestBmsPackContactorRequest::SetRequestSna,
            x => Id232bmsContactorRequestBmsPackContactorRequest::Other(x),
        }
    }
    
    /// Get raw value of BMS_packContactorRequest
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_pack_contactor_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_packContactorRequest
    #[inline(always)]
    pub fn set_bms_pack_contactor_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 562 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// BMS_pcsPwmDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_pcs_pwm_disable(&self) -> bool {
        self.bms_pcs_pwm_disable_raw()
    }
    
    /// Get raw value of BMS_pcsPwmDisable
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_pcs_pwm_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_pcsPwmDisable
    #[inline(always)]
    pub fn set_bms_pcs_pwm_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id232bmsContactorRequest {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id232bmsContactorRequest
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let bms_ens_should_be_active_for_drive = u.int_in_range(0..=1)? == 1;
        let bms_fc_contactor_request = u.int_in_range(0..=5)?;
        let bms_fc_link_ok_to_energize_request = u.int_in_range(0..=2)?;
        let bms_gpo_has_completed = u.int_in_range(0..=1)? == 1;
        let bms_internal_hvil_sense_v = 0_f32;
        let bms_pack_contactor_request = u.int_in_range(0..=5)?;
        let bms_pcs_pwm_disable = u.int_in_range(0..=1)? == 1;
        Id232bmsContactorRequest::new(bms_ens_should_be_active_for_drive,bms_fc_contactor_request,bms_fc_link_ok_to_energize_request,bms_gpo_has_completed,bms_internal_hvil_sense_v,bms_pack_contactor_request,bms_pcs_pwm_disable).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for BMS_fcContactorRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id232bmsContactorRequestBmsFcContactorRequest {
    SetRequestClose,
    SetRequestCloseNegativeOnly,
    SetRequestClosePositiveOnly,
    SetRequestOpen,
    SetRequestOpenImmediately,
    SetRequestSna,
    Other(u8),
}
/// Defined values for BMS_fcLinkOkToEnergizeRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id232bmsContactorRequestBmsFcLinkOkToEnergizeRequest {
    FcLinkEnergyAc,
    FcLinkEnergyDc,
    FcLinkEnergyNone,
    Other(u8),
}
/// Defined values for BMS_internalHvilSenseV
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id232bmsContactorRequestBmsInternalHvilSenseV {
    Sna,
    Other(f32),
}
/// Defined values for BMS_packContactorRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id232bmsContactorRequestBmsPackContactorRequest {
    SetRequestClose,
    SetRequestCloseNegativeOnly,
    SetRequestClosePositiveOnly,
    SetRequestOpen,
    SetRequestOpenImmediately,
    SetRequestSna,
    Other(u8),
}

/// ID273UI_vehicleControl
///
/// - ID: 627 (0x273)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id273uiVehicleControl {
    raw: [u8; 8],
}

impl Id273uiVehicleControl {
    pub const MESSAGE_ID: u32 = 627;
    
    /// Construct new ID273UI_vehicleControl from values
    pub fn new(ui_accessory_power_request: bool, ui_alarm_enabled: bool, ui_ambient_lighting_enabled: bool, ui_auto_fold_mirrors_on: bool, ui_auto_high_beam_enabled: bool, ui_child_door_lock_on: bool, ui_display_brightness_level: f32, ui_dome_light_switch: u8, ui_drive_state_request: bool, ui_front_fog_switch: bool, ui_front_left_seat_heat_req: u8, ui_front_right_seat_heat_req: u8, ui_frunk_request: bool, ui_global_unlock_on: bool, ui_honk_horn: bool, ui_intrusion_sensor_on: bool, ui_lock_request: u8, ui_mirror_dip_on_reverse: bool, ui_mirror_fold_request: u8, ui_mirror_heat_request: bool, ui_power_off: bool, ui_rear_center_seat_heat_req: u8, ui_rear_fog_switch: bool, ui_rear_left_seat_heat_req: u8, ui_rear_right_seat_heat_req: u8, ui_rear_window_lockout: bool, ui_remote_closure_request: u8, ui_remote_start_request: u8, ui_see_you_home_lighting_on: bool, ui_steering_backlight_enabled: bool, ui_steering_button_mode: u8, ui_stop12v_support: bool, ui_summon_active: bool, ui_unlock_on_park: bool, ui_walk_away_lock: bool, ui_walk_up_unlock: bool, ui_wiper_mode: u8, ui_wiper_request: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_accessory_power_request(ui_accessory_power_request)?;
        res.set_ui_alarm_enabled(ui_alarm_enabled)?;
        res.set_ui_ambient_lighting_enabled(ui_ambient_lighting_enabled)?;
        res.set_ui_auto_fold_mirrors_on(ui_auto_fold_mirrors_on)?;
        res.set_ui_auto_high_beam_enabled(ui_auto_high_beam_enabled)?;
        res.set_ui_child_door_lock_on(ui_child_door_lock_on)?;
        res.set_ui_display_brightness_level(ui_display_brightness_level)?;
        res.set_ui_dome_light_switch(ui_dome_light_switch)?;
        res.set_ui_drive_state_request(ui_drive_state_request)?;
        res.set_ui_front_fog_switch(ui_front_fog_switch)?;
        res.set_ui_front_left_seat_heat_req(ui_front_left_seat_heat_req)?;
        res.set_ui_front_right_seat_heat_req(ui_front_right_seat_heat_req)?;
        res.set_ui_frunk_request(ui_frunk_request)?;
        res.set_ui_global_unlock_on(ui_global_unlock_on)?;
        res.set_ui_honk_horn(ui_honk_horn)?;
        res.set_ui_intrusion_sensor_on(ui_intrusion_sensor_on)?;
        res.set_ui_lock_request(ui_lock_request)?;
        res.set_ui_mirror_dip_on_reverse(ui_mirror_dip_on_reverse)?;
        res.set_ui_mirror_fold_request(ui_mirror_fold_request)?;
        res.set_ui_mirror_heat_request(ui_mirror_heat_request)?;
        res.set_ui_power_off(ui_power_off)?;
        res.set_ui_rear_center_seat_heat_req(ui_rear_center_seat_heat_req)?;
        res.set_ui_rear_fog_switch(ui_rear_fog_switch)?;
        res.set_ui_rear_left_seat_heat_req(ui_rear_left_seat_heat_req)?;
        res.set_ui_rear_right_seat_heat_req(ui_rear_right_seat_heat_req)?;
        res.set_ui_rear_window_lockout(ui_rear_window_lockout)?;
        res.set_ui_remote_closure_request(ui_remote_closure_request)?;
        res.set_ui_remote_start_request(ui_remote_start_request)?;
        res.set_ui_see_you_home_lighting_on(ui_see_you_home_lighting_on)?;
        res.set_ui_steering_backlight_enabled(ui_steering_backlight_enabled)?;
        res.set_ui_steering_button_mode(ui_steering_button_mode)?;
        res.set_ui_stop12v_support(ui_stop12v_support)?;
        res.set_ui_summon_active(ui_summon_active)?;
        res.set_ui_unlock_on_park(ui_unlock_on_park)?;
        res.set_ui_walk_away_lock(ui_walk_away_lock)?;
        res.set_ui_walk_up_unlock(ui_walk_up_unlock)?;
        res.set_ui_wiper_mode(ui_wiper_mode)?;
        res.set_ui_wiper_request(ui_wiper_request)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_accessoryPowerRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_accessory_power_request(&self) -> bool {
        self.ui_accessory_power_request_raw()
    }
    
    /// Get raw value of UI_accessoryPowerRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_accessory_power_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_accessoryPowerRequest
    #[inline(always)]
    pub fn set_ui_accessory_power_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_alarmEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_alarm_enabled(&self) -> bool {
        self.ui_alarm_enabled_raw()
    }
    
    /// Get raw value of UI_alarmEnabled
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_alarm_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_alarmEnabled
    #[inline(always)]
    pub fn set_ui_alarm_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// UI_ambientLightingEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ambient_lighting_enabled(&self) -> bool {
        self.ui_ambient_lighting_enabled_raw()
    }
    
    /// Get raw value of UI_ambientLightingEnabled
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ambient_lighting_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_ambientLightingEnabled
    #[inline(always)]
    pub fn set_ui_ambient_lighting_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// UI_autoFoldMirrorsOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_auto_fold_mirrors_on(&self) -> bool {
        self.ui_auto_fold_mirrors_on_raw()
    }
    
    /// Get raw value of UI_autoFoldMirrorsOn
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_auto_fold_mirrors_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_autoFoldMirrorsOn
    #[inline(always)]
    pub fn set_ui_auto_fold_mirrors_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[52..53].store_le(value);
        Ok(())
    }
    
    /// UI_autoHighBeamEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_auto_high_beam_enabled(&self) -> bool {
        self.ui_auto_high_beam_enabled_raw()
    }
    
    /// Get raw value of UI_autoHighBeamEnabled
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_auto_high_beam_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_autoHighBeamEnabled
    #[inline(always)]
    pub fn set_ui_auto_high_beam_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// UI_childDoorLockOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_child_door_lock_on(&self) -> bool {
        self.ui_child_door_lock_on_raw()
    }
    
    /// Get raw value of UI_childDoorLockOn
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_child_door_lock_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_childDoorLockOn
    #[inline(always)]
    pub fn set_ui_child_door_lock_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// UI_displayBrightnessLevel
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_display_brightness_level(&self) -> Id273uiVehicleControlUiDisplayBrightnessLevel {
        match self.ui_display_brightness_level_raw() {
            255 => Id273uiVehicleControlUiDisplayBrightnessLevel::Sna,
            x => Id273uiVehicleControlUiDisplayBrightnessLevel::Other(x),
        }
    }
    
    /// Get raw value of UI_displayBrightnessLevel
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_display_brightness_level_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_displayBrightnessLevel
    #[inline(always)]
    pub fn set_ui_display_brightness_level(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// UI_domeLightSwitch
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_dome_light_switch(&self) -> Id273uiVehicleControlUiDomeLightSwitch {
        match self.ui_dome_light_switch_raw() {
            2 => Id273uiVehicleControlUiDomeLightSwitch::DomeLightSwitchAuto,
            0 => Id273uiVehicleControlUiDomeLightSwitch::DomeLightSwitchOff,
            1 => Id273uiVehicleControlUiDomeLightSwitch::DomeLightSwitchOn,
            x => Id273uiVehicleControlUiDomeLightSwitch::Other(x),
        }
    }
    
    /// Get raw value of UI_domeLightSwitch
    ///
    /// - Start bit: 59
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_dome_light_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[59..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_domeLightSwitch
    #[inline(always)]
    pub fn set_ui_dome_light_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[59..61].store_le(value);
        Ok(())
    }
    
    /// UI_driveStateRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_drive_state_request(&self) -> Id273uiVehicleControlUiDriveStateRequest {
        match self.ui_drive_state_request_raw() {
            false => Id273uiVehicleControlUiDriveStateRequest::DriveStateReqIdle,
            true => Id273uiVehicleControlUiDriveStateRequest::DriveStateReqStart,
            x => Id273uiVehicleControlUiDriveStateRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_driveStateRequest
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_drive_state_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_driveStateRequest
    #[inline(always)]
    pub fn set_ui_drive_state_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// UI_frontFogSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_front_fog_switch(&self) -> bool {
        self.ui_front_fog_switch_raw()
    }
    
    /// Get raw value of UI_frontFogSwitch
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_front_fog_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_frontFogSwitch
    #[inline(always)]
    pub fn set_ui_front_fog_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_frontLeftSeatHeatReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_front_left_seat_heat_req(&self) -> Id273uiVehicleControlUiFrontLeftSeatHeatReq {
        match self.ui_front_left_seat_heat_req_raw() {
            1 => Id273uiVehicleControlUiFrontLeftSeatHeatReq::HeaterRequestLevel1,
            2 => Id273uiVehicleControlUiFrontLeftSeatHeatReq::HeaterRequestLevel2,
            3 => Id273uiVehicleControlUiFrontLeftSeatHeatReq::HeaterRequestLevel3,
            0 => Id273uiVehicleControlUiFrontLeftSeatHeatReq::HeaterRequestOff,
            x => Id273uiVehicleControlUiFrontLeftSeatHeatReq::Other(x),
        }
    }
    
    /// Get raw value of UI_frontLeftSeatHeatReq
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_front_left_seat_heat_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_frontLeftSeatHeatReq
    #[inline(always)]
    pub fn set_ui_front_left_seat_heat_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..44].store_le(value);
        Ok(())
    }
    
    /// UI_frontRightSeatHeatReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_front_right_seat_heat_req(&self) -> Id273uiVehicleControlUiFrontRightSeatHeatReq {
        match self.ui_front_right_seat_heat_req_raw() {
            1 => Id273uiVehicleControlUiFrontRightSeatHeatReq::HeaterRequestLevel1,
            2 => Id273uiVehicleControlUiFrontRightSeatHeatReq::HeaterRequestLevel2,
            3 => Id273uiVehicleControlUiFrontRightSeatHeatReq::HeaterRequestLevel3,
            0 => Id273uiVehicleControlUiFrontRightSeatHeatReq::HeaterRequestOff,
            x => Id273uiVehicleControlUiFrontRightSeatHeatReq::Other(x),
        }
    }
    
    /// Get raw value of UI_frontRightSeatHeatReq
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_front_right_seat_heat_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_frontRightSeatHeatReq
    #[inline(always)]
    pub fn set_ui_front_right_seat_heat_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
    /// UI_frunkRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_frunk_request(&self) -> bool {
        self.ui_frunk_request_raw()
    }
    
    /// Get raw value of UI_frunkRequest
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_frunk_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_frunkRequest
    #[inline(always)]
    pub fn set_ui_frunk_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// UI_globalUnlockOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_global_unlock_on(&self) -> bool {
        self.ui_global_unlock_on_raw()
    }
    
    /// Get raw value of UI_globalUnlockOn
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_global_unlock_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_globalUnlockOn
    #[inline(always)]
    pub fn set_ui_global_unlock_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// UI_honkHorn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_honk_horn(&self) -> bool {
        self.ui_honk_horn_raw()
    }
    
    /// Get raw value of UI_honkHorn
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_honk_horn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_honkHorn
    #[inline(always)]
    pub fn set_ui_honk_horn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// UI_intrusionSensorOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_intrusion_sensor_on(&self) -> bool {
        self.ui_intrusion_sensor_on_raw()
    }
    
    /// Get raw value of UI_intrusionSensorOn
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_intrusion_sensor_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_intrusionSensorOn
    #[inline(always)]
    pub fn set_ui_intrusion_sensor_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[21..22].store_le(value);
        Ok(())
    }
    
    /// UI_lockRequest
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_lock_request(&self) -> Id273uiVehicleControlUiLockRequest {
        match self.ui_lock_request_raw() {
            0 => Id273uiVehicleControlUiLockRequest::UiLockRequestIdle,
            1 => Id273uiVehicleControlUiLockRequest::UiLockRequestLock,
            4 => Id273uiVehicleControlUiLockRequest::UiLockRequestRemoteLock,
            3 => Id273uiVehicleControlUiLockRequest::UiLockRequestRemoteUnlock,
            7 => Id273uiVehicleControlUiLockRequest::UiLockRequestSna,
            2 => Id273uiVehicleControlUiLockRequest::UiLockRequestUnlock,
            x => Id273uiVehicleControlUiLockRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_lockRequest
    ///
    /// - Start bit: 17
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_lock_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[17..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_lockRequest
    #[inline(always)]
    pub fn set_ui_lock_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[17..20].store_le(value);
        Ok(())
    }
    
    /// UI_mirrorDipOnReverse
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_mirror_dip_on_reverse(&self) -> bool {
        self.ui_mirror_dip_on_reverse_raw()
    }
    
    /// Get raw value of UI_mirrorDipOnReverse
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_mirror_dip_on_reverse_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_mirrorDipOnReverse
    #[inline(always)]
    pub fn set_ui_mirror_dip_on_reverse(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[53..54].store_le(value);
        Ok(())
    }
    
    /// UI_mirrorFoldRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_mirror_fold_request(&self) -> Id273uiVehicleControlUiMirrorFoldRequest {
        match self.ui_mirror_fold_request_raw() {
            0 => Id273uiVehicleControlUiMirrorFoldRequest::MirrorFoldRequestIdle,
            2 => Id273uiVehicleControlUiMirrorFoldRequest::MirrorFoldRequestPresent,
            1 => Id273uiVehicleControlUiMirrorFoldRequest::MirrorFoldRequestRetract,
            3 => Id273uiVehicleControlUiMirrorFoldRequest::MirrorFoldRequestSna,
            x => Id273uiVehicleControlUiMirrorFoldRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_mirrorFoldRequest
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_mirror_fold_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_mirrorFoldRequest
    #[inline(always)]
    pub fn set_ui_mirror_fold_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// UI_mirrorHeatRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_mirror_heat_request(&self) -> bool {
        self.ui_mirror_heat_request_raw()
    }
    
    /// Get raw value of UI_mirrorHeatRequest
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_mirror_heat_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_mirrorHeatRequest
    #[inline(always)]
    pub fn set_ui_mirror_heat_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// UI_powerOff
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_power_off(&self) -> bool {
        self.ui_power_off_raw()
    }
    
    /// Get raw value of UI_powerOff
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_power_off_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_powerOff
    #[inline(always)]
    pub fn set_ui_power_off(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// UI_rearCenterSeatHeatReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_rear_center_seat_heat_req(&self) -> Id273uiVehicleControlUiRearCenterSeatHeatReq {
        match self.ui_rear_center_seat_heat_req_raw() {
            1 => Id273uiVehicleControlUiRearCenterSeatHeatReq::HeaterRequestLevel1,
            2 => Id273uiVehicleControlUiRearCenterSeatHeatReq::HeaterRequestLevel2,
            3 => Id273uiVehicleControlUiRearCenterSeatHeatReq::HeaterRequestLevel3,
            0 => Id273uiVehicleControlUiRearCenterSeatHeatReq::HeaterRequestOff,
            x => Id273uiVehicleControlUiRearCenterSeatHeatReq::Other(x),
        }
    }
    
    /// Get raw value of UI_rearCenterSeatHeatReq
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_rear_center_seat_heat_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_rearCenterSeatHeatReq
    #[inline(always)]
    pub fn set_ui_rear_center_seat_heat_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// UI_rearFogSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_rear_fog_switch(&self) -> bool {
        self.ui_rear_fog_switch_raw()
    }
    
    /// Get raw value of UI_rearFogSwitch
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_rear_fog_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rearFogSwitch
    #[inline(always)]
    pub fn set_ui_rear_fog_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// UI_rearLeftSeatHeatReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_rear_left_seat_heat_req(&self) -> Id273uiVehicleControlUiRearLeftSeatHeatReq {
        match self.ui_rear_left_seat_heat_req_raw() {
            1 => Id273uiVehicleControlUiRearLeftSeatHeatReq::HeaterRequestLevel1,
            2 => Id273uiVehicleControlUiRearLeftSeatHeatReq::HeaterRequestLevel2,
            3 => Id273uiVehicleControlUiRearLeftSeatHeatReq::HeaterRequestLevel3,
            0 => Id273uiVehicleControlUiRearLeftSeatHeatReq::HeaterRequestOff,
            x => Id273uiVehicleControlUiRearLeftSeatHeatReq::Other(x),
        }
    }
    
    /// Get raw value of UI_rearLeftSeatHeatReq
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_rear_left_seat_heat_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_rearLeftSeatHeatReq
    #[inline(always)]
    pub fn set_ui_rear_left_seat_heat_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..48].store_le(value);
        Ok(())
    }
    
    /// UI_rearRightSeatHeatReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_rear_right_seat_heat_req(&self) -> Id273uiVehicleControlUiRearRightSeatHeatReq {
        match self.ui_rear_right_seat_heat_req_raw() {
            1 => Id273uiVehicleControlUiRearRightSeatHeatReq::HeaterRequestLevel1,
            2 => Id273uiVehicleControlUiRearRightSeatHeatReq::HeaterRequestLevel2,
            3 => Id273uiVehicleControlUiRearRightSeatHeatReq::HeaterRequestLevel3,
            0 => Id273uiVehicleControlUiRearRightSeatHeatReq::HeaterRequestOff,
            x => Id273uiVehicleControlUiRearRightSeatHeatReq::Other(x),
        }
    }
    
    /// Get raw value of UI_rearRightSeatHeatReq
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_rear_right_seat_heat_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_rearRightSeatHeatReq
    #[inline(always)]
    pub fn set_ui_rear_right_seat_heat_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..52].store_le(value);
        Ok(())
    }
    
    /// UI_rearWindowLockout
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_rear_window_lockout(&self) -> bool {
        self.ui_rear_window_lockout_raw()
    }
    
    /// Get raw value of UI_rearWindowLockout
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_rear_window_lockout_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rearWindowLockout
    #[inline(always)]
    pub fn set_ui_rear_window_lockout(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// UI_remoteClosureRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_remote_closure_request(&self) -> Id273uiVehicleControlUiRemoteClosureRequest {
        match self.ui_remote_closure_request_raw() {
            2 => Id273uiVehicleControlUiRemoteClosureRequest::UiRemoteClosureRequestFrontTrunkMove,
            0 => Id273uiVehicleControlUiRemoteClosureRequest::UiRemoteClosureRequestIdle,
            1 => Id273uiVehicleControlUiRemoteClosureRequest::UiRemoteClosureRequestRearTrunkMove,
            3 => Id273uiVehicleControlUiRemoteClosureRequest::UiRemoteClosureRequestSna,
            x => Id273uiVehicleControlUiRemoteClosureRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_remoteClosureRequest
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_remote_closure_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_remoteClosureRequest
    #[inline(always)]
    pub fn set_ui_remote_closure_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// UI_remoteStartRequest
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_remote_start_request(&self) -> Id273uiVehicleControlUiRemoteStartRequest {
        match self.ui_remote_start_request_raw() {
            0 => Id273uiVehicleControlUiRemoteStartRequest::UiRemoteStartRequestIdle,
            4 => Id273uiVehicleControlUiRemoteStartRequest::UiRemoteStartRequestSna,
            1 => Id273uiVehicleControlUiRemoteStartRequest::UiRemoteStartRequestStart,
            x => Id273uiVehicleControlUiRemoteStartRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_remoteStartRequest
    ///
    /// - Start bit: 27
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_remote_start_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_remoteStartRequest
    #[inline(always)]
    pub fn set_ui_remote_start_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..30].store_le(value);
        Ok(())
    }
    
    /// UI_seeYouHomeLightingOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_see_you_home_lighting_on(&self) -> bool {
        self.ui_see_you_home_lighting_on_raw()
    }
    
    /// Get raw value of UI_seeYouHomeLightingOn
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_see_you_home_lighting_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_seeYouHomeLightingOn
    #[inline(always)]
    pub fn set_ui_see_you_home_lighting_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// UI_steeringBacklightEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_steering_backlight_enabled(&self) -> Id273uiVehicleControlUiSteeringBacklightEnabled {
        match self.ui_steering_backlight_enabled_raw() {
            false => Id273uiVehicleControlUiSteeringBacklightEnabled::SteeringBacklightDisabled,
            true => Id273uiVehicleControlUiSteeringBacklightEnabled::SteeringBacklightEnabled,
            x => Id273uiVehicleControlUiSteeringBacklightEnabled::Other(x),
        }
    }
    
    /// Get raw value of UI_steeringBacklightEnabled
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_steering_backlight_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_steeringBacklightEnabled
    #[inline(always)]
    pub fn set_ui_steering_backlight_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// UI_steeringButtonMode
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_steering_button_mode(&self) -> Id273uiVehicleControlUiSteeringButtonMode {
        match self.ui_steering_button_mode_raw() {
            4 => Id273uiVehicleControlUiSteeringButtonMode::SteeringButtonModeHeadlightLeft,
            5 => Id273uiVehicleControlUiSteeringButtonMode::SteeringButtonModeHeadlightRight,
            2 => Id273uiVehicleControlUiSteeringButtonMode::SteeringButtonModeMirrorLeft,
            3 => Id273uiVehicleControlUiSteeringButtonMode::SteeringButtonModeMirrorRight,
            0 => Id273uiVehicleControlUiSteeringButtonMode::SteeringButtonModeOff,
            1 => Id273uiVehicleControlUiSteeringButtonMode::SteeringButtonModeSteeringColumnAdj,
            x => Id273uiVehicleControlUiSteeringButtonMode::Other(x),
        }
    }
    
    /// Get raw value of UI_steeringButtonMode
    ///
    /// - Start bit: 9
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_steering_button_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[9..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_steeringButtonMode
    #[inline(always)]
    pub fn set_ui_steering_button_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[9..12].store_le(value);
        Ok(())
    }
    
    /// UI_stop12vSupport
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_stop12v_support(&self) -> bool {
        self.ui_stop12v_support_raw()
    }
    
    /// Get raw value of UI_stop12vSupport
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_stop12v_support_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_stop12vSupport
    #[inline(always)]
    pub fn set_ui_stop12v_support(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[22..23].store_le(value);
        Ok(())
    }
    
    /// UI_summonActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_summon_active(&self) -> bool {
        self.ui_summon_active_raw()
    }
    
    /// Get raw value of UI_summonActive
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_summon_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_summonActive
    #[inline(always)]
    pub fn set_ui_summon_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_unlockOnPark
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_unlock_on_park(&self) -> bool {
        self.ui_unlock_on_park_raw()
    }
    
    /// Get raw value of UI_unlockOnPark
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_unlock_on_park_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_unlockOnPark
    #[inline(always)]
    pub fn set_ui_unlock_on_park(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// UI_walkAwayLock
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_walk_away_lock(&self) -> bool {
        self.ui_walk_away_lock_raw()
    }
    
    /// Get raw value of UI_walkAwayLock
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_walk_away_lock_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_walkAwayLock
    #[inline(always)]
    pub fn set_ui_walk_away_lock(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// UI_walkUpUnlock
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_walk_up_unlock(&self) -> bool {
        self.ui_walk_up_unlock_raw()
    }
    
    /// Get raw value of UI_walkUpUnlock
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_walk_up_unlock_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_walkUpUnlock
    #[inline(always)]
    pub fn set_ui_walk_up_unlock(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// UI_wiperMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wiper_mode(&self) -> Id273uiVehicleControlUiWiperMode {
        match self.ui_wiper_mode_raw() {
            2 => Id273uiVehicleControlUiWiperMode::WiperModeNormal,
            3 => Id273uiVehicleControlUiWiperMode::WiperModePark,
            1 => Id273uiVehicleControlUiWiperMode::WiperModeService,
            0 => Id273uiVehicleControlUiWiperMode::WiperModeSna,
            x => Id273uiVehicleControlUiWiperMode::Other(x),
        }
    }
    
    /// Get raw value of UI_wiperMode
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wiper_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_wiperMode
    #[inline(always)]
    pub fn set_ui_wiper_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// UI_wiperRequest
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wiper_request(&self) -> Id273uiVehicleControlUiWiperRequest {
        match self.ui_wiper_request_raw() {
            2 => Id273uiVehicleControlUiWiperRequest::WiperRequestAuto,
            6 => Id273uiVehicleControlUiWiperRequest::WiperRequestFastContinuous,
            4 => Id273uiVehicleControlUiWiperRequest::WiperRequestFastIntermittent,
            1 => Id273uiVehicleControlUiWiperRequest::WiperRequestOff,
            5 => Id273uiVehicleControlUiWiperRequest::WiperRequestSlowContinuous,
            3 => Id273uiVehicleControlUiWiperRequest::WiperRequestSlowIntermittent,
            0 => Id273uiVehicleControlUiWiperRequest::WiperRequestSna,
            x => Id273uiVehicleControlUiWiperRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_wiperRequest
    ///
    /// - Start bit: 56
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wiper_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_wiperRequest
    #[inline(always)]
    pub fn set_ui_wiper_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 627 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..59].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id273uiVehicleControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id273uiVehicleControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_accessory_power_request = u.int_in_range(0..=1)? == 1;
        let ui_alarm_enabled = u.int_in_range(0..=1)? == 1;
        let ui_ambient_lighting_enabled = u.int_in_range(0..=1)? == 1;
        let ui_auto_fold_mirrors_on = u.int_in_range(0..=1)? == 1;
        let ui_auto_high_beam_enabled = u.int_in_range(0..=1)? == 1;
        let ui_child_door_lock_on = u.int_in_range(0..=1)? == 1;
        let ui_display_brightness_level = 0_f32;
        let ui_dome_light_switch = u.int_in_range(0..=2)?;
        let ui_drive_state_request = u.int_in_range(0..=1)? == 1;
        let ui_front_fog_switch = u.int_in_range(0..=1)? == 1;
        let ui_front_left_seat_heat_req = u.int_in_range(0..=3)?;
        let ui_front_right_seat_heat_req = u.int_in_range(0..=3)?;
        let ui_frunk_request = u.int_in_range(0..=1)? == 1;
        let ui_global_unlock_on = u.int_in_range(0..=1)? == 1;
        let ui_honk_horn = u.int_in_range(0..=1)? == 1;
        let ui_intrusion_sensor_on = u.int_in_range(0..=1)? == 1;
        let ui_lock_request = u.int_in_range(0..=7)?;
        let ui_mirror_dip_on_reverse = u.int_in_range(0..=1)? == 1;
        let ui_mirror_fold_request = u.int_in_range(0..=3)?;
        let ui_mirror_heat_request = u.int_in_range(0..=1)? == 1;
        let ui_power_off = u.int_in_range(0..=1)? == 1;
        let ui_rear_center_seat_heat_req = u.int_in_range(0..=3)?;
        let ui_rear_fog_switch = u.int_in_range(0..=1)? == 1;
        let ui_rear_left_seat_heat_req = u.int_in_range(0..=3)?;
        let ui_rear_right_seat_heat_req = u.int_in_range(0..=3)?;
        let ui_rear_window_lockout = u.int_in_range(0..=1)? == 1;
        let ui_remote_closure_request = u.int_in_range(0..=3)?;
        let ui_remote_start_request = u.int_in_range(0..=4)?;
        let ui_see_you_home_lighting_on = u.int_in_range(0..=1)? == 1;
        let ui_steering_backlight_enabled = u.int_in_range(0..=1)? == 1;
        let ui_steering_button_mode = u.int_in_range(0..=5)?;
        let ui_stop12v_support = u.int_in_range(0..=1)? == 1;
        let ui_summon_active = u.int_in_range(0..=1)? == 1;
        let ui_unlock_on_park = u.int_in_range(0..=1)? == 1;
        let ui_walk_away_lock = u.int_in_range(0..=1)? == 1;
        let ui_walk_up_unlock = u.int_in_range(0..=1)? == 1;
        let ui_wiper_mode = u.int_in_range(0..=3)?;
        let ui_wiper_request = u.int_in_range(0..=6)?;
        Id273uiVehicleControl::new(ui_accessory_power_request,ui_alarm_enabled,ui_ambient_lighting_enabled,ui_auto_fold_mirrors_on,ui_auto_high_beam_enabled,ui_child_door_lock_on,ui_display_brightness_level,ui_dome_light_switch,ui_drive_state_request,ui_front_fog_switch,ui_front_left_seat_heat_req,ui_front_right_seat_heat_req,ui_frunk_request,ui_global_unlock_on,ui_honk_horn,ui_intrusion_sensor_on,ui_lock_request,ui_mirror_dip_on_reverse,ui_mirror_fold_request,ui_mirror_heat_request,ui_power_off,ui_rear_center_seat_heat_req,ui_rear_fog_switch,ui_rear_left_seat_heat_req,ui_rear_right_seat_heat_req,ui_rear_window_lockout,ui_remote_closure_request,ui_remote_start_request,ui_see_you_home_lighting_on,ui_steering_backlight_enabled,ui_steering_button_mode,ui_stop12v_support,ui_summon_active,ui_unlock_on_park,ui_walk_away_lock,ui_walk_up_unlock,ui_wiper_mode,ui_wiper_request).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_displayBrightnessLevel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiDisplayBrightnessLevel {
    Sna,
    Other(f32),
}
/// Defined values for UI_domeLightSwitch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiDomeLightSwitch {
    DomeLightSwitchAuto,
    DomeLightSwitchOff,
    DomeLightSwitchOn,
    Other(u8),
}
/// Defined values for UI_driveStateRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiDriveStateRequest {
    DriveStateReqIdle,
    DriveStateReqStart,
    Other(bool),
}
/// Defined values for UI_frontLeftSeatHeatReq
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiFrontLeftSeatHeatReq {
    HeaterRequestLevel1,
    HeaterRequestLevel2,
    HeaterRequestLevel3,
    HeaterRequestOff,
    Other(u8),
}
/// Defined values for UI_frontRightSeatHeatReq
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiFrontRightSeatHeatReq {
    HeaterRequestLevel1,
    HeaterRequestLevel2,
    HeaterRequestLevel3,
    HeaterRequestOff,
    Other(u8),
}
/// Defined values for UI_lockRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiLockRequest {
    UiLockRequestIdle,
    UiLockRequestLock,
    UiLockRequestRemoteLock,
    UiLockRequestRemoteUnlock,
    UiLockRequestSna,
    UiLockRequestUnlock,
    Other(u8),
}
/// Defined values for UI_mirrorFoldRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiMirrorFoldRequest {
    MirrorFoldRequestIdle,
    MirrorFoldRequestPresent,
    MirrorFoldRequestRetract,
    MirrorFoldRequestSna,
    Other(u8),
}
/// Defined values for UI_rearCenterSeatHeatReq
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiRearCenterSeatHeatReq {
    HeaterRequestLevel1,
    HeaterRequestLevel2,
    HeaterRequestLevel3,
    HeaterRequestOff,
    Other(u8),
}
/// Defined values for UI_rearLeftSeatHeatReq
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiRearLeftSeatHeatReq {
    HeaterRequestLevel1,
    HeaterRequestLevel2,
    HeaterRequestLevel3,
    HeaterRequestOff,
    Other(u8),
}
/// Defined values for UI_rearRightSeatHeatReq
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiRearRightSeatHeatReq {
    HeaterRequestLevel1,
    HeaterRequestLevel2,
    HeaterRequestLevel3,
    HeaterRequestOff,
    Other(u8),
}
/// Defined values for UI_remoteClosureRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiRemoteClosureRequest {
    UiRemoteClosureRequestFrontTrunkMove,
    UiRemoteClosureRequestIdle,
    UiRemoteClosureRequestRearTrunkMove,
    UiRemoteClosureRequestSna,
    Other(u8),
}
/// Defined values for UI_remoteStartRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiRemoteStartRequest {
    UiRemoteStartRequestIdle,
    UiRemoteStartRequestSna,
    UiRemoteStartRequestStart,
    Other(u8),
}
/// Defined values for UI_steeringBacklightEnabled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiSteeringBacklightEnabled {
    SteeringBacklightDisabled,
    SteeringBacklightEnabled,
    Other(bool),
}
/// Defined values for UI_steeringButtonMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiSteeringButtonMode {
    SteeringButtonModeHeadlightLeft,
    SteeringButtonModeHeadlightRight,
    SteeringButtonModeMirrorLeft,
    SteeringButtonModeMirrorRight,
    SteeringButtonModeOff,
    SteeringButtonModeSteeringColumnAdj,
    Other(u8),
}
/// Defined values for UI_wiperMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiWiperMode {
    WiperModeNormal,
    WiperModePark,
    WiperModeService,
    WiperModeSna,
    Other(u8),
}
/// Defined values for UI_wiperRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id273uiVehicleControlUiWiperRequest {
    WiperRequestAuto,
    WiperRequestFastContinuous,
    WiperRequestFastIntermittent,
    WiperRequestOff,
    WiperRequestSlowContinuous,
    WiperRequestSlowIntermittent,
    WiperRequestSna,
    Other(u8),
}

/// ID27DCP_dcChargeLimits
///
/// - ID: 637 (0x27d)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id27dcpDcChargeLimits {
    raw: [u8; 8],
}

impl Id27dcpDcChargeLimits {
    pub const MESSAGE_ID: u32 = 637;
    
    /// Construct new ID27DCP_dcChargeLimits from values
    pub fn new(cp_evse_instant_dc_current_limit: f32, cp_evse_max_dc_current_limit: f32, cp_evse_max_dc_voltage_limit: f32, cp_evse_min_dc_current_limit: f32, cp_evse_min_dc_voltage_limit: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cp_evse_instant_dc_current_limit(cp_evse_instant_dc_current_limit)?;
        res.set_cp_evse_max_dc_current_limit(cp_evse_max_dc_current_limit)?;
        res.set_cp_evse_max_dc_voltage_limit(cp_evse_max_dc_voltage_limit)?;
        res.set_cp_evse_min_dc_current_limit(cp_evse_min_dc_current_limit)?;
        res.set_cp_evse_min_dc_voltage_limit(cp_evse_min_dc_voltage_limit)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_evseInstantDcCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 599.854
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_instant_dc_current_limit(&self) -> f32 {
        self.cp_evse_instant_dc_current_limit_raw()
    }
    
    /// Get raw value of CP_evseInstantDcCurrentLimit
    ///
    /// - Start bit: 52
    /// - Signal size: 12 bits
    /// - Factor: 0.146484
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_instant_dc_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[52..64].load_le::<u16>();
        
        let factor = 0.146484_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseInstantDcCurrentLimit
    #[inline(always)]
    pub fn set_cp_evse_instant_dc_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.854_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 637 }); }
        let factor = 0.146484_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[52..64].store_le(value);
        Ok(())
    }
    
    /// CP_evseMaxDcCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 599.927
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_max_dc_current_limit(&self) -> f32 {
        self.cp_evse_max_dc_current_limit_raw()
    }
    
    /// Get raw value of CP_evseMaxDcCurrentLimit
    ///
    /// - Start bit: 0
    /// - Signal size: 13 bits
    /// - Factor: 0.0732422
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_max_dc_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..13].load_le::<u16>();
        
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseMaxDcCurrentLimit
    #[inline(always)]
    pub fn set_cp_evse_max_dc_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.927_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 637 }); }
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..13].store_le(value);
        Ok(())
    }
    
    /// CP_evseMaxDcVoltageLimit
    ///
    /// - Min: 0
    /// - Max: 599.927
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_max_dc_voltage_limit(&self) -> f32 {
        self.cp_evse_max_dc_voltage_limit_raw()
    }
    
    /// Get raw value of CP_evseMaxDcVoltageLimit
    ///
    /// - Start bit: 26
    /// - Signal size: 13 bits
    /// - Factor: 0.0732422
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_max_dc_voltage_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[26..39].load_le::<u16>();
        
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseMaxDcVoltageLimit
    #[inline(always)]
    pub fn set_cp_evse_max_dc_voltage_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.927_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 637 }); }
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[26..39].store_le(value);
        Ok(())
    }
    
    /// CP_evseMinDcCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 599.927
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_min_dc_current_limit(&self) -> f32 {
        self.cp_evse_min_dc_current_limit_raw()
    }
    
    /// Get raw value of CP_evseMinDcCurrentLimit
    ///
    /// - Start bit: 13
    /// - Signal size: 13 bits
    /// - Factor: 0.0732422
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_min_dc_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[13..26].load_le::<u16>();
        
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseMinDcCurrentLimit
    #[inline(always)]
    pub fn set_cp_evse_min_dc_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.927_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 637 }); }
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[13..26].store_le(value);
        Ok(())
    }
    
    /// CP_evseMinDcVoltageLimit
    ///
    /// - Min: 0
    /// - Max: 599.927
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_min_dc_voltage_limit(&self) -> f32 {
        self.cp_evse_min_dc_voltage_limit_raw()
    }
    
    /// Get raw value of CP_evseMinDcVoltageLimit
    ///
    /// - Start bit: 39
    /// - Signal size: 13 bits
    /// - Factor: 0.0732422
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_min_dc_voltage_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[39..52].load_le::<u16>();
        
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseMinDcVoltageLimit
    #[inline(always)]
    pub fn set_cp_evse_min_dc_voltage_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.927_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 637 }); }
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[39..52].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id27dcpDcChargeLimits {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id27dcpDcChargeLimits
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_evse_instant_dc_current_limit = 0_f32;
        let cp_evse_max_dc_current_limit = 0_f32;
        let cp_evse_max_dc_voltage_limit = 0_f32;
        let cp_evse_min_dc_current_limit = 0_f32;
        let cp_evse_min_dc_voltage_limit = 0_f32;
        Id27dcpDcChargeLimits::new(cp_evse_instant_dc_current_limit,cp_evse_max_dc_current_limit,cp_evse_max_dc_voltage_limit,cp_evse_min_dc_current_limit,cp_evse_min_dc_voltage_limit).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID2BDCP_dcPowerLimits
///
/// - ID: 701 (0x2bd)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2bdcpDcPowerLimits {
    raw: [u8; 4],
}

impl Id2bdcpDcPowerLimits {
    pub const MESSAGE_ID: u32 = 701;
    
    /// Construct new ID2BDCP_dcPowerLimits from values
    pub fn new(cp_evse_instant_dc_power_limit: f32, cp_evse_max_dc_power_limit: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cp_evse_instant_dc_power_limit(cp_evse_instant_dc_power_limit)?;
        res.set_cp_evse_max_dc_power_limit(cp_evse_max_dc_power_limit)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_evseInstantDcPowerLimit
    ///
    /// - Min: 0
    /// - Max: 509.938
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_instant_dc_power_limit(&self) -> f32 {
        self.cp_evse_instant_dc_power_limit_raw()
    }
    
    /// Get raw value of CP_evseInstantDcPowerLimit
    ///
    /// - Start bit: 0
    /// - Signal size: 13 bits
    /// - Factor: 0.0622559
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_instant_dc_power_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..13].load_le::<u16>();
        
        let factor = 0.0622559_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseInstantDcPowerLimit
    #[inline(always)]
    pub fn set_cp_evse_instant_dc_power_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 509.938_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 701 }); }
        let factor = 0.0622559_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..13].store_le(value);
        Ok(())
    }
    
    /// CP_evseMaxDcPowerLimit
    ///
    /// - Min: 0
    /// - Max: 509.938
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_max_dc_power_limit(&self) -> f32 {
        self.cp_evse_max_dc_power_limit_raw()
    }
    
    /// Get raw value of CP_evseMaxDcPowerLimit
    ///
    /// - Start bit: 16
    /// - Signal size: 13 bits
    /// - Factor: 0.0622559
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_max_dc_power_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..29].load_le::<u16>();
        
        let factor = 0.0622559_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseMaxDcPowerLimit
    #[inline(always)]
    pub fn set_cp_evse_max_dc_power_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 509.938_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 701 }); }
        let factor = 0.0622559_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..29].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2bdcpDcPowerLimits {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2bdcpDcPowerLimits
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_evse_instant_dc_power_limit = 0_f32;
        let cp_evse_max_dc_power_limit = 0_f32;
        Id2bdcpDcPowerLimits::new(cp_evse_instant_dc_power_limit,cp_evse_max_dc_power_limit).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID42AVCSEC_TPMSConnectionData
///
/// - ID: 1066 (0x42a)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id42avcsecTpmsConnectionData {
    raw: [u8; 8],
}

impl Id42avcsecTpmsConnectionData {
    pub const MESSAGE_ID: u32 = 1066;
    
    /// Construct new ID42AVCSEC_TPMSConnectionData from values
    pub fn new(vcsec_tpms_connection_type_current0: u8, vcsec_tpms_connection_type_current1: u8, vcsec_tpms_connection_type_current2: u8, vcsec_tpms_connection_type_current3: u8, vcsec_tpms_connection_type_desired0: u8, vcsec_tpms_connection_type_desired1: u8, vcsec_tpms_connection_type_desired2: u8, vcsec_tpms_connection_type_desired3: u8, vcsec_tpmsrssi0: i8, vcsec_tpmsrssi1: i8, vcsec_tpmsrssi2: i8, vcsec_tpmsrssi3: i8, vcsec_tpms_sensor_state0: u8, vcsec_tpms_sensor_state1: u8, vcsec_tpms_sensor_state2: u8, vcsec_tpms_sensor_state3: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcsec_tpms_connection_type_current0(vcsec_tpms_connection_type_current0)?;
        res.set_vcsec_tpms_connection_type_current1(vcsec_tpms_connection_type_current1)?;
        res.set_vcsec_tpms_connection_type_current2(vcsec_tpms_connection_type_current2)?;
        res.set_vcsec_tpms_connection_type_current3(vcsec_tpms_connection_type_current3)?;
        res.set_vcsec_tpms_connection_type_desired0(vcsec_tpms_connection_type_desired0)?;
        res.set_vcsec_tpms_connection_type_desired1(vcsec_tpms_connection_type_desired1)?;
        res.set_vcsec_tpms_connection_type_desired2(vcsec_tpms_connection_type_desired2)?;
        res.set_vcsec_tpms_connection_type_desired3(vcsec_tpms_connection_type_desired3)?;
        res.set_vcsec_tpmsrssi0(vcsec_tpmsrssi0)?;
        res.set_vcsec_tpmsrssi1(vcsec_tpmsrssi1)?;
        res.set_vcsec_tpmsrssi2(vcsec_tpmsrssi2)?;
        res.set_vcsec_tpmsrssi3(vcsec_tpmsrssi3)?;
        res.set_vcsec_tpms_sensor_state0(vcsec_tpms_sensor_state0)?;
        res.set_vcsec_tpms_sensor_state1(vcsec_tpms_sensor_state1)?;
        res.set_vcsec_tpms_sensor_state2(vcsec_tpms_sensor_state2)?;
        res.set_vcsec_tpms_sensor_state3(vcsec_tpms_sensor_state3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCSEC_TPMSConnectionTypeCurrent0
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current0(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent0 {
        match self.vcsec_tpms_connection_type_current0_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent0::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent0::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent0::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeCurrent0
    ///
    /// - Start bit: 11
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeCurrent0
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_current0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..13].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeCurrent1
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current1(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent1 {
        match self.vcsec_tpms_connection_type_current1_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent1::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent1::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent1::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeCurrent1
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeCurrent1
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_current1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..28].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeCurrent2
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current2(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent2 {
        match self.vcsec_tpms_connection_type_current2_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent2::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent2::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent2::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeCurrent2
    ///
    /// - Start bit: 41
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[41..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeCurrent2
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_current2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[41..43].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeCurrent3
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current3(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent3 {
        match self.vcsec_tpms_connection_type_current3_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent3::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent3::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent3::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeCurrent3
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_current3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeCurrent3
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_current3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..58].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeDesired0
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired0(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired0 {
        match self.vcsec_tpms_connection_type_desired0_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired0::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired0::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired0::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeDesired0
    ///
    /// - Start bit: 13
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeDesired0
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_desired0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..15].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeDesired1
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired1(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired1 {
        match self.vcsec_tpms_connection_type_desired1_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired1::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired1::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired1::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeDesired1
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeDesired1
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_desired1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..30].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeDesired2
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired2(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired2 {
        match self.vcsec_tpms_connection_type_desired2_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired2::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired2::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired2::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeDesired2
    ///
    /// - Start bit: 43
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[43..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeDesired2
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_desired2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[43..45].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSConnectionTypeDesired3
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired3(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired3 {
        match self.vcsec_tpms_connection_type_desired3_raw() {
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired3::ConnectiontypeFast,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired3::ConnectiontypeSlow,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired3::ConnectiontypeUnknown,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSConnectionTypeDesired3
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_connection_type_desired3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSConnectionTypeDesired3
    #[inline(always)]
    pub fn set_vcsec_tpms_connection_type_desired3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..60].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSRSSI0
    ///
    /// - Min: -127
    /// - Max: 0
    /// - Unit: "dBm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpmsrssi0(&self) -> i8 {
        self.vcsec_tpmsrssi0_raw()
    }
    
    /// Get raw value of VCSEC_TPMSRSSI0
    ///
    /// - Start bit: 3
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcsec_tpmsrssi0_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..11].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCSEC_TPMSRSSI0
    #[inline(always)]
    pub fn set_vcsec_tpmsrssi0(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_i8 || 0_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[3..11].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSRSSI1
    ///
    /// - Min: -127
    /// - Max: 0
    /// - Unit: "dBm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpmsrssi1(&self) -> i8 {
        self.vcsec_tpmsrssi1_raw()
    }
    
    /// Get raw value of VCSEC_TPMSRSSI1
    ///
    /// - Start bit: 18
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcsec_tpmsrssi1_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..26].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCSEC_TPMSRSSI1
    #[inline(always)]
    pub fn set_vcsec_tpmsrssi1(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_i8 || 0_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[18..26].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSRSSI2
    ///
    /// - Min: -127
    /// - Max: 0
    /// - Unit: "dBm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpmsrssi2(&self) -> i8 {
        self.vcsec_tpmsrssi2_raw()
    }
    
    /// Get raw value of VCSEC_TPMSRSSI2
    ///
    /// - Start bit: 33
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcsec_tpmsrssi2_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[33..41].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCSEC_TPMSRSSI2
    #[inline(always)]
    pub fn set_vcsec_tpmsrssi2(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_i8 || 0_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[33..41].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSRSSI3
    ///
    /// - Min: -127
    /// - Max: 0
    /// - Unit: "dBm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpmsrssi3(&self) -> i8 {
        self.vcsec_tpmsrssi3_raw()
    }
    
    /// Get raw value of VCSEC_TPMSRSSI3
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcsec_tpmsrssi3_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCSEC_TPMSRSSI3
    #[inline(always)]
    pub fn set_vcsec_tpmsrssi3(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_i8 || 0_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSSensorState0
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state0(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0 {
        match self.vcsec_tpms_sensor_state0_raw() {
            3 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0::SensorConnected,
            4 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0::SensorDisconnecting,
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0::SensorNotPaired,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0::SensorWaitForAdv,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0::SensorWaitForConn,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSSensorState0
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSSensorState0
    #[inline(always)]
    pub fn set_vcsec_tpms_sensor_state0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSSensorState1
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state1(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1 {
        match self.vcsec_tpms_sensor_state1_raw() {
            3 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1::SensorConnected,
            4 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1::SensorDisconnecting,
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1::SensorNotPaired,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1::SensorWaitForAdv,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1::SensorWaitForConn,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSSensorState1
    ///
    /// - Start bit: 15
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[15..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSSensorState1
    #[inline(always)]
    pub fn set_vcsec_tpms_sensor_state1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[15..18].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSSensorState2
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state2(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2 {
        match self.vcsec_tpms_sensor_state2_raw() {
            3 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2::SensorConnected,
            4 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2::SensorDisconnecting,
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2::SensorNotPaired,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2::SensorWaitForAdv,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2::SensorWaitForConn,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSSensorState2
    ///
    /// - Start bit: 30
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..33].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSSensorState2
    #[inline(always)]
    pub fn set_vcsec_tpms_sensor_state2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..33].store_le(value);
        Ok(())
    }
    
    /// VCSEC_TPMSSensorState3
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state3(&self) -> Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3 {
        match self.vcsec_tpms_sensor_state3_raw() {
            3 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3::SensorConnected,
            4 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3::SensorDisconnecting,
            0 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3::SensorNotPaired,
            1 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3::SensorWaitForAdv,
            2 => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3::SensorWaitForConn,
            x => Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3::Other(x),
        }
    }
    
    /// Get raw value of VCSEC_TPMSSensorState3
    ///
    /// - Start bit: 45
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcsec_tpms_sensor_state3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[45..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCSEC_TPMSSensorState3
    #[inline(always)]
    pub fn set_vcsec_tpms_sensor_state3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1066 }); }
        self.raw.view_bits_mut::<LocalBits>()[45..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id42avcsecTpmsConnectionData {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id42avcsecTpmsConnectionData
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcsec_tpms_connection_type_current0 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_current1 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_current2 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_current3 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_desired0 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_desired1 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_desired2 = u.int_in_range(0..=2)?;
        let vcsec_tpms_connection_type_desired3 = u.int_in_range(0..=2)?;
        let vcsec_tpmsrssi0 = u.int_in_range(-127..=0)?;
        let vcsec_tpmsrssi1 = u.int_in_range(-127..=0)?;
        let vcsec_tpmsrssi2 = u.int_in_range(-127..=0)?;
        let vcsec_tpmsrssi3 = u.int_in_range(-127..=0)?;
        let vcsec_tpms_sensor_state0 = u.int_in_range(0..=4)?;
        let vcsec_tpms_sensor_state1 = u.int_in_range(0..=4)?;
        let vcsec_tpms_sensor_state2 = u.int_in_range(0..=4)?;
        let vcsec_tpms_sensor_state3 = u.int_in_range(0..=4)?;
        Id42avcsecTpmsConnectionData::new(vcsec_tpms_connection_type_current0,vcsec_tpms_connection_type_current1,vcsec_tpms_connection_type_current2,vcsec_tpms_connection_type_current3,vcsec_tpms_connection_type_desired0,vcsec_tpms_connection_type_desired1,vcsec_tpms_connection_type_desired2,vcsec_tpms_connection_type_desired3,vcsec_tpmsrssi0,vcsec_tpmsrssi1,vcsec_tpmsrssi2,vcsec_tpmsrssi3,vcsec_tpms_sensor_state0,vcsec_tpms_sensor_state1,vcsec_tpms_sensor_state2,vcsec_tpms_sensor_state3).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCSEC_TPMSConnectionTypeCurrent0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent0 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeCurrent1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent1 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeCurrent2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent2 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeCurrent3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeCurrent3 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeDesired0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired0 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeDesired1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired1 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeDesired2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired2 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSConnectionTypeDesired3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsConnectionTypeDesired3 {
    ConnectiontypeFast,
    ConnectiontypeSlow,
    ConnectiontypeUnknown,
    Other(u8),
}
/// Defined values for VCSEC_TPMSSensorState0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsSensorState0 {
    SensorConnected,
    SensorDisconnecting,
    SensorNotPaired,
    SensorWaitForAdv,
    SensorWaitForConn,
    Other(u8),
}
/// Defined values for VCSEC_TPMSSensorState1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsSensorState1 {
    SensorConnected,
    SensorDisconnecting,
    SensorNotPaired,
    SensorWaitForAdv,
    SensorWaitForConn,
    Other(u8),
}
/// Defined values for VCSEC_TPMSSensorState2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsSensorState2 {
    SensorConnected,
    SensorDisconnecting,
    SensorNotPaired,
    SensorWaitForAdv,
    SensorWaitForConn,
    Other(u8),
}
/// Defined values for VCSEC_TPMSSensorState3
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id42avcsecTpmsConnectionDataVcsecTpmsSensorState3 {
    SensorConnected,
    SensorDisconnecting,
    SensorNotPaired,
    SensorWaitForAdv,
    SensorWaitForConn,
    Other(u8),
}

/// ID22EPARK_sdiRear
///
/// - ID: 558 (0x22e)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id22eparkSdiRear {
    raw: [u8; 8],
}

impl Id22eparkSdiRear {
    pub const MESSAGE_ID: u32 = 558;
    
    /// Construct new ID22EPARK_sdiRear from values
    pub fn new(park_sdi_rear_checksum: u8, park_sdi_rear_counter: u8, park_sdi_sensor10_raw_dist_data: u16, park_sdi_sensor11_raw_dist_data: u16, park_sdi_sensor12_raw_dist_data: u16, park_sdi_sensor7_raw_dist_data: u16, park_sdi_sensor8_raw_dist_data: u16, park_sdi_sensor9_raw_dist_data: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_park_sdi_rear_checksum(park_sdi_rear_checksum)?;
        res.set_park_sdi_rear_counter(park_sdi_rear_counter)?;
        res.set_park_sdi_sensor10_raw_dist_data(park_sdi_sensor10_raw_dist_data)?;
        res.set_park_sdi_sensor11_raw_dist_data(park_sdi_sensor11_raw_dist_data)?;
        res.set_park_sdi_sensor12_raw_dist_data(park_sdi_sensor12_raw_dist_data)?;
        res.set_park_sdi_sensor7_raw_dist_data(park_sdi_sensor7_raw_dist_data)?;
        res.set_park_sdi_sensor8_raw_dist_data(park_sdi_sensor8_raw_dist_data)?;
        res.set_park_sdi_sensor9_raw_dist_data(park_sdi_sensor9_raw_dist_data)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// PARK_sdiRearChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_rear_checksum(&self) -> u8 {
        self.park_sdi_rear_checksum_raw()
    }
    
    /// Get raw value of PARK_sdiRearChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_rear_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PARK_sdiRearChecksum
    #[inline(always)]
    pub fn set_park_sdi_rear_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiRearCounter
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_rear_counter(&self) -> u8 {
        self.park_sdi_rear_counter_raw()
    }
    
    /// Get raw value of PARK_sdiRearCounter
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_rear_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PARK_sdiRearCounter
    #[inline(always)]
    pub fn set_park_sdi_rear_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor10RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor10_raw_dist_data(&self) -> Id22eparkSdiRearParkSdiSensor10RawDistData {
        match self.park_sdi_sensor10_raw_dist_data_raw() {
            0 => Id22eparkSdiRearParkSdiSensor10RawDistData::Blocked,
            1 => Id22eparkSdiRearParkSdiSensor10RawDistData::NearDetection,
            500 => Id22eparkSdiRearParkSdiSensor10RawDistData::NoObjectDetected,
            511 => Id22eparkSdiRearParkSdiSensor10RawDistData::Sna,
            x => Id22eparkSdiRearParkSdiSensor10RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor10RawDistData
    ///
    /// - Start bit: 27
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor10_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[27..36].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor10RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor10_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..36].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor11RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor11_raw_dist_data(&self) -> Id22eparkSdiRearParkSdiSensor11RawDistData {
        match self.park_sdi_sensor11_raw_dist_data_raw() {
            0 => Id22eparkSdiRearParkSdiSensor11RawDistData::Blocked,
            1 => Id22eparkSdiRearParkSdiSensor11RawDistData::NearDetection,
            500 => Id22eparkSdiRearParkSdiSensor11RawDistData::NoObjectDetected,
            511 => Id22eparkSdiRearParkSdiSensor11RawDistData::Sna,
            x => Id22eparkSdiRearParkSdiSensor11RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor11RawDistData
    ///
    /// - Start bit: 36
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor11_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[36..45].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor11RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor11_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..45].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor12RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor12_raw_dist_data(&self) -> Id22eparkSdiRearParkSdiSensor12RawDistData {
        match self.park_sdi_sensor12_raw_dist_data_raw() {
            0 => Id22eparkSdiRearParkSdiSensor12RawDistData::Blocked,
            1 => Id22eparkSdiRearParkSdiSensor12RawDistData::NearDetection,
            500 => Id22eparkSdiRearParkSdiSensor12RawDistData::NoObjectDetected,
            511 => Id22eparkSdiRearParkSdiSensor12RawDistData::Sna,
            x => Id22eparkSdiRearParkSdiSensor12RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor12RawDistData
    ///
    /// - Start bit: 45
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor12_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[45..54].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor12RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor12_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[45..54].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor7RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor7_raw_dist_data(&self) -> Id22eparkSdiRearParkSdiSensor7RawDistData {
        match self.park_sdi_sensor7_raw_dist_data_raw() {
            0 => Id22eparkSdiRearParkSdiSensor7RawDistData::Blocked,
            1 => Id22eparkSdiRearParkSdiSensor7RawDistData::NearDetection,
            500 => Id22eparkSdiRearParkSdiSensor7RawDistData::NoObjectDetected,
            511 => Id22eparkSdiRearParkSdiSensor7RawDistData::Sna,
            x => Id22eparkSdiRearParkSdiSensor7RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor7RawDistData
    ///
    /// - Start bit: 0
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor7_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[0..9].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor7RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor7_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..9].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor8RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor8_raw_dist_data(&self) -> Id22eparkSdiRearParkSdiSensor8RawDistData {
        match self.park_sdi_sensor8_raw_dist_data_raw() {
            0 => Id22eparkSdiRearParkSdiSensor8RawDistData::Blocked,
            1 => Id22eparkSdiRearParkSdiSensor8RawDistData::NearDetection,
            500 => Id22eparkSdiRearParkSdiSensor8RawDistData::NoObjectDetected,
            511 => Id22eparkSdiRearParkSdiSensor8RawDistData::Sna,
            x => Id22eparkSdiRearParkSdiSensor8RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor8RawDistData
    ///
    /// - Start bit: 9
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor8_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[9..18].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor8RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor8_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[9..18].store_le(value);
        Ok(())
    }
    
    /// PARK_sdiSensor9RawDistData
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "cm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn park_sdi_sensor9_raw_dist_data(&self) -> Id22eparkSdiRearParkSdiSensor9RawDistData {
        match self.park_sdi_sensor9_raw_dist_data_raw() {
            0 => Id22eparkSdiRearParkSdiSensor9RawDistData::Blocked,
            1 => Id22eparkSdiRearParkSdiSensor9RawDistData::NearDetection,
            500 => Id22eparkSdiRearParkSdiSensor9RawDistData::NoObjectDetected,
            511 => Id22eparkSdiRearParkSdiSensor9RawDistData::Sna,
            x => Id22eparkSdiRearParkSdiSensor9RawDistData::Other(x),
        }
    }
    
    /// Get raw value of PARK_sdiSensor9RawDistData
    ///
    /// - Start bit: 18
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn park_sdi_sensor9_raw_dist_data_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[18..27].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PARK_sdiSensor9RawDistData
    #[inline(always)]
    pub fn set_park_sdi_sensor9_raw_dist_data(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 558 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..27].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id22eparkSdiRear {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id22eparkSdiRear
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let park_sdi_rear_checksum = u.int_in_range(0..=255)?;
        let park_sdi_rear_counter = u.int_in_range(0..=3)?;
        let park_sdi_sensor10_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor11_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor12_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor7_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor8_raw_dist_data = u.int_in_range(0..=511)?;
        let park_sdi_sensor9_raw_dist_data = u.int_in_range(0..=511)?;
        Id22eparkSdiRear::new(park_sdi_rear_checksum,park_sdi_rear_counter,park_sdi_sensor10_raw_dist_data,park_sdi_sensor11_raw_dist_data,park_sdi_sensor12_raw_dist_data,park_sdi_sensor7_raw_dist_data,park_sdi_sensor8_raw_dist_data,park_sdi_sensor9_raw_dist_data).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for PARK_sdiSensor10RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22eparkSdiRearParkSdiSensor10RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor11RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22eparkSdiRearParkSdiSensor11RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor12RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22eparkSdiRearParkSdiSensor12RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor7RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22eparkSdiRearParkSdiSensor7RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor8RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22eparkSdiRearParkSdiSensor8RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}
/// Defined values for PARK_sdiSensor9RawDistData
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id22eparkSdiRearParkSdiSensor9RawDistData {
    Blocked,
    NearDetection,
    NoObjectDetected,
    Sna,
    Other(u16),
}

/// ID238UI_driverAssistMapData
///
/// - ID: 568 (0x238)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id238uiDriverAssistMapData {
    raw: [u8; 8],
}

impl Id238uiDriverAssistMapData {
    pub const MESSAGE_ID: u32 = 568;
    
    /// Construct new ID238UI_driverAssistMapData from values
    pub fn new(ui_accept_botts_dots: bool, ui_autosteer_restricted: bool, ui_controlled_access: bool, ui_country_code: u16, ui_gps_road_match: bool, ui_in_supercharger_geofence: bool, ui_map_data_checksum: u8, ui_map_data_counter: u8, ui_map_speed_limit: u8, ui_map_speed_limit_dependency: u8, ui_map_speed_limit_type: u8, ui_map_speed_units: bool, ui_nav_route_active: bool, ui_next_branch_dist: f32, ui_next_branch_left_off_ramp: bool, ui_next_branch_right_off_ramp: bool, ui_parallel_autopark_enabled: bool, ui_perpendicular_autopark_enabled: bool, ui_pmm_enabled: bool, ui_reject_autosteer: bool, ui_reject_hpp: bool, ui_reject_hands_on: bool, ui_reject_left_free_space: bool, ui_reject_left_lane: bool, ui_reject_nav: bool, ui_reject_right_free_space: bool, ui_reject_right_lane: bool, ui_road_class: u8, ui_sca_enabled: bool, ui_street_count: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_accept_botts_dots(ui_accept_botts_dots)?;
        res.set_ui_autosteer_restricted(ui_autosteer_restricted)?;
        res.set_ui_controlled_access(ui_controlled_access)?;
        res.set_ui_country_code(ui_country_code)?;
        res.set_ui_gps_road_match(ui_gps_road_match)?;
        res.set_ui_in_supercharger_geofence(ui_in_supercharger_geofence)?;
        res.set_ui_map_data_checksum(ui_map_data_checksum)?;
        res.set_ui_map_data_counter(ui_map_data_counter)?;
        res.set_ui_map_speed_limit(ui_map_speed_limit)?;
        res.set_ui_map_speed_limit_dependency(ui_map_speed_limit_dependency)?;
        res.set_ui_map_speed_limit_type(ui_map_speed_limit_type)?;
        res.set_ui_map_speed_units(ui_map_speed_units)?;
        res.set_ui_nav_route_active(ui_nav_route_active)?;
        res.set_ui_next_branch_dist(ui_next_branch_dist)?;
        res.set_ui_next_branch_left_off_ramp(ui_next_branch_left_off_ramp)?;
        res.set_ui_next_branch_right_off_ramp(ui_next_branch_right_off_ramp)?;
        res.set_ui_parallel_autopark_enabled(ui_parallel_autopark_enabled)?;
        res.set_ui_perpendicular_autopark_enabled(ui_perpendicular_autopark_enabled)?;
        res.set_ui_pmm_enabled(ui_pmm_enabled)?;
        res.set_ui_reject_autosteer(ui_reject_autosteer)?;
        res.set_ui_reject_hpp(ui_reject_hpp)?;
        res.set_ui_reject_hands_on(ui_reject_hands_on)?;
        res.set_ui_reject_left_free_space(ui_reject_left_free_space)?;
        res.set_ui_reject_left_lane(ui_reject_left_lane)?;
        res.set_ui_reject_nav(ui_reject_nav)?;
        res.set_ui_reject_right_free_space(ui_reject_right_free_space)?;
        res.set_ui_reject_right_lane(ui_reject_right_lane)?;
        res.set_ui_road_class(ui_road_class)?;
        res.set_ui_sca_enabled(ui_sca_enabled)?;
        res.set_ui_street_count(ui_street_count)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_acceptBottsDots
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_accept_botts_dots(&self) -> bool {
        self.ui_accept_botts_dots_raw()
    }
    
    /// Get raw value of UI_acceptBottsDots
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_accept_botts_dots_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_acceptBottsDots
    #[inline(always)]
    pub fn set_ui_accept_botts_dots(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// UI_autosteerRestricted
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_autosteer_restricted(&self) -> bool {
        self.ui_autosteer_restricted_raw()
    }
    
    /// Get raw value of UI_autosteerRestricted
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_autosteer_restricted_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_autosteerRestricted
    #[inline(always)]
    pub fn set_ui_autosteer_restricted(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// UI_controlledAccess
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_controlled_access(&self) -> bool {
        self.ui_controlled_access_raw()
    }
    
    /// Get raw value of UI_controlledAccess
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_controlled_access_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_controlledAccess
    #[inline(always)]
    pub fn set_ui_controlled_access(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// UI_countryCode
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_country_code(&self) -> Id238uiDriverAssistMapDataUiCountryCode {
        match self.ui_country_code_raw() {
            1023 => Id238uiDriverAssistMapDataUiCountryCode::Sna,
            0 => Id238uiDriverAssistMapDataUiCountryCode::Unknown,
            x => Id238uiDriverAssistMapDataUiCountryCode::Other(x),
        }
    }
    
    /// Get raw value of UI_countryCode
    ///
    /// - Start bit: 16
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_country_code_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..26].load_le::<u16>();
        
        signal
    }
    
    /// Set value of UI_countryCode
    #[inline(always)]
    pub fn set_ui_country_code(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..26].store_le(value);
        Ok(())
    }
    
    /// UI_gpsRoadMatch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_road_match(&self) -> bool {
        self.ui_gps_road_match_raw()
    }
    
    /// Get raw value of UI_gpsRoadMatch
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_road_match_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_gpsRoadMatch
    #[inline(always)]
    pub fn set_ui_gps_road_match(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// UI_inSuperchargerGeofence
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_in_supercharger_geofence(&self) -> bool {
        self.ui_in_supercharger_geofence_raw()
    }
    
    /// Get raw value of UI_inSuperchargerGeofence
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_in_supercharger_geofence_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_inSuperchargerGeofence
    #[inline(always)]
    pub fn set_ui_in_supercharger_geofence(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// UI_mapDataChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_data_checksum(&self) -> u8 {
        self.ui_map_data_checksum_raw()
    }
    
    /// Get raw value of UI_mapDataChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_data_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_mapDataChecksum
    #[inline(always)]
    pub fn set_ui_map_data_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// UI_mapDataCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_data_counter(&self) -> u8 {
        self.ui_map_data_counter_raw()
    }
    
    /// Get raw value of UI_mapDataCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_data_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_mapDataCounter
    #[inline(always)]
    pub fn set_ui_map_data_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// UI_mapSpeedLimit
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_speed_limit(&self) -> Id238uiDriverAssistMapDataUiMapSpeedLimit {
        match self.ui_map_speed_limit_raw() {
            3 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq10,
            21 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq100,
            22 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq105,
            23 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq110,
            24 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq115,
            25 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq120,
            26 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq130,
            27 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq140,
            4 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq15,
            28 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq150,
            29 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq160,
            5 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq20,
            6 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq25,
            7 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq30,
            8 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq35,
            9 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq40,
            10 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq45,
            1 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq5,
            11 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq50,
            12 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq55,
            13 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq60,
            14 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq65,
            2 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq7,
            15 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq70,
            16 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq75,
            17 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq80,
            18 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq85,
            19 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq90,
            20 => Id238uiDriverAssistMapDataUiMapSpeedLimit::LessOrEq95,
            31 => Id238uiDriverAssistMapDataUiMapSpeedLimit::Sna,
            0 => Id238uiDriverAssistMapDataUiMapSpeedLimit::Unknown,
            30 => Id238uiDriverAssistMapDataUiMapSpeedLimit::Unlimited,
            x => Id238uiDriverAssistMapDataUiMapSpeedLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_mapSpeedLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_speed_limit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_mapSpeedLimit
    #[inline(always)]
    pub fn set_ui_map_speed_limit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..13].store_le(value);
        Ok(())
    }
    
    /// UI_mapSpeedLimitDependency
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_speed_limit_dependency(&self) -> Id238uiDriverAssistMapDataUiMapSpeedLimitDependency {
        match self.ui_map_speed_limit_dependency_raw() {
            6 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Lane,
            0 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::None,
            2 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Rain,
            1 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::School,
            5 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Season,
            7 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Sna,
            3 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Snow,
            4 => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Time,
            x => Id238uiDriverAssistMapDataUiMapSpeedLimitDependency::Other(x),
        }
    }
    
    /// Get raw value of UI_mapSpeedLimitDependency
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_speed_limit_dependency_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_mapSpeedLimitDependency
    #[inline(always)]
    pub fn set_ui_map_speed_limit_dependency(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// UI_mapSpeedLimitType
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_speed_limit_type(&self) -> Id238uiDriverAssistMapDataUiMapSpeedLimitType {
        match self.ui_map_speed_limit_type_raw() {
            2 => Id238uiDriverAssistMapDataUiMapSpeedLimitType::Advisory,
            4 => Id238uiDriverAssistMapDataUiMapSpeedLimitType::Bumps,
            3 => Id238uiDriverAssistMapDataUiMapSpeedLimitType::Dependent,
            1 => Id238uiDriverAssistMapDataUiMapSpeedLimitType::Regular,
            7 => Id238uiDriverAssistMapDataUiMapSpeedLimitType::UnknownSna,
            x => Id238uiDriverAssistMapDataUiMapSpeedLimitType::Other(x),
        }
    }
    
    /// Get raw value of UI_mapSpeedLimitType
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_speed_limit_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_mapSpeedLimitType
    #[inline(always)]
    pub fn set_ui_map_speed_limit_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..16].store_le(value);
        Ok(())
    }
    
    /// UI_mapSpeedUnits
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_speed_units(&self) -> Id238uiDriverAssistMapDataUiMapSpeedUnits {
        match self.ui_map_speed_units_raw() {
            true => Id238uiDriverAssistMapDataUiMapSpeedUnits::Kph,
            false => Id238uiDriverAssistMapDataUiMapSpeedUnits::Mph,
            x => Id238uiDriverAssistMapDataUiMapSpeedUnits::Other(x),
        }
    }
    
    /// Get raw value of UI_mapSpeedUnits
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_speed_units_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_mapSpeedUnits
    #[inline(always)]
    pub fn set_ui_map_speed_units(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// UI_navRouteActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_nav_route_active(&self) -> bool {
        self.ui_nav_route_active_raw()
    }
    
    /// Get raw value of UI_navRouteActive
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_nav_route_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_navRouteActive
    #[inline(always)]
    pub fn set_ui_nav_route_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// UI_nextBranchDist
    ///
    /// - Min: 0
    /// - Max: 300
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_next_branch_dist(&self) -> Id238uiDriverAssistMapDataUiNextBranchDist {
        match self.ui_next_branch_dist_raw() {
            31 => Id238uiDriverAssistMapDataUiNextBranchDist::Sna,
            x => Id238uiDriverAssistMapDataUiNextBranchDist::Other(x),
        }
    }
    
    /// Get raw value of UI_nextBranchDist
    ///
    /// - Start bit: 32
    /// - Signal size: 5 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_next_branch_dist_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..37].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_nextBranchDist
    #[inline(always)]
    pub fn set_ui_next_branch_dist(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 300_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..37].store_le(value);
        Ok(())
    }
    
    /// UI_nextBranchLeftOffRamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_next_branch_left_off_ramp(&self) -> bool {
        self.ui_next_branch_left_off_ramp_raw()
    }
    
    /// Get raw value of UI_nextBranchLeftOffRamp
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_next_branch_left_off_ramp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_nextBranchLeftOffRamp
    #[inline(always)]
    pub fn set_ui_next_branch_left_off_ramp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// UI_nextBranchRightOffRamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_next_branch_right_off_ramp(&self) -> bool {
        self.ui_next_branch_right_off_ramp_raw()
    }
    
    /// Get raw value of UI_nextBranchRightOffRamp
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_next_branch_right_off_ramp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_nextBranchRightOffRamp
    #[inline(always)]
    pub fn set_ui_next_branch_right_off_ramp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// UI_parallelAutoparkEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_parallel_autopark_enabled(&self) -> bool {
        self.ui_parallel_autopark_enabled_raw()
    }
    
    /// Get raw value of UI_parallelAutoparkEnabled
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_parallel_autopark_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_parallelAutoparkEnabled
    #[inline(always)]
    pub fn set_ui_parallel_autopark_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// UI_perpendicularAutoparkEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_perpendicular_autopark_enabled(&self) -> bool {
        self.ui_perpendicular_autopark_enabled_raw()
    }
    
    /// Get raw value of UI_perpendicularAutoparkEnabled
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_perpendicular_autopark_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_perpendicularAutoparkEnabled
    #[inline(always)]
    pub fn set_ui_perpendicular_autopark_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// UI_pmmEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_pmm_enabled(&self) -> bool {
        self.ui_pmm_enabled_raw()
    }
    
    /// Get raw value of UI_pmmEnabled
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_pmm_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_pmmEnabled
    #[inline(always)]
    pub fn set_ui_pmm_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
    /// UI_rejectAutosteer
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_autosteer(&self) -> bool {
        self.ui_reject_autosteer_raw()
    }
    
    /// Get raw value of UI_rejectAutosteer
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_autosteer_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectAutosteer
    #[inline(always)]
    pub fn set_ui_reject_autosteer(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[46..47].store_le(value);
        Ok(())
    }
    
    /// UI_rejectHPP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_hpp(&self) -> bool {
        self.ui_reject_hpp_raw()
    }
    
    /// Get raw value of UI_rejectHPP
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_hpp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectHPP
    #[inline(always)]
    pub fn set_ui_reject_hpp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// UI_rejectHandsOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_hands_on(&self) -> bool {
        self.ui_reject_hands_on_raw()
    }
    
    /// Get raw value of UI_rejectHandsOn
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_hands_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectHandsOn
    #[inline(always)]
    pub fn set_ui_reject_hands_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[47..48].store_le(value);
        Ok(())
    }
    
    /// UI_rejectLeftFreeSpace
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_left_free_space(&self) -> bool {
        self.ui_reject_left_free_space_raw()
    }
    
    /// Get raw value of UI_rejectLeftFreeSpace
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_left_free_space_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectLeftFreeSpace
    #[inline(always)]
    pub fn set_ui_reject_left_free_space(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[44..45].store_le(value);
        Ok(())
    }
    
    /// UI_rejectLeftLane
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_left_lane(&self) -> bool {
        self.ui_reject_left_lane_raw()
    }
    
    /// Get raw value of UI_rejectLeftLane
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_left_lane_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectLeftLane
    #[inline(always)]
    pub fn set_ui_reject_left_lane(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// UI_rejectNav
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_nav(&self) -> bool {
        self.ui_reject_nav_raw()
    }
    
    /// Get raw value of UI_rejectNav
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_nav_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectNav
    #[inline(always)]
    pub fn set_ui_reject_nav(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// UI_rejectRightFreeSpace
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_right_free_space(&self) -> bool {
        self.ui_reject_right_free_space_raw()
    }
    
    /// Get raw value of UI_rejectRightFreeSpace
    ///
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_right_free_space_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[45..46].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectRightFreeSpace
    #[inline(always)]
    pub fn set_ui_reject_right_free_space(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[45..46].store_le(value);
        Ok(())
    }
    
    /// UI_rejectRightLane
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_reject_right_lane(&self) -> bool {
        self.ui_reject_right_lane_raw()
    }
    
    /// Get raw value of UI_rejectRightLane
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_reject_right_lane_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_rejectRightLane
    #[inline(always)]
    pub fn set_ui_reject_right_lane(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// UI_roadClass
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_road_class(&self) -> Id238uiDriverAssistMapDataUiRoadClass {
        match self.ui_road_class_raw() {
            1 => Id238uiDriverAssistMapDataUiRoadClass::Class1Major,
            2 => Id238uiDriverAssistMapDataUiRoadClass::Class2,
            3 => Id238uiDriverAssistMapDataUiRoadClass::Class3,
            4 => Id238uiDriverAssistMapDataUiRoadClass::Class4,
            5 => Id238uiDriverAssistMapDataUiRoadClass::Class5,
            6 => Id238uiDriverAssistMapDataUiRoadClass::Class6Minor,
            0 => Id238uiDriverAssistMapDataUiRoadClass::UnknownInvalidSna,
            x => Id238uiDriverAssistMapDataUiRoadClass::Other(x),
        }
    }
    
    /// Get raw value of UI_roadClass
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_road_class_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_roadClass
    #[inline(always)]
    pub fn set_ui_road_class(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// UI_scaEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_sca_enabled(&self) -> bool {
        self.ui_sca_enabled_raw()
    }
    
    /// Get raw value of UI_scaEnabled
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_sca_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_scaEnabled
    #[inline(always)]
    pub fn set_ui_sca_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// UI_streetCount
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_street_count(&self) -> u8 {
        self.ui_street_count_raw()
    }
    
    /// Get raw value of UI_streetCount
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_street_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_streetCount
    #[inline(always)]
    pub fn set_ui_street_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 568 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..28].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id238uiDriverAssistMapData {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id238uiDriverAssistMapData
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_accept_botts_dots = u.int_in_range(0..=1)? == 1;
        let ui_autosteer_restricted = u.int_in_range(0..=1)? == 1;
        let ui_controlled_access = u.int_in_range(0..=1)? == 1;
        let ui_country_code = u.int_in_range(0..=1023)?;
        let ui_gps_road_match = u.int_in_range(0..=1)? == 1;
        let ui_in_supercharger_geofence = u.int_in_range(0..=1)? == 1;
        let ui_map_data_checksum = u.int_in_range(0..=255)?;
        let ui_map_data_counter = u.int_in_range(0..=15)?;
        let ui_map_speed_limit = u.int_in_range(0..=31)?;
        let ui_map_speed_limit_dependency = u.int_in_range(0..=7)?;
        let ui_map_speed_limit_type = u.int_in_range(0..=7)?;
        let ui_map_speed_units = u.int_in_range(0..=1)? == 1;
        let ui_nav_route_active = u.int_in_range(0..=1)? == 1;
        let ui_next_branch_dist = 0_f32;
        let ui_next_branch_left_off_ramp = u.int_in_range(0..=1)? == 1;
        let ui_next_branch_right_off_ramp = u.int_in_range(0..=1)? == 1;
        let ui_parallel_autopark_enabled = u.int_in_range(0..=1)? == 1;
        let ui_perpendicular_autopark_enabled = u.int_in_range(0..=1)? == 1;
        let ui_pmm_enabled = u.int_in_range(0..=1)? == 1;
        let ui_reject_autosteer = u.int_in_range(0..=1)? == 1;
        let ui_reject_hpp = u.int_in_range(0..=1)? == 1;
        let ui_reject_hands_on = u.int_in_range(0..=1)? == 1;
        let ui_reject_left_free_space = u.int_in_range(0..=1)? == 1;
        let ui_reject_left_lane = u.int_in_range(0..=1)? == 1;
        let ui_reject_nav = u.int_in_range(0..=1)? == 1;
        let ui_reject_right_free_space = u.int_in_range(0..=1)? == 1;
        let ui_reject_right_lane = u.int_in_range(0..=1)? == 1;
        let ui_road_class = u.int_in_range(0..=6)?;
        let ui_sca_enabled = u.int_in_range(0..=1)? == 1;
        let ui_street_count = u.int_in_range(0..=3)?;
        Id238uiDriverAssistMapData::new(ui_accept_botts_dots,ui_autosteer_restricted,ui_controlled_access,ui_country_code,ui_gps_road_match,ui_in_supercharger_geofence,ui_map_data_checksum,ui_map_data_counter,ui_map_speed_limit,ui_map_speed_limit_dependency,ui_map_speed_limit_type,ui_map_speed_units,ui_nav_route_active,ui_next_branch_dist,ui_next_branch_left_off_ramp,ui_next_branch_right_off_ramp,ui_parallel_autopark_enabled,ui_perpendicular_autopark_enabled,ui_pmm_enabled,ui_reject_autosteer,ui_reject_hpp,ui_reject_hands_on,ui_reject_left_free_space,ui_reject_left_lane,ui_reject_nav,ui_reject_right_free_space,ui_reject_right_lane,ui_road_class,ui_sca_enabled,ui_street_count).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_countryCode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiCountryCode {
    Sna,
    Unknown,
    Other(u16),
}
/// Defined values for UI_mapSpeedLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiMapSpeedLimit {
    LessOrEq10,
    LessOrEq100,
    LessOrEq105,
    LessOrEq110,
    LessOrEq115,
    LessOrEq120,
    LessOrEq130,
    LessOrEq140,
    LessOrEq15,
    LessOrEq150,
    LessOrEq160,
    LessOrEq20,
    LessOrEq25,
    LessOrEq30,
    LessOrEq35,
    LessOrEq40,
    LessOrEq45,
    LessOrEq5,
    LessOrEq50,
    LessOrEq55,
    LessOrEq60,
    LessOrEq65,
    LessOrEq7,
    LessOrEq70,
    LessOrEq75,
    LessOrEq80,
    LessOrEq85,
    LessOrEq90,
    LessOrEq95,
    Sna,
    Unknown,
    Unlimited,
    Other(u8),
}
/// Defined values for UI_mapSpeedLimitDependency
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiMapSpeedLimitDependency {
    Lane,
    None,
    Rain,
    School,
    Season,
    Sna,
    Snow,
    Time,
    Other(u8),
}
/// Defined values for UI_mapSpeedLimitType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiMapSpeedLimitType {
    Advisory,
    Bumps,
    Dependent,
    Regular,
    UnknownSna,
    Other(u8),
}
/// Defined values for UI_mapSpeedUnits
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiMapSpeedUnits {
    Kph,
    Mph,
    Other(bool),
}
/// Defined values for UI_nextBranchDist
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiNextBranchDist {
    Sna,
    Other(f32),
}
/// Defined values for UI_roadClass
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id238uiDriverAssistMapDataUiRoadClass {
    Class1Major,
    Class2,
    Class3,
    Class4,
    Class5,
    Class6Minor,
    UnknownInvalidSna,
    Other(u8),
}

/// ID239DAS_lanes
///
/// - ID: 569 (0x239)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id239dasLanes {
    raw: [u8; 8],
}

impl Id239dasLanes {
    pub const MESSAGE_ID: u32 = 569;
    
    /// Construct new ID239DAS_lanes from values
    pub fn new(das_lanes_counter: u8, das_left_fork: u8, das_left_lane_exists: bool, das_left_line_usage: u8, das_right_fork: u8, das_right_lane_exists: bool, das_right_line_usage: u8, das_virtual_lane_c0: f32, das_virtual_lane_c1: f32, das_virtual_lane_c2: f32, das_virtual_lane_c3: f32, das_virtual_lane_view_range: u8, das_virtual_lane_width: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_lanes_counter(das_lanes_counter)?;
        res.set_das_left_fork(das_left_fork)?;
        res.set_das_left_lane_exists(das_left_lane_exists)?;
        res.set_das_left_line_usage(das_left_line_usage)?;
        res.set_das_right_fork(das_right_fork)?;
        res.set_das_right_lane_exists(das_right_lane_exists)?;
        res.set_das_right_line_usage(das_right_line_usage)?;
        res.set_das_virtual_lane_c0(das_virtual_lane_c0)?;
        res.set_das_virtual_lane_c1(das_virtual_lane_c1)?;
        res.set_das_virtual_lane_c2(das_virtual_lane_c2)?;
        res.set_das_virtual_lane_c3(das_virtual_lane_c3)?;
        res.set_das_virtual_lane_view_range(das_virtual_lane_view_range)?;
        res.set_das_virtual_lane_width(das_virtual_lane_width)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_lanesCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lanes_counter(&self) -> u8 {
        self.das_lanes_counter_raw()
    }
    
    /// Get raw value of DAS_lanesCounter
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lanes_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_lanesCounter
    #[inline(always)]
    pub fn set_das_lanes_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        self.raw.view_bits_mut::<LocalBits>()[60..64].store_le(value);
        Ok(())
    }
    
    /// DAS_leftFork
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_fork(&self) -> Id239dasLanesDasLeftFork {
        match self.das_left_fork_raw() {
            1 => Id239dasLanesDasLeftFork::LeftForkAvailable,
            0 => Id239dasLanesDasLeftFork::LeftForkNone,
            2 => Id239dasLanesDasLeftFork::LeftForkSelected,
            3 => Id239dasLanesDasLeftFork::LeftForkUnavailable,
            x => Id239dasLanesDasLeftFork::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftFork
    ///
    /// - Start bit: 52
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_fork_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leftFork
    #[inline(always)]
    pub fn set_das_left_fork(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..54].store_le(value);
        Ok(())
    }
    
    /// DAS_leftLaneExists
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_lane_exists(&self) -> bool {
        self.das_left_lane_exists_raw()
    }
    
    /// Get raw value of DAS_leftLaneExists
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_lane_exists_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_leftLaneExists
    #[inline(always)]
    pub fn set_das_left_lane_exists(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// DAS_leftLineUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_line_usage(&self) -> Id239dasLanesDasLeftLineUsage {
        match self.das_left_line_usage_raw() {
            1 => Id239dasLanesDasLeftLineUsage::Available,
            3 => Id239dasLanesDasLeftLineUsage::Blacklisted,
            2 => Id239dasLanesDasLeftLineUsage::Fused,
            0 => Id239dasLanesDasLeftLineUsage::RejectedUnavailable,
            x => Id239dasLanesDasLeftLineUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftLineUsage
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_line_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leftLineUsage
    #[inline(always)]
    pub fn set_das_left_line_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// DAS_rightFork
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_fork(&self) -> Id239dasLanesDasRightFork {
        match self.das_right_fork_raw() {
            1 => Id239dasLanesDasRightFork::RightForkAvailable,
            0 => Id239dasLanesDasRightFork::RightForkNone,
            2 => Id239dasLanesDasRightFork::RightForkSelected,
            3 => Id239dasLanesDasRightFork::RightForkUnavailable,
            x => Id239dasLanesDasRightFork::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightFork
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_fork_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_rightFork
    #[inline(always)]
    pub fn set_das_right_fork(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// DAS_rightLaneExists
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_lane_exists(&self) -> bool {
        self.das_right_lane_exists_raw()
    }
    
    /// Get raw value of DAS_rightLaneExists
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_lane_exists_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rightLaneExists
    #[inline(always)]
    pub fn set_das_right_lane_exists(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// DAS_rightLineUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_line_usage(&self) -> Id239dasLanesDasRightLineUsage {
        match self.das_right_line_usage_raw() {
            1 => Id239dasLanesDasRightLineUsage::Available,
            3 => Id239dasLanesDasRightLineUsage::Blacklisted,
            2 => Id239dasLanesDasRightLineUsage::Fused,
            0 => Id239dasLanesDasRightLineUsage::RejectedUnavailable,
            x => Id239dasLanesDasRightLineUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightLineUsage
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_line_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_rightLineUsage
    #[inline(always)]
    pub fn set_das_right_line_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..52].store_le(value);
        Ok(())
    }
    
    /// DAS_virtualLaneC0
    ///
    /// - Min: -3.5
    /// - Max: 3.5
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_virtual_lane_c0(&self) -> f32 {
        self.das_virtual_lane_c0_raw()
    }
    
    /// Get raw value of DAS_virtualLaneC0
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.035
    /// - Offset: -3.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_virtual_lane_c0_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.035_f32;
        let offset = -3.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_virtualLaneC0
    #[inline(always)]
    pub fn set_das_virtual_lane_c0(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.5_f32 || 3.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        let factor = 0.035_f32;
        let offset = -3.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DAS_virtualLaneC1
    ///
    /// - Min: -0.2
    /// - Max: 0.2
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_virtual_lane_c1(&self) -> f32 {
        self.das_virtual_lane_c1_raw()
    }
    
    /// Get raw value of DAS_virtualLaneC1
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.0016
    /// - Offset: -0.2
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_virtual_lane_c1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.0016_f32;
        let offset = -0.2_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_virtualLaneC1
    #[inline(always)]
    pub fn set_das_virtual_lane_c1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -0.2_f32 || 0.2_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        let factor = 0.0016_f32;
        let offset = -0.2_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DAS_virtualLaneC2
    ///
    /// - Min: -0.0025
    /// - Max: 0.0025
    /// - Unit: "m-1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_virtual_lane_c2(&self) -> f32 {
        self.das_virtual_lane_c2_raw()
    }
    
    /// Get raw value of DAS_virtualLaneC2
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.00002
    /// - Offset: -0.0025
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_virtual_lane_c2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.00002_f32;
        let offset = -0.0025_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_virtualLaneC2
    #[inline(always)]
    pub fn set_das_virtual_lane_c2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -0.0025_f32 || 0.0025_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        let factor = 0.00002_f32;
        let offset = -0.0025_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DAS_virtualLaneC3
    ///
    /// - Min: -0.00003
    /// - Max: 0.00003
    /// - Unit: "m-2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_virtual_lane_c3(&self) -> f32 {
        self.das_virtual_lane_c3_raw()
    }
    
    /// Get raw value of DAS_virtualLaneC3
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.00000024
    /// - Offset: -0.00003
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_virtual_lane_c3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.00000024_f32;
        let offset = -0.00003_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_virtualLaneC3
    #[inline(always)]
    pub fn set_das_virtual_lane_c3(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -0.00003_f32 || 0.00003_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        let factor = 0.00000024_f32;
        let offset = -0.00003_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DAS_virtualLaneViewRange
    ///
    /// - Min: 0
    /// - Max: 160
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_virtual_lane_view_range(&self) -> u8 {
        self.das_virtual_lane_view_range_raw()
    }
    
    /// Get raw value of DAS_virtualLaneViewRange
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_virtual_lane_view_range_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_virtualLaneViewRange
    #[inline(always)]
    pub fn set_das_virtual_lane_view_range(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 160_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DAS_virtualLaneWidth
    ///
    /// - Min: 2
    /// - Max: 6.6875
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_virtual_lane_width(&self) -> f32 {
        self.das_virtual_lane_width_raw()
    }
    
    /// Get raw value of DAS_virtualLaneWidth
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 0.3125
    /// - Offset: 2
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_virtual_lane_width_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[4..8].load_le::<u8>();
        
        let factor = 0.3125_f32;
        let offset = 2_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_virtualLaneWidth
    #[inline(always)]
    pub fn set_das_virtual_lane_width(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 2_f32 || 6.6875_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 569 }); }
        let factor = 0.3125_f32;
        let offset = 2_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[4..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id239dasLanes {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id239dasLanes
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_lanes_counter = u.int_in_range(0..=15)?;
        let das_left_fork = u.int_in_range(0..=3)?;
        let das_left_lane_exists = u.int_in_range(0..=1)? == 1;
        let das_left_line_usage = u.int_in_range(0..=3)?;
        let das_right_fork = u.int_in_range(0..=3)?;
        let das_right_lane_exists = u.int_in_range(0..=1)? == 1;
        let das_right_line_usage = u.int_in_range(0..=3)?;
        let das_virtual_lane_c0 = -3.5_f32;
        let das_virtual_lane_c1 = -0.2_f32;
        let das_virtual_lane_c2 = -0.0025_f32;
        let das_virtual_lane_c3 = -0.00003_f32;
        let das_virtual_lane_view_range = u.int_in_range(0..=160)?;
        let das_virtual_lane_width = 2_f32;
        Id239dasLanes::new(das_lanes_counter,das_left_fork,das_left_lane_exists,das_left_line_usage,das_right_fork,das_right_lane_exists,das_right_line_usage,das_virtual_lane_c0,das_virtual_lane_c1,das_virtual_lane_c2,das_virtual_lane_c3,das_virtual_lane_view_range,das_virtual_lane_width).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_leftFork
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id239dasLanesDasLeftFork {
    LeftForkAvailable,
    LeftForkNone,
    LeftForkSelected,
    LeftForkUnavailable,
    Other(u8),
}
/// Defined values for DAS_leftLineUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id239dasLanesDasLeftLineUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}
/// Defined values for DAS_rightFork
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id239dasLanesDasRightFork {
    RightForkAvailable,
    RightForkNone,
    RightForkSelected,
    RightForkUnavailable,
    Other(u8),
}
/// Defined values for DAS_rightLineUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id239dasLanesDasRightLineUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}

/// ID24ADAS_visualDebug
///
/// - ID: 586 (0x24a)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id24adasVisualDebug {
    raw: [u8; 8],
}

impl Id24adasVisualDebug {
    pub const MESSAGE_ID: u32 = 586;
    
    /// Construct new ID24ADAS_visualDebug from values
    pub fn new(das_acc_smart_speed_active: bool, das_acc_smart_speed_state: u8, das_autosteer_botts_dots_usage: u8, das_autosteer_hpp_usage: u8, das_autosteer_health_anomaly_level: u8, das_autosteer_health_state: u8, das_autosteer_model_usage: u8, das_autosteer_navigation_usage: u8, das_autosteer_vehicles_usage: u8, das_behavior_type: u8, das_dev_app_interface_enabled: bool, das_last_autosteer_abort_reason: u8, das_last_line_preference_reason: u8, das_nav_available: bool, das_nav_distance: f32, das_offset_side: u8, das_planner_state: u8, das_rear_left_veh_detected_current: bool, das_rear_left_veh_detected_trip: bool, das_rear_right_veh_detected_trip: bool, das_rear_veh_detected_this_cycle: bool, das_road_surface_type: u8, das_ulc_in_progress: bool, das_ulc_type: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_acc_smart_speed_active(das_acc_smart_speed_active)?;
        res.set_das_acc_smart_speed_state(das_acc_smart_speed_state)?;
        res.set_das_autosteer_botts_dots_usage(das_autosteer_botts_dots_usage)?;
        res.set_das_autosteer_hpp_usage(das_autosteer_hpp_usage)?;
        res.set_das_autosteer_health_anomaly_level(das_autosteer_health_anomaly_level)?;
        res.set_das_autosteer_health_state(das_autosteer_health_state)?;
        res.set_das_autosteer_model_usage(das_autosteer_model_usage)?;
        res.set_das_autosteer_navigation_usage(das_autosteer_navigation_usage)?;
        res.set_das_autosteer_vehicles_usage(das_autosteer_vehicles_usage)?;
        res.set_das_behavior_type(das_behavior_type)?;
        res.set_das_dev_app_interface_enabled(das_dev_app_interface_enabled)?;
        res.set_das_last_autosteer_abort_reason(das_last_autosteer_abort_reason)?;
        res.set_das_last_line_preference_reason(das_last_line_preference_reason)?;
        res.set_das_nav_available(das_nav_available)?;
        res.set_das_nav_distance(das_nav_distance)?;
        res.set_das_offset_side(das_offset_side)?;
        res.set_das_planner_state(das_planner_state)?;
        res.set_das_rear_left_veh_detected_current(das_rear_left_veh_detected_current)?;
        res.set_das_rear_left_veh_detected_trip(das_rear_left_veh_detected_trip)?;
        res.set_das_rear_right_veh_detected_trip(das_rear_right_veh_detected_trip)?;
        res.set_das_rear_veh_detected_this_cycle(das_rear_veh_detected_this_cycle)?;
        res.set_das_road_surface_type(das_road_surface_type)?;
        res.set_das_ulc_in_progress(das_ulc_in_progress)?;
        res.set_das_ulc_type(das_ulc_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_accSmartSpeedActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_acc_smart_speed_active(&self) -> bool {
        self.das_acc_smart_speed_active_raw()
    }
    
    /// Get raw value of DAS_accSmartSpeedActive
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_acc_smart_speed_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_accSmartSpeedActive
    #[inline(always)]
    pub fn set_das_acc_smart_speed_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// DAS_accSmartSpeedState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_acc_smart_speed_state(&self) -> Id24adasVisualDebugDasAccSmartSpeedState {
        match self.das_acc_smart_speed_state_raw() {
            2 => Id24adasVisualDebugDasAccSmartSpeedState::ActiveIntegrating,
            1 => Id24adasVisualDebugDasAccSmartSpeedState::ActiveOfframp,
            3 => Id24adasVisualDebugDasAccSmartSpeedState::ActiveOnramp,
            0 => Id24adasVisualDebugDasAccSmartSpeedState::NotActive,
            5 => Id24adasVisualDebugDasAccSmartSpeedState::OfframpDelay,
            4 => Id24adasVisualDebugDasAccSmartSpeedState::SetSpeedSetRequested,
            7 => Id24adasVisualDebugDasAccSmartSpeedState::Sna,
            x => Id24adasVisualDebugDasAccSmartSpeedState::Other(x),
        }
    }
    
    /// Get raw value of DAS_accSmartSpeedState
    ///
    /// - Start bit: 49
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_acc_smart_speed_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[49..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_accSmartSpeedState
    #[inline(always)]
    pub fn set_das_acc_smart_speed_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..52].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerBottsDotsUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_botts_dots_usage(&self) -> Id24adasVisualDebugDasAutosteerBottsDotsUsage {
        match self.das_autosteer_botts_dots_usage_raw() {
            1 => Id24adasVisualDebugDasAutosteerBottsDotsUsage::Available,
            3 => Id24adasVisualDebugDasAutosteerBottsDotsUsage::Blacklisted,
            2 => Id24adasVisualDebugDasAutosteerBottsDotsUsage::Fused,
            0 => Id24adasVisualDebugDasAutosteerBottsDotsUsage::RejectedUnavailable,
            x => Id24adasVisualDebugDasAutosteerBottsDotsUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_autosteerBottsDotsUsage
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_botts_dots_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerBottsDotsUsage
    #[inline(always)]
    pub fn set_das_autosteer_botts_dots_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerHPPUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_hpp_usage(&self) -> Id24adasVisualDebugDasAutosteerHppUsage {
        match self.das_autosteer_hpp_usage_raw() {
            1 => Id24adasVisualDebugDasAutosteerHppUsage::Available,
            3 => Id24adasVisualDebugDasAutosteerHppUsage::Blacklisted,
            2 => Id24adasVisualDebugDasAutosteerHppUsage::Fused,
            0 => Id24adasVisualDebugDasAutosteerHppUsage::RejectedUnavailable,
            x => Id24adasVisualDebugDasAutosteerHppUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_autosteerHPPUsage
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_hpp_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerHPPUsage
    #[inline(always)]
    pub fn set_das_autosteer_hpp_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerHealthAnomalyLevel
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_health_anomaly_level(&self) -> u8 {
        self.das_autosteer_health_anomaly_level_raw()
    }
    
    /// Get raw value of DAS_autosteerHealthAnomalyLevel
    ///
    /// - Start bit: 18
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_health_anomaly_level_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerHealthAnomalyLevel
    #[inline(always)]
    pub fn set_das_autosteer_health_anomaly_level(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..21].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerHealthState
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_health_state(&self) -> Id24adasVisualDebugDasAutosteerHealthState {
        match self.das_autosteer_health_state_raw() {
            4 => Id24adasVisualDebugDasAutosteerHealthState::HealthAborting,
            2 => Id24adasVisualDebugDasAutosteerHealthState::HealthDegraded,
            5 => Id24adasVisualDebugDasAutosteerHealthState::HealthFault,
            1 => Id24adasVisualDebugDasAutosteerHealthState::HealthNominal,
            3 => Id24adasVisualDebugDasAutosteerHealthState::HealthSeverelyDegraded,
            0 => Id24adasVisualDebugDasAutosteerHealthState::HealthUnavailable,
            x => Id24adasVisualDebugDasAutosteerHealthState::Other(x),
        }
    }
    
    /// Get raw value of DAS_autosteerHealthState
    ///
    /// - Start bit: 21
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_health_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerHealthState
    #[inline(always)]
    pub fn set_das_autosteer_health_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..24].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerModelUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_model_usage(&self) -> Id24adasVisualDebugDasAutosteerModelUsage {
        match self.das_autosteer_model_usage_raw() {
            1 => Id24adasVisualDebugDasAutosteerModelUsage::Available,
            3 => Id24adasVisualDebugDasAutosteerModelUsage::Blacklisted,
            2 => Id24adasVisualDebugDasAutosteerModelUsage::Fused,
            0 => Id24adasVisualDebugDasAutosteerModelUsage::RejectedUnavailable,
            x => Id24adasVisualDebugDasAutosteerModelUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_autosteerModelUsage
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_model_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerModelUsage
    #[inline(always)]
    pub fn set_das_autosteer_model_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerNavigationUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_navigation_usage(&self) -> Id24adasVisualDebugDasAutosteerNavigationUsage {
        match self.das_autosteer_navigation_usage_raw() {
            1 => Id24adasVisualDebugDasAutosteerNavigationUsage::Available,
            3 => Id24adasVisualDebugDasAutosteerNavigationUsage::Blacklisted,
            2 => Id24adasVisualDebugDasAutosteerNavigationUsage::Fused,
            0 => Id24adasVisualDebugDasAutosteerNavigationUsage::RejectedUnavailable,
            x => Id24adasVisualDebugDasAutosteerNavigationUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_autosteerNavigationUsage
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_navigation_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerNavigationUsage
    #[inline(always)]
    pub fn set_das_autosteer_navigation_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// DAS_autosteerVehiclesUsage
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autosteer_vehicles_usage(&self) -> Id24adasVisualDebugDasAutosteerVehiclesUsage {
        match self.das_autosteer_vehicles_usage_raw() {
            1 => Id24adasVisualDebugDasAutosteerVehiclesUsage::Available,
            3 => Id24adasVisualDebugDasAutosteerVehiclesUsage::Blacklisted,
            2 => Id24adasVisualDebugDasAutosteerVehiclesUsage::Fused,
            0 => Id24adasVisualDebugDasAutosteerVehiclesUsage::RejectedUnavailable,
            x => Id24adasVisualDebugDasAutosteerVehiclesUsage::Other(x),
        }
    }
    
    /// Get raw value of DAS_autosteerVehiclesUsage
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autosteer_vehicles_usage_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autosteerVehiclesUsage
    #[inline(always)]
    pub fn set_das_autosteer_vehicles_usage(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// DAS_behaviorType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_behavior_type(&self) -> Id24adasVisualDebugDasBehaviorType {
        match self.das_behavior_type_raw() {
            0 => Id24adasVisualDebugDasBehaviorType::DasBehaviorInvalid,
            1 => Id24adasVisualDebugDasBehaviorType::DasBehaviorInLane,
            2 => Id24adasVisualDebugDasBehaviorType::DasBehaviorLaneChangeLeft,
            3 => Id24adasVisualDebugDasBehaviorType::DasBehaviorLaneChangeRight,
            x => Id24adasVisualDebugDasBehaviorType::Other(x),
        }
    }
    
    /// Get raw value of DAS_behaviorType
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_behavior_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_behaviorType
    #[inline(always)]
    pub fn set_das_behavior_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..58].store_le(value);
        Ok(())
    }
    
    /// DAS_devAppInterfaceEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_dev_app_interface_enabled(&self) -> bool {
        self.das_dev_app_interface_enabled_raw()
    }
    
    /// Get raw value of DAS_devAppInterfaceEnabled
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_dev_app_interface_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_devAppInterfaceEnabled
    #[inline(always)]
    pub fn set_das_dev_app_interface_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// DAS_lastAutosteerAbortReason
    ///
    /// - Min: 0
    /// - Max: 34
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_last_autosteer_abort_reason(&self) -> Id24adasVisualDebugDasLastAutosteerAbortReason {
        match self.das_last_autosteer_abort_reason_raw() {
            29 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonAccCancel,
            32 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonAeb,
            14 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonAppMeStateNotVision,
            30 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonCameraFailsafes,
            16 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonCamMsgMia,
            17 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonCamWatchdog,
            23 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonCidSwitchDisabled,
            21 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonComponentMia,
            22 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonCruiseFault,
            24 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonDrivingOffNav,
            20 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonEpasEacDenied,
            28 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonEpasErrorCode,
            26 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonFollowerOutputInvalid,
            0 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonHmLaneViewRange,
            2 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonHmSteeringError,
            1 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonHmVirtualLaneNoInputs,
            15 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonMeMainStateNotVision,
            31 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonNoAbort,
            27 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonPlannerOutputInvalid,
            33 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonSeatbeltUnbuckled,
            19 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonSideCollisionImminent,
            18 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonTrailerMode,
            34 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonUserOverrideStrikeout,
            25 => Id24adasVisualDebugDasLastAutosteerAbortReason::UiAbortReasonVehicleSpeedAboveMax,
            x => Id24adasVisualDebugDasLastAutosteerAbortReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_lastAutosteerAbortReason
    ///
    /// - Start bit: 32
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_last_autosteer_abort_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_lastAutosteerAbortReason
    #[inline(always)]
    pub fn set_das_last_autosteer_abort_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 34_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..38].store_le(value);
        Ok(())
    }
    
    /// DAS_lastLinePreferenceReason
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_last_line_preference_reason(&self) -> Id24adasVisualDebugDasLastLinePreferenceReason {
        match self.das_last_line_preference_reason_raw() {
            1 => Id24adasVisualDebugDasLastLinePreferenceReason::AgreementWithNeighborLanes,
            4 => Id24adasVisualDebugDasLastLinePreferenceReason::AvoidOncomingLanes,
            5 => Id24adasVisualDebugDasLastLinePreferenceReason::CountryDrivingSide,
            3 => Id24adasVisualDebugDasLastLinePreferenceReason::NavigationBranch,
            2 => Id24adasVisualDebugDasLastLinePreferenceReason::NeighborLaneProbabiliy,
            15 => Id24adasVisualDebugDasLastLinePreferenceReason::None,
            0 => Id24adasVisualDebugDasLastLinePreferenceReason::OtherLaneDisagreesWithModel,
            x => Id24adasVisualDebugDasLastLinePreferenceReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_lastLinePreferenceReason
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_last_line_preference_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_lastLinePreferenceReason
    #[inline(always)]
    pub fn set_das_last_line_preference_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..28].store_le(value);
        Ok(())
    }
    
    /// DAS_navAvailable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_nav_available(&self) -> Id24adasVisualDebugDasNavAvailable {
        match self.das_nav_available_raw() {
            true => Id24adasVisualDebugDasNavAvailable::DasNavAvailable,
            false => Id24adasVisualDebugDasNavAvailable::DasNavUnavailable,
            x => Id24adasVisualDebugDasNavAvailable::Other(x),
        }
    }
    
    /// Get raw value of DAS_navAvailable
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_nav_available_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_navAvailable
    #[inline(always)]
    pub fn set_das_nav_available(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// DAS_navDistance
    ///
    /// - Min: 0
    /// - Max: 25500
    /// - Unit: "km"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_nav_distance(&self) -> f32 {
        self.das_nav_distance_raw()
    }
    
    /// Get raw value of DAS_navDistance
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 100
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_nav_distance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 100_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_navDistance
    #[inline(always)]
    pub fn set_das_nav_distance(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        let factor = 100_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DAS_offsetSide
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_offset_side(&self) -> Id24adasVisualDebugDasOffsetSide {
        match self.das_offset_side_raw() {
            0 => Id24adasVisualDebugDasOffsetSide::NoOffset,
            3 => Id24adasVisualDebugDasOffsetSide::OffsetBothObjects,
            2 => Id24adasVisualDebugDasOffsetSide::OffsetLeftObject,
            1 => Id24adasVisualDebugDasOffsetSide::OffsetRightObject,
            x => Id24adasVisualDebugDasOffsetSide::Other(x),
        }
    }
    
    /// Get raw value of DAS_offsetSide
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_offset_side_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_offsetSide
    #[inline(always)]
    pub fn set_das_offset_side(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// DAS_plannerState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_planner_state(&self) -> Id24adasVisualDebugDasPlannerState {
        match self.das_planner_state_raw() {
            0 => Id24adasVisualDebugDasPlannerState::TpExtstateDisabled,
            2 => Id24adasVisualDebugDasPlannerState::TpExtstateFollow,
            7 => Id24adasVisualDebugDasPlannerState::TpExtstateLanechangeAbort,
            4 => Id24adasVisualDebugDasPlannerState::TpExtstateLanechangeInProgress,
            3 => Id24adasVisualDebugDasPlannerState::TpExtstateLanechangeRequested,
            6 => Id24adasVisualDebugDasPlannerState::TpExtstateLanechangeWaitForFwdObstacle,
            5 => Id24adasVisualDebugDasPlannerState::TpExtstateLanechangeWaitForSideObstacle,
            1 => Id24adasVisualDebugDasPlannerState::TpExtstateVl,
            x => Id24adasVisualDebugDasPlannerState::Other(x),
        }
    }
    
    /// Get raw value of DAS_plannerState
    ///
    /// - Start bit: 28
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_planner_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_plannerState
    #[inline(always)]
    pub fn set_das_planner_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..32].store_le(value);
        Ok(())
    }
    
    /// DAS_rearLeftVehDetectedCurrent
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_rear_left_veh_detected_current(&self) -> Id24adasVisualDebugDasRearLeftVehDetectedCurrent {
        match self.das_rear_left_veh_detected_current_raw() {
            true => Id24adasVisualDebugDasRearLeftVehDetectedCurrent::VehicleDetected,
            false => Id24adasVisualDebugDasRearLeftVehDetectedCurrent::VehicleNotDetected,
            x => Id24adasVisualDebugDasRearLeftVehDetectedCurrent::Other(x),
        }
    }
    
    /// Get raw value of DAS_rearLeftVehDetectedCurrent
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_rear_left_veh_detected_current_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rearLeftVehDetectedCurrent
    #[inline(always)]
    pub fn set_das_rear_left_veh_detected_current(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// DAS_rearLeftVehDetectedTrip
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_rear_left_veh_detected_trip(&self) -> Id24adasVisualDebugDasRearLeftVehDetectedTrip {
        match self.das_rear_left_veh_detected_trip_raw() {
            true => Id24adasVisualDebugDasRearLeftVehDetectedTrip::VehicleDetected,
            false => Id24adasVisualDebugDasRearLeftVehDetectedTrip::VehicleNotDetected,
            x => Id24adasVisualDebugDasRearLeftVehDetectedTrip::Other(x),
        }
    }
    
    /// Get raw value of DAS_rearLeftVehDetectedTrip
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_rear_left_veh_detected_trip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rearLeftVehDetectedTrip
    #[inline(always)]
    pub fn set_das_rear_left_veh_detected_trip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// DAS_rearRightVehDetectedTrip
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_rear_right_veh_detected_trip(&self) -> Id24adasVisualDebugDasRearRightVehDetectedTrip {
        match self.das_rear_right_veh_detected_trip_raw() {
            true => Id24adasVisualDebugDasRearRightVehDetectedTrip::VehicleDetected,
            false => Id24adasVisualDebugDasRearRightVehDetectedTrip::VehicleNotDetected,
            x => Id24adasVisualDebugDasRearRightVehDetectedTrip::Other(x),
        }
    }
    
    /// Get raw value of DAS_rearRightVehDetectedTrip
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_rear_right_veh_detected_trip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rearRightVehDetectedTrip
    #[inline(always)]
    pub fn set_das_rear_right_veh_detected_trip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// DAS_rearVehDetectedThisCycle
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_rear_veh_detected_this_cycle(&self) -> Id24adasVisualDebugDasRearVehDetectedThisCycle {
        match self.das_rear_veh_detected_this_cycle_raw() {
            true => Id24adasVisualDebugDasRearVehDetectedThisCycle::VehicleDetected,
            false => Id24adasVisualDebugDasRearVehDetectedThisCycle::VehicleNotDetected,
            x => Id24adasVisualDebugDasRearVehDetectedThisCycle::Other(x),
        }
    }
    
    /// Get raw value of DAS_rearVehDetectedThisCycle
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_rear_veh_detected_this_cycle_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rearVehDetectedThisCycle
    #[inline(always)]
    pub fn set_das_rear_veh_detected_this_cycle(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSurfaceType
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_surface_type(&self) -> Id24adasVisualDebugDasRoadSurfaceType {
        match self.das_road_surface_type_raw() {
            2 => Id24adasVisualDebugDasRoadSurfaceType::RoadSurfaceEnhanced,
            1 => Id24adasVisualDebugDasRoadSurfaceType::RoadSurfaceNormal,
            0 => Id24adasVisualDebugDasRoadSurfaceType::RoadSurfaceSna,
            x => Id24adasVisualDebugDasRoadSurfaceType::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSurfaceType
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_surface_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_roadSurfaceType
    #[inline(always)]
    pub fn set_das_road_surface_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// DAS_ulcInProgress
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_ulc_in_progress(&self) -> Id24adasVisualDebugDasUlcInProgress {
        match self.das_ulc_in_progress_raw() {
            true => Id24adasVisualDebugDasUlcInProgress::UlcActive,
            false => Id24adasVisualDebugDasUlcInProgress::UlcInactive,
            x => Id24adasVisualDebugDasUlcInProgress::Other(x),
        }
    }
    
    /// Get raw value of DAS_ulcInProgress
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_ulc_in_progress_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_ulcInProgress
    #[inline(always)]
    pub fn set_das_ulc_in_progress(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[52..53].store_le(value);
        Ok(())
    }
    
    /// DAS_ulcType
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_ulc_type(&self) -> Id24adasVisualDebugDasUlcType {
        match self.das_ulc_type_raw() {
            1 => Id24adasVisualDebugDasUlcType::UlcTypeNav,
            0 => Id24adasVisualDebugDasUlcType::UlcTypeNone,
            2 => Id24adasVisualDebugDasUlcType::UlcTypeSpeed,
            x => Id24adasVisualDebugDasUlcType::Other(x),
        }
    }
    
    /// Get raw value of DAS_ulcType
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_ulc_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_ulcType
    #[inline(always)]
    pub fn set_das_ulc_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 586 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..60].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id24adasVisualDebug {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id24adasVisualDebug
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_acc_smart_speed_active = u.int_in_range(0..=1)? == 1;
        let das_acc_smart_speed_state = u.int_in_range(0..=7)?;
        let das_autosteer_botts_dots_usage = u.int_in_range(0..=3)?;
        let das_autosteer_hpp_usage = u.int_in_range(0..=3)?;
        let das_autosteer_health_anomaly_level = u.int_in_range(0..=7)?;
        let das_autosteer_health_state = u.int_in_range(0..=5)?;
        let das_autosteer_model_usage = u.int_in_range(0..=3)?;
        let das_autosteer_navigation_usage = u.int_in_range(0..=3)?;
        let das_autosteer_vehicles_usage = u.int_in_range(0..=3)?;
        let das_behavior_type = u.int_in_range(0..=3)?;
        let das_dev_app_interface_enabled = u.int_in_range(0..=1)? == 1;
        let das_last_autosteer_abort_reason = u.int_in_range(0..=34)?;
        let das_last_line_preference_reason = u.int_in_range(0..=15)?;
        let das_nav_available = u.int_in_range(0..=1)? == 1;
        let das_nav_distance = 0_f32;
        let das_offset_side = u.int_in_range(0..=3)?;
        let das_planner_state = u.int_in_range(0..=7)?;
        let das_rear_left_veh_detected_current = u.int_in_range(0..=1)? == 1;
        let das_rear_left_veh_detected_trip = u.int_in_range(0..=1)? == 1;
        let das_rear_right_veh_detected_trip = u.int_in_range(0..=1)? == 1;
        let das_rear_veh_detected_this_cycle = u.int_in_range(0..=1)? == 1;
        let das_road_surface_type = u.int_in_range(0..=2)?;
        let das_ulc_in_progress = u.int_in_range(0..=1)? == 1;
        let das_ulc_type = u.int_in_range(0..=2)?;
        Id24adasVisualDebug::new(das_acc_smart_speed_active,das_acc_smart_speed_state,das_autosteer_botts_dots_usage,das_autosteer_hpp_usage,das_autosteer_health_anomaly_level,das_autosteer_health_state,das_autosteer_model_usage,das_autosteer_navigation_usage,das_autosteer_vehicles_usage,das_behavior_type,das_dev_app_interface_enabled,das_last_autosteer_abort_reason,das_last_line_preference_reason,das_nav_available,das_nav_distance,das_offset_side,das_planner_state,das_rear_left_veh_detected_current,das_rear_left_veh_detected_trip,das_rear_right_veh_detected_trip,das_rear_veh_detected_this_cycle,das_road_surface_type,das_ulc_in_progress,das_ulc_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_accSmartSpeedState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAccSmartSpeedState {
    ActiveIntegrating,
    ActiveOfframp,
    ActiveOnramp,
    NotActive,
    OfframpDelay,
    SetSpeedSetRequested,
    Sna,
    Other(u8),
}
/// Defined values for DAS_autosteerBottsDotsUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAutosteerBottsDotsUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}
/// Defined values for DAS_autosteerHPPUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAutosteerHppUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}
/// Defined values for DAS_autosteerHealthState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAutosteerHealthState {
    HealthAborting,
    HealthDegraded,
    HealthFault,
    HealthNominal,
    HealthSeverelyDegraded,
    HealthUnavailable,
    Other(u8),
}
/// Defined values for DAS_autosteerModelUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAutosteerModelUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}
/// Defined values for DAS_autosteerNavigationUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAutosteerNavigationUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}
/// Defined values for DAS_autosteerVehiclesUsage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasAutosteerVehiclesUsage {
    Available,
    Blacklisted,
    Fused,
    RejectedUnavailable,
    Other(u8),
}
/// Defined values for DAS_behaviorType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasBehaviorType {
    DasBehaviorInvalid,
    DasBehaviorInLane,
    DasBehaviorLaneChangeLeft,
    DasBehaviorLaneChangeRight,
    Other(u8),
}
/// Defined values for DAS_lastAutosteerAbortReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasLastAutosteerAbortReason {
    UiAbortReasonAccCancel,
    UiAbortReasonAeb,
    UiAbortReasonAppMeStateNotVision,
    UiAbortReasonCameraFailsafes,
    UiAbortReasonCamMsgMia,
    UiAbortReasonCamWatchdog,
    UiAbortReasonCidSwitchDisabled,
    UiAbortReasonComponentMia,
    UiAbortReasonCruiseFault,
    UiAbortReasonDrivingOffNav,
    UiAbortReasonEpasEacDenied,
    UiAbortReasonEpasErrorCode,
    UiAbortReasonFollowerOutputInvalid,
    UiAbortReasonHmLaneViewRange,
    UiAbortReasonHmSteeringError,
    UiAbortReasonHmVirtualLaneNoInputs,
    UiAbortReasonMeMainStateNotVision,
    UiAbortReasonNoAbort,
    UiAbortReasonPlannerOutputInvalid,
    UiAbortReasonSeatbeltUnbuckled,
    UiAbortReasonSideCollisionImminent,
    UiAbortReasonTrailerMode,
    UiAbortReasonUserOverrideStrikeout,
    UiAbortReasonVehicleSpeedAboveMax,
    Other(u8),
}
/// Defined values for DAS_lastLinePreferenceReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasLastLinePreferenceReason {
    AgreementWithNeighborLanes,
    AvoidOncomingLanes,
    CountryDrivingSide,
    NavigationBranch,
    NeighborLaneProbabiliy,
    None,
    OtherLaneDisagreesWithModel,
    Other(u8),
}
/// Defined values for DAS_navAvailable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasNavAvailable {
    DasNavAvailable,
    DasNavUnavailable,
    Other(bool),
}
/// Defined values for DAS_offsetSide
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasOffsetSide {
    NoOffset,
    OffsetBothObjects,
    OffsetLeftObject,
    OffsetRightObject,
    Other(u8),
}
/// Defined values for DAS_plannerState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasPlannerState {
    TpExtstateDisabled,
    TpExtstateFollow,
    TpExtstateLanechangeAbort,
    TpExtstateLanechangeInProgress,
    TpExtstateLanechangeRequested,
    TpExtstateLanechangeWaitForFwdObstacle,
    TpExtstateLanechangeWaitForSideObstacle,
    TpExtstateVl,
    Other(u8),
}
/// Defined values for DAS_rearLeftVehDetectedCurrent
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasRearLeftVehDetectedCurrent {
    VehicleDetected,
    VehicleNotDetected,
    Other(bool),
}
/// Defined values for DAS_rearLeftVehDetectedTrip
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasRearLeftVehDetectedTrip {
    VehicleDetected,
    VehicleNotDetected,
    Other(bool),
}
/// Defined values for DAS_rearRightVehDetectedTrip
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasRearRightVehDetectedTrip {
    VehicleDetected,
    VehicleNotDetected,
    Other(bool),
}
/// Defined values for DAS_rearVehDetectedThisCycle
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasRearVehDetectedThisCycle {
    VehicleDetected,
    VehicleNotDetected,
    Other(bool),
}
/// Defined values for DAS_roadSurfaceType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasRoadSurfaceType {
    RoadSurfaceEnhanced,
    RoadSurfaceNormal,
    RoadSurfaceSna,
    Other(u8),
}
/// Defined values for DAS_ulcInProgress
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasUlcInProgress {
    UlcActive,
    UlcInactive,
    Other(bool),
}
/// Defined values for DAS_ulcType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id24adasVisualDebugDasUlcType {
    UlcTypeNav,
    UlcTypeNone,
    UlcTypeSpeed,
    Other(u8),
}

/// ID25BAPP_environment
///
/// - ID: 603 (0x25b)
/// - Size: 1 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id25bappEnvironment {
    raw: [u8; 1],
}

impl Id25bappEnvironment {
    pub const MESSAGE_ID: u32 = 603;
    
    /// Construct new ID25BAPP_environment from values
    pub fn new(app_environment_rainy: bool, app_environment_snowy: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 1] };
        res.set_app_environment_rainy(app_environment_rainy)?;
        res.set_app_environment_snowy(app_environment_snowy)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// APP_environmentRainy
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn app_environment_rainy(&self) -> bool {
        self.app_environment_rainy_raw()
    }
    
    /// Get raw value of APP_environmentRainy
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn app_environment_rainy_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of APP_environmentRainy
    #[inline(always)]
    pub fn set_app_environment_rainy(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// APP_environmentSnowy
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn app_environment_snowy(&self) -> bool {
        self.app_environment_snowy_raw()
    }
    
    /// Get raw value of APP_environmentSnowy
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn app_environment_snowy_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of APP_environmentSnowy
    #[inline(always)]
    pub fn set_app_environment_snowy(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id25bappEnvironment {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 1 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 1];
        raw.copy_from_slice(&payload[..1]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id25bappEnvironment
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let app_environment_rainy = u.int_in_range(0..=1)? == 1;
        let app_environment_snowy = u.int_in_range(0..=1)? == 1;
        Id25bappEnvironment::new(app_environment_rainy,app_environment_snowy).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID25DCP_status
///
/// - ID: 605 (0x25d)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id25dcpStatus {
    raw: [u8; 8],
}

impl Id25dcpStatus {
    pub const MESSAGE_ID: u32 = 605;
    
    /// Construct new ID25DCP_status from values
    pub fn new(cp_uhf_control_state: u8, cp_uhf_handle_found: bool, cp_aps_voltage: f32, cp_charge_cable_present: bool, cp_charge_cable_secured: bool, cp_charge_cable_state: u8, cp_charge_door_open: bool, cp_charge_door_open_ui: bool, cp_cold_weather_mode: bool, cp_cover_closed: bool, cp_door_button_pressed: bool, cp_door_control_state: u8, cp_door_open_requested: bool, cp_fault_line_sensed: bool, cp_hv_inlet_exposed: bool, cp_inductive_door_state: u8, cp_inductive_sensor_state: u8, cp_insert_enable_line: bool, cp_latch2_control_state: u8, cp_latch2_state: u8, cp_latch_control_state: u8, cp_latch_engaged: bool, cp_latch_state: u8, cp_led_color: u8, cp_num_alerts_set: u8, cp_permanent_power_request: bool, cp_swcan_relay_closed: bool, cp_type: u8, cp_vehicle_unlock_request: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cp_uhf_control_state(cp_uhf_control_state)?;
        res.set_cp_uhf_handle_found(cp_uhf_handle_found)?;
        res.set_cp_aps_voltage(cp_aps_voltage)?;
        res.set_cp_charge_cable_present(cp_charge_cable_present)?;
        res.set_cp_charge_cable_secured(cp_charge_cable_secured)?;
        res.set_cp_charge_cable_state(cp_charge_cable_state)?;
        res.set_cp_charge_door_open(cp_charge_door_open)?;
        res.set_cp_charge_door_open_ui(cp_charge_door_open_ui)?;
        res.set_cp_cold_weather_mode(cp_cold_weather_mode)?;
        res.set_cp_cover_closed(cp_cover_closed)?;
        res.set_cp_door_button_pressed(cp_door_button_pressed)?;
        res.set_cp_door_control_state(cp_door_control_state)?;
        res.set_cp_door_open_requested(cp_door_open_requested)?;
        res.set_cp_fault_line_sensed(cp_fault_line_sensed)?;
        res.set_cp_hv_inlet_exposed(cp_hv_inlet_exposed)?;
        res.set_cp_inductive_door_state(cp_inductive_door_state)?;
        res.set_cp_inductive_sensor_state(cp_inductive_sensor_state)?;
        res.set_cp_insert_enable_line(cp_insert_enable_line)?;
        res.set_cp_latch2_control_state(cp_latch2_control_state)?;
        res.set_cp_latch2_state(cp_latch2_state)?;
        res.set_cp_latch_control_state(cp_latch_control_state)?;
        res.set_cp_latch_engaged(cp_latch_engaged)?;
        res.set_cp_latch_state(cp_latch_state)?;
        res.set_cp_led_color(cp_led_color)?;
        res.set_cp_num_alerts_set(cp_num_alerts_set)?;
        res.set_cp_permanent_power_request(cp_permanent_power_request)?;
        res.set_cp_swcan_relay_closed(cp_swcan_relay_closed)?;
        res.set_cp_type(cp_type)?;
        res.set_cp_vehicle_unlock_request(cp_vehicle_unlock_request)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_UHF_controlState
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_control_state(&self) -> Id25dcpStatusCpUhfControlState {
        match self.cp_uhf_control_state_raw() {
            3 => Id25dcpStatusCpUhfControlState::CpUhfCalibrate,
            6 => Id25dcpStatusCpUhfControlState::CpUhfCheckRx,
            1 => Id25dcpStatusCpUhfControlState::CpUhfConfig,
            10 => Id25dcpStatusCpUhfControlState::CpUhfFault,
            8 => Id25dcpStatusCpUhfControlState::CpUhfHandleFound,
            2 => Id25dcpStatusCpUhfControlState::CpUhfIdle,
            0 => Id25dcpStatusCpUhfControlState::CpUhfInit,
            4 => Id25dcpStatusCpUhfControlState::CpUhfPrepareRx,
            7 => Id25dcpStatusCpUhfControlState::CpUhfReadRxfifo,
            5 => Id25dcpStatusCpUhfControlState::CpUhfRx,
            9 => Id25dcpStatusCpUhfControlState::CpUhfSleep,
            x => Id25dcpStatusCpUhfControlState::Other(x),
        }
    }
    
    /// Get raw value of CP_UHF_controlState
    ///
    /// - Start bit: 38
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_control_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_UHF_controlState
    #[inline(always)]
    pub fn set_cp_uhf_control_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..42].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_handleFound
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_handle_found(&self) -> bool {
        self.cp_uhf_handle_found_raw()
    }
    
    /// Get raw value of CP_UHF_handleFound
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_handle_found_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_UHF_handleFound
    #[inline(always)]
    pub fn set_cp_uhf_handle_found(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// CP_apsVoltage
    ///
    /// - Min: 0
    /// - Max: 18.249
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_aps_voltage(&self) -> f32 {
        self.cp_aps_voltage_raw()
    }
    
    /// Get raw value of CP_apsVoltage
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.0715686
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_aps_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.0715686_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_apsVoltage
    #[inline(always)]
    pub fn set_cp_aps_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 18.249_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        let factor = 0.0715686_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CP_chargeCablePresent
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_cable_present(&self) -> Id25dcpStatusCpChargeCablePresent {
        match self.cp_charge_cable_present_raw() {
            false => Id25dcpStatusCpChargeCablePresent::CableNotPresent,
            true => Id25dcpStatusCpChargeCablePresent::CablePresent,
            x => Id25dcpStatusCpChargeCablePresent::Other(x),
        }
    }
    
    /// Get raw value of CP_chargeCablePresent
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_cable_present_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_chargeCablePresent
    #[inline(always)]
    pub fn set_cp_charge_cable_present(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CP_chargeCableSecured
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_cable_secured(&self) -> bool {
        self.cp_charge_cable_secured_raw()
    }
    
    /// Get raw value of CP_chargeCableSecured
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_cable_secured_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_chargeCableSecured
    #[inline(always)]
    pub fn set_cp_charge_cable_secured(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CP_chargeCableState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_cable_state(&self) -> Id25dcpStatusCpChargeCableState {
        match self.cp_charge_cable_state_raw() {
            2 => Id25dcpStatusCpChargeCableState::ChargeCableConnected,
            1 => Id25dcpStatusCpChargeCableState::ChargeCableNotConnected,
            0 => Id25dcpStatusCpChargeCableState::ChargeCableUnknownSna,
            x => Id25dcpStatusCpChargeCableState::Other(x),
        }
    }
    
    /// Get raw value of CP_chargeCableState
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_cable_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_chargeCableState
    #[inline(always)]
    pub fn set_cp_charge_cable_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CP_chargeDoorOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_door_open(&self) -> bool {
        self.cp_charge_door_open_raw()
    }
    
    /// Get raw value of CP_chargeDoorOpen
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_door_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_chargeDoorOpen
    #[inline(always)]
    pub fn set_cp_charge_door_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// CP_chargeDoorOpenUI
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_door_open_ui(&self) -> bool {
        self.cp_charge_door_open_ui_raw()
    }
    
    /// Get raw value of CP_chargeDoorOpenUI
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_door_open_ui_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_chargeDoorOpenUI
    #[inline(always)]
    pub fn set_cp_charge_door_open_ui(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// CP_coldWeatherMode
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_cold_weather_mode(&self) -> Id25dcpStatusCpColdWeatherMode {
        match self.cp_cold_weather_mode_raw() {
            true => Id25dcpStatusCpColdWeatherMode::CpColdWeatherLatchMitigation,
            false => Id25dcpStatusCpColdWeatherMode::CpColdWeatherNone,
            x => Id25dcpStatusCpColdWeatherMode::Other(x),
        }
    }
    
    /// Get raw value of CP_coldWeatherMode
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_cold_weather_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_coldWeatherMode
    #[inline(always)]
    pub fn set_cp_cold_weather_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// CP_coverClosed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_cover_closed(&self) -> bool {
        self.cp_cover_closed_raw()
    }
    
    /// Get raw value of CP_coverClosed
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_cover_closed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_coverClosed
    #[inline(always)]
    pub fn set_cp_cover_closed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// CP_doorButtonPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_button_pressed(&self) -> bool {
        self.cp_door_button_pressed_raw()
    }
    
    /// Get raw value of CP_doorButtonPressed
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_button_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_doorButtonPressed
    #[inline(always)]
    pub fn set_cp_door_button_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// CP_doorControlState
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_control_state(&self) -> Id25dcpStatusCpDoorControlState {
        match self.cp_door_control_state_raw() {
            5 => Id25dcpStatusCpDoorControlState::CpDoorClosing,
            1 => Id25dcpStatusCpDoorControlState::CpDoorIdle,
            0 => Id25dcpStatusCpDoorControlState::CpDoorInit,
            2 => Id25dcpStatusCpDoorControlState::CpDoorOpenRequested,
            3 => Id25dcpStatusCpDoorControlState::CpDoorOpening,
            6 => Id25dcpStatusCpDoorControlState::CpDoorSenseClosed,
            4 => Id25dcpStatusCpDoorControlState::CpDoorSenseOpen,
            x => Id25dcpStatusCpDoorControlState::Other(x),
        }
    }
    
    /// Get raw value of CP_doorControlState
    ///
    /// - Start bit: 11
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_control_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_doorControlState
    #[inline(always)]
    pub fn set_cp_door_control_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..14].store_le(value);
        Ok(())
    }
    
    /// CP_doorOpenRequested
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_open_requested(&self) -> bool {
        self.cp_door_open_requested_raw()
    }
    
    /// Get raw value of CP_doorOpenRequested
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_open_requested_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_doorOpenRequested
    #[inline(always)]
    pub fn set_cp_door_open_requested(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// CP_faultLineSensed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_fault_line_sensed(&self) -> Id25dcpStatusCpFaultLineSensed {
        match self.cp_fault_line_sensed_raw() {
            false => Id25dcpStatusCpFaultLineSensed::FaultLineCleared,
            true => Id25dcpStatusCpFaultLineSensed::FaultLineSet,
            x => Id25dcpStatusCpFaultLineSensed::Other(x),
        }
    }
    
    /// Get raw value of CP_faultLineSensed
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_fault_line_sensed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_faultLineSensed
    #[inline(always)]
    pub fn set_cp_fault_line_sensed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[44..45].store_le(value);
        Ok(())
    }
    
    /// CP_hvInletExposed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_hv_inlet_exposed(&self) -> bool {
        self.cp_hv_inlet_exposed_raw()
    }
    
    /// Get raw value of CP_hvInletExposed
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_hv_inlet_exposed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_hvInletExposed
    #[inline(always)]
    pub fn set_cp_hv_inlet_exposed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// CP_inductiveDoorState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inductive_door_state(&self) -> Id25dcpStatusCpInductiveDoorState {
        match self.cp_inductive_door_state_raw() {
            7 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorFault,
            0 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorInit,
            1 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorInitFromCharge,
            2 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorInitFromDrive,
            4 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorNotPresent,
            6 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorOffCharge,
            5 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorOffDrive,
            3 => Id25dcpStatusCpInductiveDoorState::CpInductiveDoorPresent,
            x => Id25dcpStatusCpInductiveDoorState::Other(x),
        }
    }
    
    /// Get raw value of CP_inductiveDoorState
    ///
    /// - Start bit: 45
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inductive_door_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[45..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_inductiveDoorState
    #[inline(always)]
    pub fn set_cp_inductive_door_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[45..48].store_le(value);
        Ok(())
    }
    
    /// CP_inductiveSensorState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inductive_sensor_state(&self) -> Id25dcpStatusCpInductiveSensorState {
        match self.cp_inductive_sensor_state_raw() {
            7 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorConfig,
            5 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorFault,
            0 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorInit,
            3 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorPause,
            1 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorPoll,
            6 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorReset,
            2 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorShutdown,
            4 => Id25dcpStatusCpInductiveSensorState::CpInductiveSensorWaitForInit,
            x => Id25dcpStatusCpInductiveSensorState::Other(x),
        }
    }
    
    /// Get raw value of CP_inductiveSensorState
    ///
    /// - Start bit: 48
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inductive_sensor_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_inductiveSensorState
    #[inline(always)]
    pub fn set_cp_inductive_sensor_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..51].store_le(value);
        Ok(())
    }
    
    /// CP_insertEnableLine
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_insert_enable_line(&self) -> bool {
        self.cp_insert_enable_line_raw()
    }
    
    /// Get raw value of CP_insertEnableLine
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_insert_enable_line_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_insertEnableLine
    #[inline(always)]
    pub fn set_cp_insert_enable_line(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// CP_latch2ControlState
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch2_control_state(&self) -> Id25dcpStatusCpLatch2ControlState {
        match self.cp_latch2_control_state_raw() {
            2 => Id25dcpStatusCpLatch2ControlState::CpLatchDisengageRequested,
            4 => Id25dcpStatusCpLatch2ControlState::CpLatchDisengaged,
            3 => Id25dcpStatusCpLatch2ControlState::CpLatchDisengaging,
            5 => Id25dcpStatusCpLatch2ControlState::CpLatchEngaging,
            1 => Id25dcpStatusCpLatch2ControlState::CpLatchIdle,
            0 => Id25dcpStatusCpLatch2ControlState::CpLatchInit,
            x => Id25dcpStatusCpLatch2ControlState::Other(x),
        }
    }
    
    /// Get raw value of CP_latch2ControlState
    ///
    /// - Start bit: 19
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch2_control_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[19..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_latch2ControlState
    #[inline(always)]
    pub fn set_cp_latch2_control_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[19..22].store_le(value);
        Ok(())
    }
    
    /// CP_latch2State
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch2_state(&self) -> Id25dcpStatusCpLatch2State {
        match self.cp_latch2_state_raw() {
            3 => Id25dcpStatusCpLatch2State::CpLatchBlocking,
            1 => Id25dcpStatusCpLatch2State::CpLatchDisengaged,
            2 => Id25dcpStatusCpLatch2State::CpLatchEngaged,
            0 => Id25dcpStatusCpLatch2State::CpLatchSna,
            x => Id25dcpStatusCpLatch2State::Other(x),
        }
    }
    
    /// Get raw value of CP_latch2State
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch2_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_latch2State
    #[inline(always)]
    pub fn set_cp_latch2_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CP_latchControlState
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch_control_state(&self) -> Id25dcpStatusCpLatchControlState {
        match self.cp_latch_control_state_raw() {
            2 => Id25dcpStatusCpLatchControlState::CpLatchDisengageRequested,
            4 => Id25dcpStatusCpLatchControlState::CpLatchDisengaged,
            3 => Id25dcpStatusCpLatchControlState::CpLatchDisengaging,
            5 => Id25dcpStatusCpLatchControlState::CpLatchEngaging,
            1 => Id25dcpStatusCpLatchControlState::CpLatchIdle,
            0 => Id25dcpStatusCpLatchControlState::CpLatchInit,
            x => Id25dcpStatusCpLatchControlState::Other(x),
        }
    }
    
    /// Get raw value of CP_latchControlState
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch_control_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_latchControlState
    #[inline(always)]
    pub fn set_cp_latch_control_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..19].store_le(value);
        Ok(())
    }
    
    /// CP_latchEngaged
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch_engaged(&self) -> bool {
        self.cp_latch_engaged_raw()
    }
    
    /// Get raw value of CP_latchEngaged
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch_engaged_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_latchEngaged
    #[inline(always)]
    pub fn set_cp_latch_engaged(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// CP_latchState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch_state(&self) -> Id25dcpStatusCpLatchState {
        match self.cp_latch_state_raw() {
            3 => Id25dcpStatusCpLatchState::CpLatchBlocking,
            1 => Id25dcpStatusCpLatchState::CpLatchDisengaged,
            2 => Id25dcpStatusCpLatchState::CpLatchEngaged,
            0 => Id25dcpStatusCpLatchState::CpLatchSna,
            x => Id25dcpStatusCpLatchState::Other(x),
        }
    }
    
    /// Get raw value of CP_latchState
    ///
    /// - Start bit: 5
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[5..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_latchState
    #[inline(always)]
    pub fn set_cp_latch_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..7].store_le(value);
        Ok(())
    }
    
    /// CP_ledColor
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_led_color(&self) -> Id25dcpStatusCpLedColor {
        match self.cp_led_color_raw() {
            7 => Id25dcpStatusCpLedColor::CpLedsAmber,
            3 => Id25dcpStatusCpLedColor::CpLedsBlue,
            9 => Id25dcpStatusCpLedColor::CpLedsDebug,
            6 => Id25dcpStatusCpLedColor::CpLedsFlashingAmber,
            10 => Id25dcpStatusCpLedColor::CpLedsFlashingBlue,
            5 => Id25dcpStatusCpLedColor::CpLedsFlashingGreen,
            2 => Id25dcpStatusCpLedColor::CpLedsGreen,
            0 => Id25dcpStatusCpLedColor::CpLedsOff,
            8 => Id25dcpStatusCpLedColor::CpLedsRave,
            1 => Id25dcpStatusCpLedColor::CpLedsRed,
            4 => Id25dcpStatusCpLedColor::CpLedsWhite,
            x => Id25dcpStatusCpLedColor::Other(x),
        }
    }
    
    /// Get raw value of CP_ledColor
    ///
    /// - Start bit: 33
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_led_color_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[33..37].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_ledColor
    #[inline(always)]
    pub fn set_cp_led_color(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[33..37].store_le(value);
        Ok(())
    }
    
    /// CP_numAlertsSet
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_num_alerts_set(&self) -> u8 {
        self.cp_num_alerts_set_raw()
    }
    
    /// Get raw value of CP_numAlertsSet
    ///
    /// - Start bit: 53
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_num_alerts_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[53..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_numAlertsSet
    #[inline(always)]
    pub fn set_cp_num_alerts_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[53..60].store_le(value);
        Ok(())
    }
    
    /// CP_permanentPowerRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_permanent_power_request(&self) -> bool {
        self.cp_permanent_power_request_raw()
    }
    
    /// Get raw value of CP_permanentPowerRequest
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_permanent_power_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_permanentPowerRequest
    #[inline(always)]
    pub fn set_cp_permanent_power_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CP_swcanRelayClosed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_swcan_relay_closed(&self) -> bool {
        self.cp_swcan_relay_closed_raw()
    }
    
    /// Get raw value of CP_swcanRelayClosed
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_swcan_relay_closed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_swcanRelayClosed
    #[inline(always)]
    pub fn set_cp_swcan_relay_closed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// CP_type
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_type(&self) -> Id25dcpStatusCpType {
        match self.cp_type_raw() {
            1 => Id25dcpStatusCpType::CpTypeEuroIec,
            2 => Id25dcpStatusCpType::CpTypeGb,
            3 => Id25dcpStatusCpType::CpTypeIecCcs,
            0 => Id25dcpStatusCpType::CpTypeUsTesla,
            x => Id25dcpStatusCpType::Other(x),
        }
    }
    
    /// Get raw value of CP_type
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_type
    #[inline(always)]
    pub fn set_cp_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 605 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CP_vehicleUnlockRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_unlock_request(&self) -> bool {
        self.cp_vehicle_unlock_request_raw()
    }
    
    /// Get raw value of CP_vehicleUnlockRequest
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_unlock_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehicleUnlockRequest
    #[inline(always)]
    pub fn set_cp_vehicle_unlock_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[52..53].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id25dcpStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id25dcpStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_uhf_control_state = u.int_in_range(0..=10)?;
        let cp_uhf_handle_found = u.int_in_range(0..=1)? == 1;
        let cp_aps_voltage = 0_f32;
        let cp_charge_cable_present = u.int_in_range(0..=1)? == 1;
        let cp_charge_cable_secured = u.int_in_range(0..=1)? == 1;
        let cp_charge_cable_state = u.int_in_range(0..=2)?;
        let cp_charge_door_open = u.int_in_range(0..=1)? == 1;
        let cp_charge_door_open_ui = u.int_in_range(0..=1)? == 1;
        let cp_cold_weather_mode = u.int_in_range(0..=1)? == 1;
        let cp_cover_closed = u.int_in_range(0..=1)? == 1;
        let cp_door_button_pressed = u.int_in_range(0..=1)? == 1;
        let cp_door_control_state = u.int_in_range(0..=6)?;
        let cp_door_open_requested = u.int_in_range(0..=1)? == 1;
        let cp_fault_line_sensed = u.int_in_range(0..=1)? == 1;
        let cp_hv_inlet_exposed = u.int_in_range(0..=1)? == 1;
        let cp_inductive_door_state = u.int_in_range(0..=7)?;
        let cp_inductive_sensor_state = u.int_in_range(0..=7)?;
        let cp_insert_enable_line = u.int_in_range(0..=1)? == 1;
        let cp_latch2_control_state = u.int_in_range(0..=5)?;
        let cp_latch2_state = u.int_in_range(0..=3)?;
        let cp_latch_control_state = u.int_in_range(0..=5)?;
        let cp_latch_engaged = u.int_in_range(0..=1)? == 1;
        let cp_latch_state = u.int_in_range(0..=3)?;
        let cp_led_color = u.int_in_range(0..=10)?;
        let cp_num_alerts_set = u.int_in_range(0..=127)?;
        let cp_permanent_power_request = u.int_in_range(0..=1)? == 1;
        let cp_swcan_relay_closed = u.int_in_range(0..=1)? == 1;
        let cp_type = u.int_in_range(0..=3)?;
        let cp_vehicle_unlock_request = u.int_in_range(0..=1)? == 1;
        Id25dcpStatus::new(cp_uhf_control_state,cp_uhf_handle_found,cp_aps_voltage,cp_charge_cable_present,cp_charge_cable_secured,cp_charge_cable_state,cp_charge_door_open,cp_charge_door_open_ui,cp_cold_weather_mode,cp_cover_closed,cp_door_button_pressed,cp_door_control_state,cp_door_open_requested,cp_fault_line_sensed,cp_hv_inlet_exposed,cp_inductive_door_state,cp_inductive_sensor_state,cp_insert_enable_line,cp_latch2_control_state,cp_latch2_state,cp_latch_control_state,cp_latch_engaged,cp_latch_state,cp_led_color,cp_num_alerts_set,cp_permanent_power_request,cp_swcan_relay_closed,cp_type,cp_vehicle_unlock_request).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CP_UHF_controlState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpUhfControlState {
    CpUhfCalibrate,
    CpUhfCheckRx,
    CpUhfConfig,
    CpUhfFault,
    CpUhfHandleFound,
    CpUhfIdle,
    CpUhfInit,
    CpUhfPrepareRx,
    CpUhfReadRxfifo,
    CpUhfRx,
    CpUhfSleep,
    Other(u8),
}
/// Defined values for CP_chargeCablePresent
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpChargeCablePresent {
    CableNotPresent,
    CablePresent,
    Other(bool),
}
/// Defined values for CP_chargeCableState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpChargeCableState {
    ChargeCableConnected,
    ChargeCableNotConnected,
    ChargeCableUnknownSna,
    Other(u8),
}
/// Defined values for CP_coldWeatherMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpColdWeatherMode {
    CpColdWeatherLatchMitigation,
    CpColdWeatherNone,
    Other(bool),
}
/// Defined values for CP_doorControlState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpDoorControlState {
    CpDoorClosing,
    CpDoorIdle,
    CpDoorInit,
    CpDoorOpenRequested,
    CpDoorOpening,
    CpDoorSenseClosed,
    CpDoorSenseOpen,
    Other(u8),
}
/// Defined values for CP_faultLineSensed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpFaultLineSensed {
    FaultLineCleared,
    FaultLineSet,
    Other(bool),
}
/// Defined values for CP_inductiveDoorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpInductiveDoorState {
    CpInductiveDoorFault,
    CpInductiveDoorInit,
    CpInductiveDoorInitFromCharge,
    CpInductiveDoorInitFromDrive,
    CpInductiveDoorNotPresent,
    CpInductiveDoorOffCharge,
    CpInductiveDoorOffDrive,
    CpInductiveDoorPresent,
    Other(u8),
}
/// Defined values for CP_inductiveSensorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpInductiveSensorState {
    CpInductiveSensorConfig,
    CpInductiveSensorFault,
    CpInductiveSensorInit,
    CpInductiveSensorPause,
    CpInductiveSensorPoll,
    CpInductiveSensorReset,
    CpInductiveSensorShutdown,
    CpInductiveSensorWaitForInit,
    Other(u8),
}
/// Defined values for CP_latch2ControlState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpLatch2ControlState {
    CpLatchDisengageRequested,
    CpLatchDisengaged,
    CpLatchDisengaging,
    CpLatchEngaging,
    CpLatchIdle,
    CpLatchInit,
    Other(u8),
}
/// Defined values for CP_latch2State
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpLatch2State {
    CpLatchBlocking,
    CpLatchDisengaged,
    CpLatchEngaged,
    CpLatchSna,
    Other(u8),
}
/// Defined values for CP_latchControlState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpLatchControlState {
    CpLatchDisengageRequested,
    CpLatchDisengaged,
    CpLatchDisengaging,
    CpLatchEngaging,
    CpLatchIdle,
    CpLatchInit,
    Other(u8),
}
/// Defined values for CP_latchState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpLatchState {
    CpLatchBlocking,
    CpLatchDisengaged,
    CpLatchEngaged,
    CpLatchSna,
    Other(u8),
}
/// Defined values for CP_ledColor
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpLedColor {
    CpLedsAmber,
    CpLedsBlue,
    CpLedsDebug,
    CpLedsFlashingAmber,
    CpLedsFlashingBlue,
    CpLedsFlashingGreen,
    CpLedsGreen,
    CpLedsOff,
    CpLedsRave,
    CpLedsRed,
    CpLedsWhite,
    Other(u8),
}
/// Defined values for CP_type
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id25dcpStatusCpType {
    CpTypeEuroIec,
    CpTypeGb,
    CpTypeIecCcs,
    CpTypeUsTesla,
    Other(u8),
}

/// ID29DCP_dcChargeStatus
///
/// - ID: 669 (0x29d)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id29dcpDcChargeStatus {
    raw: [u8; 4],
}

impl Id29dcpDcChargeStatus {
    pub const MESSAGE_ID: u32 = 669;
    
    /// Construct new ID29DCP_dcChargeStatus from values
    pub fn new(cp_evse_output_dc_current: f32, cp_evse_output_dc_current_stale: bool, cp_evse_output_dc_voltage: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cp_evse_output_dc_current(cp_evse_output_dc_current)?;
        res.set_cp_evse_output_dc_current_stale(cp_evse_output_dc_current_stale)?;
        res.set_cp_evse_output_dc_voltage(cp_evse_output_dc_voltage)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_evseOutputDcCurrent
    ///
    /// - Min: -1200
    /// - Max: 1200
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_output_dc_current(&self) -> f32 {
        self.cp_evse_output_dc_current_raw()
    }
    
    /// Get raw value of CP_evseOutputDcCurrent
    ///
    /// - Start bit: 0
    /// - Signal size: 15 bits
    /// - Factor: 0.0732467
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_evse_output_dc_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..15].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0732467_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseOutputDcCurrent
    #[inline(always)]
    pub fn set_cp_evse_output_dc_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1200_f32 || 1200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 669 }); }
        let factor = 0.0732467_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[0..15].store_le(value);
        Ok(())
    }
    
    /// CP_evseOutputDcCurrentStale
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_output_dc_current_stale(&self) -> bool {
        self.cp_evse_output_dc_current_stale_raw()
    }
    
    /// Get raw value of CP_evseOutputDcCurrentStale
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_output_dc_current_stale_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_evseOutputDcCurrentStale
    #[inline(always)]
    pub fn set_cp_evse_output_dc_current_stale(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// CP_evseOutputDcVoltage
    ///
    /// - Min: 0
    /// - Max: 599.927
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_output_dc_voltage(&self) -> f32 {
        self.cp_evse_output_dc_voltage_raw()
    }
    
    /// Get raw value of CP_evseOutputDcVoltage
    ///
    /// - Start bit: 16
    /// - Signal size: 13 bits
    /// - Factor: 0.0732422
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_output_dc_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..29].load_le::<u16>();
        
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_evseOutputDcVoltage
    #[inline(always)]
    pub fn set_cp_evse_output_dc_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.927_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 669 }); }
        let factor = 0.0732422_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..29].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id29dcpDcChargeStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id29dcpDcChargeStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_evse_output_dc_current = -1200_f32;
        let cp_evse_output_dc_current_stale = u.int_in_range(0..=1)? == 1;
        let cp_evse_output_dc_voltage = 0_f32;
        Id29dcpDcChargeStatus::new(cp_evse_output_dc_current,cp_evse_output_dc_current_stale,cp_evse_output_dc_voltage).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID2B4PCS_dcdcRailStatus
///
/// - ID: 692 (0x2b4)
/// - Size: 5 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2b4pcsDcdcRailStatus {
    raw: [u8; 5],
}

impl Id2b4pcsDcdcRailStatus {
    pub const MESSAGE_ID: u32 = 692;
    
    /// Construct new ID2B4PCS_dcdcRailStatus from values
    pub fn new(pcs_dcdc_hv_bus_volt: f32, pcs_dcdc_lv_bus_volt: f32, pcs_dcdc_lv_output_current: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_pcs_dcdc_hv_bus_volt(pcs_dcdc_hv_bus_volt)?;
        res.set_pcs_dcdc_lv_bus_volt(pcs_dcdc_lv_bus_volt)?;
        res.set_pcs_dcdc_lv_output_current(pcs_dcdc_lv_output_current)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// PCS_dcdcHvBusVolt
    ///
    /// DCDC HV Voltage
    ///
    /// - Min: 0
    /// - Max: 599.854
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_dcdc_hv_bus_volt(&self) -> f32 {
        self.pcs_dcdc_hv_bus_volt_raw()
    }
    
    /// Get raw value of PCS_dcdcHvBusVolt
    ///
    /// - Start bit: 10
    /// - Signal size: 12 bits
    /// - Factor: 0.146484
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_dcdc_hv_bus_volt_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..22].load_le::<u16>();
        
        let factor = 0.146484_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_dcdcHvBusVolt
    #[inline(always)]
    pub fn set_pcs_dcdc_hv_bus_volt(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 599.854_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 692 }); }
        let factor = 0.146484_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[10..22].store_le(value);
        Ok(())
    }
    
    /// PCS_dcdcLvBusVolt
    ///
    /// DCDC 12v Voltage
    ///
    /// - Min: 0
    /// - Max: 39.9609
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_dcdc_lv_bus_volt(&self) -> f32 {
        self.pcs_dcdc_lv_bus_volt_raw()
    }
    
    /// Get raw value of PCS_dcdcLvBusVolt
    ///
    /// - Start bit: 0
    /// - Signal size: 10 bits
    /// - Factor: 0.0390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_dcdc_lv_bus_volt_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..10].load_le::<u16>();
        
        let factor = 0.0390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_dcdcLvBusVolt
    #[inline(always)]
    pub fn set_pcs_dcdc_lv_bus_volt(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 39.9609_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 692 }); }
        let factor = 0.0390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..10].store_le(value);
        Ok(())
    }
    
    /// PCS_dcdcLvOutputCurrent
    ///
    /// DCDC 12v Output Current
    ///
    /// - Min: 0
    /// - Max: 400
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn pcs_dcdc_lv_output_current(&self) -> f32 {
        self.pcs_dcdc_lv_output_current_raw()
    }
    
    /// Get raw value of PCS_dcdcLvOutputCurrent
    ///
    /// - Start bit: 24
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pcs_dcdc_lv_output_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..36].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PCS_dcdcLvOutputCurrent
    #[inline(always)]
    pub fn set_pcs_dcdc_lv_output_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 400_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 692 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..36].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2b4pcsDcdcRailStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2b4pcsDcdcRailStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let pcs_dcdc_hv_bus_volt = 0_f32;
        let pcs_dcdc_lv_bus_volt = 0_f32;
        let pcs_dcdc_lv_output_current = 0_f32;
        Id2b4pcsDcdcRailStatus::new(pcs_dcdc_hv_bus_volt,pcs_dcdc_lv_bus_volt,pcs_dcdc_lv_output_current).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID2B9DAS_control
///
/// - ID: 697 (0x2b9)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2b9dasControl {
    raw: [u8; 8],
}

impl Id2b9dasControl {
    pub const MESSAGE_ID: u32 = 697;
    
    /// Construct new ID2B9DAS_control from values
    pub fn new(das_acc_state: u8, das_accel_max: f32, das_accel_min: f32, das_aeb_event: u8, das_control_checksum: u8, das_control_counter: u8, das_jerk_max: f32, das_jerk_min: f32, das_set_speed: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_acc_state(das_acc_state)?;
        res.set_das_accel_max(das_accel_max)?;
        res.set_das_accel_min(das_accel_min)?;
        res.set_das_aeb_event(das_aeb_event)?;
        res.set_das_control_checksum(das_control_checksum)?;
        res.set_das_control_counter(das_control_counter)?;
        res.set_das_jerk_max(das_jerk_max)?;
        res.set_das_jerk_min(das_jerk_min)?;
        res.set_das_set_speed(das_set_speed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_accState
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_acc_state(&self) -> Id2b9dasControlDasAccState {
        match self.das_acc_state_raw() {
            1 => Id2b9dasControlDasAccState::AccCancelCameraBlind,
            0 => Id2b9dasControlDasAccState::AccCancelGeneric,
            13 => Id2b9dasControlDasAccState::AccCancelGenericSilent,
            14 => Id2b9dasControlDasAccState::AccCancelOutOfCalibration,
            12 => Id2b9dasControlDasAccState::AccCancelPathNotClear,
            2 => Id2b9dasControlDasAccState::AccCancelRadarBlind,
            3 => Id2b9dasControlDasAccState::AccHold,
            4 => Id2b9dasControlDasAccState::AccOn,
            8 => Id2b9dasControlDasAccState::ApcAbort,
            5 => Id2b9dasControlDasAccState::ApcBackward,
            7 => Id2b9dasControlDasAccState::ApcComplete,
            6 => Id2b9dasControlDasAccState::ApcForward,
            9 => Id2b9dasControlDasAccState::ApcPause,
            11 => Id2b9dasControlDasAccState::ApcSelfparkStart,
            10 => Id2b9dasControlDasAccState::ApcUnparkComplete,
            15 => Id2b9dasControlDasAccState::FaultSna,
            x => Id2b9dasControlDasAccState::Other(x),
        }
    }
    
    /// Get raw value of DAS_accState
    ///
    /// - Start bit: 12
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_acc_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_accState
    #[inline(always)]
    pub fn set_das_acc_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..16].store_le(value);
        Ok(())
    }
    
    /// DAS_accelMax
    ///
    /// - Min: -15
    /// - Max: 5.44
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_accel_max(&self) -> Id2b9dasControlDasAccelMax {
        match self.das_accel_max_raw() {
            511 => Id2b9dasControlDasAccelMax::Sna,
            x => Id2b9dasControlDasAccelMax::Other(x),
        }
    }
    
    /// Get raw value of DAS_accelMax
    ///
    /// - Start bit: 44
    /// - Signal size: 9 bits
    /// - Factor: 0.04
    /// - Offset: -15
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_accel_max_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..53].load_le::<u16>();
        
        let factor = 0.04_f32;
        let offset = -15_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_accelMax
    #[inline(always)]
    pub fn set_das_accel_max(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -15_f32 || 5.44_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        let factor = 0.04_f32;
        let offset = -15_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[44..53].store_le(value);
        Ok(())
    }
    
    /// DAS_accelMin
    ///
    /// - Min: -15
    /// - Max: 5.44
    /// - Unit: "m/s^2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_accel_min(&self) -> Id2b9dasControlDasAccelMin {
        match self.das_accel_min_raw() {
            511 => Id2b9dasControlDasAccelMin::Sna,
            x => Id2b9dasControlDasAccelMin::Other(x),
        }
    }
    
    /// Get raw value of DAS_accelMin
    ///
    /// - Start bit: 35
    /// - Signal size: 9 bits
    /// - Factor: 0.04
    /// - Offset: -15
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_accel_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[35..44].load_le::<u16>();
        
        let factor = 0.04_f32;
        let offset = -15_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_accelMin
    #[inline(always)]
    pub fn set_das_accel_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -15_f32 || 5.44_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        let factor = 0.04_f32;
        let offset = -15_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[35..44].store_le(value);
        Ok(())
    }
    
    /// DAS_aebEvent
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_aeb_event(&self) -> Id2b9dasControlDasAebEvent {
        match self.das_aeb_event_raw() {
            1 => Id2b9dasControlDasAebEvent::AebActive,
            2 => Id2b9dasControlDasAebEvent::AebFault,
            0 => Id2b9dasControlDasAebEvent::AebNotActive,
            3 => Id2b9dasControlDasAebEvent::AebSna,
            x => Id2b9dasControlDasAebEvent::Other(x),
        }
    }
    
    /// Get raw value of DAS_aebEvent
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_aeb_event_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_aebEvent
    #[inline(always)]
    pub fn set_das_aeb_event(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// DAS_controlChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_control_checksum(&self) -> u8 {
        self.das_control_checksum_raw()
    }
    
    /// Get raw value of DAS_controlChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_control_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_controlChecksum
    #[inline(always)]
    pub fn set_das_control_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DAS_controlCounter
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_control_counter(&self) -> u8 {
        self.das_control_counter_raw()
    }
    
    /// Get raw value of DAS_controlCounter
    ///
    /// - Start bit: 53
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_control_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[53..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_controlCounter
    #[inline(always)]
    pub fn set_das_control_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        self.raw.view_bits_mut::<LocalBits>()[53..56].store_le(value);
        Ok(())
    }
    
    /// DAS_jerkMax
    ///
    /// - Min: 0
    /// - Max: 15.045
    /// - Unit: "m/s^3"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_jerk_max(&self) -> Id2b9dasControlDasJerkMax {
        match self.das_jerk_max_raw() {
            255 => Id2b9dasControlDasJerkMax::Sna,
            x => Id2b9dasControlDasJerkMax::Other(x),
        }
    }
    
    /// Get raw value of DAS_jerkMax
    ///
    /// - Start bit: 27
    /// - Signal size: 8 bits
    /// - Factor: 0.059
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_jerk_max_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[27..35].load_le::<u8>();
        
        let factor = 0.059_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_jerkMax
    #[inline(always)]
    pub fn set_das_jerk_max(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 15.045_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        let factor = 0.059_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[27..35].store_le(value);
        Ok(())
    }
    
    /// DAS_jerkMin
    ///
    /// - Min: -15.232
    /// - Max: 0.098
    /// - Unit: "m/s^3"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_jerk_min(&self) -> Id2b9dasControlDasJerkMin {
        match self.das_jerk_min_raw() {
            511 => Id2b9dasControlDasJerkMin::Sna,
            x => Id2b9dasControlDasJerkMin::Other(x),
        }
    }
    
    /// Get raw value of DAS_jerkMin
    ///
    /// - Start bit: 18
    /// - Signal size: 9 bits
    /// - Factor: 0.03
    /// - Offset: -15.232
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_jerk_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[18..27].load_le::<u16>();
        
        let factor = 0.03_f32;
        let offset = -15.232_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_jerkMin
    #[inline(always)]
    pub fn set_das_jerk_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -15.232_f32 || 0.098_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        let factor = 0.03_f32;
        let offset = -15.232_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[18..27].store_le(value);
        Ok(())
    }
    
    /// DAS_setSpeed
    ///
    /// - Min: 0
    /// - Max: 409.4
    /// - Unit: "kph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_set_speed(&self) -> Id2b9dasControlDasSetSpeed {
        match self.das_set_speed_raw() {
            4095 => Id2b9dasControlDasSetSpeed::Sna,
            x => Id2b9dasControlDasSetSpeed::Other(x),
        }
    }
    
    /// Get raw value of DAS_setSpeed
    ///
    /// - Start bit: 0
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_set_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..12].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_setSpeed
    #[inline(always)]
    pub fn set_das_set_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 409.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 697 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..12].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2b9dasControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2b9dasControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_acc_state = u.int_in_range(0..=15)?;
        let das_accel_max = -15_f32;
        let das_accel_min = -15_f32;
        let das_aeb_event = u.int_in_range(0..=3)?;
        let das_control_checksum = u.int_in_range(0..=255)?;
        let das_control_counter = u.int_in_range(0..=7)?;
        let das_jerk_max = 0_f32;
        let das_jerk_min = -15.232_f32;
        let das_set_speed = 0_f32;
        Id2b9dasControl::new(das_acc_state,das_accel_max,das_accel_min,das_aeb_event,das_control_checksum,das_control_counter,das_jerk_max,das_jerk_min,das_set_speed).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_accState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasAccState {
    AccCancelCameraBlind,
    AccCancelGeneric,
    AccCancelGenericSilent,
    AccCancelOutOfCalibration,
    AccCancelPathNotClear,
    AccCancelRadarBlind,
    AccHold,
    AccOn,
    ApcAbort,
    ApcBackward,
    ApcComplete,
    ApcForward,
    ApcPause,
    ApcSelfparkStart,
    ApcUnparkComplete,
    FaultSna,
    Other(u8),
}
/// Defined values for DAS_accelMax
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasAccelMax {
    Sna,
    Other(f32),
}
/// Defined values for DAS_accelMin
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasAccelMin {
    Sna,
    Other(f32),
}
/// Defined values for DAS_aebEvent
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasAebEvent {
    AebActive,
    AebFault,
    AebNotActive,
    AebSna,
    Other(u8),
}
/// Defined values for DAS_jerkMax
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasJerkMax {
    Sna,
    Other(f32),
}
/// Defined values for DAS_jerkMin
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasJerkMin {
    Sna,
    Other(f32),
}
/// Defined values for DAS_setSpeed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b9dasControlDasSetSpeed {
    Sna,
    Other(f32),
}

/// ID2D3UI_solarData
///
/// - ID: 723 (0x2d3)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2d3uiSolarData {
    raw: [u8; 8],
}

impl Id2d3uiSolarData {
    pub const MESSAGE_ID: u32 = 723;
    
    /// Construct new ID2D3UI_solarData from values
    pub fn new(ui_is_sun_up: u8, ui_mins_to_sunrise: f32, ui_mins_to_sunset: f32, ui_screen_pcb_temperature: f32, ui_solar_azimuth_angle: i16, ui_solar_azimuth_angle_car_ref: i16, ui_solar_elevation_angle: i8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_is_sun_up(ui_is_sun_up)?;
        res.set_ui_mins_to_sunrise(ui_mins_to_sunrise)?;
        res.set_ui_mins_to_sunset(ui_mins_to_sunset)?;
        res.set_ui_screen_pcb_temperature(ui_screen_pcb_temperature)?;
        res.set_ui_solar_azimuth_angle(ui_solar_azimuth_angle)?;
        res.set_ui_solar_azimuth_angle_car_ref(ui_solar_azimuth_angle_car_ref)?;
        res.set_ui_solar_elevation_angle(ui_solar_elevation_angle)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_isSunUp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_is_sun_up(&self) -> Id2d3uiSolarDataUiIsSunUp {
        match self.ui_is_sun_up_raw() {
            0 => Id2d3uiSolarDataUiIsSunUp::SunDown,
            3 => Id2d3uiSolarDataUiIsSunUp::SunSna,
            1 => Id2d3uiSolarDataUiIsSunUp::SunUp,
            x => Id2d3uiSolarDataUiIsSunUp::Other(x),
        }
    }
    
    /// Get raw value of UI_isSunUp
    ///
    /// - Start bit: 25
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_is_sun_up_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[25..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_isSunUp
    #[inline(always)]
    pub fn set_ui_is_sun_up(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        self.raw.view_bits_mut::<LocalBits>()[25..27].store_le(value);
        Ok(())
    }
    
    /// UI_minsToSunrise
    ///
    /// - Min: 0
    /// - Max: 2550
    /// - Unit: "min"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_mins_to_sunrise(&self) -> f32 {
        self.ui_mins_to_sunrise_raw()
    }
    
    /// Get raw value of UI_minsToSunrise
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_mins_to_sunrise_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_minsToSunrise
    #[inline(always)]
    pub fn set_ui_mins_to_sunrise(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2550_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// UI_minsToSunset
    ///
    /// - Min: 0
    /// - Max: 2550
    /// - Unit: "min"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_mins_to_sunset(&self) -> f32 {
        self.ui_mins_to_sunset_raw()
    }
    
    /// Get raw value of UI_minsToSunset
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_mins_to_sunset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_minsToSunset
    #[inline(always)]
    pub fn set_ui_mins_to_sunset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2550_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// UI_screenPCBTemperature
    ///
    /// - Min: -20
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_screen_pcb_temperature(&self) -> f32 {
        self.ui_screen_pcb_temperature_raw()
    }
    
    /// Get raw value of UI_screenPCBTemperature
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_screen_pcb_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.5_f32;
        let offset = 40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_screenPCBTemperature
    #[inline(always)]
    pub fn set_ui_screen_pcb_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        let factor = 0.5_f32;
        let offset = 40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// UI_solarAzimuthAngle
    ///
    /// - Min: -32767
    /// - Max: 32767
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_solar_azimuth_angle(&self) -> Id2d3uiSolarDataUiSolarAzimuthAngle {
        match self.ui_solar_azimuth_angle_raw() {
            32768 => Id2d3uiSolarDataUiSolarAzimuthAngle::Sna,
            x => Id2d3uiSolarDataUiSolarAzimuthAngle::Other(x),
        }
    }
    
    /// Get raw value of UI_solarAzimuthAngle
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_solar_azimuth_angle_raw(&self) -> i16 {
        let signal = self.raw.view_bits::<LocalBits>()[0..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of UI_solarAzimuthAngle
    #[inline(always)]
    pub fn set_ui_solar_azimuth_angle(&mut self, value: i16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -32767_i16 || 32767_i16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[0..16].store_le(value);
        Ok(())
    }
    
    /// UI_solarAzimuthAngleCarRef
    ///
    /// - Min: -256
    /// - Max: 254
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_solar_azimuth_angle_car_ref(&self) -> Id2d3uiSolarDataUiSolarAzimuthAngleCarRef {
        match self.ui_solar_azimuth_angle_car_ref_raw() {
            255 => Id2d3uiSolarDataUiSolarAzimuthAngleCarRef::Sna,
            x => Id2d3uiSolarDataUiSolarAzimuthAngleCarRef::Other(x),
        }
    }
    
    /// Get raw value of UI_solarAzimuthAngleCarRef
    ///
    /// - Start bit: 16
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_solar_azimuth_angle_car_ref_raw(&self) -> i16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..25].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of UI_solarAzimuthAngleCarRef
    #[inline(always)]
    pub fn set_ui_solar_azimuth_angle_car_ref(&mut self, value: i16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -256_i16 || 254_i16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..25].store_le(value);
        Ok(())
    }
    
    /// UI_solarElevationAngle
    ///
    /// - Min: -128
    /// - Max: 126
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_solar_elevation_angle(&self) -> Id2d3uiSolarDataUiSolarElevationAngle {
        match self.ui_solar_elevation_angle_raw() {
            127 => Id2d3uiSolarDataUiSolarElevationAngle::Sna,
            x => Id2d3uiSolarDataUiSolarElevationAngle::Other(x),
        }
    }
    
    /// Get raw value of UI_solarElevationAngle
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ui_solar_elevation_angle_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of UI_solarElevationAngle
    #[inline(always)]
    pub fn set_ui_solar_elevation_angle(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_i8 || 126_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 723 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2d3uiSolarData {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2d3uiSolarData
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_is_sun_up = u.int_in_range(0..=3)?;
        let ui_mins_to_sunrise = 0_f32;
        let ui_mins_to_sunset = 0_f32;
        let ui_screen_pcb_temperature = -20_f32;
        let ui_solar_azimuth_angle = u.int_in_range(-32767..=32767)?;
        let ui_solar_azimuth_angle_car_ref = u.int_in_range(-256..=254)?;
        let ui_solar_elevation_angle = u.int_in_range(-128..=126)?;
        Id2d3uiSolarData::new(ui_is_sun_up,ui_mins_to_sunrise,ui_mins_to_sunset,ui_screen_pcb_temperature,ui_solar_azimuth_angle,ui_solar_azimuth_angle_car_ref,ui_solar_elevation_angle).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_isSunUp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2d3uiSolarDataUiIsSunUp {
    SunDown,
    SunSna,
    SunUp,
    Other(u8),
}
/// Defined values for UI_solarAzimuthAngle
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2d3uiSolarDataUiSolarAzimuthAngle {
    Sna,
    Other(i16),
}
/// Defined values for UI_solarAzimuthAngleCarRef
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2d3uiSolarDataUiSolarAzimuthAngleCarRef {
    Sna,
    Other(i16),
}
/// Defined values for UI_solarElevationAngle
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2d3uiSolarDataUiSolarElevationAngle {
    Sna,
    Other(i8),
}

/// ID309DAS_object
///
/// - ID: 777 (0x309)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id309dasObject {
    raw: [u8; 8],
}

impl Id309dasObject {
    pub const MESSAGE_ID: u32 = 777;
    
    /// Construct new ID309DAS_object from values
    pub fn new(das_object_id: u8, das_cutin_veh_dx: f32, das_cutin_veh_dy: f32, das_cutin_veh_heading: f32, das_cutin_veh_id: u8, das_cutin_veh_relevant_for_control: bool, das_cutin_veh_type: u8, das_cutin_veh_vx_rel: f32, das_lead_veh2_dx: f32, das_lead_veh2_dy: f32, das_lead_veh2_heading: f32, das_lead_veh2_id: u8, das_lead_veh2_relevant_for_control: bool, das_lead_veh2_type: u8, das_lead_veh2_vx_rel: f32, das_lead_veh_dx: f32, das_lead_veh_dy: f32, das_lead_veh_heading: f32, das_lead_veh_id: u8, das_lead_veh_relevant_for_control: bool, das_lead_veh_type: u8, das_lead_veh_vx_rel: f32, das_left_veh2_dx: f32, das_left_veh2_dy: f32, das_left_veh2_heading: f32, das_left_veh2_id: u8, das_left_veh2_relevant_for_control: bool, das_left_veh2_type: u8, das_left_veh2_vx_rel: f32, das_left_veh_dx: f32, das_left_veh_dy: f32, das_left_veh_heading: f32, das_left_veh_id: u8, das_left_veh_relevant_for_control: bool, das_left_veh_type: u8, das_left_veh_vx_rel: f32, das_right_veh2_dx: f32, das_right_veh2_dy: f32, das_right_veh2_heading: f32, das_right_veh2_id: u8, das_right_veh2_relevant_for_control: bool, das_right_veh2_type: u8, das_right_veh2_vx_rel: f32, das_right_veh_dx: f32, das_right_veh_dy: f32, das_right_veh_heading: f32, das_right_veh_id: u8, das_right_veh_relevant_for_control: bool, das_right_veh_type: u8, das_right_veh_vx_rel: f32, das_road_sign_arrow: u8, das_road_sign_color: u8, das_road_sign_control_active: bool, das_road_sign_id: u8, das_road_sign_orientation: u8, das_road_sign_source: u8, das_road_sign_stop_line_dist: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_object_id(das_object_id)?;
        res.set_das_cutin_veh_dx(das_cutin_veh_dx)?;
        res.set_das_cutin_veh_dy(das_cutin_veh_dy)?;
        res.set_das_cutin_veh_heading(das_cutin_veh_heading)?;
        res.set_das_cutin_veh_id(das_cutin_veh_id)?;
        res.set_das_cutin_veh_relevant_for_control(das_cutin_veh_relevant_for_control)?;
        res.set_das_cutin_veh_type(das_cutin_veh_type)?;
        res.set_das_cutin_veh_vx_rel(das_cutin_veh_vx_rel)?;
        res.set_das_lead_veh2_dx(das_lead_veh2_dx)?;
        res.set_das_lead_veh2_dy(das_lead_veh2_dy)?;
        res.set_das_lead_veh2_heading(das_lead_veh2_heading)?;
        res.set_das_lead_veh2_id(das_lead_veh2_id)?;
        res.set_das_lead_veh2_relevant_for_control(das_lead_veh2_relevant_for_control)?;
        res.set_das_lead_veh2_type(das_lead_veh2_type)?;
        res.set_das_lead_veh2_vx_rel(das_lead_veh2_vx_rel)?;
        res.set_das_lead_veh_dx(das_lead_veh_dx)?;
        res.set_das_lead_veh_dy(das_lead_veh_dy)?;
        res.set_das_lead_veh_heading(das_lead_veh_heading)?;
        res.set_das_lead_veh_id(das_lead_veh_id)?;
        res.set_das_lead_veh_relevant_for_control(das_lead_veh_relevant_for_control)?;
        res.set_das_lead_veh_type(das_lead_veh_type)?;
        res.set_das_lead_veh_vx_rel(das_lead_veh_vx_rel)?;
        res.set_das_left_veh2_dx(das_left_veh2_dx)?;
        res.set_das_left_veh2_dy(das_left_veh2_dy)?;
        res.set_das_left_veh2_heading(das_left_veh2_heading)?;
        res.set_das_left_veh2_id(das_left_veh2_id)?;
        res.set_das_left_veh2_relevant_for_control(das_left_veh2_relevant_for_control)?;
        res.set_das_left_veh2_type(das_left_veh2_type)?;
        res.set_das_left_veh2_vx_rel(das_left_veh2_vx_rel)?;
        res.set_das_left_veh_dx(das_left_veh_dx)?;
        res.set_das_left_veh_dy(das_left_veh_dy)?;
        res.set_das_left_veh_heading(das_left_veh_heading)?;
        res.set_das_left_veh_id(das_left_veh_id)?;
        res.set_das_left_veh_relevant_for_control(das_left_veh_relevant_for_control)?;
        res.set_das_left_veh_type(das_left_veh_type)?;
        res.set_das_left_veh_vx_rel(das_left_veh_vx_rel)?;
        res.set_das_right_veh2_dx(das_right_veh2_dx)?;
        res.set_das_right_veh2_dy(das_right_veh2_dy)?;
        res.set_das_right_veh2_heading(das_right_veh2_heading)?;
        res.set_das_right_veh2_id(das_right_veh2_id)?;
        res.set_das_right_veh2_relevant_for_control(das_right_veh2_relevant_for_control)?;
        res.set_das_right_veh2_type(das_right_veh2_type)?;
        res.set_das_right_veh2_vx_rel(das_right_veh2_vx_rel)?;
        res.set_das_right_veh_dx(das_right_veh_dx)?;
        res.set_das_right_veh_dy(das_right_veh_dy)?;
        res.set_das_right_veh_heading(das_right_veh_heading)?;
        res.set_das_right_veh_id(das_right_veh_id)?;
        res.set_das_right_veh_relevant_for_control(das_right_veh_relevant_for_control)?;
        res.set_das_right_veh_type(das_right_veh_type)?;
        res.set_das_right_veh_vx_rel(das_right_veh_vx_rel)?;
        res.set_das_road_sign_arrow(das_road_sign_arrow)?;
        res.set_das_road_sign_color(das_road_sign_color)?;
        res.set_das_road_sign_control_active(das_road_sign_control_active)?;
        res.set_das_road_sign_id(das_road_sign_id)?;
        res.set_das_road_sign_orientation(das_road_sign_orientation)?;
        res.set_das_road_sign_source(das_road_sign_source)?;
        res.set_das_road_sign_stop_line_dist(das_road_sign_stop_line_dist)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_objectId
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_object_id(&self) -> Id309dasObjectDasObjectId {
        match self.das_object_id_raw() {
            3 => Id309dasObjectDasObjectId::CutinVehicle,
            0 => Id309dasObjectDasObjectId::LeadVehicles,
            1 => Id309dasObjectDasObjectId::LeftVehicles,
            2 => Id309dasObjectDasObjectId::RightVehicles,
            4 => Id309dasObjectDasObjectId::RoadSign,
            5 => Id309dasObjectDasObjectId::VehicleHeadings,
            x => Id309dasObjectDasObjectId::Other(x),
        }
    }
    
    /// Get raw value of DAS_objectId
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_object_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_objectId
    #[inline(always)]
    pub fn set_das_object_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehDx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_dx(&self) -> Id309dasObjectDasCutinVehDx {
        match self.das_cutin_veh_dx_raw() {
            255 => Id309dasObjectDasCutinVehDx::Sna,
            x => Id309dasObjectDasCutinVehDx::Other(x),
        }
    }
    
    /// Get raw value of DAS_cutinVehDx
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_cutinVehDx
    #[inline(always)]
    pub fn set_das_cutin_veh_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehDy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_dy(&self) -> f32 {
        self.das_cutin_veh_dy_raw()
    }
    
    /// Get raw value of DAS_cutinVehDy
    ///
    /// - Start bit: 20
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..27].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_cutinVehDy
    #[inline(always)]
    pub fn set_das_cutin_veh_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[20..27].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehHeading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_heading(&self) -> Id309dasObjectDasCutinVehHeading {
        match self.das_cutin_veh_heading_raw() {
            255 => Id309dasObjectDasCutinVehHeading::Sna,
            x => Id309dasObjectDasCutinVehHeading::Other(x),
        }
    }
    
    /// Get raw value of DAS_cutinVehHeading
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_cutinVehHeading
    #[inline(always)]
    pub fn set_das_cutin_veh_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehId
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_id(&self) -> Id309dasObjectDasCutinVehId {
        match self.das_cutin_veh_id_raw() {
            127 => Id309dasObjectDasCutinVehId::Sna,
            x => Id309dasObjectDasCutinVehId::Other(x),
        }
    }
    
    /// Get raw value of DAS_cutinVehId
    ///
    /// - Start bit: 27
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_cutinVehId
    #[inline(always)]
    pub fn set_das_cutin_veh_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..34].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehRelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_relevant_for_control(&self) -> bool {
        self.das_cutin_veh_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_cutinVehRelevantForControl
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_cutinVehRelevantForControl
    #[inline(always)]
    pub fn set_das_cutin_veh_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehType
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_type(&self) -> Id309dasObjectDasCutinVehType {
        match self.das_cutin_veh_type_raw() {
            4 => Id309dasObjectDasCutinVehType::Bicycle,
            2 => Id309dasObjectDasCutinVehType::Car,
            3 => Id309dasObjectDasCutinVehType::Motorcycle,
            5 => Id309dasObjectDasCutinVehType::Pedestrian,
            1 => Id309dasObjectDasCutinVehType::Truck,
            0 => Id309dasObjectDasCutinVehType::Unknown,
            x => Id309dasObjectDasCutinVehType::Other(x),
        }
    }
    
    /// Get raw value of DAS_cutinVehType
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_cutinVehType
    #[inline(always)]
    pub fn set_das_cutin_veh_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// DAS_cutinVehVxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_cutin_veh_vx_rel(&self) -> Id309dasObjectDasCutinVehVxRel {
        match self.das_cutin_veh_vx_rel_raw() {
            15 => Id309dasObjectDasCutinVehVxRel::Sna,
            x => Id309dasObjectDasCutinVehVxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_cutinVehVxRel
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_cutin_veh_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_cutinVehVxRel
    #[inline(always)]
    pub fn set_das_cutin_veh_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2Dx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_dx(&self) -> Id309dasObjectDasLeadVeh2Dx {
        match self.das_lead_veh2_dx_raw() {
            255 => Id309dasObjectDasLeadVeh2Dx::Sna,
            x => Id309dasObjectDasLeadVeh2Dx::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVeh2Dx
    ///
    /// - Start bit: 39
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[39..47].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVeh2Dx
    #[inline(always)]
    pub fn set_das_lead_veh2_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[39..47].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2Dy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_dy(&self) -> f32 {
        self.das_lead_veh2_dy_raw()
    }
    
    /// Get raw value of DAS_leadVeh2Dy
    ///
    /// - Start bit: 51
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..58].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVeh2Dy
    #[inline(always)]
    pub fn set_das_lead_veh2_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[51..58].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2Heading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_heading(&self) -> Id309dasObjectDasLeadVeh2Heading {
        match self.das_lead_veh2_heading_raw() {
            255 => Id309dasObjectDasLeadVeh2Heading::Sna,
            x => Id309dasObjectDasLeadVeh2Heading::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVeh2Heading
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVeh2Heading
    #[inline(always)]
    pub fn set_das_lead_veh2_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2Id
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_id(&self) -> Id309dasObjectDasLeadVeh2Id {
        match self.das_lead_veh2_id_raw() {
            0 => Id309dasObjectDasLeadVeh2Id::Sna,
            x => Id309dasObjectDasLeadVeh2Id::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVeh2Id
    ///
    /// - Start bit: 58
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leadVeh2Id
    #[inline(always)]
    pub fn set_das_lead_veh2_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..64].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2RelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_relevant_for_control(&self) -> bool {
        self.das_lead_veh2_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_leadVeh2RelevantForControl
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_leadVeh2RelevantForControl
    #[inline(always)]
    pub fn set_das_lead_veh2_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2Type
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_type(&self) -> Id309dasObjectDasLeadVeh2Type {
        match self.das_lead_veh2_type_raw() {
            4 => Id309dasObjectDasLeadVeh2Type::Bicycle,
            2 => Id309dasObjectDasLeadVeh2Type::Car,
            3 => Id309dasObjectDasLeadVeh2Type::Motorcycle,
            5 => Id309dasObjectDasLeadVeh2Type::Pedestrian,
            1 => Id309dasObjectDasLeadVeh2Type::Truck,
            0 => Id309dasObjectDasLeadVeh2Type::Unknown,
            x => Id309dasObjectDasLeadVeh2Type::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVeh2Type
    ///
    /// - Start bit: 34
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..37].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leadVeh2Type
    #[inline(always)]
    pub fn set_das_lead_veh2_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..37].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVeh2VxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh2_vx_rel(&self) -> Id309dasObjectDasLeadVeh2VxRel {
        match self.das_lead_veh2_vx_rel_raw() {
            15 => Id309dasObjectDasLeadVeh2VxRel::Sna,
            x => Id309dasObjectDasLeadVeh2VxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVeh2VxRel
    ///
    /// - Start bit: 47
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh2_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..51].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVeh2VxRel
    #[inline(always)]
    pub fn set_das_lead_veh2_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[47..51].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehDx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_dx(&self) -> Id309dasObjectDasLeadVehDx {
        match self.das_lead_veh_dx_raw() {
            255 => Id309dasObjectDasLeadVehDx::Sna,
            x => Id309dasObjectDasLeadVehDx::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVehDx
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVehDx
    #[inline(always)]
    pub fn set_das_lead_veh_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehDy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_dy(&self) -> f32 {
        self.das_lead_veh_dy_raw()
    }
    
    /// Get raw value of DAS_leadVehDy
    ///
    /// - Start bit: 20
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..27].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVehDy
    #[inline(always)]
    pub fn set_das_lead_veh_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[20..27].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehHeading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_heading(&self) -> Id309dasObjectDasLeadVehHeading {
        match self.das_lead_veh_heading_raw() {
            255 => Id309dasObjectDasLeadVehHeading::Sna,
            x => Id309dasObjectDasLeadVehHeading::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVehHeading
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVehHeading
    #[inline(always)]
    pub fn set_das_lead_veh_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehId
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_id(&self) -> Id309dasObjectDasLeadVehId {
        match self.das_lead_veh_id_raw() {
            127 => Id309dasObjectDasLeadVehId::Sna,
            x => Id309dasObjectDasLeadVehId::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVehId
    ///
    /// - Start bit: 27
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leadVehId
    #[inline(always)]
    pub fn set_das_lead_veh_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..34].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehRelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_relevant_for_control(&self) -> bool {
        self.das_lead_veh_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_leadVehRelevantForControl
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_leadVehRelevantForControl
    #[inline(always)]
    pub fn set_das_lead_veh_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehType
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_type(&self) -> Id309dasObjectDasLeadVehType {
        match self.das_lead_veh_type_raw() {
            4 => Id309dasObjectDasLeadVehType::Bicycle,
            2 => Id309dasObjectDasLeadVehType::Car,
            6 => Id309dasObjectDasLeadVehType::Ipso,
            3 => Id309dasObjectDasLeadVehType::Motorcycle,
            5 => Id309dasObjectDasLeadVehType::Pedestrian,
            1 => Id309dasObjectDasLeadVehType::Truck,
            0 => Id309dasObjectDasLeadVehType::Unknown,
            x => Id309dasObjectDasLeadVehType::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVehType
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leadVehType
    #[inline(always)]
    pub fn set_das_lead_veh_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// DAS_leadVehVxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lead_veh_vx_rel(&self) -> Id309dasObjectDasLeadVehVxRel {
        match self.das_lead_veh_vx_rel_raw() {
            15 => Id309dasObjectDasLeadVehVxRel::Sna,
            x => Id309dasObjectDasLeadVehVxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_leadVehVxRel
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lead_veh_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leadVehVxRel
    #[inline(always)]
    pub fn set_das_lead_veh_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2Dx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_dx(&self) -> Id309dasObjectDasLeftVeh2Dx {
        match self.das_left_veh2_dx_raw() {
            255 => Id309dasObjectDasLeftVeh2Dx::Sna,
            x => Id309dasObjectDasLeftVeh2Dx::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVeh2Dx
    ///
    /// - Start bit: 39
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[39..47].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVeh2Dx
    #[inline(always)]
    pub fn set_das_left_veh2_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[39..47].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2Dy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_dy(&self) -> f32 {
        self.das_left_veh2_dy_raw()
    }
    
    /// Get raw value of DAS_leftVeh2Dy
    ///
    /// - Start bit: 51
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..58].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVeh2Dy
    #[inline(always)]
    pub fn set_das_left_veh2_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[51..58].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2Heading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_heading(&self) -> Id309dasObjectDasLeftVeh2Heading {
        match self.das_left_veh2_heading_raw() {
            255 => Id309dasObjectDasLeftVeh2Heading::Sna,
            x => Id309dasObjectDasLeftVeh2Heading::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVeh2Heading
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVeh2Heading
    #[inline(always)]
    pub fn set_das_left_veh2_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2Id
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_id(&self) -> Id309dasObjectDasLeftVeh2Id {
        match self.das_left_veh2_id_raw() {
            0 => Id309dasObjectDasLeftVeh2Id::Sna,
            x => Id309dasObjectDasLeftVeh2Id::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVeh2Id
    ///
    /// - Start bit: 58
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leftVeh2Id
    #[inline(always)]
    pub fn set_das_left_veh2_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..64].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2RelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_relevant_for_control(&self) -> bool {
        self.das_left_veh2_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_leftVeh2RelevantForControl
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_leftVeh2RelevantForControl
    #[inline(always)]
    pub fn set_das_left_veh2_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2Type
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_type(&self) -> Id309dasObjectDasLeftVeh2Type {
        match self.das_left_veh2_type_raw() {
            4 => Id309dasObjectDasLeftVeh2Type::Bicycle,
            2 => Id309dasObjectDasLeftVeh2Type::Car,
            3 => Id309dasObjectDasLeftVeh2Type::Motorcycle,
            5 => Id309dasObjectDasLeftVeh2Type::Pedestrian,
            1 => Id309dasObjectDasLeftVeh2Type::Truck,
            0 => Id309dasObjectDasLeftVeh2Type::Unknown,
            x => Id309dasObjectDasLeftVeh2Type::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVeh2Type
    ///
    /// - Start bit: 34
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..37].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leftVeh2Type
    #[inline(always)]
    pub fn set_das_left_veh2_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..37].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVeh2VxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh2_vx_rel(&self) -> Id309dasObjectDasLeftVeh2VxRel {
        match self.das_left_veh2_vx_rel_raw() {
            15 => Id309dasObjectDasLeftVeh2VxRel::Sna,
            x => Id309dasObjectDasLeftVeh2VxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVeh2VxRel
    ///
    /// - Start bit: 47
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh2_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..51].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVeh2VxRel
    #[inline(always)]
    pub fn set_das_left_veh2_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[47..51].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehDx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_dx(&self) -> Id309dasObjectDasLeftVehDx {
        match self.das_left_veh_dx_raw() {
            255 => Id309dasObjectDasLeftVehDx::Sna,
            x => Id309dasObjectDasLeftVehDx::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVehDx
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVehDx
    #[inline(always)]
    pub fn set_das_left_veh_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehDy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_dy(&self) -> f32 {
        self.das_left_veh_dy_raw()
    }
    
    /// Get raw value of DAS_leftVehDy
    ///
    /// - Start bit: 20
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..27].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVehDy
    #[inline(always)]
    pub fn set_das_left_veh_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[20..27].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehHeading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_heading(&self) -> Id309dasObjectDasLeftVehHeading {
        match self.das_left_veh_heading_raw() {
            255 => Id309dasObjectDasLeftVehHeading::Sna,
            x => Id309dasObjectDasLeftVehHeading::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVehHeading
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVehHeading
    #[inline(always)]
    pub fn set_das_left_veh_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehId
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_id(&self) -> Id309dasObjectDasLeftVehId {
        match self.das_left_veh_id_raw() {
            127 => Id309dasObjectDasLeftVehId::Sna,
            x => Id309dasObjectDasLeftVehId::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVehId
    ///
    /// - Start bit: 27
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leftVehId
    #[inline(always)]
    pub fn set_das_left_veh_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..34].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehRelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_relevant_for_control(&self) -> bool {
        self.das_left_veh_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_leftVehRelevantForControl
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_leftVehRelevantForControl
    #[inline(always)]
    pub fn set_das_left_veh_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehType
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_type(&self) -> Id309dasObjectDasLeftVehType {
        match self.das_left_veh_type_raw() {
            4 => Id309dasObjectDasLeftVehType::Bicycle,
            2 => Id309dasObjectDasLeftVehType::Car,
            3 => Id309dasObjectDasLeftVehType::Motorcycle,
            5 => Id309dasObjectDasLeftVehType::Pedestrian,
            1 => Id309dasObjectDasLeftVehType::Truck,
            0 => Id309dasObjectDasLeftVehType::Unknown,
            x => Id309dasObjectDasLeftVehType::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVehType
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_leftVehType
    #[inline(always)]
    pub fn set_das_left_veh_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// DAS_leftVehVxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_left_veh_vx_rel(&self) -> Id309dasObjectDasLeftVehVxRel {
        match self.das_left_veh_vx_rel_raw() {
            15 => Id309dasObjectDasLeftVehVxRel::Sna,
            x => Id309dasObjectDasLeftVehVxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_leftVehVxRel
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_left_veh_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_leftVehVxRel
    #[inline(always)]
    pub fn set_das_left_veh_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2Dx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_dx(&self) -> Id309dasObjectDasRightVeh2Dx {
        match self.das_right_veh2_dx_raw() {
            255 => Id309dasObjectDasRightVeh2Dx::Sna,
            x => Id309dasObjectDasRightVeh2Dx::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVeh2Dx
    ///
    /// - Start bit: 39
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[39..47].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVeh2Dx
    #[inline(always)]
    pub fn set_das_right_veh2_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[39..47].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2Dy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_dy(&self) -> f32 {
        self.das_right_veh2_dy_raw()
    }
    
    /// Get raw value of DAS_rightVeh2Dy
    ///
    /// - Start bit: 51
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..58].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVeh2Dy
    #[inline(always)]
    pub fn set_das_right_veh2_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[51..58].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2Heading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_heading(&self) -> Id309dasObjectDasRightVeh2Heading {
        match self.das_right_veh2_heading_raw() {
            255 => Id309dasObjectDasRightVeh2Heading::Sna,
            x => Id309dasObjectDasRightVeh2Heading::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVeh2Heading
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVeh2Heading
    #[inline(always)]
    pub fn set_das_right_veh2_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2Id
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_id(&self) -> Id309dasObjectDasRightVeh2Id {
        match self.das_right_veh2_id_raw() {
            0 => Id309dasObjectDasRightVeh2Id::Sna,
            x => Id309dasObjectDasRightVeh2Id::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVeh2Id
    ///
    /// - Start bit: 58
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_rightVeh2Id
    #[inline(always)]
    pub fn set_das_right_veh2_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..64].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2RelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_relevant_for_control(&self) -> bool {
        self.das_right_veh2_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_rightVeh2RelevantForControl
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rightVeh2RelevantForControl
    #[inline(always)]
    pub fn set_das_right_veh2_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2Type
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_type(&self) -> Id309dasObjectDasRightVeh2Type {
        match self.das_right_veh2_type_raw() {
            4 => Id309dasObjectDasRightVeh2Type::Bicycle,
            2 => Id309dasObjectDasRightVeh2Type::Car,
            3 => Id309dasObjectDasRightVeh2Type::Motorcycle,
            5 => Id309dasObjectDasRightVeh2Type::Pedestrian,
            1 => Id309dasObjectDasRightVeh2Type::Truck,
            0 => Id309dasObjectDasRightVeh2Type::Unknown,
            x => Id309dasObjectDasRightVeh2Type::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVeh2Type
    ///
    /// - Start bit: 34
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..37].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_rightVeh2Type
    #[inline(always)]
    pub fn set_das_right_veh2_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..37].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVeh2VxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh2_vx_rel(&self) -> Id309dasObjectDasRightVeh2VxRel {
        match self.das_right_veh2_vx_rel_raw() {
            15 => Id309dasObjectDasRightVeh2VxRel::Sna,
            x => Id309dasObjectDasRightVeh2VxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVeh2VxRel
    ///
    /// - Start bit: 47
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh2_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..51].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVeh2VxRel
    #[inline(always)]
    pub fn set_das_right_veh2_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[47..51].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehDx
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_dx(&self) -> Id309dasObjectDasRightVehDx {
        match self.das_right_veh_dx_raw() {
            255 => Id309dasObjectDasRightVehDx::Sna,
            x => Id309dasObjectDasRightVehDx::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVehDx
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_dx_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVehDx
    #[inline(always)]
    pub fn set_das_right_veh_dx(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehDy
    ///
    /// - Min: -22.05
    /// - Max: 22.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_dy(&self) -> f32 {
        self.das_right_veh_dy_raw()
    }
    
    /// Get raw value of DAS_rightVehDy
    ///
    /// - Start bit: 20
    /// - Signal size: 7 bits
    /// - Factor: 0.35
    /// - Offset: -22.05
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_dy_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..27].load_le::<u8>();
        
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVehDy
    #[inline(always)]
    pub fn set_das_right_veh_dy(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22.05_f32 || 22.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.35_f32;
        let offset = -22.05_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[20..27].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehHeading
    ///
    /// - Min: -3.14159
    /// - Max: 3.09251
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_heading(&self) -> Id309dasObjectDasRightVehHeading {
        match self.das_right_veh_heading_raw() {
            255 => Id309dasObjectDasRightVehHeading::Sna,
            x => Id309dasObjectDasRightVehHeading::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVehHeading
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.0245437
    /// - Offset: -3.14159
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVehHeading
    #[inline(always)]
    pub fn set_das_right_veh_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3.14159_f32 || 3.09251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.0245437_f32;
        let offset = -3.14159_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehId
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_id(&self) -> Id309dasObjectDasRightVehId {
        match self.das_right_veh_id_raw() {
            127 => Id309dasObjectDasRightVehId::Sna,
            x => Id309dasObjectDasRightVehId::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVehId
    ///
    /// - Start bit: 27
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_rightVehId
    #[inline(always)]
    pub fn set_das_right_veh_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..34].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehRelevantForControl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_relevant_for_control(&self) -> bool {
        self.das_right_veh_relevant_for_control_raw()
    }
    
    /// Get raw value of DAS_rightVehRelevantForControl
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_relevant_for_control_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_rightVehRelevantForControl
    #[inline(always)]
    pub fn set_das_right_veh_relevant_for_control(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehType
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_type(&self) -> Id309dasObjectDasRightVehType {
        match self.das_right_veh_type_raw() {
            4 => Id309dasObjectDasRightVehType::Bicycle,
            2 => Id309dasObjectDasRightVehType::Car,
            3 => Id309dasObjectDasRightVehType::Motorcycle,
            5 => Id309dasObjectDasRightVehType::Pedestrian,
            1 => Id309dasObjectDasRightVehType::Truck,
            0 => Id309dasObjectDasRightVehType::Unknown,
            x => Id309dasObjectDasRightVehType::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVehType
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_rightVehType
    #[inline(always)]
    pub fn set_das_right_veh_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// DAS_rightVehVxRel
    ///
    /// - Min: -30
    /// - Max: 26
    /// - Unit: "m/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_right_veh_vx_rel(&self) -> Id309dasObjectDasRightVehVxRel {
        match self.das_right_veh_vx_rel_raw() {
            15 => Id309dasObjectDasRightVehVxRel::Sna,
            x => Id309dasObjectDasRightVehVxRel::Other(x),
        }
    }
    
    /// Get raw value of DAS_rightVehVxRel
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 4
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_right_veh_vx_rel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_rightVehVxRel
    #[inline(always)]
    pub fn set_das_right_veh_vx_rel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 4_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignArrow
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_arrow(&self) -> Id309dasObjectDasRoadSignArrow {
        match self.das_road_sign_arrow_raw() {
            0 => Id309dasObjectDasRoadSignArrow::Circle,
            1 => Id309dasObjectDasRoadSignArrow::Left,
            2 => Id309dasObjectDasRoadSignArrow::Right,
            3 => Id309dasObjectDasRoadSignArrow::Straight,
            4 => Id309dasObjectDasRoadSignArrow::Unknown,
            x => Id309dasObjectDasRoadSignArrow::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSignArrow
    ///
    /// - Start bit: 27
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_arrow_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_roadSignArrow
    #[inline(always)]
    pub fn set_das_road_sign_arrow(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..30].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignColor
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_color(&self) -> Id309dasObjectDasRoadSignColor {
        match self.das_road_sign_color_raw() {
            3 => Id309dasObjectDasRoadSignColor::Green,
            0 => Id309dasObjectDasRoadSignColor::None,
            1 => Id309dasObjectDasRoadSignColor::Red,
            4 => Id309dasObjectDasRoadSignColor::RedYellow,
            2 => Id309dasObjectDasRoadSignColor::Yellow,
            x => Id309dasObjectDasRoadSignColor::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSignColor
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_color_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_roadSignColor
    #[inline(always)]
    pub fn set_das_road_sign_color(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..6].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignControlActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_control_active(&self) -> bool {
        self.das_road_sign_control_active_raw()
    }
    
    /// Get raw value of DAS_roadSignControlActive
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_control_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_roadSignControlActive
    #[inline(always)]
    pub fn set_das_road_sign_control_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_id(&self) -> Id309dasObjectDasRoadSignId {
        match self.das_road_sign_id_raw() {
            255 => Id309dasObjectDasRoadSignId::Sna,
            0 => Id309dasObjectDasRoadSignId::StopSign,
            1 => Id309dasObjectDasRoadSignId::TrafficLight,
            x => Id309dasObjectDasRoadSignId::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSignId
    ///
    /// - Start bit: 6
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_roadSignId
    #[inline(always)]
    pub fn set_das_road_sign_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..14].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignOrientation
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_orientation(&self) -> Id309dasObjectDasRoadSignOrientation {
        match self.das_road_sign_orientation_raw() {
            2 => Id309dasObjectDasRoadSignOrientation::Horizontal3Light,
            0 => Id309dasObjectDasRoadSignOrientation::Unknown,
            1 => Id309dasObjectDasRoadSignOrientation::Vertical3Light,
            x => Id309dasObjectDasRoadSignOrientation::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSignOrientation
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_orientation_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_roadSignOrientation
    #[inline(always)]
    pub fn set_das_road_sign_orientation(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..32].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignSource
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_source(&self) -> Id309dasObjectDasRoadSignSource {
        match self.das_road_sign_source_raw() {
            1 => Id309dasObjectDasRoadSignSource::Nav,
            0 => Id309dasObjectDasRoadSignSource::None,
            2 => Id309dasObjectDasRoadSignSource::Vision,
            x => Id309dasObjectDasRoadSignSource::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSignSource
    ///
    /// - Start bit: 25
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_source_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[25..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_roadSignSource
    #[inline(always)]
    pub fn set_das_road_sign_source(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        self.raw.view_bits_mut::<LocalBits>()[25..27].store_le(value);
        Ok(())
    }
    
    /// DAS_roadSignStopLineDist
    ///
    /// - Min: -20
    /// - Max: 184.4
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_road_sign_stop_line_dist(&self) -> Id309dasObjectDasRoadSignStopLineDist {
        match self.das_road_sign_stop_line_dist_raw() {
            1023 => Id309dasObjectDasRoadSignStopLineDist::Sna,
            x => Id309dasObjectDasRoadSignStopLineDist::Other(x),
        }
    }
    
    /// Get raw value of DAS_roadSignStopLineDist
    ///
    /// - Start bit: 14
    /// - Signal size: 10 bits
    /// - Factor: 0.2
    /// - Offset: -20
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_road_sign_stop_line_dist_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[14..24].load_le::<u16>();
        
        let factor = 0.2_f32;
        let offset = -20_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_roadSignStopLineDist
    #[inline(always)]
    pub fn set_das_road_sign_stop_line_dist(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 184.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 777 }); }
        let factor = 0.2_f32;
        let offset = -20_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[14..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id309dasObject {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id309dasObject
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_object_id = u.int_in_range(0..=5)?;
        let das_cutin_veh_dx = 0_f32;
        let das_cutin_veh_dy = -22.05_f32;
        let das_cutin_veh_heading = -3.14159_f32;
        let das_cutin_veh_id = u.int_in_range(0..=127)?;
        let das_cutin_veh_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_cutin_veh_type = u.int_in_range(0..=5)?;
        let das_cutin_veh_vx_rel = -30_f32;
        let das_lead_veh2_dx = 0_f32;
        let das_lead_veh2_dy = -22.05_f32;
        let das_lead_veh2_heading = -3.14159_f32;
        let das_lead_veh2_id = u.int_in_range(0..=63)?;
        let das_lead_veh2_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_lead_veh2_type = u.int_in_range(0..=5)?;
        let das_lead_veh2_vx_rel = -30_f32;
        let das_lead_veh_dx = 0_f32;
        let das_lead_veh_dy = -22.05_f32;
        let das_lead_veh_heading = -3.14159_f32;
        let das_lead_veh_id = u.int_in_range(0..=127)?;
        let das_lead_veh_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_lead_veh_type = u.int_in_range(0..=6)?;
        let das_lead_veh_vx_rel = -30_f32;
        let das_left_veh2_dx = 0_f32;
        let das_left_veh2_dy = -22.05_f32;
        let das_left_veh2_heading = -3.14159_f32;
        let das_left_veh2_id = u.int_in_range(0..=63)?;
        let das_left_veh2_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_left_veh2_type = u.int_in_range(0..=5)?;
        let das_left_veh2_vx_rel = -30_f32;
        let das_left_veh_dx = 0_f32;
        let das_left_veh_dy = -22.05_f32;
        let das_left_veh_heading = -3.14159_f32;
        let das_left_veh_id = u.int_in_range(0..=127)?;
        let das_left_veh_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_left_veh_type = u.int_in_range(0..=5)?;
        let das_left_veh_vx_rel = -30_f32;
        let das_right_veh2_dx = 0_f32;
        let das_right_veh2_dy = -22.05_f32;
        let das_right_veh2_heading = -3.14159_f32;
        let das_right_veh2_id = u.int_in_range(0..=63)?;
        let das_right_veh2_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_right_veh2_type = u.int_in_range(0..=5)?;
        let das_right_veh2_vx_rel = -30_f32;
        let das_right_veh_dx = 0_f32;
        let das_right_veh_dy = -22.05_f32;
        let das_right_veh_heading = -3.14159_f32;
        let das_right_veh_id = u.int_in_range(0..=127)?;
        let das_right_veh_relevant_for_control = u.int_in_range(0..=1)? == 1;
        let das_right_veh_type = u.int_in_range(0..=5)?;
        let das_right_veh_vx_rel = -30_f32;
        let das_road_sign_arrow = u.int_in_range(0..=4)?;
        let das_road_sign_color = u.int_in_range(0..=4)?;
        let das_road_sign_control_active = u.int_in_range(0..=1)? == 1;
        let das_road_sign_id = u.int_in_range(0..=255)?;
        let das_road_sign_orientation = u.int_in_range(0..=2)?;
        let das_road_sign_source = u.int_in_range(0..=2)?;
        let das_road_sign_stop_line_dist = -20_f32;
        Id309dasObject::new(das_object_id,das_cutin_veh_dx,das_cutin_veh_dy,das_cutin_veh_heading,das_cutin_veh_id,das_cutin_veh_relevant_for_control,das_cutin_veh_type,das_cutin_veh_vx_rel,das_lead_veh2_dx,das_lead_veh2_dy,das_lead_veh2_heading,das_lead_veh2_id,das_lead_veh2_relevant_for_control,das_lead_veh2_type,das_lead_veh2_vx_rel,das_lead_veh_dx,das_lead_veh_dy,das_lead_veh_heading,das_lead_veh_id,das_lead_veh_relevant_for_control,das_lead_veh_type,das_lead_veh_vx_rel,das_left_veh2_dx,das_left_veh2_dy,das_left_veh2_heading,das_left_veh2_id,das_left_veh2_relevant_for_control,das_left_veh2_type,das_left_veh2_vx_rel,das_left_veh_dx,das_left_veh_dy,das_left_veh_heading,das_left_veh_id,das_left_veh_relevant_for_control,das_left_veh_type,das_left_veh_vx_rel,das_right_veh2_dx,das_right_veh2_dy,das_right_veh2_heading,das_right_veh2_id,das_right_veh2_relevant_for_control,das_right_veh2_type,das_right_veh2_vx_rel,das_right_veh_dx,das_right_veh_dy,das_right_veh_heading,das_right_veh_id,das_right_veh_relevant_for_control,das_right_veh_type,das_right_veh_vx_rel,das_road_sign_arrow,das_road_sign_color,das_road_sign_control_active,das_road_sign_id,das_road_sign_orientation,das_road_sign_source,das_road_sign_stop_line_dist).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_objectId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasObjectId {
    CutinVehicle,
    LeadVehicles,
    LeftVehicles,
    RightVehicles,
    RoadSign,
    VehicleHeadings,
    Other(u8),
}
/// Defined values for DAS_cutinVehDx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasCutinVehDx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_cutinVehHeading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasCutinVehHeading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_cutinVehId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasCutinVehId {
    Sna,
    Other(u8),
}
/// Defined values for DAS_cutinVehType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasCutinVehType {
    Bicycle,
    Car,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_cutinVehVxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasCutinVehVxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leadVeh2Dx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVeh2Dx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leadVeh2Heading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVeh2Heading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leadVeh2Id
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVeh2Id {
    Sna,
    Other(u8),
}
/// Defined values for DAS_leadVeh2Type
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVeh2Type {
    Bicycle,
    Car,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_leadVeh2VxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVeh2VxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leadVehDx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVehDx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leadVehHeading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVehHeading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leadVehId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVehId {
    Sna,
    Other(u8),
}
/// Defined values for DAS_leadVehType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVehType {
    Bicycle,
    Car,
    Ipso,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_leadVehVxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeadVehVxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leftVeh2Dx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVeh2Dx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leftVeh2Heading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVeh2Heading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leftVeh2Id
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVeh2Id {
    Sna,
    Other(u8),
}
/// Defined values for DAS_leftVeh2Type
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVeh2Type {
    Bicycle,
    Car,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_leftVeh2VxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVeh2VxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leftVehDx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVehDx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leftVehHeading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVehHeading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_leftVehId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVehId {
    Sna,
    Other(u8),
}
/// Defined values for DAS_leftVehType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVehType {
    Bicycle,
    Car,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_leftVehVxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasLeftVehVxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_rightVeh2Dx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVeh2Dx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_rightVeh2Heading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVeh2Heading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_rightVeh2Id
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVeh2Id {
    Sna,
    Other(u8),
}
/// Defined values for DAS_rightVeh2Type
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVeh2Type {
    Bicycle,
    Car,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_rightVeh2VxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVeh2VxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_rightVehDx
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVehDx {
    Sna,
    Other(f32),
}
/// Defined values for DAS_rightVehHeading
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVehHeading {
    Sna,
    Other(f32),
}
/// Defined values for DAS_rightVehId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVehId {
    Sna,
    Other(u8),
}
/// Defined values for DAS_rightVehType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVehType {
    Bicycle,
    Car,
    Motorcycle,
    Pedestrian,
    Truck,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_rightVehVxRel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRightVehVxRel {
    Sna,
    Other(f32),
}
/// Defined values for DAS_roadSignArrow
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRoadSignArrow {
    Circle,
    Left,
    Right,
    Straight,
    Unknown,
    Other(u8),
}
/// Defined values for DAS_roadSignColor
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRoadSignColor {
    Green,
    None,
    Red,
    RedYellow,
    Yellow,
    Other(u8),
}
/// Defined values for DAS_roadSignId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRoadSignId {
    Sna,
    StopSign,
    TrafficLight,
    Other(u8),
}
/// Defined values for DAS_roadSignOrientation
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRoadSignOrientation {
    Horizontal3Light,
    Unknown,
    Vertical3Light,
    Other(u8),
}
/// Defined values for DAS_roadSignSource
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRoadSignSource {
    Nav,
    None,
    Vision,
    Other(u8),
}
/// Defined values for DAS_roadSignStopLineDist
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id309dasObjectDasRoadSignStopLineDist {
    Sna,
    Other(f32),
}

/// ID389DAS_status2
///
/// - ID: 905 (0x389)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id389dasStatus2 {
    raw: [u8; 8],
}

impl Id389dasStatus2 {
    pub const MESSAGE_ID: u32 = 905;
    
    /// Construct new ID389DAS_status2 from values
    pub fn new(das_acc_report: u8, das_acc_speed_limit: f32, das_activation_failure_status: u8, das_csa_state: u8, das_driver_interaction_level: u8, das_long_collision_warning: u8, das_pmm_camera_fault_reason: u8, das_pmm_logging_request: bool, das_pmm_obstacle_severity: u8, das_pmm_radar_fault_reason: u8, das_pmm_sys_fault_reason: u8, das_pmm_ultrasonics_fault_reason: u8, das_pp_offset_desired_ramp: f32, das_radar_telemetry: u8, das_relax_cruise_limits: bool, das_rob_state: u8, das_status2_checksum: u8, das_status2_counter: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_acc_report(das_acc_report)?;
        res.set_das_acc_speed_limit(das_acc_speed_limit)?;
        res.set_das_activation_failure_status(das_activation_failure_status)?;
        res.set_das_csa_state(das_csa_state)?;
        res.set_das_driver_interaction_level(das_driver_interaction_level)?;
        res.set_das_long_collision_warning(das_long_collision_warning)?;
        res.set_das_pmm_camera_fault_reason(das_pmm_camera_fault_reason)?;
        res.set_das_pmm_logging_request(das_pmm_logging_request)?;
        res.set_das_pmm_obstacle_severity(das_pmm_obstacle_severity)?;
        res.set_das_pmm_radar_fault_reason(das_pmm_radar_fault_reason)?;
        res.set_das_pmm_sys_fault_reason(das_pmm_sys_fault_reason)?;
        res.set_das_pmm_ultrasonics_fault_reason(das_pmm_ultrasonics_fault_reason)?;
        res.set_das_pp_offset_desired_ramp(das_pp_offset_desired_ramp)?;
        res.set_das_radar_telemetry(das_radar_telemetry)?;
        res.set_das_relax_cruise_limits(das_relax_cruise_limits)?;
        res.set_das_rob_state(das_rob_state)?;
        res.set_das_status2_checksum(das_status2_checksum)?;
        res.set_das_status2_counter(das_status2_counter)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_ACC_report
    ///
    /// - Min: 0
    /// - Max: 24
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_acc_report(&self) -> Id389dasStatus2DasAccReport {
        match self.das_acc_report_raw() {
            24 => Id389dasStatus2DasAccReport::AccReportBehaviorReport,
            23 => Id389dasStatus2DasAccReport::AccReportCameraOnly,
            21 => Id389dasStatus2DasAccReport::AccReportCipvCuttingOut,
            10 => Id389dasStatus2DasAccReport::AccReportCsa,
            18 => Id389dasStatus2DasAccReport::AccReportFleetSpeeds,
            13 => Id389dasStatus2DasAccReport::AccReportLcExternalStateAborted,
            12 => Id389dasStatus2DasAccReport::AccReportLcExternalStateAborting,
            14 => Id389dasStatus2DasAccReport::AccReportLcExternalStateActiveRestricted,
            11 => Id389dasStatus2DasAccReport::AccReportLcHandsOnReqdStruckOut,
            19 => Id389dasStatus2DasAccReport::AccReportMcvlrDpp,
            20 => Id389dasStatus2DasAccReport::AccReportMcvlrInPath,
            22 => Id389dasStatus2DasAccReport::AccReportRadarObjFive,
            15 => Id389dasStatus2DasAccReport::AccReportRadarObjOne,
            16 => Id389dasStatus2DasAccReport::AccReportRadarObjTwo,
            1 => Id389dasStatus2DasAccReport::AccReportTargetCipv,
            5 => Id389dasStatus2DasAccReport::AccReportTargetCutin,
            2 => Id389dasStatus2DasAccReport::AccReportTargetInFrontOfCipv,
            17 => Id389dasStatus2DasAccReport::AccReportTargetMcp,
            3 => Id389dasStatus2DasAccReport::AccReportTargetMcvl,
            4 => Id389dasStatus2DasAccReport::AccReportTargetMcvr,
            0 => Id389dasStatus2DasAccReport::AccReportTargetNone,
            9 => Id389dasStatus2DasAccReport::AccReportTargetTypeFault,
            8 => Id389dasStatus2DasAccReport::AccReportTargetTypeIpso,
            6 => Id389dasStatus2DasAccReport::AccReportTargetTypeStopSign,
            7 => Id389dasStatus2DasAccReport::AccReportTargetTypeTrafficLight,
            x => Id389dasStatus2DasAccReport::Other(x),
        }
    }
    
    /// Get raw value of DAS_ACC_report
    ///
    /// - Start bit: 26
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_acc_report_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_ACC_report
    #[inline(always)]
    pub fn set_das_acc_report(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 24_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..31].store_le(value);
        Ok(())
    }
    
    /// DAS_accSpeedLimit
    ///
    /// - Min: 0
    /// - Max: 204.6
    /// - Unit: "mph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_acc_speed_limit(&self) -> Id389dasStatus2DasAccSpeedLimit {
        match self.das_acc_speed_limit_raw() {
            0 => Id389dasStatus2DasAccSpeedLimit::None,
            1023 => Id389dasStatus2DasAccSpeedLimit::Sna,
            x => Id389dasStatus2DasAccSpeedLimit::Other(x),
        }
    }
    
    /// Get raw value of DAS_accSpeedLimit
    ///
    /// - Start bit: 0
    /// - Signal size: 10 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_acc_speed_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..10].load_le::<u16>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_accSpeedLimit
    #[inline(always)]
    pub fn set_das_acc_speed_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 204.6_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..10].store_le(value);
        Ok(())
    }
    
    /// DAS_activationFailureStatus
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_activation_failure_status(&self) -> Id389dasStatus2DasActivationFailureStatus {
        match self.das_activation_failure_status_raw() {
            1 => Id389dasStatus2DasActivationFailureStatus::LcActivationFailed1,
            2 => Id389dasStatus2DasActivationFailureStatus::LcActivationFailed2,
            0 => Id389dasStatus2DasActivationFailureStatus::LcActivationIdle,
            x => Id389dasStatus2DasActivationFailureStatus::Other(x),
        }
    }
    
    /// Get raw value of DAS_activationFailureStatus
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_activation_failure_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_activationFailureStatus
    #[inline(always)]
    pub fn set_das_activation_failure_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// DAS_csaState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_csa_state(&self) -> Id389dasStatus2DasCsaState {
        match self.das_csa_state_raw() {
            1 => Id389dasStatus2DasCsaState::CsaExternalStateAvailable,
            2 => Id389dasStatus2DasCsaState::CsaExternalStateEnable,
            3 => Id389dasStatus2DasCsaState::CsaExternalStateHold,
            0 => Id389dasStatus2DasCsaState::CsaExternalStateUnavailable,
            x => Id389dasStatus2DasCsaState::Other(x),
        }
    }
    
    /// Get raw value of DAS_csaState
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_csa_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_csaState
    #[inline(always)]
    pub fn set_das_csa_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// DAS_driverInteractionLevel
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_driver_interaction_level(&self) -> Id389dasStatus2DasDriverInteractionLevel {
        match self.das_driver_interaction_level_raw() {
            2 => Id389dasStatus2DasDriverInteractionLevel::ContinuedDriverNotInteracting,
            0 => Id389dasStatus2DasDriverInteractionLevel::DriverInteracting,
            1 => Id389dasStatus2DasDriverInteractionLevel::DriverNotInteracting,
            x => Id389dasStatus2DasDriverInteractionLevel::Other(x),
        }
    }
    
    /// Get raw value of DAS_driverInteractionLevel
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_driver_interaction_level_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_driverInteractionLevel
    #[inline(always)]
    pub fn set_das_driver_interaction_level(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// DAS_longCollisionWarning
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_long_collision_warning(&self) -> Id389dasStatus2DasLongCollisionWarning {
        match self.das_long_collision_warning_raw() {
            3 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningIpso,
            0 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningNone,
            2 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningPedestrian,
            15 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningSna,
            4 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningStopsignStopline,
            5 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningTflStopline,
            6 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleCipv,
            12 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleCipv2,
            7 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleCutin,
            8 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleMcvl,
            9 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleMcvl2,
            10 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleMcvr,
            11 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleMcvr2,
            1 => Id389dasStatus2DasLongCollisionWarning::FcmLongCollisionWarningVehicleUnknown,
            x => Id389dasStatus2DasLongCollisionWarning::Other(x),
        }
    }
    
    /// Get raw value of DAS_longCollisionWarning
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_long_collision_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_longCollisionWarning
    #[inline(always)]
    pub fn set_das_long_collision_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..52].store_le(value);
        Ok(())
    }
    
    /// DAS_pmmCameraFaultReason
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pmm_camera_fault_reason(&self) -> Id389dasStatus2DasPmmCameraFaultReason {
        match self.das_pmm_camera_fault_reason_raw() {
            1 => Id389dasStatus2DasPmmCameraFaultReason::PmmCameraBlockedFront,
            2 => Id389dasStatus2DasPmmCameraFaultReason::PmmCameraInvalidMia,
            0 => Id389dasStatus2DasPmmCameraFaultReason::PmmCameraNoFault,
            x => Id389dasStatus2DasPmmCameraFaultReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_pmmCameraFaultReason
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pmm_camera_fault_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_pmmCameraFaultReason
    #[inline(always)]
    pub fn set_das_pmm_camera_fault_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// DAS_pmmLoggingRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pmm_logging_request(&self) -> Id389dasStatus2DasPmmLoggingRequest {
        match self.das_pmm_logging_request_raw() {
            false => Id389dasStatus2DasPmmLoggingRequest::False,
            true => Id389dasStatus2DasPmmLoggingRequest::True,
            x => Id389dasStatus2DasPmmLoggingRequest::Other(x),
        }
    }
    
    /// Get raw value of DAS_pmmLoggingRequest
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pmm_logging_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_pmmLoggingRequest
    #[inline(always)]
    pub fn set_das_pmm_logging_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// DAS_pmmObstacleSeverity
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pmm_obstacle_severity(&self) -> Id389dasStatus2DasPmmObstacleSeverity {
        match self.das_pmm_obstacle_severity_raw() {
            6 => Id389dasStatus2DasPmmObstacleSeverity::PmmAccelLimit,
            3 => Id389dasStatus2DasPmmObstacleSeverity::PmmBrakeRequest,
            5 => Id389dasStatus2DasPmmObstacleSeverity::PmmCrashFront,
            4 => Id389dasStatus2DasPmmObstacleSeverity::PmmCrashRear,
            2 => Id389dasStatus2DasPmmObstacleSeverity::PmmImminentFront,
            1 => Id389dasStatus2DasPmmObstacleSeverity::PmmImminentRear,
            0 => Id389dasStatus2DasPmmObstacleSeverity::PmmNone,
            7 => Id389dasStatus2DasPmmObstacleSeverity::PmmSna,
            x => Id389dasStatus2DasPmmObstacleSeverity::Other(x),
        }
    }
    
    /// Get raw value of DAS_pmmObstacleSeverity
    ///
    /// - Start bit: 10
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pmm_obstacle_severity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_pmmObstacleSeverity
    #[inline(always)]
    pub fn set_das_pmm_obstacle_severity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..13].store_le(value);
        Ok(())
    }
    
    /// DAS_pmmRadarFaultReason
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pmm_radar_fault_reason(&self) -> Id389dasStatus2DasPmmRadarFaultReason {
        match self.das_pmm_radar_fault_reason_raw() {
            1 => Id389dasStatus2DasPmmRadarFaultReason::PmmRadarBlockedFront,
            2 => Id389dasStatus2DasPmmRadarFaultReason::PmmRadarInvalidMia,
            0 => Id389dasStatus2DasPmmRadarFaultReason::PmmRadarNoFault,
            x => Id389dasStatus2DasPmmRadarFaultReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_pmmRadarFaultReason
    ///
    /// - Start bit: 19
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pmm_radar_fault_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[19..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_pmmRadarFaultReason
    #[inline(always)]
    pub fn set_das_pmm_radar_fault_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[19..21].store_le(value);
        Ok(())
    }
    
    /// DAS_pmmSysFaultReason
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pmm_sys_fault_reason(&self) -> Id389dasStatus2DasPmmSysFaultReason {
        match self.das_pmm_sys_fault_reason_raw() {
            7 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultBrakePedalInhibit,
            1 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultDasDisabled,
            5 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultDisabledByUser,
            3 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultDiFault,
            0 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultNone,
            6 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultRoadType,
            2 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultSpeed,
            4 => Id389dasStatus2DasPmmSysFaultReason::PmmFaultSteeringAngleRate,
            x => Id389dasStatus2DasPmmSysFaultReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_pmmSysFaultReason
    ///
    /// - Start bit: 21
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pmm_sys_fault_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_pmmSysFaultReason
    #[inline(always)]
    pub fn set_das_pmm_sys_fault_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..24].store_le(value);
        Ok(())
    }
    
    /// DAS_pmmUltrasonicsFaultReason
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pmm_ultrasonics_fault_reason(&self) -> Id389dasStatus2DasPmmUltrasonicsFaultReason {
        match self.das_pmm_ultrasonics_fault_reason_raw() {
            3 => Id389dasStatus2DasPmmUltrasonicsFaultReason::PmmUltrasonicsBlockedBoth,
            1 => Id389dasStatus2DasPmmUltrasonicsFaultReason::PmmUltrasonicsBlockedFront,
            2 => Id389dasStatus2DasPmmUltrasonicsFaultReason::PmmUltrasonicsBlockedRear,
            4 => Id389dasStatus2DasPmmUltrasonicsFaultReason::PmmUltrasonicsInvalidMia,
            0 => Id389dasStatus2DasPmmUltrasonicsFaultReason::PmmUltrasonicsNoFault,
            x => Id389dasStatus2DasPmmUltrasonicsFaultReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_pmmUltrasonicsFaultReason
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pmm_ultrasonics_fault_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_pmmUltrasonicsFaultReason
    #[inline(always)]
    pub fn set_das_pmm_ultrasonics_fault_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..19].store_le(value);
        Ok(())
    }
    
    /// DAS_ppOffsetDesiredRamp
    ///
    /// - Min: -1.28
    /// - Max: 1.27
    /// - Unit: "m"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_pp_offset_desired_ramp(&self) -> Id389dasStatus2DasPpOffsetDesiredRamp {
        match self.das_pp_offset_desired_ramp_raw() {
            128 => Id389dasStatus2DasPpOffsetDesiredRamp::PpNoOffset,
            x => Id389dasStatus2DasPpOffsetDesiredRamp::Other(x),
        }
    }
    
    /// Get raw value of DAS_ppOffsetDesiredRamp
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: -1.28
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_pp_offset_desired_ramp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = -1.28_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_ppOffsetDesiredRamp
    #[inline(always)]
    pub fn set_das_pp_offset_desired_ramp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.28_f32 || 1.27_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        let factor = 0.01_f32;
        let offset = -1.28_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DAS_radarTelemetry
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_radar_telemetry(&self) -> Id389dasStatus2DasRadarTelemetry {
        match self.das_radar_telemetry_raw() {
            0 => Id389dasStatus2DasRadarTelemetry::RadarTelemetryIdle,
            1 => Id389dasStatus2DasRadarTelemetry::RadarTelemetryNormal,
            2 => Id389dasStatus2DasRadarTelemetry::RadarTelemetryUrgent,
            x => Id389dasStatus2DasRadarTelemetry::Other(x),
        }
    }
    
    /// Get raw value of DAS_radarTelemetry
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_radar_telemetry_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_radarTelemetry
    #[inline(always)]
    pub fn set_das_radar_telemetry(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// DAS_relaxCruiseLimits
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_relax_cruise_limits(&self) -> bool {
        self.das_relax_cruise_limits_raw()
    }
    
    /// Get raw value of DAS_relaxCruiseLimits
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_relax_cruise_limits_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_relaxCruiseLimits
    #[inline(always)]
    pub fn set_das_relax_cruise_limits(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// DAS_robState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_rob_state(&self) -> Id389dasStatus2DasRobState {
        match self.das_rob_state_raw() {
            2 => Id389dasStatus2DasRobState::RobStateActive,
            0 => Id389dasStatus2DasRobState::RobStateInhibited,
            3 => Id389dasStatus2DasRobState::RobStateMapless,
            1 => Id389dasStatus2DasRobState::RobStateMeasure,
            x => Id389dasStatus2DasRobState::Other(x),
        }
    }
    
    /// Get raw value of DAS_robState
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_rob_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_robState
    #[inline(always)]
    pub fn set_das_rob_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..38].store_le(value);
        Ok(())
    }
    
    /// DAS_status2Checksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_status2_checksum(&self) -> u8 {
        self.das_status2_checksum_raw()
    }
    
    /// Get raw value of DAS_status2Checksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_status2_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_status2Checksum
    #[inline(always)]
    pub fn set_das_status2_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DAS_status2Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_status2_counter(&self) -> u8 {
        self.das_status2_counter_raw()
    }
    
    /// Get raw value of DAS_status2Counter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_status2_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_status2Counter
    #[inline(always)]
    pub fn set_das_status2_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 905 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id389dasStatus2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id389dasStatus2
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_acc_report = u.int_in_range(0..=24)?;
        let das_acc_speed_limit = 0_f32;
        let das_activation_failure_status = u.int_in_range(0..=2)?;
        let das_csa_state = u.int_in_range(0..=3)?;
        let das_driver_interaction_level = u.int_in_range(0..=2)?;
        let das_long_collision_warning = u.int_in_range(0..=15)?;
        let das_pmm_camera_fault_reason = u.int_in_range(0..=2)?;
        let das_pmm_logging_request = u.int_in_range(0..=1)? == 1;
        let das_pmm_obstacle_severity = u.int_in_range(0..=7)?;
        let das_pmm_radar_fault_reason = u.int_in_range(0..=2)?;
        let das_pmm_sys_fault_reason = u.int_in_range(0..=7)?;
        let das_pmm_ultrasonics_fault_reason = u.int_in_range(0..=4)?;
        let das_pp_offset_desired_ramp = -1.28_f32;
        let das_radar_telemetry = u.int_in_range(0..=2)?;
        let das_relax_cruise_limits = u.int_in_range(0..=1)? == 1;
        let das_rob_state = u.int_in_range(0..=3)?;
        let das_status2_checksum = u.int_in_range(0..=255)?;
        let das_status2_counter = u.int_in_range(0..=15)?;
        Id389dasStatus2::new(das_acc_report,das_acc_speed_limit,das_activation_failure_status,das_csa_state,das_driver_interaction_level,das_long_collision_warning,das_pmm_camera_fault_reason,das_pmm_logging_request,das_pmm_obstacle_severity,das_pmm_radar_fault_reason,das_pmm_sys_fault_reason,das_pmm_ultrasonics_fault_reason,das_pp_offset_desired_ramp,das_radar_telemetry,das_relax_cruise_limits,das_rob_state,das_status2_checksum,das_status2_counter).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_ACC_report
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasAccReport {
    AccReportBehaviorReport,
    AccReportCameraOnly,
    AccReportCipvCuttingOut,
    AccReportCsa,
    AccReportFleetSpeeds,
    AccReportLcExternalStateAborted,
    AccReportLcExternalStateAborting,
    AccReportLcExternalStateActiveRestricted,
    AccReportLcHandsOnReqdStruckOut,
    AccReportMcvlrDpp,
    AccReportMcvlrInPath,
    AccReportRadarObjFive,
    AccReportRadarObjOne,
    AccReportRadarObjTwo,
    AccReportTargetCipv,
    AccReportTargetCutin,
    AccReportTargetInFrontOfCipv,
    AccReportTargetMcp,
    AccReportTargetMcvl,
    AccReportTargetMcvr,
    AccReportTargetNone,
    AccReportTargetTypeFault,
    AccReportTargetTypeIpso,
    AccReportTargetTypeStopSign,
    AccReportTargetTypeTrafficLight,
    Other(u8),
}
/// Defined values for DAS_accSpeedLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasAccSpeedLimit {
    None,
    Sna,
    Other(f32),
}
/// Defined values for DAS_activationFailureStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasActivationFailureStatus {
    LcActivationFailed1,
    LcActivationFailed2,
    LcActivationIdle,
    Other(u8),
}
/// Defined values for DAS_csaState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasCsaState {
    CsaExternalStateAvailable,
    CsaExternalStateEnable,
    CsaExternalStateHold,
    CsaExternalStateUnavailable,
    Other(u8),
}
/// Defined values for DAS_driverInteractionLevel
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasDriverInteractionLevel {
    ContinuedDriverNotInteracting,
    DriverInteracting,
    DriverNotInteracting,
    Other(u8),
}
/// Defined values for DAS_longCollisionWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasLongCollisionWarning {
    FcmLongCollisionWarningIpso,
    FcmLongCollisionWarningNone,
    FcmLongCollisionWarningPedestrian,
    FcmLongCollisionWarningSna,
    FcmLongCollisionWarningStopsignStopline,
    FcmLongCollisionWarningTflStopline,
    FcmLongCollisionWarningVehicleCipv,
    FcmLongCollisionWarningVehicleCipv2,
    FcmLongCollisionWarningVehicleCutin,
    FcmLongCollisionWarningVehicleMcvl,
    FcmLongCollisionWarningVehicleMcvl2,
    FcmLongCollisionWarningVehicleMcvr,
    FcmLongCollisionWarningVehicleMcvr2,
    FcmLongCollisionWarningVehicleUnknown,
    Other(u8),
}
/// Defined values for DAS_pmmCameraFaultReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPmmCameraFaultReason {
    PmmCameraBlockedFront,
    PmmCameraInvalidMia,
    PmmCameraNoFault,
    Other(u8),
}
/// Defined values for DAS_pmmLoggingRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPmmLoggingRequest {
    False,
    True,
    Other(bool),
}
/// Defined values for DAS_pmmObstacleSeverity
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPmmObstacleSeverity {
    PmmAccelLimit,
    PmmBrakeRequest,
    PmmCrashFront,
    PmmCrashRear,
    PmmImminentFront,
    PmmImminentRear,
    PmmNone,
    PmmSna,
    Other(u8),
}
/// Defined values for DAS_pmmRadarFaultReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPmmRadarFaultReason {
    PmmRadarBlockedFront,
    PmmRadarInvalidMia,
    PmmRadarNoFault,
    Other(u8),
}
/// Defined values for DAS_pmmSysFaultReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPmmSysFaultReason {
    PmmFaultBrakePedalInhibit,
    PmmFaultDasDisabled,
    PmmFaultDisabledByUser,
    PmmFaultDiFault,
    PmmFaultNone,
    PmmFaultRoadType,
    PmmFaultSpeed,
    PmmFaultSteeringAngleRate,
    Other(u8),
}
/// Defined values for DAS_pmmUltrasonicsFaultReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPmmUltrasonicsFaultReason {
    PmmUltrasonicsBlockedBoth,
    PmmUltrasonicsBlockedFront,
    PmmUltrasonicsBlockedRear,
    PmmUltrasonicsInvalidMia,
    PmmUltrasonicsNoFault,
    Other(u8),
}
/// Defined values for DAS_ppOffsetDesiredRamp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasPpOffsetDesiredRamp {
    PpNoOffset,
    Other(f32),
}
/// Defined values for DAS_radarTelemetry
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasRadarTelemetry {
    RadarTelemetryIdle,
    RadarTelemetryNormal,
    RadarTelemetryUrgent,
    Other(u8),
}
/// Defined values for DAS_robState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id389dasStatus2DasRobState {
    RobStateActive,
    RobStateInhibited,
    RobStateMapless,
    RobStateMeasure,
    Other(u8),
}

/// ID399DAS_status
///
/// - ID: 921 (0x399)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id399dasStatus {
    raw: [u8; 8],
}

impl Id399dasStatus {
    pub const MESSAGE_ID: u32 = 921;
    
    /// Construct new ID399DAS_status from values
    pub fn new(das_auto_lane_change_state: u8, das_auto_parked: bool, das_autopark_ready: bool, das_autopark_waiting_for_brake: bool, das_autopilot_hands_on_state: u8, das_autopilot_state: u8, das_blind_spot_rear_left: u8, das_blind_spot_rear_right: u8, das_fleet_speed_state: u8, das_forward_collision_warning: u8, das_fused_speed_limit: f32, das_heater_state: bool, das_lane_departure_warning: u8, das_lss_state: u8, das_side_collision_avoid: u8, das_side_collision_inhibit: bool, das_side_collision_warning: u8, das_status_checksum: u8, das_status_counter: u8, das_summon_available: bool, das_summon_cleared_gate: bool, das_summon_fwd_leash_reached: bool, das_summon_obstacle: bool, das_summon_rvs_leash_reached: bool, das_suppress_speed_warning: bool, das_vision_only_speed_limit: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_auto_lane_change_state(das_auto_lane_change_state)?;
        res.set_das_auto_parked(das_auto_parked)?;
        res.set_das_autopark_ready(das_autopark_ready)?;
        res.set_das_autopark_waiting_for_brake(das_autopark_waiting_for_brake)?;
        res.set_das_autopilot_hands_on_state(das_autopilot_hands_on_state)?;
        res.set_das_autopilot_state(das_autopilot_state)?;
        res.set_das_blind_spot_rear_left(das_blind_spot_rear_left)?;
        res.set_das_blind_spot_rear_right(das_blind_spot_rear_right)?;
        res.set_das_fleet_speed_state(das_fleet_speed_state)?;
        res.set_das_forward_collision_warning(das_forward_collision_warning)?;
        res.set_das_fused_speed_limit(das_fused_speed_limit)?;
        res.set_das_heater_state(das_heater_state)?;
        res.set_das_lane_departure_warning(das_lane_departure_warning)?;
        res.set_das_lss_state(das_lss_state)?;
        res.set_das_side_collision_avoid(das_side_collision_avoid)?;
        res.set_das_side_collision_inhibit(das_side_collision_inhibit)?;
        res.set_das_side_collision_warning(das_side_collision_warning)?;
        res.set_das_status_checksum(das_status_checksum)?;
        res.set_das_status_counter(das_status_counter)?;
        res.set_das_summon_available(das_summon_available)?;
        res.set_das_summon_cleared_gate(das_summon_cleared_gate)?;
        res.set_das_summon_fwd_leash_reached(das_summon_fwd_leash_reached)?;
        res.set_das_summon_obstacle(das_summon_obstacle)?;
        res.set_das_summon_rvs_leash_reached(das_summon_rvs_leash_reached)?;
        res.set_das_suppress_speed_warning(das_suppress_speed_warning)?;
        res.set_das_vision_only_speed_limit(das_vision_only_speed_limit)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_autoLaneChangeState
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_auto_lane_change_state(&self) -> Id399dasStatusDasAutoLaneChangeState {
        match self.das_auto_lane_change_state_raw() {
            19 => Id399dasStatusDasAutoLaneChangeState::AlcAbortBlinkerTurnedOff,
            18 => Id399dasStatusDasAutoLaneChangeState::AlcAbortLcHealthBad,
            30 => Id399dasStatusDasAutoLaneChangeState::AlcAbortMissionPlanInvalid,
            20 => Id399dasStatusDasAutoLaneChangeState::AlcAbortOtherReason,
            17 => Id399dasStatusDasAutoLaneChangeState::AlcAbortPoorViewRange,
            15 => Id399dasStatusDasAutoLaneChangeState::AlcAbortSideObstaclePresentL,
            16 => Id399dasStatusDasAutoLaneChangeState::AlcAbortSideObstaclePresentR,
            29 => Id399dasStatusDasAutoLaneChangeState::AlcAbortTimeout,
            8 => Id399dasStatusDasAutoLaneChangeState::AlcAvailableBoth,
            6 => Id399dasStatusDasAutoLaneChangeState::AlcAvailableOnlyL,
            7 => Id399dasStatusDasAutoLaneChangeState::AlcAvailableOnlyR,
            26 => Id399dasStatusDasAutoLaneChangeState::AlcBlockedLaneTypeL,
            27 => Id399dasStatusDasAutoLaneChangeState::AlcBlockedLaneTypeR,
            23 => Id399dasStatusDasAutoLaneChangeState::AlcBlockedVehTtcAndUssL,
            25 => Id399dasStatusDasAutoLaneChangeState::AlcBlockedVehTtcAndUssR,
            22 => Id399dasStatusDasAutoLaneChangeState::AlcBlockedVehTtcL,
            24 => Id399dasStatusDasAutoLaneChangeState::AlcBlockedVehTtcR,
            9 => Id399dasStatusDasAutoLaneChangeState::AlcInProgressL,
            10 => Id399dasStatusDasAutoLaneChangeState::AlcInProgressR,
            31 => Id399dasStatusDasAutoLaneChangeState::AlcSna,
            0 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableDisabled,
            4 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableExitingHighway,
            1 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableNoLanes,
            21 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableSolidLaneLine,
            2 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableSonicsInvalid,
            3 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableTpFollow,
            5 => Id399dasStatusDasAutoLaneChangeState::AlcUnavailableVehicleSpeed,
            13 => Id399dasStatusDasAutoLaneChangeState::AlcWaitingForFwdObstToPassL,
            14 => Id399dasStatusDasAutoLaneChangeState::AlcWaitingForFwdObstToPassR,
            11 => Id399dasStatusDasAutoLaneChangeState::AlcWaitingForSideObstToPassL,
            12 => Id399dasStatusDasAutoLaneChangeState::AlcWaitingForSideObstToPassR,
            28 => Id399dasStatusDasAutoLaneChangeState::AlcWaitingHandsOn,
            x => Id399dasStatusDasAutoLaneChangeState::Other(x),
        }
    }
    
    /// Get raw value of DAS_autoLaneChangeState
    ///
    /// - Start bit: 46
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_auto_lane_change_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autoLaneChangeState
    #[inline(always)]
    pub fn set_das_auto_lane_change_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..51].store_le(value);
        Ok(())
    }
    
    /// DAS_autoParked
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_auto_parked(&self) -> bool {
        self.das_auto_parked_raw()
    }
    
    /// Get raw value of DAS_autoParked
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_auto_parked_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_autoParked
    #[inline(always)]
    pub fn set_das_auto_parked(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// DAS_autoparkReady
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autopark_ready(&self) -> Id399dasStatusDasAutoparkReady {
        match self.das_autopark_ready_raw() {
            true => Id399dasStatusDasAutoparkReady::AutoparkReady,
            false => Id399dasStatusDasAutoparkReady::AutoparkUnavailable,
            x => Id399dasStatusDasAutoparkReady::Other(x),
        }
    }
    
    /// Get raw value of DAS_autoparkReady
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autopark_ready_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_autoparkReady
    #[inline(always)]
    pub fn set_das_autopark_ready(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// DAS_autoparkWaitingForBrake
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autopark_waiting_for_brake(&self) -> bool {
        self.das_autopark_waiting_for_brake_raw()
    }
    
    /// Get raw value of DAS_autoparkWaitingForBrake
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autopark_waiting_for_brake_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_autoparkWaitingForBrake
    #[inline(always)]
    pub fn set_das_autopark_waiting_for_brake(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// DAS_autopilotHandsOnState
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autopilot_hands_on_state(&self) -> Id399dasStatusDasAutopilotHandsOnState {
        match self.das_autopilot_hands_on_state_raw() {
            0 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnNotReqd,
            4 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdChime1,
            5 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdChime2,
            1 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdDetected,
            9 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdEscalatedChime1,
            10 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdEscalatedChime2,
            2 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdNotDetected,
            6 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdSlowing,
            7 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdStruckOut,
            3 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnReqdVisual,
            15 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnSna,
            8 => Id399dasStatusDasAutopilotHandsOnState::LcHandsOnSuspended,
            x => Id399dasStatusDasAutopilotHandsOnState::Other(x),
        }
    }
    
    /// Get raw value of DAS_autopilotHandsOnState
    ///
    /// - Start bit: 42
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autopilot_hands_on_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autopilotHandsOnState
    #[inline(always)]
    pub fn set_das_autopilot_hands_on_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..46].store_le(value);
        Ok(())
    }
    
    /// DAS_autopilotState
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_autopilot_state(&self) -> Id399dasStatusDasAutopilotState {
        match self.das_autopilot_state_raw() {
            9 => Id399dasStatusDasAutopilotState::Aborted,
            8 => Id399dasStatusDasAutopilotState::Aborting,
            5 => Id399dasStatusDasAutopilotState::ActiveNav,
            3 => Id399dasStatusDasAutopilotState::ActiveNominal,
            4 => Id399dasStatusDasAutopilotState::ActiveRestricted,
            2 => Id399dasStatusDasAutopilotState::Available,
            0 => Id399dasStatusDasAutopilotState::Disabled,
            14 => Id399dasStatusDasAutopilotState::Fault,
            15 => Id399dasStatusDasAutopilotState::Sna,
            1 => Id399dasStatusDasAutopilotState::Unavailable,
            x => Id399dasStatusDasAutopilotState::Other(x),
        }
    }
    
    /// Get raw value of DAS_autopilotState
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_autopilot_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_autopilotState
    #[inline(always)]
    pub fn set_das_autopilot_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..4].store_le(value);
        Ok(())
    }
    
    /// DAS_blindSpotRearLeft
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_blind_spot_rear_left(&self) -> Id399dasStatusDasBlindSpotRearLeft {
        match self.das_blind_spot_rear_left_raw() {
            0 => Id399dasStatusDasBlindSpotRearLeft::NoWarning,
            3 => Id399dasStatusDasBlindSpotRearLeft::Sna,
            1 => Id399dasStatusDasBlindSpotRearLeft::WarningLevel1,
            2 => Id399dasStatusDasBlindSpotRearLeft::WarningLevel2,
            x => Id399dasStatusDasBlindSpotRearLeft::Other(x),
        }
    }
    
    /// Get raw value of DAS_blindSpotRearLeft
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_blind_spot_rear_left_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_blindSpotRearLeft
    #[inline(always)]
    pub fn set_das_blind_spot_rear_left(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// DAS_blindSpotRearRight
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_blind_spot_rear_right(&self) -> Id399dasStatusDasBlindSpotRearRight {
        match self.das_blind_spot_rear_right_raw() {
            0 => Id399dasStatusDasBlindSpotRearRight::NoWarning,
            3 => Id399dasStatusDasBlindSpotRearRight::Sna,
            1 => Id399dasStatusDasBlindSpotRearRight::WarningLevel1,
            2 => Id399dasStatusDasBlindSpotRearRight::WarningLevel2,
            x => Id399dasStatusDasBlindSpotRearRight::Other(x),
        }
    }
    
    /// Get raw value of DAS_blindSpotRearRight
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_blind_spot_rear_right_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_blindSpotRearRight
    #[inline(always)]
    pub fn set_das_blind_spot_rear_right(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// DAS_fleetSpeedState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_fleet_speed_state(&self) -> Id399dasStatusDasFleetSpeedState {
        match self.das_fleet_speed_state_raw() {
            2 => Id399dasStatusDasFleetSpeedState::FleetspeedActive,
            1 => Id399dasStatusDasFleetSpeedState::FleetspeedAvailable,
            3 => Id399dasStatusDasFleetSpeedState::FleetspeedHold,
            0 => Id399dasStatusDasFleetSpeedState::FleetspeedUnavailable,
            x => Id399dasStatusDasFleetSpeedState::Other(x),
        }
    }
    
    /// Get raw value of DAS_fleetSpeedState
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_fleet_speed_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_fleetSpeedState
    #[inline(always)]
    pub fn set_das_fleet_speed_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// DAS_forwardCollisionWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_forward_collision_warning(&self) -> Id399dasStatusDasForwardCollisionWarning {
        match self.das_forward_collision_warning_raw() {
            1 => Id399dasStatusDasForwardCollisionWarning::ForwardCollisionWarning,
            0 => Id399dasStatusDasForwardCollisionWarning::None,
            3 => Id399dasStatusDasForwardCollisionWarning::Sna,
            x => Id399dasStatusDasForwardCollisionWarning::Other(x),
        }
    }
    
    /// Get raw value of DAS_forwardCollisionWarning
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_forward_collision_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_forwardCollisionWarning
    #[inline(always)]
    pub fn set_das_forward_collision_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// DAS_fusedSpeedLimit
    ///
    /// - Min: 0
    /// - Max: 150
    /// - Unit: "kph/mph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_fused_speed_limit(&self) -> Id399dasStatusDasFusedSpeedLimit {
        match self.das_fused_speed_limit_raw() {
            31 => Id399dasStatusDasFusedSpeedLimit::None,
            0 => Id399dasStatusDasFusedSpeedLimit::UnknownSna,
            x => Id399dasStatusDasFusedSpeedLimit::Other(x),
        }
    }
    
    /// Get raw value of DAS_fusedSpeedLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_fused_speed_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..13].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_fusedSpeedLimit
    #[inline(always)]
    pub fn set_das_fused_speed_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..13].store_le(value);
        Ok(())
    }
    
    /// DAS_heaterState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_heater_state(&self) -> Id399dasStatusDasHeaterState {
        match self.das_heater_state_raw() {
            false => Id399dasStatusDasHeaterState::HeaterOffSna,
            true => Id399dasStatusDasHeaterState::HeaterOn,
            x => Id399dasStatusDasHeaterState::Other(x),
        }
    }
    
    /// Get raw value of DAS_heaterState
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_heater_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_heaterState
    #[inline(always)]
    pub fn set_das_heater_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[21..22].store_le(value);
        Ok(())
    }
    
    /// DAS_laneDepartureWarning
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lane_departure_warning(&self) -> Id399dasStatusDasLaneDepartureWarning {
        match self.das_lane_departure_warning_raw() {
            1 => Id399dasStatusDasLaneDepartureWarning::LeftWarning,
            3 => Id399dasStatusDasLaneDepartureWarning::LeftWarningSevere,
            0 => Id399dasStatusDasLaneDepartureWarning::None,
            2 => Id399dasStatusDasLaneDepartureWarning::RightWarning,
            4 => Id399dasStatusDasLaneDepartureWarning::RightWarningSevere,
            5 => Id399dasStatusDasLaneDepartureWarning::Sna,
            x => Id399dasStatusDasLaneDepartureWarning::Other(x),
        }
    }
    
    /// Get raw value of DAS_laneDepartureWarning
    ///
    /// - Start bit: 37
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lane_departure_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[37..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_laneDepartureWarning
    #[inline(always)]
    pub fn set_das_lane_departure_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[37..40].store_le(value);
        Ok(())
    }
    
    /// DAS_lssState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_lss_state(&self) -> Id399dasStatusDasLssState {
        match self.das_lss_state_raw() {
            6 => Id399dasStatusDasLssState::LssStateAbort,
            5 => Id399dasStatusDasLssState::LssStateBlindspot,
            3 => Id399dasStatusDasLssState::LssStateElk,
            0 => Id399dasStatusDasLssState::LssStateFault,
            1 => Id399dasStatusDasLssState::LssStateLdw,
            2 => Id399dasStatusDasLssState::LssStateLka,
            4 => Id399dasStatusDasLssState::LssStateMonitor,
            7 => Id399dasStatusDasLssState::LssStateOff,
            x => Id399dasStatusDasLssState::Other(x),
        }
    }
    
    /// Get raw value of DAS_lssState
    ///
    /// - Start bit: 29
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_lss_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[29..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_lssState
    #[inline(always)]
    pub fn set_das_lss_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[29..32].store_le(value);
        Ok(())
    }
    
    /// DAS_sideCollisionAvoid
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_side_collision_avoid(&self) -> Id399dasStatusDasSideCollisionAvoid {
        match self.das_side_collision_avoid_raw() {
            1 => Id399dasStatusDasSideCollisionAvoid::AvoidLeft,
            2 => Id399dasStatusDasSideCollisionAvoid::AvoidRight,
            0 => Id399dasStatusDasSideCollisionAvoid::None,
            3 => Id399dasStatusDasSideCollisionAvoid::Sna,
            x => Id399dasStatusDasSideCollisionAvoid::Other(x),
        }
    }
    
    /// Get raw value of DAS_sideCollisionAvoid
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_side_collision_avoid_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_sideCollisionAvoid
    #[inline(always)]
    pub fn set_das_side_collision_avoid(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// DAS_sideCollisionInhibit
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_side_collision_inhibit(&self) -> Id399dasStatusDasSideCollisionInhibit {
        match self.das_side_collision_inhibit_raw() {
            true => Id399dasStatusDasSideCollisionInhibit::Inhibit,
            false => Id399dasStatusDasSideCollisionInhibit::NoInhibit,
            x => Id399dasStatusDasSideCollisionInhibit::Other(x),
        }
    }
    
    /// Get raw value of DAS_sideCollisionInhibit
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_side_collision_inhibit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_sideCollisionInhibit
    #[inline(always)]
    pub fn set_das_side_collision_inhibit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
    /// DAS_sideCollisionWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_side_collision_warning(&self) -> Id399dasStatusDasSideCollisionWarning {
        match self.das_side_collision_warning_raw() {
            0 => Id399dasStatusDasSideCollisionWarning::None,
            1 => Id399dasStatusDasSideCollisionWarning::WarnLeft,
            3 => Id399dasStatusDasSideCollisionWarning::WarnLeftRight,
            2 => Id399dasStatusDasSideCollisionWarning::WarnRight,
            x => Id399dasStatusDasSideCollisionWarning::Other(x),
        }
    }
    
    /// Get raw value of DAS_sideCollisionWarning
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_side_collision_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_sideCollisionWarning
    #[inline(always)]
    pub fn set_das_side_collision_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// DAS_statusChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_status_checksum(&self) -> u8 {
        self.das_status_checksum_raw()
    }
    
    /// Get raw value of DAS_statusChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_status_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_statusChecksum
    #[inline(always)]
    pub fn set_das_status_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DAS_statusCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_status_counter(&self) -> u8 {
        self.das_status_counter_raw()
    }
    
    /// Get raw value of DAS_statusCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_status_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_statusCounter
    #[inline(always)]
    pub fn set_das_status_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// DAS_summonAvailable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_summon_available(&self) -> bool {
        self.das_summon_available_raw()
    }
    
    /// Get raw value of DAS_summonAvailable
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_summon_available_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_summonAvailable
    #[inline(always)]
    pub fn set_das_summon_available(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// DAS_summonClearedGate
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_summon_cleared_gate(&self) -> bool {
        self.das_summon_cleared_gate_raw()
    }
    
    /// Get raw value of DAS_summonClearedGate
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_summon_cleared_gate_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_summonClearedGate
    #[inline(always)]
    pub fn set_das_summon_cleared_gate(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// DAS_summonFwdLeashReached
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_summon_fwd_leash_reached(&self) -> bool {
        self.das_summon_fwd_leash_reached_raw()
    }
    
    /// Get raw value of DAS_summonFwdLeashReached
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_summon_fwd_leash_reached_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_summonFwdLeashReached
    #[inline(always)]
    pub fn set_das_summon_fwd_leash_reached(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// DAS_summonObstacle
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_summon_obstacle(&self) -> bool {
        self.das_summon_obstacle_raw()
    }
    
    /// Get raw value of DAS_summonObstacle
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_summon_obstacle_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_summonObstacle
    #[inline(always)]
    pub fn set_das_summon_obstacle(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// DAS_summonRvsLeashReached
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_summon_rvs_leash_reached(&self) -> bool {
        self.das_summon_rvs_leash_reached_raw()
    }
    
    /// Get raw value of DAS_summonRvsLeashReached
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_summon_rvs_leash_reached_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_summonRvsLeashReached
    #[inline(always)]
    pub fn set_das_summon_rvs_leash_reached(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// DAS_suppressSpeedWarning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_suppress_speed_warning(&self) -> Id399dasStatusDasSuppressSpeedWarning {
        match self.das_suppress_speed_warning_raw() {
            false => Id399dasStatusDasSuppressSpeedWarning::DoNotSuppress,
            true => Id399dasStatusDasSuppressSpeedWarning::SuppressSpeedWarning,
            x => Id399dasStatusDasSuppressSpeedWarning::Other(x),
        }
    }
    
    /// Get raw value of DAS_suppressSpeedWarning
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_suppress_speed_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_suppressSpeedWarning
    #[inline(always)]
    pub fn set_das_suppress_speed_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// DAS_visionOnlySpeedLimit
    ///
    /// - Min: 0
    /// - Max: 150
    /// - Unit: "kph/mph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_vision_only_speed_limit(&self) -> Id399dasStatusDasVisionOnlySpeedLimit {
        match self.das_vision_only_speed_limit_raw() {
            31 => Id399dasStatusDasVisionOnlySpeedLimit::None,
            0 => Id399dasStatusDasVisionOnlySpeedLimit::UnknownSna,
            x => Id399dasStatusDasVisionOnlySpeedLimit::Other(x),
        }
    }
    
    /// Get raw value of DAS_visionOnlySpeedLimit
    ///
    /// - Start bit: 16
    /// - Signal size: 5 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_vision_only_speed_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..21].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DAS_visionOnlySpeedLimit
    #[inline(always)]
    pub fn set_das_vision_only_speed_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 921 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..21].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id399dasStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id399dasStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_auto_lane_change_state = u.int_in_range(0..=31)?;
        let das_auto_parked = u.int_in_range(0..=1)? == 1;
        let das_autopark_ready = u.int_in_range(0..=1)? == 1;
        let das_autopark_waiting_for_brake = u.int_in_range(0..=1)? == 1;
        let das_autopilot_hands_on_state = u.int_in_range(0..=15)?;
        let das_autopilot_state = u.int_in_range(0..=15)?;
        let das_blind_spot_rear_left = u.int_in_range(0..=3)?;
        let das_blind_spot_rear_right = u.int_in_range(0..=3)?;
        let das_fleet_speed_state = u.int_in_range(0..=3)?;
        let das_forward_collision_warning = u.int_in_range(0..=3)?;
        let das_fused_speed_limit = 0_f32;
        let das_heater_state = u.int_in_range(0..=1)? == 1;
        let das_lane_departure_warning = u.int_in_range(0..=5)?;
        let das_lss_state = u.int_in_range(0..=7)?;
        let das_side_collision_avoid = u.int_in_range(0..=3)?;
        let das_side_collision_inhibit = u.int_in_range(0..=1)? == 1;
        let das_side_collision_warning = u.int_in_range(0..=3)?;
        let das_status_checksum = u.int_in_range(0..=255)?;
        let das_status_counter = u.int_in_range(0..=15)?;
        let das_summon_available = u.int_in_range(0..=1)? == 1;
        let das_summon_cleared_gate = u.int_in_range(0..=1)? == 1;
        let das_summon_fwd_leash_reached = u.int_in_range(0..=1)? == 1;
        let das_summon_obstacle = u.int_in_range(0..=1)? == 1;
        let das_summon_rvs_leash_reached = u.int_in_range(0..=1)? == 1;
        let das_suppress_speed_warning = u.int_in_range(0..=1)? == 1;
        let das_vision_only_speed_limit = 0_f32;
        Id399dasStatus::new(das_auto_lane_change_state,das_auto_parked,das_autopark_ready,das_autopark_waiting_for_brake,das_autopilot_hands_on_state,das_autopilot_state,das_blind_spot_rear_left,das_blind_spot_rear_right,das_fleet_speed_state,das_forward_collision_warning,das_fused_speed_limit,das_heater_state,das_lane_departure_warning,das_lss_state,das_side_collision_avoid,das_side_collision_inhibit,das_side_collision_warning,das_status_checksum,das_status_counter,das_summon_available,das_summon_cleared_gate,das_summon_fwd_leash_reached,das_summon_obstacle,das_summon_rvs_leash_reached,das_suppress_speed_warning,das_vision_only_speed_limit).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_autoLaneChangeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasAutoLaneChangeState {
    AlcAbortBlinkerTurnedOff,
    AlcAbortLcHealthBad,
    AlcAbortMissionPlanInvalid,
    AlcAbortOtherReason,
    AlcAbortPoorViewRange,
    AlcAbortSideObstaclePresentL,
    AlcAbortSideObstaclePresentR,
    AlcAbortTimeout,
    AlcAvailableBoth,
    AlcAvailableOnlyL,
    AlcAvailableOnlyR,
    AlcBlockedLaneTypeL,
    AlcBlockedLaneTypeR,
    AlcBlockedVehTtcAndUssL,
    AlcBlockedVehTtcAndUssR,
    AlcBlockedVehTtcL,
    AlcBlockedVehTtcR,
    AlcInProgressL,
    AlcInProgressR,
    AlcSna,
    AlcUnavailableDisabled,
    AlcUnavailableExitingHighway,
    AlcUnavailableNoLanes,
    AlcUnavailableSolidLaneLine,
    AlcUnavailableSonicsInvalid,
    AlcUnavailableTpFollow,
    AlcUnavailableVehicleSpeed,
    AlcWaitingForFwdObstToPassL,
    AlcWaitingForFwdObstToPassR,
    AlcWaitingForSideObstToPassL,
    AlcWaitingForSideObstToPassR,
    AlcWaitingHandsOn,
    Other(u8),
}
/// Defined values for DAS_autoparkReady
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasAutoparkReady {
    AutoparkReady,
    AutoparkUnavailable,
    Other(bool),
}
/// Defined values for DAS_autopilotHandsOnState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasAutopilotHandsOnState {
    LcHandsOnNotReqd,
    LcHandsOnReqdChime1,
    LcHandsOnReqdChime2,
    LcHandsOnReqdDetected,
    LcHandsOnReqdEscalatedChime1,
    LcHandsOnReqdEscalatedChime2,
    LcHandsOnReqdNotDetected,
    LcHandsOnReqdSlowing,
    LcHandsOnReqdStruckOut,
    LcHandsOnReqdVisual,
    LcHandsOnSna,
    LcHandsOnSuspended,
    Other(u8),
}
/// Defined values for DAS_autopilotState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasAutopilotState {
    Aborted,
    Aborting,
    ActiveNav,
    ActiveNominal,
    ActiveRestricted,
    Available,
    Disabled,
    Fault,
    Sna,
    Unavailable,
    Other(u8),
}
/// Defined values for DAS_blindSpotRearLeft
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasBlindSpotRearLeft {
    NoWarning,
    Sna,
    WarningLevel1,
    WarningLevel2,
    Other(u8),
}
/// Defined values for DAS_blindSpotRearRight
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasBlindSpotRearRight {
    NoWarning,
    Sna,
    WarningLevel1,
    WarningLevel2,
    Other(u8),
}
/// Defined values for DAS_fleetSpeedState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasFleetSpeedState {
    FleetspeedActive,
    FleetspeedAvailable,
    FleetspeedHold,
    FleetspeedUnavailable,
    Other(u8),
}
/// Defined values for DAS_forwardCollisionWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasForwardCollisionWarning {
    ForwardCollisionWarning,
    None,
    Sna,
    Other(u8),
}
/// Defined values for DAS_fusedSpeedLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasFusedSpeedLimit {
    None,
    UnknownSna,
    Other(f32),
}
/// Defined values for DAS_heaterState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasHeaterState {
    HeaterOffSna,
    HeaterOn,
    Other(bool),
}
/// Defined values for DAS_laneDepartureWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasLaneDepartureWarning {
    LeftWarning,
    LeftWarningSevere,
    None,
    RightWarning,
    RightWarningSevere,
    Sna,
    Other(u8),
}
/// Defined values for DAS_lssState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasLssState {
    LssStateAbort,
    LssStateBlindspot,
    LssStateElk,
    LssStateFault,
    LssStateLdw,
    LssStateLka,
    LssStateMonitor,
    LssStateOff,
    Other(u8),
}
/// Defined values for DAS_sideCollisionAvoid
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasSideCollisionAvoid {
    AvoidLeft,
    AvoidRight,
    None,
    Sna,
    Other(u8),
}
/// Defined values for DAS_sideCollisionInhibit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasSideCollisionInhibit {
    Inhibit,
    NoInhibit,
    Other(bool),
}
/// Defined values for DAS_sideCollisionWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasSideCollisionWarning {
    None,
    WarnLeft,
    WarnLeftRight,
    WarnRight,
    Other(u8),
}
/// Defined values for DAS_suppressSpeedWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasSuppressSpeedWarning {
    DoNotSuppress,
    SuppressSpeedWarning,
    Other(bool),
}
/// Defined values for DAS_visionOnlySpeedLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id399dasStatusDasVisionOnlySpeedLimit {
    None,
    UnknownSna,
    Other(f32),
}

/// ID39DIBST_status
///
/// - ID: 925 (0x39d)
/// - Size: 5 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id39dibstStatus {
    raw: [u8; 5],
}

impl Id39dibstStatus {
    pub const MESSAGE_ID: u32 = 925;
    
    /// Construct new ID39DIBST_status from values
    pub fn new(ibst_driver_brake_apply: u8, ibst_i_booster_status: u8, ibst_internal_state: u8, ibst_s_input_rod_driver: f32, ibst_status_checksum: u8, ibst_status_counter: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_ibst_driver_brake_apply(ibst_driver_brake_apply)?;
        res.set_ibst_i_booster_status(ibst_i_booster_status)?;
        res.set_ibst_internal_state(ibst_internal_state)?;
        res.set_ibst_s_input_rod_driver(ibst_s_input_rod_driver)?;
        res.set_ibst_status_checksum(ibst_status_checksum)?;
        res.set_ibst_status_counter(ibst_status_counter)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// IBST_driverBrakeApply
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ibst_driver_brake_apply(&self) -> Id39dibstStatusIbstDriverBrakeApply {
        match self.ibst_driver_brake_apply_raw() {
            1 => Id39dibstStatusIbstDriverBrakeApply::BrakesNotApplied,
            2 => Id39dibstStatusIbstDriverBrakeApply::DriverApplyingBrakes,
            3 => Id39dibstStatusIbstDriverBrakeApply::Fault,
            0 => Id39dibstStatusIbstDriverBrakeApply::NotInitOrOff,
            x => Id39dibstStatusIbstDriverBrakeApply::Other(x),
        }
    }
    
    /// Get raw value of IBST_driverBrakeApply
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ibst_driver_brake_apply_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of IBST_driverBrakeApply
    #[inline(always)]
    pub fn set_ibst_driver_brake_apply(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 925 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// IBST_iBoosterStatus
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ibst_i_booster_status(&self) -> Id39dibstStatusIbstIBoosterStatus {
        match self.ibst_i_booster_status_raw() {
            4 => Id39dibstStatusIbstIBoosterStatus::IboosterActiveGoodCheck,
            6 => Id39dibstStatusIbstIBoosterStatus::IboosterActuation,
            3 => Id39dibstStatusIbstIBoosterStatus::IboosterDiagnostic,
            2 => Id39dibstStatusIbstIBoosterStatus::IboosterFailure,
            1 => Id39dibstStatusIbstIBoosterStatus::IboosterInit,
            0 => Id39dibstStatusIbstIBoosterStatus::IboosterOff,
            5 => Id39dibstStatusIbstIBoosterStatus::IboosterReady,
            x => Id39dibstStatusIbstIBoosterStatus::Other(x),
        }
    }
    
    /// Get raw value of IBST_iBoosterStatus
    ///
    /// - Start bit: 12
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ibst_i_booster_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of IBST_iBoosterStatus
    #[inline(always)]
    pub fn set_ibst_i_booster_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 925 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..15].store_le(value);
        Ok(())
    }
    
    /// IBST_internalState
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ibst_internal_state(&self) -> Id39dibstStatusIbstInternalState {
        match self.ibst_internal_state_raw() {
            4 => Id39dibstStatusIbstInternalState::Diagnostic,
            3 => Id39dibstStatusIbstInternalState::ExternalBrakeRequest,
            2 => Id39dibstStatusIbstInternalState::LocalBrakeRequest,
            0 => Id39dibstStatusIbstInternalState::NoModeActive,
            6 => Id39dibstStatusIbstInternalState::PostDriveCheck,
            1 => Id39dibstStatusIbstInternalState::PreDriveCheck,
            5 => Id39dibstStatusIbstInternalState::TransitionToIdle,
            x => Id39dibstStatusIbstInternalState::Other(x),
        }
    }
    
    /// Get raw value of IBST_internalState
    ///
    /// - Start bit: 18
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ibst_internal_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of IBST_internalState
    #[inline(always)]
    pub fn set_ibst_internal_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 925 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..21].store_le(value);
        Ok(())
    }
    
    /// IBST_sInputRodDriver
    ///
    /// - Min: -5
    /// - Max: 47
    /// - Unit: "mm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ibst_s_input_rod_driver(&self) -> f32 {
        self.ibst_s_input_rod_driver_raw()
    }
    
    /// Get raw value of IBST_sInputRodDriver
    ///
    /// - Start bit: 21
    /// - Signal size: 12 bits
    /// - Factor: 0.015625
    /// - Offset: -5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ibst_s_input_rod_driver_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[21..33].load_le::<u16>();
        
        let factor = 0.015625_f32;
        let offset = -5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IBST_sInputRodDriver
    #[inline(always)]
    pub fn set_ibst_s_input_rod_driver(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -5_f32 || 47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 925 }); }
        let factor = 0.015625_f32;
        let offset = -5_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[21..33].store_le(value);
        Ok(())
    }
    
    /// IBST_statusChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ibst_status_checksum(&self) -> u8 {
        self.ibst_status_checksum_raw()
    }
    
    /// Get raw value of IBST_statusChecksum
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ibst_status_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of IBST_statusChecksum
    #[inline(always)]
    pub fn set_ibst_status_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 925 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// IBST_statusCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ibst_status_counter(&self) -> u8 {
        self.ibst_status_counter_raw()
    }
    
    /// Get raw value of IBST_statusCounter
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ibst_status_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of IBST_statusCounter
    #[inline(always)]
    pub fn set_ibst_status_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 925 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id39dibstStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id39dibstStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ibst_driver_brake_apply = u.int_in_range(0..=3)?;
        let ibst_i_booster_status = u.int_in_range(0..=6)?;
        let ibst_internal_state = u.int_in_range(0..=6)?;
        let ibst_s_input_rod_driver = -5_f32;
        let ibst_status_checksum = u.int_in_range(0..=255)?;
        let ibst_status_counter = u.int_in_range(0..=15)?;
        Id39dibstStatus::new(ibst_driver_brake_apply,ibst_i_booster_status,ibst_internal_state,ibst_s_input_rod_driver,ibst_status_checksum,ibst_status_counter).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for IBST_driverBrakeApply
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id39dibstStatusIbstDriverBrakeApply {
    BrakesNotApplied,
    DriverApplyingBrakes,
    Fault,
    NotInitOrOff,
    Other(u8),
}
/// Defined values for IBST_iBoosterStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id39dibstStatusIbstIBoosterStatus {
    IboosterActiveGoodCheck,
    IboosterActuation,
    IboosterDiagnostic,
    IboosterFailure,
    IboosterInit,
    IboosterOff,
    IboosterReady,
    Other(u8),
}
/// Defined values for IBST_internalState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id39dibstStatusIbstInternalState {
    Diagnostic,
    ExternalBrakeRequest,
    LocalBrakeRequest,
    NoModeActive,
    PostDriveCheck,
    PreDriveCheck,
    TransitionToIdle,
    Other(u8),
}

/// ID3A1VCFRONT_vehicleStatus
///
/// - ID: 929 (0x3a1)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3a1vcfrontVehicleStatus {
    raw: [u8; 8],
}

impl Id3a1vcfrontVehicleStatus {
    pub const MESSAGE_ID: u32 = 929;
    
    /// Construct new ID3A1VCFRONT_vehicleStatus from values
    pub fn new(vcfront_12v_status_for_drive: u8, vcfront_2row_center_unbuckled: u8, vcfront_2row_left_unbuckled: u8, vcfront_2row_right_unbuckled: u8, vcfront_ap_glass_heater_state: u8, vcfront_acc_plus_available: bool, vcfront_battery_support_request: bool, vcfront_bms_hv_charge_enable: bool, vcfront_di_power_on_state: u8, vcfront_driver_buckle_status: bool, vcfront_driver_door_status: bool, vcfront_driver_is_leaving: bool, vcfront_driver_is_leaving_any_speed: bool, vcfront_driver_present: bool, vcfront_driver_unbuckled: u8, vcfront_ota12_v_support_request: bool, vcfront_passenger_present: bool, vcfront_passenger_unbuckled: u8, vcfront_pcs12v_voltage_target: f32, vcfront_pcs_e_fuse_voltage: f32, vcfront_precondition_request: bool, vcfront_standby_supply_supported: bool, vcfront_thermal_system_type: bool, vcfront_vehicle_status_checksum: u8, vcfront_vehicle_status_counter: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcfront_12v_status_for_drive(vcfront_12v_status_for_drive)?;
        res.set_vcfront_2row_center_unbuckled(vcfront_2row_center_unbuckled)?;
        res.set_vcfront_2row_left_unbuckled(vcfront_2row_left_unbuckled)?;
        res.set_vcfront_2row_right_unbuckled(vcfront_2row_right_unbuckled)?;
        res.set_vcfront_ap_glass_heater_state(vcfront_ap_glass_heater_state)?;
        res.set_vcfront_acc_plus_available(vcfront_acc_plus_available)?;
        res.set_vcfront_battery_support_request(vcfront_battery_support_request)?;
        res.set_vcfront_bms_hv_charge_enable(vcfront_bms_hv_charge_enable)?;
        res.set_vcfront_di_power_on_state(vcfront_di_power_on_state)?;
        res.set_vcfront_driver_buckle_status(vcfront_driver_buckle_status)?;
        res.set_vcfront_driver_door_status(vcfront_driver_door_status)?;
        res.set_vcfront_driver_is_leaving(vcfront_driver_is_leaving)?;
        res.set_vcfront_driver_is_leaving_any_speed(vcfront_driver_is_leaving_any_speed)?;
        res.set_vcfront_driver_present(vcfront_driver_present)?;
        res.set_vcfront_driver_unbuckled(vcfront_driver_unbuckled)?;
        res.set_vcfront_ota12_v_support_request(vcfront_ota12_v_support_request)?;
        res.set_vcfront_passenger_present(vcfront_passenger_present)?;
        res.set_vcfront_passenger_unbuckled(vcfront_passenger_unbuckled)?;
        res.set_vcfront_pcs12v_voltage_target(vcfront_pcs12v_voltage_target)?;
        res.set_vcfront_pcs_e_fuse_voltage(vcfront_pcs_e_fuse_voltage)?;
        res.set_vcfront_precondition_request(vcfront_precondition_request)?;
        res.set_vcfront_standby_supply_supported(vcfront_standby_supply_supported)?;
        res.set_vcfront_thermal_system_type(vcfront_thermal_system_type)?;
        res.set_vcfront_vehicle_status_checksum(vcfront_vehicle_status_checksum)?;
        res.set_vcfront_vehicle_status_counter(vcfront_vehicle_status_counter)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_12vStatusForDrive
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_12v_status_for_drive(&self) -> Id3a1vcfrontVehicleStatusVcfront12vStatusForDrive {
        match self.vcfront_12v_status_for_drive_raw() {
            2 => Id3a1vcfrontVehicleStatusVcfront12vStatusForDrive::ExitDriveRequested12v,
            0 => Id3a1vcfrontVehicleStatusVcfront12vStatusForDrive::NotReadyForDrive12v,
            1 => Id3a1vcfrontVehicleStatusVcfront12vStatusForDrive::ReadyForDrive12v,
            x => Id3a1vcfrontVehicleStatusVcfront12vStatusForDrive::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_12vStatusForDrive
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_12v_status_for_drive_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_12vStatusForDrive
    #[inline(always)]
    pub fn set_vcfront_12v_status_for_drive(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_2RowCenterUnbuckled
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_2row_center_unbuckled(&self) -> Id3a1vcfrontVehicleStatusVcfront2rowCenterUnbuckled {
        match self.vcfront_2row_center_unbuckled_raw() {
            0 => Id3a1vcfrontVehicleStatusVcfront2rowCenterUnbuckled::ChimeNone,
            1 => Id3a1vcfrontVehicleStatusVcfront2rowCenterUnbuckled::ChimeOccupiedAndUnbuckled,
            2 => Id3a1vcfrontVehicleStatusVcfront2rowCenterUnbuckled::ChimeSna,
            x => Id3a1vcfrontVehicleStatusVcfront2rowCenterUnbuckled::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_2RowCenterUnbuckled
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_2row_center_unbuckled_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_2RowCenterUnbuckled
    #[inline(always)]
    pub fn set_vcfront_2row_center_unbuckled(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_2RowLeftUnbuckled
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_2row_left_unbuckled(&self) -> Id3a1vcfrontVehicleStatusVcfront2rowLeftUnbuckled {
        match self.vcfront_2row_left_unbuckled_raw() {
            0 => Id3a1vcfrontVehicleStatusVcfront2rowLeftUnbuckled::ChimeNone,
            1 => Id3a1vcfrontVehicleStatusVcfront2rowLeftUnbuckled::ChimeOccupiedAndUnbuckled,
            2 => Id3a1vcfrontVehicleStatusVcfront2rowLeftUnbuckled::ChimeSna,
            x => Id3a1vcfrontVehicleStatusVcfront2rowLeftUnbuckled::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_2RowLeftUnbuckled
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_2row_left_unbuckled_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_2RowLeftUnbuckled
    #[inline(always)]
    pub fn set_vcfront_2row_left_unbuckled(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..38].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_2RowRightUnbuckled
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_2row_right_unbuckled(&self) -> Id3a1vcfrontVehicleStatusVcfront2rowRightUnbuckled {
        match self.vcfront_2row_right_unbuckled_raw() {
            0 => Id3a1vcfrontVehicleStatusVcfront2rowRightUnbuckled::ChimeNone,
            1 => Id3a1vcfrontVehicleStatusVcfront2rowRightUnbuckled::ChimeOccupiedAndUnbuckled,
            2 => Id3a1vcfrontVehicleStatusVcfront2rowRightUnbuckled::ChimeSna,
            x => Id3a1vcfrontVehicleStatusVcfront2rowRightUnbuckled::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_2RowRightUnbuckled
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_2row_right_unbuckled_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_2RowRightUnbuckled
    #[inline(always)]
    pub fn set_vcfront_2row_right_unbuckled(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_APGlassHeaterState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ap_glass_heater_state(&self) -> Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState {
        match self.vcfront_ap_glass_heater_state_raw() {
            4 => Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState::HeaterStateFault,
            2 => Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState::HeaterStateOff,
            3 => Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState::HeaterStateOffUnavailable,
            1 => Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState::HeaterStateOn,
            0 => Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState::HeaterStateSna,
            x => Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_APGlassHeaterState
    ///
    /// - Start bit: 2
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ap_glass_heater_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_APGlassHeaterState
    #[inline(always)]
    pub fn set_vcfront_ap_glass_heater_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..5].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_accPlusAvailable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_acc_plus_available(&self) -> bool {
        self.vcfront_acc_plus_available_raw()
    }
    
    /// Get raw value of VCFRONT_accPlusAvailable
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_acc_plus_available_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_accPlusAvailable
    #[inline(always)]
    pub fn set_vcfront_acc_plus_available(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_batterySupportRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_battery_support_request(&self) -> bool {
        self.vcfront_battery_support_request_raw()
    }
    
    /// Get raw value of VCFRONT_batterySupportRequest
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_battery_support_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_batterySupportRequest
    #[inline(always)]
    pub fn set_vcfront_battery_support_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_bmsHvChargeEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_bms_hv_charge_enable(&self) -> bool {
        self.vcfront_bms_hv_charge_enable_raw()
    }
    
    /// Get raw value of VCFRONT_bmsHvChargeEnable
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_bms_hv_charge_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_bmsHvChargeEnable
    #[inline(always)]
    pub fn set_vcfront_bms_hv_charge_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_diPowerOnState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_di_power_on_state(&self) -> Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState {
        match self.vcfront_di_power_on_state_raw() {
            0 => Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState::DiPoweredOff,
            3 => Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState::DiPoweredOnForDrive,
            2 => Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState::DiPoweredOnForStationaryHeat,
            1 => Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState::DiPoweredOnForSummon,
            4 => Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState::DiPowerGoingDown,
            x => Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_diPowerOnState
    ///
    /// - Start bit: 10
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_di_power_on_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_diPowerOnState
    #[inline(always)]
    pub fn set_vcfront_di_power_on_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..13].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_driverBuckleStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_driver_buckle_status(&self) -> Id3a1vcfrontVehicleStatusVcfrontDriverBuckleStatus {
        match self.vcfront_driver_buckle_status_raw() {
            true => Id3a1vcfrontVehicleStatusVcfrontDriverBuckleStatus::Buckled,
            false => Id3a1vcfrontVehicleStatusVcfrontDriverBuckleStatus::Unbuckled,
            x => Id3a1vcfrontVehicleStatusVcfrontDriverBuckleStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_driverBuckleStatus
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_driver_buckle_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_driverBuckleStatus
    #[inline(always)]
    pub fn set_vcfront_driver_buckle_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_driverDoorStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_driver_door_status(&self) -> Id3a1vcfrontVehicleStatusVcfrontDriverDoorStatus {
        match self.vcfront_driver_door_status_raw() {
            true => Id3a1vcfrontVehicleStatusVcfrontDriverDoorStatus::DoorClosed,
            false => Id3a1vcfrontVehicleStatusVcfrontDriverDoorStatus::DoorOpen,
            x => Id3a1vcfrontVehicleStatusVcfrontDriverDoorStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_driverDoorStatus
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_driver_door_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_driverDoorStatus
    #[inline(always)]
    pub fn set_vcfront_driver_door_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_driverIsLeaving
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_driver_is_leaving(&self) -> bool {
        self.vcfront_driver_is_leaving_raw()
    }
    
    /// Get raw value of VCFRONT_driverIsLeaving
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_driver_is_leaving_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_driverIsLeaving
    #[inline(always)]
    pub fn set_vcfront_driver_is_leaving(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_driverIsLeavingAnySpeed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_driver_is_leaving_any_speed(&self) -> bool {
        self.vcfront_driver_is_leaving_any_speed_raw()
    }
    
    /// Get raw value of VCFRONT_driverIsLeavingAnySpeed
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_driver_is_leaving_any_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_driverIsLeavingAnySpeed
    #[inline(always)]
    pub fn set_vcfront_driver_is_leaving_any_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_driverPresent
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_driver_present(&self) -> bool {
        self.vcfront_driver_present_raw()
    }
    
    /// Get raw value of VCFRONT_driverPresent
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_driver_present_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_driverPresent
    #[inline(always)]
    pub fn set_vcfront_driver_present(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_driverUnbuckled
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_driver_unbuckled(&self) -> Id3a1vcfrontVehicleStatusVcfrontDriverUnbuckled {
        match self.vcfront_driver_unbuckled_raw() {
            0 => Id3a1vcfrontVehicleStatusVcfrontDriverUnbuckled::ChimeNone,
            1 => Id3a1vcfrontVehicleStatusVcfrontDriverUnbuckled::ChimeOccupiedAndUnbuckled,
            2 => Id3a1vcfrontVehicleStatusVcfrontDriverUnbuckled::ChimeSna,
            x => Id3a1vcfrontVehicleStatusVcfrontDriverUnbuckled::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_driverUnbuckled
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_driver_unbuckled_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_driverUnbuckled
    #[inline(always)]
    pub fn set_vcfront_driver_unbuckled(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ota12VSupportRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ota12_v_support_request(&self) -> bool {
        self.vcfront_ota12_v_support_request_raw()
    }
    
    /// Get raw value of VCFRONT_ota12VSupportRequest
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ota12_v_support_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ota12VSupportRequest
    #[inline(always)]
    pub fn set_vcfront_ota12_v_support_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_passengerPresent
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_passenger_present(&self) -> bool {
        self.vcfront_passenger_present_raw()
    }
    
    /// Get raw value of VCFRONT_passengerPresent
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_passenger_present_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_passengerPresent
    #[inline(always)]
    pub fn set_vcfront_passenger_present(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_passengerUnbuckled
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_passenger_unbuckled(&self) -> Id3a1vcfrontVehicleStatusVcfrontPassengerUnbuckled {
        match self.vcfront_passenger_unbuckled_raw() {
            0 => Id3a1vcfrontVehicleStatusVcfrontPassengerUnbuckled::ChimeNone,
            1 => Id3a1vcfrontVehicleStatusVcfrontPassengerUnbuckled::ChimeOccupiedAndUnbuckled,
            2 => Id3a1vcfrontVehicleStatusVcfrontPassengerUnbuckled::ChimeSna,
            x => Id3a1vcfrontVehicleStatusVcfrontPassengerUnbuckled::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_passengerUnbuckled
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_passenger_unbuckled_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_passengerUnbuckled
    #[inline(always)]
    pub fn set_vcfront_passenger_unbuckled(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pcs12vVoltageTarget
    ///
    /// - Min: 0
    /// - Max: 16
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs12v_voltage_target(&self) -> f32 {
        self.vcfront_pcs12v_voltage_target_raw()
    }
    
    /// Get raw value of VCFRONT_pcs12vVoltageTarget
    ///
    /// - Start bit: 16
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs12v_voltage_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..27].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pcs12vVoltageTarget
    #[inline(always)]
    pub fn set_vcfront_pcs12v_voltage_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..27].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pcsEFuseVoltage
    ///
    /// - Min: 0
    /// - Max: 102.2
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_e_fuse_voltage(&self) -> Id3a1vcfrontVehicleStatusVcfrontPcsEFuseVoltage {
        match self.vcfront_pcs_e_fuse_voltage_raw() {
            1023 => Id3a1vcfrontVehicleStatusVcfrontPcsEFuseVoltage::Sna,
            x => Id3a1vcfrontVehicleStatusVcfrontPcsEFuseVoltage::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pcsEFuseVoltage
    ///
    /// - Start bit: 42
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_e_fuse_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[42..52].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pcsEFuseVoltage
    #[inline(always)]
    pub fn set_vcfront_pcs_e_fuse_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102.2_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[42..52].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_preconditionRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_precondition_request(&self) -> bool {
        self.vcfront_precondition_request_raw()
    }
    
    /// Get raw value of VCFRONT_preconditionRequest
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_precondition_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_preconditionRequest
    #[inline(always)]
    pub fn set_vcfront_precondition_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_standbySupplySupported
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_standby_supply_supported(&self) -> bool {
        self.vcfront_standby_supply_supported_raw()
    }
    
    /// Get raw value of VCFRONT_standbySupplySupported
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_standby_supply_supported_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_standbySupplySupported
    #[inline(always)]
    pub fn set_vcfront_standby_supply_supported(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_thermalSystemType
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_thermal_system_type(&self) -> Id3a1vcfrontVehicleStatusVcfrontThermalSystemType {
        match self.vcfront_thermal_system_type_raw() {
            true => Id3a1vcfrontVehicleStatusVcfrontThermalSystemType::HeatPumpThermalSystem,
            false => Id3a1vcfrontVehicleStatusVcfrontThermalSystemType::LegacyThermalSystem,
            x => Id3a1vcfrontVehicleStatusVcfrontThermalSystemType::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_thermalSystemType
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_thermal_system_type_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_thermalSystemType
    #[inline(always)]
    pub fn set_vcfront_thermal_system_type(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vehicleStatusChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vehicle_status_checksum(&self) -> u8 {
        self.vcfront_vehicle_status_checksum_raw()
    }
    
    /// Get raw value of VCFRONT_vehicleStatusChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vehicle_status_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vehicleStatusChecksum
    #[inline(always)]
    pub fn set_vcfront_vehicle_status_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vehicleStatusCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vehicle_status_counter(&self) -> u8 {
        self.vcfront_vehicle_status_counter_raw()
    }
    
    /// Get raw value of VCFRONT_vehicleStatusCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vehicle_status_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vehicleStatusCounter
    #[inline(always)]
    pub fn set_vcfront_vehicle_status_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 929 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3a1vcfrontVehicleStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3a1vcfrontVehicleStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_12v_status_for_drive = u.int_in_range(0..=2)?;
        let vcfront_2row_center_unbuckled = u.int_in_range(0..=2)?;
        let vcfront_2row_left_unbuckled = u.int_in_range(0..=2)?;
        let vcfront_2row_right_unbuckled = u.int_in_range(0..=2)?;
        let vcfront_ap_glass_heater_state = u.int_in_range(0..=4)?;
        let vcfront_acc_plus_available = u.int_in_range(0..=1)? == 1;
        let vcfront_battery_support_request = u.int_in_range(0..=1)? == 1;
        let vcfront_bms_hv_charge_enable = u.int_in_range(0..=1)? == 1;
        let vcfront_di_power_on_state = u.int_in_range(0..=4)?;
        let vcfront_driver_buckle_status = u.int_in_range(0..=1)? == 1;
        let vcfront_driver_door_status = u.int_in_range(0..=1)? == 1;
        let vcfront_driver_is_leaving = u.int_in_range(0..=1)? == 1;
        let vcfront_driver_is_leaving_any_speed = u.int_in_range(0..=1)? == 1;
        let vcfront_driver_present = u.int_in_range(0..=1)? == 1;
        let vcfront_driver_unbuckled = u.int_in_range(0..=2)?;
        let vcfront_ota12_v_support_request = u.int_in_range(0..=1)? == 1;
        let vcfront_passenger_present = u.int_in_range(0..=1)? == 1;
        let vcfront_passenger_unbuckled = u.int_in_range(0..=2)?;
        let vcfront_pcs12v_voltage_target = 0_f32;
        let vcfront_pcs_e_fuse_voltage = 0_f32;
        let vcfront_precondition_request = u.int_in_range(0..=1)? == 1;
        let vcfront_standby_supply_supported = u.int_in_range(0..=1)? == 1;
        let vcfront_thermal_system_type = u.int_in_range(0..=1)? == 1;
        let vcfront_vehicle_status_checksum = u.int_in_range(0..=255)?;
        let vcfront_vehicle_status_counter = u.int_in_range(0..=15)?;
        Id3a1vcfrontVehicleStatus::new(vcfront_12v_status_for_drive,vcfront_2row_center_unbuckled,vcfront_2row_left_unbuckled,vcfront_2row_right_unbuckled,vcfront_ap_glass_heater_state,vcfront_acc_plus_available,vcfront_battery_support_request,vcfront_bms_hv_charge_enable,vcfront_di_power_on_state,vcfront_driver_buckle_status,vcfront_driver_door_status,vcfront_driver_is_leaving,vcfront_driver_is_leaving_any_speed,vcfront_driver_present,vcfront_driver_unbuckled,vcfront_ota12_v_support_request,vcfront_passenger_present,vcfront_passenger_unbuckled,vcfront_pcs12v_voltage_target,vcfront_pcs_e_fuse_voltage,vcfront_precondition_request,vcfront_standby_supply_supported,vcfront_thermal_system_type,vcfront_vehicle_status_checksum,vcfront_vehicle_status_counter).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_12vStatusForDrive
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfront12vStatusForDrive {
    ExitDriveRequested12v,
    NotReadyForDrive12v,
    ReadyForDrive12v,
    Other(u8),
}
/// Defined values for VCFRONT_2RowCenterUnbuckled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfront2rowCenterUnbuckled {
    ChimeNone,
    ChimeOccupiedAndUnbuckled,
    ChimeSna,
    Other(u8),
}
/// Defined values for VCFRONT_2RowLeftUnbuckled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfront2rowLeftUnbuckled {
    ChimeNone,
    ChimeOccupiedAndUnbuckled,
    ChimeSna,
    Other(u8),
}
/// Defined values for VCFRONT_2RowRightUnbuckled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfront2rowRightUnbuckled {
    ChimeNone,
    ChimeOccupiedAndUnbuckled,
    ChimeSna,
    Other(u8),
}
/// Defined values for VCFRONT_APGlassHeaterState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontApGlassHeaterState {
    HeaterStateFault,
    HeaterStateOff,
    HeaterStateOffUnavailable,
    HeaterStateOn,
    HeaterStateSna,
    Other(u8),
}
/// Defined values for VCFRONT_diPowerOnState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontDiPowerOnState {
    DiPoweredOff,
    DiPoweredOnForDrive,
    DiPoweredOnForStationaryHeat,
    DiPoweredOnForSummon,
    DiPowerGoingDown,
    Other(u8),
}
/// Defined values for VCFRONT_driverBuckleStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontDriverBuckleStatus {
    Buckled,
    Unbuckled,
    Other(bool),
}
/// Defined values for VCFRONT_driverDoorStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontDriverDoorStatus {
    DoorClosed,
    DoorOpen,
    Other(bool),
}
/// Defined values for VCFRONT_driverUnbuckled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontDriverUnbuckled {
    ChimeNone,
    ChimeOccupiedAndUnbuckled,
    ChimeSna,
    Other(u8),
}
/// Defined values for VCFRONT_passengerUnbuckled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontPassengerUnbuckled {
    ChimeNone,
    ChimeOccupiedAndUnbuckled,
    ChimeSna,
    Other(u8),
}
/// Defined values for VCFRONT_pcsEFuseVoltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontPcsEFuseVoltage {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_thermalSystemType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3a1vcfrontVehicleStatusVcfrontThermalSystemType {
    HeatPumpThermalSystem,
    LegacyThermalSystem,
    Other(bool),
}

/// ID3D9UI_gpsVehicleSpeed
///
/// - ID: 985 (0x3d9)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3d9uiGpsVehicleSpeed {
    raw: [u8; 8],
}

impl Id3d9uiGpsVehicleSpeed {
    pub const MESSAGE_ID: u32 = 985;
    
    /// Construct new ID3D9UI_gpsVehicleSpeed from values
    pub fn new(ui_conditional_limit_active: bool, ui_conditional_speed_limit: f32, ui_gps_antenna_disconnected: bool, ui_gps_hdop: f32, ui_gps_nmea_mia: bool, ui_gps_vehicle_heading: f32, ui_gps_vehicle_speed: f32, ui_map_speed_limit_units: bool, ui_mpp_speed_limit: f32, ui_user_speed_offset: f32, ui_user_speed_offset_units: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_conditional_limit_active(ui_conditional_limit_active)?;
        res.set_ui_conditional_speed_limit(ui_conditional_speed_limit)?;
        res.set_ui_gps_antenna_disconnected(ui_gps_antenna_disconnected)?;
        res.set_ui_gps_hdop(ui_gps_hdop)?;
        res.set_ui_gps_nmea_mia(ui_gps_nmea_mia)?;
        res.set_ui_gps_vehicle_heading(ui_gps_vehicle_heading)?;
        res.set_ui_gps_vehicle_speed(ui_gps_vehicle_speed)?;
        res.set_ui_map_speed_limit_units(ui_map_speed_limit_units)?;
        res.set_ui_mpp_speed_limit(ui_mpp_speed_limit)?;
        res.set_ui_user_speed_offset(ui_user_speed_offset)?;
        res.set_ui_user_speed_offset_units(ui_user_speed_offset_units)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_conditionalLimitActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_conditional_limit_active(&self) -> bool {
        self.ui_conditional_limit_active_raw()
    }
    
    /// Get raw value of UI_conditionalLimitActive
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_conditional_limit_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_conditionalLimitActive
    #[inline(always)]
    pub fn set_ui_conditional_limit_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[55..56].store_le(value);
        Ok(())
    }
    
    /// UI_conditionalSpeedLimit
    ///
    /// - Min: 0
    /// - Max: 155
    /// - Unit: "kph/mph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_conditional_speed_limit(&self) -> Id3d9uiGpsVehicleSpeedUiConditionalSpeedLimit {
        match self.ui_conditional_speed_limit_raw() {
            31 => Id3d9uiGpsVehicleSpeedUiConditionalSpeedLimit::Sna,
            x => Id3d9uiGpsVehicleSpeedUiConditionalSpeedLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_conditionalSpeedLimit
    ///
    /// - Start bit: 56
    /// - Signal size: 5 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_conditional_speed_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..61].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_conditionalSpeedLimit
    #[inline(always)]
    pub fn set_ui_conditional_speed_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 155_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 985 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..61].store_le(value);
        Ok(())
    }
    
    /// UI_gpsAntennaDisconnected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_antenna_disconnected(&self) -> bool {
        self.ui_gps_antenna_disconnected_raw()
    }
    
    /// Get raw value of UI_gpsAntennaDisconnected
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_antenna_disconnected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_gpsAntennaDisconnected
    #[inline(always)]
    pub fn set_ui_gps_antenna_disconnected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[54..55].store_le(value);
        Ok(())
    }
    
    /// UI_gpsHDOP
    ///
    /// - Min: 0
    /// - Max: 25.5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_hdop(&self) -> f32 {
        self.ui_gps_hdop_raw()
    }
    
    /// Get raw value of UI_gpsHDOP
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_hdop_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_gpsHDOP
    #[inline(always)]
    pub fn set_ui_gps_hdop(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 985 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// UI_gpsNmeaMIA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_nmea_mia(&self) -> bool {
        self.ui_gps_nmea_mia_raw()
    }
    
    /// Get raw value of UI_gpsNmeaMIA
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_nmea_mia_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_gpsNmeaMIA
    #[inline(always)]
    pub fn set_ui_gps_nmea_mia(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[53..54].store_le(value);
        Ok(())
    }
    
    /// UI_gpsVehicleHeading
    ///
    /// GPS Heading
    ///
    /// - Min: 0
    /// - Max: 511.992
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_vehicle_heading(&self) -> f32 {
        self.ui_gps_vehicle_heading_raw()
    }
    
    /// Get raw value of UI_gpsVehicleHeading
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.0078125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_vehicle_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..24].load_le::<u16>();
        
        let factor = 0.0078125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_gpsVehicleHeading
    #[inline(always)]
    pub fn set_ui_gps_vehicle_heading(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.992_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 985 }); }
        let factor = 0.0078125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..24].store_le(value);
        Ok(())
    }
    
    /// UI_gpsVehicleSpeed
    ///
    /// GPS Speed
    ///
    /// - Min: 0
    /// - Max: 250.996
    /// - Unit: "kph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_gps_vehicle_speed(&self) -> f32 {
        self.ui_gps_vehicle_speed_raw()
    }
    
    /// Get raw value of UI_gpsVehicleSpeed
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.00390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_gps_vehicle_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..40].load_le::<u16>();
        
        let factor = 0.00390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_gpsVehicleSpeed
    #[inline(always)]
    pub fn set_ui_gps_vehicle_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 250.996_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 985 }); }
        let factor = 0.00390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..40].store_le(value);
        Ok(())
    }
    
    /// UI_mapSpeedLimitUnits
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_map_speed_limit_units(&self) -> Id3d9uiGpsVehicleSpeedUiMapSpeedLimitUnits {
        match self.ui_map_speed_limit_units_raw() {
            true => Id3d9uiGpsVehicleSpeedUiMapSpeedLimitUnits::Kph,
            false => Id3d9uiGpsVehicleSpeedUiMapSpeedLimitUnits::Mph,
            x => Id3d9uiGpsVehicleSpeedUiMapSpeedLimitUnits::Other(x),
        }
    }
    
    /// Get raw value of UI_mapSpeedLimitUnits
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_map_speed_limit_units_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_mapSpeedLimitUnits
    #[inline(always)]
    pub fn set_ui_map_speed_limit_units(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[46..47].store_le(value);
        Ok(())
    }
    
    /// UI_mppSpeedLimit
    ///
    /// - Min: 0
    /// - Max: 155
    /// - Unit: "kph/mph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_mpp_speed_limit(&self) -> f32 {
        self.ui_mpp_speed_limit_raw()
    }
    
    /// Get raw value of UI_mppSpeedLimit
    ///
    /// - Start bit: 48
    /// - Signal size: 5 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_mpp_speed_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..53].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_mppSpeedLimit
    #[inline(always)]
    pub fn set_ui_mpp_speed_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 155_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 985 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..53].store_le(value);
        Ok(())
    }
    
    /// UI_userSpeedOffset
    ///
    /// - Min: -30
    /// - Max: 33
    /// - Unit: "kph/mph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_user_speed_offset(&self) -> f32 {
        self.ui_user_speed_offset_raw()
    }
    
    /// Get raw value of UI_userSpeedOffset
    ///
    /// - Start bit: 40
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: -30
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_user_speed_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..46].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -30_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_userSpeedOffset
    #[inline(always)]
    pub fn set_ui_user_speed_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 33_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 985 }); }
        let factor = 1_f32;
        let offset = -30_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..46].store_le(value);
        Ok(())
    }
    
    /// UI_userSpeedOffsetUnits
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_user_speed_offset_units(&self) -> Id3d9uiGpsVehicleSpeedUiUserSpeedOffsetUnits {
        match self.ui_user_speed_offset_units_raw() {
            true => Id3d9uiGpsVehicleSpeedUiUserSpeedOffsetUnits::Kph,
            false => Id3d9uiGpsVehicleSpeedUiUserSpeedOffsetUnits::Mph,
            x => Id3d9uiGpsVehicleSpeedUiUserSpeedOffsetUnits::Other(x),
        }
    }
    
    /// Get raw value of UI_userSpeedOffsetUnits
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_user_speed_offset_units_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_userSpeedOffsetUnits
    #[inline(always)]
    pub fn set_ui_user_speed_offset_units(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[47..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3d9uiGpsVehicleSpeed {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3d9uiGpsVehicleSpeed
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_conditional_limit_active = u.int_in_range(0..=1)? == 1;
        let ui_conditional_speed_limit = 0_f32;
        let ui_gps_antenna_disconnected = u.int_in_range(0..=1)? == 1;
        let ui_gps_hdop = 0_f32;
        let ui_gps_nmea_mia = u.int_in_range(0..=1)? == 1;
        let ui_gps_vehicle_heading = 0_f32;
        let ui_gps_vehicle_speed = 0_f32;
        let ui_map_speed_limit_units = u.int_in_range(0..=1)? == 1;
        let ui_mpp_speed_limit = 0_f32;
        let ui_user_speed_offset = -30_f32;
        let ui_user_speed_offset_units = u.int_in_range(0..=1)? == 1;
        Id3d9uiGpsVehicleSpeed::new(ui_conditional_limit_active,ui_conditional_speed_limit,ui_gps_antenna_disconnected,ui_gps_hdop,ui_gps_nmea_mia,ui_gps_vehicle_heading,ui_gps_vehicle_speed,ui_map_speed_limit_units,ui_mpp_speed_limit,ui_user_speed_offset,ui_user_speed_offset_units).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_conditionalSpeedLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3d9uiGpsVehicleSpeedUiConditionalSpeedLimit {
    Sna,
    Other(f32),
}
/// Defined values for UI_mapSpeedLimitUnits
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3d9uiGpsVehicleSpeedUiMapSpeedLimitUnits {
    Kph,
    Mph,
    Other(bool),
}
/// Defined values for UI_userSpeedOffsetUnits
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3d9uiGpsVehicleSpeedUiUserSpeedOffsetUnits {
    Kph,
    Mph,
    Other(bool),
}

/// ID3E2VCLEFT_lightStatus
///
/// - ID: 994 (0x3e2)
/// - Size: 7 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3e2vcleftLightStatus {
    raw: [u8; 7],
}

impl Id3e2vcleftLightStatus {
    pub const MESSAGE_ID: u32 = 994;
    
    /// Construct new ID3E2VCLEFT_lightStatus from values
    pub fn new(vcleft_fl_map_light_status: u8, vcleft_fl_map_light_switch_pressed: bool, vcleft_fr_map_light_status: u8, vcleft_fr_map_light_switch_pressed: bool, vcleft_rl_map_light_status: u8, vcleft_rl_map_light_switch_pressed: bool, vcleft_rr_map_light_status: u8, vcleft_rr_map_light_switch_pressed: bool, vcleft_brake_light_status: u8, vcleft_brake_trailer_light_status: u8, vcleft_dynamic_brake_light_status: u8, vcleft_fog_trailer_light_status: u8, vcleft_front_ride_height: i8, vcleft_left_turn_trailer_light_statu: u8, vcleft_rear_ride_height: i8, vcleft_reverse_trailer_light_status: u8, vcleft_ride_height_sensor_fault: bool, vcleft_right_trn_trailer_light_statu: u8, vcleft_tail_light_outage_status: bool, vcleft_tail_light_status: u8, vcleft_tail_trailer_light_status: u8, vcleft_trailer_detected: u8, vcleft_turn_signal_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 7] };
        res.set_vcleft_fl_map_light_status(vcleft_fl_map_light_status)?;
        res.set_vcleft_fl_map_light_switch_pressed(vcleft_fl_map_light_switch_pressed)?;
        res.set_vcleft_fr_map_light_status(vcleft_fr_map_light_status)?;
        res.set_vcleft_fr_map_light_switch_pressed(vcleft_fr_map_light_switch_pressed)?;
        res.set_vcleft_rl_map_light_status(vcleft_rl_map_light_status)?;
        res.set_vcleft_rl_map_light_switch_pressed(vcleft_rl_map_light_switch_pressed)?;
        res.set_vcleft_rr_map_light_status(vcleft_rr_map_light_status)?;
        res.set_vcleft_rr_map_light_switch_pressed(vcleft_rr_map_light_switch_pressed)?;
        res.set_vcleft_brake_light_status(vcleft_brake_light_status)?;
        res.set_vcleft_brake_trailer_light_status(vcleft_brake_trailer_light_status)?;
        res.set_vcleft_dynamic_brake_light_status(vcleft_dynamic_brake_light_status)?;
        res.set_vcleft_fog_trailer_light_status(vcleft_fog_trailer_light_status)?;
        res.set_vcleft_front_ride_height(vcleft_front_ride_height)?;
        res.set_vcleft_left_turn_trailer_light_statu(vcleft_left_turn_trailer_light_statu)?;
        res.set_vcleft_rear_ride_height(vcleft_rear_ride_height)?;
        res.set_vcleft_reverse_trailer_light_status(vcleft_reverse_trailer_light_status)?;
        res.set_vcleft_ride_height_sensor_fault(vcleft_ride_height_sensor_fault)?;
        res.set_vcleft_right_trn_trailer_light_statu(vcleft_right_trn_trailer_light_statu)?;
        res.set_vcleft_tail_light_outage_status(vcleft_tail_light_outage_status)?;
        res.set_vcleft_tail_light_status(vcleft_tail_light_status)?;
        res.set_vcleft_tail_trailer_light_status(vcleft_tail_trailer_light_status)?;
        res.set_vcleft_trailer_detected(vcleft_trailer_detected)?;
        res.set_vcleft_turn_signal_status(vcleft_turn_signal_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCLEFT_FLMapLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_fl_map_light_status(&self) -> Id3e2vcleftLightStatusVcleftFlMapLightStatus {
        match self.vcleft_fl_map_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftFlMapLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftFlMapLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftFlMapLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftFlMapLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftFlMapLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_FLMapLightStatus
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_fl_map_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_FLMapLightStatus
    #[inline(always)]
    pub fn set_vcleft_fl_map_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_FLMapLightSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_fl_map_light_switch_pressed(&self) -> bool {
        self.vcleft_fl_map_light_switch_pressed_raw()
    }
    
    /// Get raw value of VCLEFT_FLMapLightSwitchPressed
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_fl_map_light_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_FLMapLightSwitchPressed
    #[inline(always)]
    pub fn set_vcleft_fl_map_light_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_FRMapLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_fr_map_light_status(&self) -> Id3e2vcleftLightStatusVcleftFrMapLightStatus {
        match self.vcleft_fr_map_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftFrMapLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftFrMapLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftFrMapLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftFrMapLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftFrMapLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_FRMapLightStatus
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_fr_map_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_FRMapLightStatus
    #[inline(always)]
    pub fn set_vcleft_fr_map_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_FRMapLightSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_fr_map_light_switch_pressed(&self) -> bool {
        self.vcleft_fr_map_light_switch_pressed_raw()
    }
    
    /// Get raw value of VCLEFT_FRMapLightSwitchPressed
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_fr_map_light_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_FRMapLightSwitchPressed
    #[inline(always)]
    pub fn set_vcleft_fr_map_light_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_RLMapLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rl_map_light_status(&self) -> Id3e2vcleftLightStatusVcleftRlMapLightStatus {
        match self.vcleft_rl_map_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftRlMapLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftRlMapLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftRlMapLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftRlMapLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftRlMapLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_RLMapLightStatus
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rl_map_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_RLMapLightStatus
    #[inline(always)]
    pub fn set_vcleft_rl_map_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_RLMapLightSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rl_map_light_switch_pressed(&self) -> bool {
        self.vcleft_rl_map_light_switch_pressed_raw()
    }
    
    /// Get raw value of VCLEFT_RLMapLightSwitchPressed
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rl_map_light_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_RLMapLightSwitchPressed
    #[inline(always)]
    pub fn set_vcleft_rl_map_light_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_RRMapLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rr_map_light_status(&self) -> Id3e2vcleftLightStatusVcleftRrMapLightStatus {
        match self.vcleft_rr_map_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftRrMapLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftRrMapLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftRrMapLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftRrMapLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftRrMapLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_RRMapLightStatus
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rr_map_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_RRMapLightStatus
    #[inline(always)]
    pub fn set_vcleft_rr_map_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_RRMapLightSwitchPressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rr_map_light_switch_pressed(&self) -> bool {
        self.vcleft_rr_map_light_switch_pressed_raw()
    }
    
    /// Get raw value of VCLEFT_RRMapLightSwitchPressed
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rr_map_light_switch_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_RRMapLightSwitchPressed
    #[inline(always)]
    pub fn set_vcleft_rr_map_light_switch_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_brakeLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_brake_light_status(&self) -> Id3e2vcleftLightStatusVcleftBrakeLightStatus {
        match self.vcleft_brake_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftBrakeLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftBrakeLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftBrakeLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftBrakeLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftBrakeLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_brakeLightStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_brake_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_brakeLightStatus
    #[inline(always)]
    pub fn set_vcleft_brake_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_brakeTrailerLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_brake_trailer_light_status(&self) -> Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus {
        match self.vcleft_brake_trailer_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_brakeTrailerLightStatus
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_brake_trailer_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_brakeTrailerLightStatus
    #[inline(always)]
    pub fn set_vcleft_brake_trailer_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_dynamicBrakeLightStatus
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_dynamic_brake_light_status(&self) -> Id3e2vcleftLightStatusVcleftDynamicBrakeLightStatus {
        match self.vcleft_dynamic_brake_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftDynamicBrakeLightStatus::DynamicBrakeLightActiveHigh,
            1 => Id3e2vcleftLightStatusVcleftDynamicBrakeLightStatus::DynamicBrakeLightActiveLow,
            0 => Id3e2vcleftLightStatusVcleftDynamicBrakeLightStatus::DynamicBrakeLightOff,
            x => Id3e2vcleftLightStatusVcleftDynamicBrakeLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_dynamicBrakeLightStatus
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_dynamic_brake_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_dynamicBrakeLightStatus
    #[inline(always)]
    pub fn set_vcleft_dynamic_brake_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_fogTrailerLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_fog_trailer_light_status(&self) -> Id3e2vcleftLightStatusVcleftFogTrailerLightStatus {
        match self.vcleft_fog_trailer_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftFogTrailerLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftFogTrailerLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftFogTrailerLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftFogTrailerLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftFogTrailerLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_fogTrailerLightStatus
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_fog_trailer_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_fogTrailerLightStatus
    #[inline(always)]
    pub fn set_vcleft_fog_trailer_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..28].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_frontRideHeight
    ///
    /// - Min: -127
    /// - Max: 127
    /// - Unit: "mm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_front_ride_height(&self) -> Id3e2vcleftLightStatusVcleftFrontRideHeight {
        match self.vcleft_front_ride_height_raw() {
            128 => Id3e2vcleftLightStatusVcleftFrontRideHeight::Sna,
            x => Id3e2vcleftLightStatusVcleftFrontRideHeight::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_frontRideHeight
    ///
    /// - Start bit: 28
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_front_ride_height_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..36].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCLEFT_frontRideHeight
    #[inline(always)]
    pub fn set_vcleft_front_ride_height(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_i8 || 127_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[28..36].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_leftTurnTrailerLightStatu
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_left_turn_trailer_light_statu(&self) -> Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu {
        match self.vcleft_left_turn_trailer_light_statu_raw() {
            2 => Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu::LightFault,
            0 => Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu::LightOff,
            1 => Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu::LightOn,
            3 => Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu::LightSna,
            x => Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_leftTurnTrailerLightStatu
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_left_turn_trailer_light_statu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_leftTurnTrailerLightStatu
    #[inline(always)]
    pub fn set_vcleft_left_turn_trailer_light_statu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..20].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rearRideHeight
    ///
    /// - Min: -127
    /// - Max: 127
    /// - Unit: "mm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rear_ride_height(&self) -> Id3e2vcleftLightStatusVcleftRearRideHeight {
        match self.vcleft_rear_ride_height_raw() {
            128 => Id3e2vcleftLightStatusVcleftRearRideHeight::Sna,
            x => Id3e2vcleftLightStatusVcleftRearRideHeight::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rearRideHeight
    ///
    /// - Start bit: 36
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcleft_rear_ride_height_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..44].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCLEFT_rearRideHeight
    #[inline(always)]
    pub fn set_vcleft_rear_ride_height(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_i8 || 127_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[36..44].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_reverseTrailerLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_reverse_trailer_light_status(&self) -> Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus {
        match self.vcleft_reverse_trailer_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_reverseTrailerLightStatus
    ///
    /// - Start bit: 49
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_reverse_trailer_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[49..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_reverseTrailerLightStatus
    #[inline(always)]
    pub fn set_vcleft_reverse_trailer_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..51].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rideHeightSensorFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_ride_height_sensor_fault(&self) -> bool {
        self.vcleft_ride_height_sensor_fault_raw()
    }
    
    /// Get raw value of VCLEFT_rideHeightSensorFault
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_ride_height_sensor_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_rideHeightSensorFault
    #[inline(always)]
    pub fn set_vcleft_ride_height_sensor_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rightTrnTrailerLightStatu
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_right_trn_trailer_light_statu(&self) -> Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu {
        match self.vcleft_right_trn_trailer_light_statu_raw() {
            2 => Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu::LightFault,
            0 => Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu::LightOff,
            1 => Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu::LightOn,
            3 => Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu::LightSna,
            x => Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rightTrnTrailerLightStatu
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_right_trn_trailer_light_statu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rightTrnTrailerLightStatu
    #[inline(always)]
    pub fn set_vcleft_right_trn_trailer_light_statu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..22].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_tailLightOutageStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_tail_light_outage_status(&self) -> bool {
        self.vcleft_tail_light_outage_status_raw()
    }
    
    /// Get raw value of VCLEFT_tailLightOutageStatus
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_tail_light_outage_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_tailLightOutageStatus
    #[inline(always)]
    pub fn set_vcleft_tail_light_outage_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_tailLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_tail_light_status(&self) -> Id3e2vcleftLightStatusVcleftTailLightStatus {
        match self.vcleft_tail_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftTailLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftTailLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftTailLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftTailLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftTailLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_tailLightStatus
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_tail_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_tailLightStatus
    #[inline(always)]
    pub fn set_vcleft_tail_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_tailTrailerLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_tail_trailer_light_status(&self) -> Id3e2vcleftLightStatusVcleftTailTrailerLightStatus {
        match self.vcleft_tail_trailer_light_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftTailTrailerLightStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftTailTrailerLightStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftTailTrailerLightStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftTailTrailerLightStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftTailTrailerLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_tailTrailerLightStatus
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_tail_trailer_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_tailTrailerLightStatus
    #[inline(always)]
    pub fn set_vcleft_tail_trailer_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_trailerDetected
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_trailer_detected(&self) -> Id3e2vcleftLightStatusVcleftTrailerDetected {
        match self.vcleft_trailer_detected_raw() {
            2 => Id3e2vcleftLightStatusVcleftTrailerDetected::TrailerLightDetectionDetected,
            1 => Id3e2vcleftLightStatusVcleftTrailerDetected::TrailerLightDetectionFault,
            3 => Id3e2vcleftLightStatusVcleftTrailerDetected::TrailerLightDetectionNotDetected,
            0 => Id3e2vcleftLightStatusVcleftTrailerDetected::TrailerLightDetectionSna,
            x => Id3e2vcleftLightStatusVcleftTrailerDetected::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_trailerDetected
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_trailer_detected_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_trailerDetected
    #[inline(always)]
    pub fn set_vcleft_trailer_detected(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..48].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_turnSignalStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_turn_signal_status(&self) -> Id3e2vcleftLightStatusVcleftTurnSignalStatus {
        match self.vcleft_turn_signal_status_raw() {
            2 => Id3e2vcleftLightStatusVcleftTurnSignalStatus::LightFault,
            0 => Id3e2vcleftLightStatusVcleftTurnSignalStatus::LightOff,
            1 => Id3e2vcleftLightStatusVcleftTurnSignalStatus::LightOn,
            3 => Id3e2vcleftLightStatusVcleftTurnSignalStatus::LightSna,
            x => Id3e2vcleftLightStatusVcleftTurnSignalStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_turnSignalStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_turn_signal_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_turnSignalStatus
    #[inline(always)]
    pub fn set_vcleft_turn_signal_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 994 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3e2vcleftLightStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 7 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 7];
        raw.copy_from_slice(&payload[..7]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3e2vcleftLightStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcleft_fl_map_light_status = u.int_in_range(0..=3)?;
        let vcleft_fl_map_light_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcleft_fr_map_light_status = u.int_in_range(0..=3)?;
        let vcleft_fr_map_light_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcleft_rl_map_light_status = u.int_in_range(0..=3)?;
        let vcleft_rl_map_light_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcleft_rr_map_light_status = u.int_in_range(0..=3)?;
        let vcleft_rr_map_light_switch_pressed = u.int_in_range(0..=1)? == 1;
        let vcleft_brake_light_status = u.int_in_range(0..=3)?;
        let vcleft_brake_trailer_light_status = u.int_in_range(0..=3)?;
        let vcleft_dynamic_brake_light_status = u.int_in_range(0..=2)?;
        let vcleft_fog_trailer_light_status = u.int_in_range(0..=3)?;
        let vcleft_front_ride_height = u.int_in_range(-127..=127)?;
        let vcleft_left_turn_trailer_light_statu = u.int_in_range(0..=3)?;
        let vcleft_rear_ride_height = u.int_in_range(-127..=127)?;
        let vcleft_reverse_trailer_light_status = u.int_in_range(0..=3)?;
        let vcleft_ride_height_sensor_fault = u.int_in_range(0..=1)? == 1;
        let vcleft_right_trn_trailer_light_statu = u.int_in_range(0..=3)?;
        let vcleft_tail_light_outage_status = u.int_in_range(0..=1)? == 1;
        let vcleft_tail_light_status = u.int_in_range(0..=3)?;
        let vcleft_tail_trailer_light_status = u.int_in_range(0..=3)?;
        let vcleft_trailer_detected = u.int_in_range(0..=3)?;
        let vcleft_turn_signal_status = u.int_in_range(0..=3)?;
        Id3e2vcleftLightStatus::new(vcleft_fl_map_light_status,vcleft_fl_map_light_switch_pressed,vcleft_fr_map_light_status,vcleft_fr_map_light_switch_pressed,vcleft_rl_map_light_status,vcleft_rl_map_light_switch_pressed,vcleft_rr_map_light_status,vcleft_rr_map_light_switch_pressed,vcleft_brake_light_status,vcleft_brake_trailer_light_status,vcleft_dynamic_brake_light_status,vcleft_fog_trailer_light_status,vcleft_front_ride_height,vcleft_left_turn_trailer_light_statu,vcleft_rear_ride_height,vcleft_reverse_trailer_light_status,vcleft_ride_height_sensor_fault,vcleft_right_trn_trailer_light_statu,vcleft_tail_light_outage_status,vcleft_tail_light_status,vcleft_tail_trailer_light_status,vcleft_trailer_detected,vcleft_turn_signal_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCLEFT_FLMapLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftFlMapLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_FRMapLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftFrMapLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_RLMapLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftRlMapLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_RRMapLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftRrMapLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_brakeLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftBrakeLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_brakeTrailerLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftBrakeTrailerLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_dynamicBrakeLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftDynamicBrakeLightStatus {
    DynamicBrakeLightActiveHigh,
    DynamicBrakeLightActiveLow,
    DynamicBrakeLightOff,
    Other(u8),
}
/// Defined values for VCLEFT_fogTrailerLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftFogTrailerLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_frontRideHeight
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftFrontRideHeight {
    Sna,
    Other(i8),
}
/// Defined values for VCLEFT_leftTurnTrailerLightStatu
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftLeftTurnTrailerLightStatu {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_rearRideHeight
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftRearRideHeight {
    Sna,
    Other(i8),
}
/// Defined values for VCLEFT_reverseTrailerLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftReverseTrailerLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_rightTrnTrailerLightStatu
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftRightTrnTrailerLightStatu {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_tailLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftTailLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_tailTrailerLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftTailTrailerLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCLEFT_trailerDetected
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftTrailerDetected {
    TrailerLightDetectionDetected,
    TrailerLightDetectionFault,
    TrailerLightDetectionNotDetected,
    TrailerLightDetectionSna,
    Other(u8),
}
/// Defined values for VCLEFT_turnSignalStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e2vcleftLightStatusVcleftTurnSignalStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}

/// ID3E9DAS_bodyControls
///
/// - ID: 1001 (0x3e9)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3e9dasBodyControls {
    raw: [u8; 8],
}

impl Id3e9dasBodyControls {
    pub const MESSAGE_ID: u32 = 1001;
    
    /// Construct new ID3E9DAS_bodyControls from values
    pub fn new(das_body_controls_checksum: u8, das_body_controls_counter: u8, das_dynamic_brake_light_request: bool, das_hazard_light_request: u8, das_headlight_request: u8, das_heater_request: u8, das_high_low_beam_decision: u8, das_high_low_beam_off_reason: u8, das_turn_indicator_request: u8, das_turn_indicator_request_reason: u8, das_wiper_speed: u8, das_radar_heater_request: bool, das_ahlb_override: bool, das_mirror_fold_request: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_das_body_controls_checksum(das_body_controls_checksum)?;
        res.set_das_body_controls_counter(das_body_controls_counter)?;
        res.set_das_dynamic_brake_light_request(das_dynamic_brake_light_request)?;
        res.set_das_hazard_light_request(das_hazard_light_request)?;
        res.set_das_headlight_request(das_headlight_request)?;
        res.set_das_heater_request(das_heater_request)?;
        res.set_das_high_low_beam_decision(das_high_low_beam_decision)?;
        res.set_das_high_low_beam_off_reason(das_high_low_beam_off_reason)?;
        res.set_das_turn_indicator_request(das_turn_indicator_request)?;
        res.set_das_turn_indicator_request_reason(das_turn_indicator_request_reason)?;
        res.set_das_wiper_speed(das_wiper_speed)?;
        res.set_das_radar_heater_request(das_radar_heater_request)?;
        res.set_das_ahlb_override(das_ahlb_override)?;
        res.set_das_mirror_fold_request(das_mirror_fold_request)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DAS_bodyControlsChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_body_controls_checksum(&self) -> u8 {
        self.das_body_controls_checksum_raw()
    }
    
    /// Get raw value of DAS_bodyControlsChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_body_controls_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_bodyControlsChecksum
    #[inline(always)]
    pub fn set_das_body_controls_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DAS_bodyControlsCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_body_controls_counter(&self) -> u8 {
        self.das_body_controls_counter_raw()
    }
    
    /// Get raw value of DAS_bodyControlsCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_body_controls_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_bodyControlsCounter
    #[inline(always)]
    pub fn set_das_body_controls_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// DAS_dynamicBrakeLightRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_dynamic_brake_light_request(&self) -> bool {
        self.das_dynamic_brake_light_request_raw()
    }
    
    /// Get raw value of DAS_dynamicBrakeLightRequest
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_dynamic_brake_light_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_dynamicBrakeLightRequest
    #[inline(always)]
    pub fn set_das_dynamic_brake_light_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[22..23].store_le(value);
        Ok(())
    }
    
    /// DAS_hazardLightRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_hazard_light_request(&self) -> Id3e9dasBodyControlsDasHazardLightRequest {
        match self.das_hazard_light_request_raw() {
            0 => Id3e9dasBodyControlsDasHazardLightRequest::DasRequestHazardsOff,
            1 => Id3e9dasBodyControlsDasHazardLightRequest::DasRequestHazardsOn,
            3 => Id3e9dasBodyControlsDasHazardLightRequest::DasRequestHazardsSna,
            2 => Id3e9dasBodyControlsDasHazardLightRequest::DasRequestHazardsUnused,
            x => Id3e9dasBodyControlsDasHazardLightRequest::Other(x),
        }
    }
    
    /// Get raw value of DAS_hazardLightRequest
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_hazard_light_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_hazardLightRequest
    #[inline(always)]
    pub fn set_das_hazard_light_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// DAS_headlightRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_headlight_request(&self) -> Id3e9dasBodyControlsDasHeadlightRequest {
        match self.das_headlight_request_raw() {
            3 => Id3e9dasBodyControlsDasHeadlightRequest::DasHeadlightRequestInvalid,
            0 => Id3e9dasBodyControlsDasHeadlightRequest::DasHeadlightRequestOff,
            1 => Id3e9dasBodyControlsDasHeadlightRequest::DasHeadlightRequestOn,
            x => Id3e9dasBodyControlsDasHeadlightRequest::Other(x),
        }
    }
    
    /// Get raw value of DAS_headlightRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_headlight_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_headlightRequest
    #[inline(always)]
    pub fn set_das_headlight_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// DAS_heaterRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_heater_request(&self) -> Id3e9dasBodyControlsDasHeaterRequest {
        match self.das_heater_request_raw() {
            1 => Id3e9dasBodyControlsDasHeaterRequest::DasHeaterOff,
            2 => Id3e9dasBodyControlsDasHeaterRequest::DasHeaterOn,
            0 => Id3e9dasBodyControlsDasHeaterRequest::DasHeaterSna,
            x => Id3e9dasBodyControlsDasHeaterRequest::Other(x),
        }
    }
    
    /// Get raw value of DAS_heaterRequest
    ///
    /// - Start bit: 13
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_heater_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_heaterRequest
    #[inline(always)]
    pub fn set_das_heater_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..15].store_le(value);
        Ok(())
    }
    
    /// DAS_highLowBeamDecision
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_high_low_beam_decision(&self) -> Id3e9dasBodyControlsDasHighLowBeamDecision {
        match self.das_high_low_beam_decision_raw() {
            1 => Id3e9dasBodyControlsDasHighLowBeamDecision::DasHighBeamOff,
            2 => Id3e9dasBodyControlsDasHighLowBeamDecision::DasHighBeamOn,
            3 => Id3e9dasBodyControlsDasHighLowBeamDecision::DasHighBeamSna,
            0 => Id3e9dasBodyControlsDasHighLowBeamDecision::DasHighBeamUndecided,
            x => Id3e9dasBodyControlsDasHighLowBeamDecision::Other(x),
        }
    }
    
    /// Get raw value of DAS_highLowBeamDecision
    ///
    /// - Start bit: 11
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_high_low_beam_decision_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_highLowBeamDecision
    #[inline(always)]
    pub fn set_das_high_low_beam_decision(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..13].store_le(value);
        Ok(())
    }
    
    /// DAS_highLowBeamOffReason
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_high_low_beam_off_reason(&self) -> Id3e9dasBodyControlsDasHighLowBeamOffReason {
        match self.das_high_low_beam_off_reason_raw() {
            3 => Id3e9dasBodyControlsDasHighLowBeamOffReason::HighBeamOffReasonAmbientLight,
            4 => Id3e9dasBodyControlsDasHighLowBeamOffReason::HighBeamOffReasonHeadLight,
            2 => Id3e9dasBodyControlsDasHighLowBeamOffReason::HighBeamOffReasonMovingRadarTarget,
            1 => Id3e9dasBodyControlsDasHighLowBeamOffReason::HighBeamOffReasonMovingVisionTarget,
            5 => Id3e9dasBodyControlsDasHighLowBeamOffReason::HighBeamOffReasonSna,
            0 => Id3e9dasBodyControlsDasHighLowBeamOffReason::HighBeamOn,
            x => Id3e9dasBodyControlsDasHighLowBeamOffReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_highLowBeamOffReason
    ///
    /// - Start bit: 15
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_high_low_beam_off_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[15..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_highLowBeamOffReason
    #[inline(always)]
    pub fn set_das_high_low_beam_off_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[15..18].store_le(value);
        Ok(())
    }
    
    /// DAS_turnIndicatorRequest
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_turn_indicator_request(&self) -> Id3e9dasBodyControlsDasTurnIndicatorRequest {
        match self.das_turn_indicator_request_raw() {
            3 => Id3e9dasBodyControlsDasTurnIndicatorRequest::DasTurnIndicatorCancel,
            4 => Id3e9dasBodyControlsDasTurnIndicatorRequest::DasTurnIndicatorDefer,
            1 => Id3e9dasBodyControlsDasTurnIndicatorRequest::DasTurnIndicatorLeft,
            0 => Id3e9dasBodyControlsDasTurnIndicatorRequest::DasTurnIndicatorNone,
            2 => Id3e9dasBodyControlsDasTurnIndicatorRequest::DasTurnIndicatorRight,
            x => Id3e9dasBodyControlsDasTurnIndicatorRequest::Other(x),
        }
    }
    
    /// Get raw value of DAS_turnIndicatorRequest
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_turn_indicator_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_turnIndicatorRequest
    #[inline(always)]
    pub fn set_das_turn_indicator_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// DAS_turnIndicatorRequestReason
    ///
    /// - Min: 0
    /// - Max: 12
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_turn_indicator_request_reason(&self) -> Id3e9dasBodyControlsDasTurnIndicatorRequestReason {
        match self.das_turn_indicator_request_reason_raw() {
            8 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveCommandedLaneChange,
            3 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveFork,
            9 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveIntersection,
            6 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveMerge,
            1 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveNavLaneChange,
            2 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveSpeedLaneChange,
            11 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasActiveSummmon,
            5 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasCancelFork,
            10 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasCancelIntersection,
            4 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasCancelLaneChange,
            7 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasCancelMerge,
            12 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasCancelSummmon,
            0 => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::DasNone,
            x => Id3e9dasBodyControlsDasTurnIndicatorRequestReason::Other(x),
        }
    }
    
    /// Get raw value of DAS_turnIndicatorRequestReason
    ///
    /// - Start bit: 18
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_turn_indicator_request_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_turnIndicatorRequestReason
    #[inline(always)]
    pub fn set_das_turn_indicator_request_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 12_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..22].store_le(value);
        Ok(())
    }
    
    /// DAS_wiperSpeed
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_wiper_speed(&self) -> Id3e9dasBodyControlsDasWiperSpeed {
        match self.das_wiper_speed_raw() {
            1 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed1,
            10 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed10,
            11 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed11,
            12 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed12,
            13 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed13,
            14 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed14,
            2 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed2,
            3 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed3,
            4 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed4,
            5 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed5,
            6 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed6,
            7 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed7,
            8 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed8,
            9 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeed9,
            15 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeedInvalid,
            0 => Id3e9dasBodyControlsDasWiperSpeed::DasWiperSpeedOff,
            x => Id3e9dasBodyControlsDasWiperSpeed::Other(x),
        }
    }
    
    /// Get raw value of DAS_wiperSpeed
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_wiper_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_wiperSpeed
    #[inline(always)]
    pub fn set_das_wiper_speed(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..8].store_le(value);
        Ok(())
    }
    
    /// DAS_radarHeaterRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_radar_heater_request(&self) -> bool {
        self.das_radar_heater_request_raw()
    }
    
    /// Get raw value of DAS_radarHeaterRequest
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_radar_heater_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_radarHeaterRequest
    #[inline(always)]
    pub fn set_das_radar_heater_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// DAS_ahlbOverride
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_ahlb_override(&self) -> bool {
        self.das_ahlb_override_raw()
    }
    
    /// Get raw value of DAS_ahlbOverride
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_ahlb_override_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DAS_ahlbOverride
    #[inline(always)]
    pub fn set_das_ahlb_override(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// DAS_mirrorFoldRequest
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn das_mirror_fold_request(&self) -> Id3e9dasBodyControlsDasMirrorFoldRequest {
        match self.das_mirror_fold_request_raw() {
            0 => Id3e9dasBodyControlsDasMirrorFoldRequest::None,
            1 => Id3e9dasBodyControlsDasMirrorFoldRequest::Fold,
            2 => Id3e9dasBodyControlsDasMirrorFoldRequest::Unfold,
            3 => Id3e9dasBodyControlsDasMirrorFoldRequest::Sna,
            x => Id3e9dasBodyControlsDasMirrorFoldRequest::Other(x),
        }
    }
    
    /// Get raw value of DAS_mirrorFoldRequest
    ///
    /// - Start bit: 25
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn das_mirror_fold_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[25..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DAS_mirrorFoldRequest
    #[inline(always)]
    pub fn set_das_mirror_fold_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1001 }); }
        self.raw.view_bits_mut::<LocalBits>()[25..27].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3e9dasBodyControls {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3e9dasBodyControls
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let das_body_controls_checksum = u.int_in_range(0..=255)?;
        let das_body_controls_counter = u.int_in_range(0..=15)?;
        let das_dynamic_brake_light_request = u.int_in_range(0..=1)? == 1;
        let das_hazard_light_request = u.int_in_range(0..=3)?;
        let das_headlight_request = u.int_in_range(0..=3)?;
        let das_heater_request = u.int_in_range(0..=2)?;
        let das_high_low_beam_decision = u.int_in_range(0..=3)?;
        let das_high_low_beam_off_reason = u.int_in_range(0..=5)?;
        let das_turn_indicator_request = u.int_in_range(0..=4)?;
        let das_turn_indicator_request_reason = u.int_in_range(0..=12)?;
        let das_wiper_speed = u.int_in_range(0..=15)?;
        let das_radar_heater_request = u.int_in_range(0..=1)? == 1;
        let das_ahlb_override = u.int_in_range(0..=1)? == 1;
        let das_mirror_fold_request = u.int_in_range(0..=0)?;
        Id3e9dasBodyControls::new(das_body_controls_checksum,das_body_controls_counter,das_dynamic_brake_light_request,das_hazard_light_request,das_headlight_request,das_heater_request,das_high_low_beam_decision,das_high_low_beam_off_reason,das_turn_indicator_request,das_turn_indicator_request_reason,das_wiper_speed,das_radar_heater_request,das_ahlb_override,das_mirror_fold_request).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DAS_hazardLightRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasHazardLightRequest {
    DasRequestHazardsOff,
    DasRequestHazardsOn,
    DasRequestHazardsSna,
    DasRequestHazardsUnused,
    Other(u8),
}
/// Defined values for DAS_headlightRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasHeadlightRequest {
    DasHeadlightRequestInvalid,
    DasHeadlightRequestOff,
    DasHeadlightRequestOn,
    Other(u8),
}
/// Defined values for DAS_heaterRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasHeaterRequest {
    DasHeaterOff,
    DasHeaterOn,
    DasHeaterSna,
    Other(u8),
}
/// Defined values for DAS_highLowBeamDecision
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasHighLowBeamDecision {
    DasHighBeamOff,
    DasHighBeamOn,
    DasHighBeamSna,
    DasHighBeamUndecided,
    Other(u8),
}
/// Defined values for DAS_highLowBeamOffReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasHighLowBeamOffReason {
    HighBeamOffReasonAmbientLight,
    HighBeamOffReasonHeadLight,
    HighBeamOffReasonMovingRadarTarget,
    HighBeamOffReasonMovingVisionTarget,
    HighBeamOffReasonSna,
    HighBeamOn,
    Other(u8),
}
/// Defined values for DAS_turnIndicatorRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasTurnIndicatorRequest {
    DasTurnIndicatorCancel,
    DasTurnIndicatorDefer,
    DasTurnIndicatorLeft,
    DasTurnIndicatorNone,
    DasTurnIndicatorRight,
    Other(u8),
}
/// Defined values for DAS_turnIndicatorRequestReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasTurnIndicatorRequestReason {
    DasActiveCommandedLaneChange,
    DasActiveFork,
    DasActiveIntersection,
    DasActiveMerge,
    DasActiveNavLaneChange,
    DasActiveSpeedLaneChange,
    DasActiveSummmon,
    DasCancelFork,
    DasCancelIntersection,
    DasCancelLaneChange,
    DasCancelMerge,
    DasCancelSummmon,
    DasNone,
    Other(u8),
}
/// Defined values for DAS_wiperSpeed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasWiperSpeed {
    DasWiperSpeed1,
    DasWiperSpeed10,
    DasWiperSpeed11,
    DasWiperSpeed12,
    DasWiperSpeed13,
    DasWiperSpeed14,
    DasWiperSpeed2,
    DasWiperSpeed3,
    DasWiperSpeed4,
    DasWiperSpeed5,
    DasWiperSpeed6,
    DasWiperSpeed7,
    DasWiperSpeed8,
    DasWiperSpeed9,
    DasWiperSpeedInvalid,
    DasWiperSpeedOff,
    Other(u8),
}
/// Defined values for DAS_mirrorFoldRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e9dasBodyControlsDasMirrorFoldRequest {
    None,
    Fold,
    Unfold,
    Sna,
    Other(u8),
}

/// ID3F3UI_odo
///
/// - ID: 1011 (0x3f3)
/// - Size: 3 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3f3uiOdo {
    raw: [u8; 3],
}

impl Id3f3uiOdo {
    pub const MESSAGE_ID: u32 = 1011;
    
    /// Construct new ID3F3UI_odo from values
    pub fn new(ui_odometer: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_ui_odometer(ui_odometer)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_odometer
    ///
    /// UI Odometer
    ///
    /// - Min: 0
    /// - Max: 1677720
    /// - Unit: "km"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_odometer(&self) -> Id3f3uiOdoUiOdometer {
        match self.ui_odometer_raw() {
            16777215 => Id3f3uiOdoUiOdometer::Sna,
            x => Id3f3uiOdoUiOdometer::Other(x),
        }
    }
    
    /// Get raw value of UI_odometer
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_odometer_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_odometer
    #[inline(always)]
    pub fn set_ui_odometer(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1677720_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1011 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<LocalBits>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3f3uiOdo {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3f3uiOdo
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_odometer = 0_f32;
        Id3f3uiOdo::new(ui_odometer).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_odometer
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f3uiOdoUiOdometer {
    Sna,
    Other(f32),
}

/// ID3F5VCFRONT_lighting
///
/// - ID: 1013 (0x3f5)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3f5vcfrontLighting {
    raw: [u8; 8],
}

impl Id3f5vcfrontLighting {
    pub const MESSAGE_ID: u32 = 1013;
    
    /// Construct new ID3F5VCFRONT_lighting from values
    pub fn new(vcfront_drl_left_status: u8, vcfront_drl_right_status: u8, vcfront_ambient_lighting_brightnes: f32, vcfront_approach_lighting_request: bool, vcfront_courtesy_lighting_request: bool, vcfront_fog_left_status: u8, vcfront_fog_right_status: u8, vcfront_hazard_light_request: u8, vcfront_hazard_switch_backlight: bool, vcfront_high_beam_left_status: u8, vcfront_high_beam_right_status: u8, vcfront_high_beam_switch_active: bool, vcfront_indicator_left_request: u8, vcfront_indicator_right_request: u8, vcfront_low_beam_left_status: u8, vcfront_low_beam_right_status: u8, vcfront_low_beams_calibrated: bool, vcfront_low_beams_on_for_drl: bool, vcfront_park_left_status: u8, vcfront_park_right_status: u8, vcfront_see_you_home_lighting_req: bool, vcfront_side_markers_status: u8, vcfront_side_repeater_left_status: u8, vcfront_side_repeater_right_status: u8, vcfront_sim_latching_stalk: u8, vcfront_switch_lighting_brightness: f32, vcfront_turn_signal_left_status: u8, vcfront_turn_signal_right_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcfront_drl_left_status(vcfront_drl_left_status)?;
        res.set_vcfront_drl_right_status(vcfront_drl_right_status)?;
        res.set_vcfront_ambient_lighting_brightnes(vcfront_ambient_lighting_brightnes)?;
        res.set_vcfront_approach_lighting_request(vcfront_approach_lighting_request)?;
        res.set_vcfront_courtesy_lighting_request(vcfront_courtesy_lighting_request)?;
        res.set_vcfront_fog_left_status(vcfront_fog_left_status)?;
        res.set_vcfront_fog_right_status(vcfront_fog_right_status)?;
        res.set_vcfront_hazard_light_request(vcfront_hazard_light_request)?;
        res.set_vcfront_hazard_switch_backlight(vcfront_hazard_switch_backlight)?;
        res.set_vcfront_high_beam_left_status(vcfront_high_beam_left_status)?;
        res.set_vcfront_high_beam_right_status(vcfront_high_beam_right_status)?;
        res.set_vcfront_high_beam_switch_active(vcfront_high_beam_switch_active)?;
        res.set_vcfront_indicator_left_request(vcfront_indicator_left_request)?;
        res.set_vcfront_indicator_right_request(vcfront_indicator_right_request)?;
        res.set_vcfront_low_beam_left_status(vcfront_low_beam_left_status)?;
        res.set_vcfront_low_beam_right_status(vcfront_low_beam_right_status)?;
        res.set_vcfront_low_beams_calibrated(vcfront_low_beams_calibrated)?;
        res.set_vcfront_low_beams_on_for_drl(vcfront_low_beams_on_for_drl)?;
        res.set_vcfront_park_left_status(vcfront_park_left_status)?;
        res.set_vcfront_park_right_status(vcfront_park_right_status)?;
        res.set_vcfront_see_you_home_lighting_req(vcfront_see_you_home_lighting_req)?;
        res.set_vcfront_side_markers_status(vcfront_side_markers_status)?;
        res.set_vcfront_side_repeater_left_status(vcfront_side_repeater_left_status)?;
        res.set_vcfront_side_repeater_right_status(vcfront_side_repeater_right_status)?;
        res.set_vcfront_sim_latching_stalk(vcfront_sim_latching_stalk)?;
        res.set_vcfront_switch_lighting_brightness(vcfront_switch_lighting_brightness)?;
        res.set_vcfront_turn_signal_left_status(vcfront_turn_signal_left_status)?;
        res.set_vcfront_turn_signal_right_status(vcfront_turn_signal_right_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_DRLLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_drl_left_status(&self) -> Id3f5vcfrontLightingVcfrontDrlLeftStatus {
        match self.vcfront_drl_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontDrlLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontDrlLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontDrlLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontDrlLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontDrlLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_DRLLeftStatus
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_drl_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_DRLLeftStatus
    #[inline(always)]
    pub fn set_vcfront_drl_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..38].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_DRLRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_drl_right_status(&self) -> Id3f5vcfrontLightingVcfrontDrlRightStatus {
        match self.vcfront_drl_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontDrlRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontDrlRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontDrlRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontDrlRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontDrlRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_DRLRightStatus
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_drl_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_DRLRightStatus
    #[inline(always)]
    pub fn set_vcfront_drl_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ambientLightingBrightnes
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ambient_lighting_brightnes(&self) -> Id3f5vcfrontLightingVcfrontAmbientLightingBrightnes {
        match self.vcfront_ambient_lighting_brightnes_raw() {
            255 => Id3f5vcfrontLightingVcfrontAmbientLightingBrightnes::Sna,
            x => Id3f5vcfrontLightingVcfrontAmbientLightingBrightnes::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_ambientLightingBrightnes
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ambient_lighting_brightnes_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ambientLightingBrightnes
    #[inline(always)]
    pub fn set_vcfront_ambient_lighting_brightnes(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_approachLightingRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_approach_lighting_request(&self) -> bool {
        self.vcfront_approach_lighting_request_raw()
    }
    
    /// Get raw value of VCFRONT_approachLightingRequest
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_approach_lighting_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_approachLightingRequest
    #[inline(always)]
    pub fn set_vcfront_approach_lighting_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_courtesyLightingRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_courtesy_lighting_request(&self) -> bool {
        self.vcfront_courtesy_lighting_request_raw()
    }
    
    /// Get raw value of VCFRONT_courtesyLightingRequest
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_courtesy_lighting_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_courtesyLightingRequest
    #[inline(always)]
    pub fn set_vcfront_courtesy_lighting_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fogLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fog_left_status(&self) -> Id3f5vcfrontLightingVcfrontFogLeftStatus {
        match self.vcfront_fog_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontFogLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontFogLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontFogLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontFogLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontFogLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_fogLeftStatus
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fog_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_fogLeftStatus
    #[inline(always)]
    pub fn set_vcfront_fog_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fogRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fog_right_status(&self) -> Id3f5vcfrontLightingVcfrontFogRightStatus {
        match self.vcfront_fog_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontFogRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontFogRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontFogRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontFogRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontFogRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_fogRightStatus
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fog_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_fogRightStatus
    #[inline(always)]
    pub fn set_vcfront_fog_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hazardLightRequest
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hazard_light_request(&self) -> Id3f5vcfrontLightingVcfrontHazardLightRequest {
        match self.vcfront_hazard_light_request_raw() {
            1 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestButton,
            6 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestCarAlarm,
            5 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestCrash,
            7 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestDas,
            2 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestLock,
            4 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestMislock,
            0 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestNone,
            8 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestUds,
            3 => Id3f5vcfrontLightingVcfrontHazardLightRequest::HazardRequestUnlock,
            x => Id3f5vcfrontLightingVcfrontHazardLightRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_hazardLightRequest
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hazard_light_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hazardLightRequest
    #[inline(always)]
    pub fn set_vcfront_hazard_light_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hazardSwitchBacklight
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hazard_switch_backlight(&self) -> bool {
        self.vcfront_hazard_switch_backlight_raw()
    }
    
    /// Get raw value of VCFRONT_hazardSwitchBacklight
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hazard_switch_backlight_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hazardSwitchBacklight
    #[inline(always)]
    pub fn set_vcfront_hazard_switch_backlight(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_highBeamLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_high_beam_left_status(&self) -> Id3f5vcfrontLightingVcfrontHighBeamLeftStatus {
        match self.vcfront_high_beam_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontHighBeamLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontHighBeamLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontHighBeamLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontHighBeamLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontHighBeamLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_highBeamLeftStatus
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_high_beam_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_highBeamLeftStatus
    #[inline(always)]
    pub fn set_vcfront_high_beam_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_highBeamRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_high_beam_right_status(&self) -> Id3f5vcfrontLightingVcfrontHighBeamRightStatus {
        match self.vcfront_high_beam_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontHighBeamRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontHighBeamRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontHighBeamRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontHighBeamRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontHighBeamRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_highBeamRightStatus
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_high_beam_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_highBeamRightStatus
    #[inline(always)]
    pub fn set_vcfront_high_beam_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_highBeamSwitchActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_high_beam_switch_active(&self) -> bool {
        self.vcfront_high_beam_switch_active_raw()
    }
    
    /// Get raw value of VCFRONT_highBeamSwitchActive
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_high_beam_switch_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_highBeamSwitchActive
    #[inline(always)]
    pub fn set_vcfront_high_beam_switch_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[58..59].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_indicatorLeftRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_indicator_left_request(&self) -> Id3f5vcfrontLightingVcfrontIndicatorLeftRequest {
        match self.vcfront_indicator_left_request_raw() {
            2 => Id3f5vcfrontLightingVcfrontIndicatorLeftRequest::TurnSignalActiveHigh,
            1 => Id3f5vcfrontLightingVcfrontIndicatorLeftRequest::TurnSignalActiveLow,
            0 => Id3f5vcfrontLightingVcfrontIndicatorLeftRequest::TurnSignalOff,
            x => Id3f5vcfrontLightingVcfrontIndicatorLeftRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_indicatorLeftRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_indicator_left_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_indicatorLeftRequest
    #[inline(always)]
    pub fn set_vcfront_indicator_left_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_indicatorRightRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_indicator_right_request(&self) -> Id3f5vcfrontLightingVcfrontIndicatorRightRequest {
        match self.vcfront_indicator_right_request_raw() {
            2 => Id3f5vcfrontLightingVcfrontIndicatorRightRequest::TurnSignalActiveHigh,
            1 => Id3f5vcfrontLightingVcfrontIndicatorRightRequest::TurnSignalActiveLow,
            0 => Id3f5vcfrontLightingVcfrontIndicatorRightRequest::TurnSignalOff,
            x => Id3f5vcfrontLightingVcfrontIndicatorRightRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_indicatorRightRequest
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_indicator_right_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_indicatorRightRequest
    #[inline(always)]
    pub fn set_vcfront_indicator_right_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lowBeamLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_low_beam_left_status(&self) -> Id3f5vcfrontLightingVcfrontLowBeamLeftStatus {
        match self.vcfront_low_beam_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontLowBeamLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontLowBeamLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontLowBeamLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontLowBeamLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontLowBeamLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_lowBeamLeftStatus
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_low_beam_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_lowBeamLeftStatus
    #[inline(always)]
    pub fn set_vcfront_low_beam_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..30].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lowBeamRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_low_beam_right_status(&self) -> Id3f5vcfrontLightingVcfrontLowBeamRightStatus {
        match self.vcfront_low_beam_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontLowBeamRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontLowBeamRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontLowBeamRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontLowBeamRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontLowBeamRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_lowBeamRightStatus
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_low_beam_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_lowBeamRightStatus
    #[inline(always)]
    pub fn set_vcfront_low_beam_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lowBeamsCalibrated
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_low_beams_calibrated(&self) -> bool {
        self.vcfront_low_beams_calibrated_raw()
    }
    
    /// Get raw value of VCFRONT_lowBeamsCalibrated
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_low_beams_calibrated_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_lowBeamsCalibrated
    #[inline(always)]
    pub fn set_vcfront_low_beams_calibrated(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lowBeamsOnForDRL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_low_beams_on_for_drl(&self) -> bool {
        self.vcfront_low_beams_on_for_drl_raw()
    }
    
    /// Get raw value of VCFRONT_lowBeamsOnForDRL
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_low_beams_on_for_drl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_lowBeamsOnForDRL
    #[inline(always)]
    pub fn set_vcfront_low_beams_on_for_drl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_parkLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_park_left_status(&self) -> Id3f5vcfrontLightingVcfrontParkLeftStatus {
        match self.vcfront_park_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontParkLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontParkLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontParkLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontParkLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontParkLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_parkLeftStatus
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_park_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_parkLeftStatus
    #[inline(always)]
    pub fn set_vcfront_park_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_parkRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_park_right_status(&self) -> Id3f5vcfrontLightingVcfrontParkRightStatus {
        match self.vcfront_park_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontParkRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontParkRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontParkRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontParkRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontParkRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_parkRightStatus
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_park_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_parkRightStatus
    #[inline(always)]
    pub fn set_vcfront_park_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..58].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_seeYouHomeLightingReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_see_you_home_lighting_req(&self) -> bool {
        self.vcfront_see_you_home_lighting_req_raw()
    }
    
    /// Get raw value of VCFRONT_seeYouHomeLightingReq
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_see_you_home_lighting_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_seeYouHomeLightingReq
    #[inline(always)]
    pub fn set_vcfront_see_you_home_lighting_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sideMarkersStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_side_markers_status(&self) -> Id3f5vcfrontLightingVcfrontSideMarkersStatus {
        match self.vcfront_side_markers_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontSideMarkersStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontSideMarkersStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontSideMarkersStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontSideMarkersStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontSideMarkersStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_sideMarkersStatus
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_side_markers_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_sideMarkersStatus
    #[inline(always)]
    pub fn set_vcfront_side_markers_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sideRepeaterLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_side_repeater_left_status(&self) -> Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus {
        match self.vcfront_side_repeater_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_sideRepeaterLeftStatus
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_side_repeater_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_sideRepeaterLeftStatus
    #[inline(always)]
    pub fn set_vcfront_side_repeater_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sideRepeaterRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_side_repeater_right_status(&self) -> Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus {
        match self.vcfront_side_repeater_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_sideRepeaterRightStatus
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_side_repeater_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_sideRepeaterRightStatus
    #[inline(always)]
    pub fn set_vcfront_side_repeater_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_simLatchingStalk
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sim_latching_stalk(&self) -> Id3f5vcfrontLightingVcfrontSimLatchingStalk {
        match self.vcfront_sim_latching_stalk_raw() {
            0 => Id3f5vcfrontLightingVcfrontSimLatchingStalk::SimulatedLatchingStalkIdle,
            1 => Id3f5vcfrontLightingVcfrontSimLatchingStalk::SimulatedLatchingStalkLeft,
            2 => Id3f5vcfrontLightingVcfrontSimLatchingStalk::SimulatedLatchingStalkRight,
            3 => Id3f5vcfrontLightingVcfrontSimLatchingStalk::SimulatedLatchingStalkSna,
            x => Id3f5vcfrontLightingVcfrontSimLatchingStalk::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_simLatchingStalk
    ///
    /// - Start bit: 59
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_sim_latching_stalk_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[59..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_simLatchingStalk
    #[inline(always)]
    pub fn set_vcfront_sim_latching_stalk(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[59..61].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_switchLightingBrightness
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_switch_lighting_brightness(&self) -> Id3f5vcfrontLightingVcfrontSwitchLightingBrightness {
        match self.vcfront_switch_lighting_brightness_raw() {
            255 => Id3f5vcfrontLightingVcfrontSwitchLightingBrightness::Sna,
            x => Id3f5vcfrontLightingVcfrontSwitchLightingBrightness::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_switchLightingBrightness
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_switch_lighting_brightness_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_switchLightingBrightness
    #[inline(always)]
    pub fn set_vcfront_switch_lighting_brightness(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_turnSignalLeftStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_turn_signal_left_status(&self) -> Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus {
        match self.vcfront_turn_signal_left_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_turnSignalLeftStatus
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_turn_signal_left_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_turnSignalLeftStatus
    #[inline(always)]
    pub fn set_vcfront_turn_signal_left_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..52].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_turnSignalRightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_turn_signal_right_status(&self) -> Id3f5vcfrontLightingVcfrontTurnSignalRightStatus {
        match self.vcfront_turn_signal_right_status_raw() {
            2 => Id3f5vcfrontLightingVcfrontTurnSignalRightStatus::LightFault,
            0 => Id3f5vcfrontLightingVcfrontTurnSignalRightStatus::LightOff,
            1 => Id3f5vcfrontLightingVcfrontTurnSignalRightStatus::LightOn,
            3 => Id3f5vcfrontLightingVcfrontTurnSignalRightStatus::LightSna,
            x => Id3f5vcfrontLightingVcfrontTurnSignalRightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_turnSignalRightStatus
    ///
    /// - Start bit: 52
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_turn_signal_right_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_turnSignalRightStatus
    #[inline(always)]
    pub fn set_vcfront_turn_signal_right_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1013 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..54].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3f5vcfrontLighting {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3f5vcfrontLighting
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_drl_left_status = u.int_in_range(0..=3)?;
        let vcfront_drl_right_status = u.int_in_range(0..=3)?;
        let vcfront_ambient_lighting_brightnes = 0_f32;
        let vcfront_approach_lighting_request = u.int_in_range(0..=1)? == 1;
        let vcfront_courtesy_lighting_request = u.int_in_range(0..=1)? == 1;
        let vcfront_fog_left_status = u.int_in_range(0..=3)?;
        let vcfront_fog_right_status = u.int_in_range(0..=3)?;
        let vcfront_hazard_light_request = u.int_in_range(0..=8)?;
        let vcfront_hazard_switch_backlight = u.int_in_range(0..=1)? == 1;
        let vcfront_high_beam_left_status = u.int_in_range(0..=3)?;
        let vcfront_high_beam_right_status = u.int_in_range(0..=3)?;
        let vcfront_high_beam_switch_active = u.int_in_range(0..=1)? == 1;
        let vcfront_indicator_left_request = u.int_in_range(0..=2)?;
        let vcfront_indicator_right_request = u.int_in_range(0..=2)?;
        let vcfront_low_beam_left_status = u.int_in_range(0..=3)?;
        let vcfront_low_beam_right_status = u.int_in_range(0..=3)?;
        let vcfront_low_beams_calibrated = u.int_in_range(0..=1)? == 1;
        let vcfront_low_beams_on_for_drl = u.int_in_range(0..=1)? == 1;
        let vcfront_park_left_status = u.int_in_range(0..=3)?;
        let vcfront_park_right_status = u.int_in_range(0..=3)?;
        let vcfront_see_you_home_lighting_req = u.int_in_range(0..=1)? == 1;
        let vcfront_side_markers_status = u.int_in_range(0..=3)?;
        let vcfront_side_repeater_left_status = u.int_in_range(0..=3)?;
        let vcfront_side_repeater_right_status = u.int_in_range(0..=3)?;
        let vcfront_sim_latching_stalk = u.int_in_range(0..=3)?;
        let vcfront_switch_lighting_brightness = 0_f32;
        let vcfront_turn_signal_left_status = u.int_in_range(0..=3)?;
        let vcfront_turn_signal_right_status = u.int_in_range(0..=3)?;
        Id3f5vcfrontLighting::new(vcfront_drl_left_status,vcfront_drl_right_status,vcfront_ambient_lighting_brightnes,vcfront_approach_lighting_request,vcfront_courtesy_lighting_request,vcfront_fog_left_status,vcfront_fog_right_status,vcfront_hazard_light_request,vcfront_hazard_switch_backlight,vcfront_high_beam_left_status,vcfront_high_beam_right_status,vcfront_high_beam_switch_active,vcfront_indicator_left_request,vcfront_indicator_right_request,vcfront_low_beam_left_status,vcfront_low_beam_right_status,vcfront_low_beams_calibrated,vcfront_low_beams_on_for_drl,vcfront_park_left_status,vcfront_park_right_status,vcfront_see_you_home_lighting_req,vcfront_side_markers_status,vcfront_side_repeater_left_status,vcfront_side_repeater_right_status,vcfront_sim_latching_stalk,vcfront_switch_lighting_brightness,vcfront_turn_signal_left_status,vcfront_turn_signal_right_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_DRLLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontDrlLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_DRLRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontDrlRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_ambientLightingBrightnes
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontAmbientLightingBrightnes {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_fogLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontFogLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_fogRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontFogRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_hazardLightRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontHazardLightRequest {
    HazardRequestButton,
    HazardRequestCarAlarm,
    HazardRequestCrash,
    HazardRequestDas,
    HazardRequestLock,
    HazardRequestMislock,
    HazardRequestNone,
    HazardRequestUds,
    HazardRequestUnlock,
    Other(u8),
}
/// Defined values for VCFRONT_highBeamLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontHighBeamLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_highBeamRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontHighBeamRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_indicatorLeftRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontIndicatorLeftRequest {
    TurnSignalActiveHigh,
    TurnSignalActiveLow,
    TurnSignalOff,
    Other(u8),
}
/// Defined values for VCFRONT_indicatorRightRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontIndicatorRightRequest {
    TurnSignalActiveHigh,
    TurnSignalActiveLow,
    TurnSignalOff,
    Other(u8),
}
/// Defined values for VCFRONT_lowBeamLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontLowBeamLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_lowBeamRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontLowBeamRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_parkLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontParkLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_parkRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontParkRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_sideMarkersStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontSideMarkersStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_sideRepeaterLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontSideRepeaterLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_sideRepeaterRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontSideRepeaterRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_simLatchingStalk
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontSimLatchingStalk {
    SimulatedLatchingStalkIdle,
    SimulatedLatchingStalkLeft,
    SimulatedLatchingStalkRight,
    SimulatedLatchingStalkSna,
    Other(u8),
}
/// Defined values for VCFRONT_switchLightingBrightness
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontSwitchLightingBrightness {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_turnSignalLeftStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontTurnSignalLeftStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCFRONT_turnSignalRightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f5vcfrontLightingVcfrontTurnSignalRightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}

/// ID3F8UI_driverAssistControl
///
/// - ID: 1016 (0x3f8)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3f8uiDriverAssistControl {
    raw: [u8; 8],
}

impl Id3f8uiDriverAssistControl {
    pub const MESSAGE_ID: u32 = 1016;
    
    /// Construct new ID3F8UI_driverAssistControl from values
    pub fn new(ui_acc_follow_distance_setting: u8, ui_adaptive_set_speed_enable: bool, ui_alc_off_highway_enable: bool, ui_auto_summon_enable: bool, ui_autopilot_control_request: bool, ui_coast_to_coast: bool, ui_curv_speed_adapt_disable: bool, ui_curvature_database_only: bool, ui_das_developer: bool, ui_drive_on_maps_enable: bool, ui_driving_side: u8, ui_enable_brake_light_pulse: bool, ui_enable_clip_telemetry: bool, ui_enable_road_segment_telemetry: bool, ui_enable_trip_telemetry: bool, ui_enable_vin_association: bool, ui_enable_vision_only_stops: bool, ui_exception_list_enable: bool, ui_follow_nav_route_enable: bool, ui_fuse_hpp_disable: bool, ui_fuse_lanes_disable: bool, ui_fuse_vehicles_disable: bool, ui_hands_on_requirement_disable: bool, ui_has_drive_on_nav: bool, ui_lss_elk_enabled: bool, ui_lss_ldw_enabled: bool, ui_lss_lka_enabled: bool, ui_road_check_disable: bool, ui_self_park_request: u8, ui_smart_summon_type: u8, ui_source3_d: u8, ui_summon_entry_type: u8, ui_summon_exit_type: u8, ui_summon_heartbeat: u8, ui_summon_reverse_dist: u8, ui_ulc_blind_spot_config: u8, ui_ulc_off_highway: bool, ui_ulc_speed_config: u8, ui_ulc_stalk_confirm: bool, ui_undertake_assist_enable: bool, ui_validation_loop: bool, ui_vision_speed_type: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_acc_follow_distance_setting(ui_acc_follow_distance_setting)?;
        res.set_ui_adaptive_set_speed_enable(ui_adaptive_set_speed_enable)?;
        res.set_ui_alc_off_highway_enable(ui_alc_off_highway_enable)?;
        res.set_ui_auto_summon_enable(ui_auto_summon_enable)?;
        res.set_ui_autopilot_control_request(ui_autopilot_control_request)?;
        res.set_ui_coast_to_coast(ui_coast_to_coast)?;
        res.set_ui_curv_speed_adapt_disable(ui_curv_speed_adapt_disable)?;
        res.set_ui_curvature_database_only(ui_curvature_database_only)?;
        res.set_ui_das_developer(ui_das_developer)?;
        res.set_ui_drive_on_maps_enable(ui_drive_on_maps_enable)?;
        res.set_ui_driving_side(ui_driving_side)?;
        res.set_ui_enable_brake_light_pulse(ui_enable_brake_light_pulse)?;
        res.set_ui_enable_clip_telemetry(ui_enable_clip_telemetry)?;
        res.set_ui_enable_road_segment_telemetry(ui_enable_road_segment_telemetry)?;
        res.set_ui_enable_trip_telemetry(ui_enable_trip_telemetry)?;
        res.set_ui_enable_vin_association(ui_enable_vin_association)?;
        res.set_ui_enable_vision_only_stops(ui_enable_vision_only_stops)?;
        res.set_ui_exception_list_enable(ui_exception_list_enable)?;
        res.set_ui_follow_nav_route_enable(ui_follow_nav_route_enable)?;
        res.set_ui_fuse_hpp_disable(ui_fuse_hpp_disable)?;
        res.set_ui_fuse_lanes_disable(ui_fuse_lanes_disable)?;
        res.set_ui_fuse_vehicles_disable(ui_fuse_vehicles_disable)?;
        res.set_ui_hands_on_requirement_disable(ui_hands_on_requirement_disable)?;
        res.set_ui_has_drive_on_nav(ui_has_drive_on_nav)?;
        res.set_ui_lss_elk_enabled(ui_lss_elk_enabled)?;
        res.set_ui_lss_ldw_enabled(ui_lss_ldw_enabled)?;
        res.set_ui_lss_lka_enabled(ui_lss_lka_enabled)?;
        res.set_ui_road_check_disable(ui_road_check_disable)?;
        res.set_ui_self_park_request(ui_self_park_request)?;
        res.set_ui_smart_summon_type(ui_smart_summon_type)?;
        res.set_ui_source3_d(ui_source3_d)?;
        res.set_ui_summon_entry_type(ui_summon_entry_type)?;
        res.set_ui_summon_exit_type(ui_summon_exit_type)?;
        res.set_ui_summon_heartbeat(ui_summon_heartbeat)?;
        res.set_ui_summon_reverse_dist(ui_summon_reverse_dist)?;
        res.set_ui_ulc_blind_spot_config(ui_ulc_blind_spot_config)?;
        res.set_ui_ulc_off_highway(ui_ulc_off_highway)?;
        res.set_ui_ulc_speed_config(ui_ulc_speed_config)?;
        res.set_ui_ulc_stalk_confirm(ui_ulc_stalk_confirm)?;
        res.set_ui_undertake_assist_enable(ui_undertake_assist_enable)?;
        res.set_ui_validation_loop(ui_validation_loop)?;
        res.set_ui_vision_speed_type(ui_vision_speed_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_accFollowDistanceSetting
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_acc_follow_distance_setting(&self) -> Id3f8uiDriverAssistControlUiAccFollowDistanceSetting {
        match self.ui_acc_follow_distance_setting_raw() {
            0 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting1,
            1 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting2,
            2 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting3,
            3 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting4,
            4 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting5,
            5 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting6,
            6 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSetting7,
            7 => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::DistanceSettingSna,
            x => Id3f8uiDriverAssistControlUiAccFollowDistanceSetting::Other(x),
        }
    }
    
    /// Get raw value of UI_accFollowDistanceSetting
    ///
    /// - Start bit: 45
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_acc_follow_distance_setting_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[45..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_accFollowDistanceSetting
    #[inline(always)]
    pub fn set_ui_acc_follow_distance_setting(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[45..48].store_le(value);
        Ok(())
    }
    
    /// UI_adaptiveSetSpeedEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_adaptive_set_speed_enable(&self) -> bool {
        self.ui_adaptive_set_speed_enable_raw()
    }
    
    /// Get raw value of UI_adaptiveSetSpeedEnable
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_adaptive_set_speed_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_adaptiveSetSpeedEnable
    #[inline(always)]
    pub fn set_ui_adaptive_set_speed_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// UI_alcOffHighwayEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_alc_off_highway_enable(&self) -> bool {
        self.ui_alc_off_highway_enable_raw()
    }
    
    /// Get raw value of UI_alcOffHighwayEnable
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_alc_off_highway_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_alcOffHighwayEnable
    #[inline(always)]
    pub fn set_ui_alc_off_highway_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[56..57].store_le(value);
        Ok(())
    }
    
    /// UI_autoSummonEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_auto_summon_enable(&self) -> bool {
        self.ui_auto_summon_enable_raw()
    }
    
    /// Get raw value of UI_autoSummonEnable
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_auto_summon_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_autoSummonEnable
    #[inline(always)]
    pub fn set_ui_auto_summon_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// UI_autopilotControlRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_autopilot_control_request(&self) -> Id3f8uiDriverAssistControlUiAutopilotControlRequest {
        match self.ui_autopilot_control_request_raw() {
            false => Id3f8uiDriverAssistControlUiAutopilotControlRequest::LegacyLatCtrl,
            true => Id3f8uiDriverAssistControlUiAutopilotControlRequest::NextGenCtrl,
            x => Id3f8uiDriverAssistControlUiAutopilotControlRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_autopilotControlRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_autopilot_control_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_autopilotControlRequest
    #[inline(always)]
    pub fn set_ui_autopilot_control_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_coastToCoast
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_coast_to_coast(&self) -> bool {
        self.ui_coast_to_coast_raw()
    }
    
    /// Get raw value of UI_coastToCoast
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_coast_to_coast_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_coastToCoast
    #[inline(always)]
    pub fn set_ui_coast_to_coast(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// UI_curvSpeedAdaptDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_curv_speed_adapt_disable(&self) -> Id3f8uiDriverAssistControlUiCurvSpeedAdaptDisable {
        match self.ui_curv_speed_adapt_disable_raw() {
            true => Id3f8uiDriverAssistControlUiCurvSpeedAdaptDisable::CsaOff,
            false => Id3f8uiDriverAssistControlUiCurvSpeedAdaptDisable::CsaOn,
            x => Id3f8uiDriverAssistControlUiCurvSpeedAdaptDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_curvSpeedAdaptDisable
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_curv_speed_adapt_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_curvSpeedAdaptDisable
    #[inline(always)]
    pub fn set_ui_curv_speed_adapt_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_curvatureDatabaseOnly
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_curvature_database_only(&self) -> Id3f8uiDriverAssistControlUiCurvatureDatabaseOnly {
        match self.ui_curvature_database_only_raw() {
            false => Id3f8uiDriverAssistControlUiCurvatureDatabaseOnly::Off,
            true => Id3f8uiDriverAssistControlUiCurvatureDatabaseOnly::On,
            x => Id3f8uiDriverAssistControlUiCurvatureDatabaseOnly::Other(x),
        }
    }
    
    /// Get raw value of UI_curvatureDatabaseOnly
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_curvature_database_only_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_curvatureDatabaseOnly
    #[inline(always)]
    pub fn set_ui_curvature_database_only(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[22..23].store_le(value);
        Ok(())
    }
    
    /// UI_dasDeveloper
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_das_developer(&self) -> bool {
        self.ui_das_developer_raw()
    }
    
    /// Get raw value of UI_dasDeveloper
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_das_developer_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_dasDeveloper
    #[inline(always)]
    pub fn set_ui_das_developer(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// UI_driveOnMapsEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_drive_on_maps_enable(&self) -> Id3f8uiDriverAssistControlUiDriveOnMapsEnable {
        match self.ui_drive_on_maps_enable_raw() {
            false => Id3f8uiDriverAssistControlUiDriveOnMapsEnable::DomOff,
            true => Id3f8uiDriverAssistControlUiDriveOnMapsEnable::DomOn,
            x => Id3f8uiDriverAssistControlUiDriveOnMapsEnable::Other(x),
        }
    }
    
    /// Get raw value of UI_driveOnMapsEnable
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_drive_on_maps_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_driveOnMapsEnable
    #[inline(always)]
    pub fn set_ui_drive_on_maps_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// UI_drivingSide
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_driving_side(&self) -> Id3f8uiDriverAssistControlUiDrivingSide {
        match self.ui_driving_side_raw() {
            0 => Id3f8uiDriverAssistControlUiDrivingSide::DrivingSideLeft,
            1 => Id3f8uiDriverAssistControlUiDrivingSide::DrivingSideRight,
            2 => Id3f8uiDriverAssistControlUiDrivingSide::DrivingSideUnknown,
            x => Id3f8uiDriverAssistControlUiDrivingSide::Other(x),
        }
    }
    
    /// Get raw value of UI_drivingSide
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_driving_side_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_drivingSide
    #[inline(always)]
    pub fn set_ui_driving_side(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// UI_enableBrakeLightPulse
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_brake_light_pulse(&self) -> bool {
        self.ui_enable_brake_light_pulse_raw()
    }
    
    /// Get raw value of UI_enableBrakeLightPulse
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_brake_light_pulse_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableBrakeLightPulse
    #[inline(always)]
    pub fn set_ui_enable_brake_light_pulse(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// UI_enableClipTelemetry
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_clip_telemetry(&self) -> bool {
        self.ui_enable_clip_telemetry_raw()
    }
    
    /// Get raw value of UI_enableClipTelemetry
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_clip_telemetry_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableClipTelemetry
    #[inline(always)]
    pub fn set_ui_enable_clip_telemetry(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// UI_enableRoadSegmentTelemetry
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_road_segment_telemetry(&self) -> bool {
        self.ui_enable_road_segment_telemetry_raw()
    }
    
    /// Get raw value of UI_enableRoadSegmentTelemetry
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_road_segment_telemetry_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableRoadSegmentTelemetry
    #[inline(always)]
    pub fn set_ui_enable_road_segment_telemetry(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[44..45].store_le(value);
        Ok(())
    }
    
    /// UI_enableTripTelemetry
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_trip_telemetry(&self) -> bool {
        self.ui_enable_trip_telemetry_raw()
    }
    
    /// Get raw value of UI_enableTripTelemetry
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_trip_telemetry_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableTripTelemetry
    #[inline(always)]
    pub fn set_ui_enable_trip_telemetry(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// UI_enableVinAssociation
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_vin_association(&self) -> bool {
        self.ui_enable_vin_association_raw()
    }
    
    /// Get raw value of UI_enableVinAssociation
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_vin_association_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableVinAssociation
    #[inline(always)]
    pub fn set_ui_enable_vin_association(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// UI_enableVisionOnlyStops
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_vision_only_stops(&self) -> bool {
        self.ui_enable_vision_only_stops_raw()
    }
    
    /// Get raw value of UI_enableVisionOnlyStops
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_vision_only_stops_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableVisionOnlyStops
    #[inline(always)]
    pub fn set_ui_enable_vision_only_stops(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// UI_exceptionListEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_exception_list_enable(&self) -> Id3f8uiDriverAssistControlUiExceptionListEnable {
        match self.ui_exception_list_enable_raw() {
            false => Id3f8uiDriverAssistControlUiExceptionListEnable::ExceptionListOff,
            true => Id3f8uiDriverAssistControlUiExceptionListEnable::ExceptionListOn,
            x => Id3f8uiDriverAssistControlUiExceptionListEnable::Other(x),
        }
    }
    
    /// Get raw value of UI_exceptionListEnable
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_exception_list_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_exceptionListEnable
    #[inline(always)]
    pub fn set_ui_exception_list_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// UI_followNavRouteEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_follow_nav_route_enable(&self) -> Id3f8uiDriverAssistControlUiFollowNavRouteEnable {
        match self.ui_follow_nav_route_enable_raw() {
            false => Id3f8uiDriverAssistControlUiFollowNavRouteEnable::NavRouteOff,
            true => Id3f8uiDriverAssistControlUiFollowNavRouteEnable::NavRouteOn,
            x => Id3f8uiDriverAssistControlUiFollowNavRouteEnable::Other(x),
        }
    }
    
    /// Get raw value of UI_followNavRouteEnable
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_follow_nav_route_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_followNavRouteEnable
    #[inline(always)]
    pub fn set_ui_follow_nav_route_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// UI_fuseHPPDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_fuse_hpp_disable(&self) -> Id3f8uiDriverAssistControlUiFuseHppDisable {
        match self.ui_fuse_hpp_disable_raw() {
            true => Id3f8uiDriverAssistControlUiFuseHppDisable::FuseHppOff,
            false => Id3f8uiDriverAssistControlUiFuseHppDisable::FuseHppOn,
            x => Id3f8uiDriverAssistControlUiFuseHppDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_fuseHPPDisable
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_fuse_hpp_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_fuseHPPDisable
    #[inline(always)]
    pub fn set_ui_fuse_hpp_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// UI_fuseLanesDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_fuse_lanes_disable(&self) -> Id3f8uiDriverAssistControlUiFuseLanesDisable {
        match self.ui_fuse_lanes_disable_raw() {
            true => Id3f8uiDriverAssistControlUiFuseLanesDisable::FuseLanesOff,
            false => Id3f8uiDriverAssistControlUiFuseLanesDisable::FuseLanesOn,
            x => Id3f8uiDriverAssistControlUiFuseLanesDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_fuseLanesDisable
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_fuse_lanes_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_fuseLanesDisable
    #[inline(always)]
    pub fn set_ui_fuse_lanes_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// UI_fuseVehiclesDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_fuse_vehicles_disable(&self) -> Id3f8uiDriverAssistControlUiFuseVehiclesDisable {
        match self.ui_fuse_vehicles_disable_raw() {
            true => Id3f8uiDriverAssistControlUiFuseVehiclesDisable::FuseVehOff,
            false => Id3f8uiDriverAssistControlUiFuseVehiclesDisable::FuseVehOn,
            x => Id3f8uiDriverAssistControlUiFuseVehiclesDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_fuseVehiclesDisable
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_fuse_vehicles_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_fuseVehiclesDisable
    #[inline(always)]
    pub fn set_ui_fuse_vehicles_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// UI_handsOnRequirementDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hands_on_requirement_disable(&self) -> Id3f8uiDriverAssistControlUiHandsOnRequirementDisable {
        match self.ui_hands_on_requirement_disable_raw() {
            true => Id3f8uiDriverAssistControlUiHandsOnRequirementDisable::HandsOnReqOff,
            false => Id3f8uiDriverAssistControlUiHandsOnRequirementDisable::HandsOnReqOn,
            x => Id3f8uiDriverAssistControlUiHandsOnRequirementDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_handsOnRequirementDisable
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hands_on_requirement_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_handsOnRequirementDisable
    #[inline(always)]
    pub fn set_ui_hands_on_requirement_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// UI_hasDriveOnNav
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_has_drive_on_nav(&self) -> bool {
        self.ui_has_drive_on_nav_raw()
    }
    
    /// Get raw value of UI_hasDriveOnNav
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_has_drive_on_nav_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_hasDriveOnNav
    #[inline(always)]
    pub fn set_ui_has_drive_on_nav(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// UI_lssElkEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_lss_elk_enabled(&self) -> Id3f8uiDriverAssistControlUiLssElkEnabled {
        match self.ui_lss_elk_enabled_raw() {
            false => Id3f8uiDriverAssistControlUiLssElkEnabled::ElkOff,
            true => Id3f8uiDriverAssistControlUiLssElkEnabled::ElkOn,
            x => Id3f8uiDriverAssistControlUiLssElkEnabled::Other(x),
        }
    }
    
    /// Get raw value of UI_lssElkEnabled
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_lss_elk_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_lssElkEnabled
    #[inline(always)]
    pub fn set_ui_lss_elk_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// UI_lssLdwEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_lss_ldw_enabled(&self) -> Id3f8uiDriverAssistControlUiLssLdwEnabled {
        match self.ui_lss_ldw_enabled_raw() {
            false => Id3f8uiDriverAssistControlUiLssLdwEnabled::LdwOff,
            true => Id3f8uiDriverAssistControlUiLssLdwEnabled::LdwOn,
            x => Id3f8uiDriverAssistControlUiLssLdwEnabled::Other(x),
        }
    }
    
    /// Get raw value of UI_lssLdwEnabled
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_lss_ldw_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_lssLdwEnabled
    #[inline(always)]
    pub fn set_ui_lss_ldw_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// UI_lssLkaEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_lss_lka_enabled(&self) -> Id3f8uiDriverAssistControlUiLssLkaEnabled {
        match self.ui_lss_lka_enabled_raw() {
            false => Id3f8uiDriverAssistControlUiLssLkaEnabled::LkaOff,
            true => Id3f8uiDriverAssistControlUiLssLkaEnabled::LkaOn,
            x => Id3f8uiDriverAssistControlUiLssLkaEnabled::Other(x),
        }
    }
    
    /// Get raw value of UI_lssLkaEnabled
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_lss_lka_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_lssLkaEnabled
    #[inline(always)]
    pub fn set_ui_lss_lka_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// UI_roadCheckDisable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_road_check_disable(&self) -> Id3f8uiDriverAssistControlUiRoadCheckDisable {
        match self.ui_road_check_disable_raw() {
            true => Id3f8uiDriverAssistControlUiRoadCheckDisable::RcOff,
            false => Id3f8uiDriverAssistControlUiRoadCheckDisable::RcOn,
            x => Id3f8uiDriverAssistControlUiRoadCheckDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_roadCheckDisable
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_road_check_disable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_roadCheckDisable
    #[inline(always)]
    pub fn set_ui_road_check_disable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// UI_selfParkRequest
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_self_park_request(&self) -> Id3f8uiDriverAssistControlUiSelfParkRequest {
        match self.ui_self_park_request_raw() {
            3 => Id3f8uiDriverAssistControlUiSelfParkRequest::Abort,
            9 => Id3f8uiDriverAssistControlUiSelfParkRequest::AutoSummonCancel,
            7 => Id3f8uiDriverAssistControlUiSelfParkRequest::AutoSummonForward,
            10 => Id3f8uiDriverAssistControlUiSelfParkRequest::AutoSummonPrimed,
            8 => Id3f8uiDriverAssistControlUiSelfParkRequest::AutoSummonReverse,
            0 => Id3f8uiDriverAssistControlUiSelfParkRequest::None,
            5 => Id3f8uiDriverAssistControlUiSelfParkRequest::Pause,
            4 => Id3f8uiDriverAssistControlUiSelfParkRequest::Prime,
            6 => Id3f8uiDriverAssistControlUiSelfParkRequest::Resume,
            1 => Id3f8uiDriverAssistControlUiSelfParkRequest::SelfParkForward,
            2 => Id3f8uiDriverAssistControlUiSelfParkRequest::SelfParkReverse,
            11 => Id3f8uiDriverAssistControlUiSelfParkRequest::SmartSummon,
            12 => Id3f8uiDriverAssistControlUiSelfParkRequest::SmartSummonNoOp,
            15 => Id3f8uiDriverAssistControlUiSelfParkRequest::Sna,
            x => Id3f8uiDriverAssistControlUiSelfParkRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_selfParkRequest
    ///
    /// - Start bit: 28
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_self_park_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_selfParkRequest
    #[inline(always)]
    pub fn set_ui_self_park_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..32].store_le(value);
        Ok(())
    }
    
    /// UI_smartSummonType
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_smart_summon_type(&self) -> Id3f8uiDriverAssistControlUiSmartSummonType {
        match self.ui_smart_summon_type_raw() {
            1 => Id3f8uiDriverAssistControlUiSmartSummonType::FindMe,
            0 => Id3f8uiDriverAssistControlUiSmartSummonType::PinDrop,
            2 => Id3f8uiDriverAssistControlUiSmartSummonType::SmartAutopark,
            x => Id3f8uiDriverAssistControlUiSmartSummonType::Other(x),
        }
    }
    
    /// Get raw value of UI_smartSummonType
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_smart_summon_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_smartSummonType
    #[inline(always)]
    pub fn set_ui_smart_summon_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..60].store_le(value);
        Ok(())
    }
    
    /// UI_source3D
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_source3_d(&self) -> Id3f8uiDriverAssistControlUiSource3D {
        match self.ui_source3_d_raw() {
            2 => Id3f8uiDriverAssistControlUiSource3D::XyzPrediction,
            0 => Id3f8uiDriverAssistControlUiSource3D::ZFromMap,
            1 => Id3f8uiDriverAssistControlUiSource3D::ZFromPathPrediction,
            x => Id3f8uiDriverAssistControlUiSource3D::Other(x),
        }
    }
    
    /// Get raw value of UI_source3D
    ///
    /// - Start bit: 61
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_source3_d_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[61..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_source3D
    #[inline(always)]
    pub fn set_ui_source3_d(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[61..63].store_le(value);
        Ok(())
    }
    
    /// UI_summonEntryType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_summon_entry_type(&self) -> Id3f8uiDriverAssistControlUiSummonEntryType {
        match self.ui_summon_entry_type_raw() {
            3 => Id3f8uiDriverAssistControlUiSummonEntryType::Sna,
            0 => Id3f8uiDriverAssistControlUiSummonEntryType::Straight,
            2 => Id3f8uiDriverAssistControlUiSummonEntryType::TurnLeft,
            1 => Id3f8uiDriverAssistControlUiSummonEntryType::TurnRight,
            x => Id3f8uiDriverAssistControlUiSummonEntryType::Other(x),
        }
    }
    
    /// Get raw value of UI_summonEntryType
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_summon_entry_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_summonEntryType
    #[inline(always)]
    pub fn set_ui_summon_entry_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..28].store_le(value);
        Ok(())
    }
    
    /// UI_summonExitType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_summon_exit_type(&self) -> Id3f8uiDriverAssistControlUiSummonExitType {
        match self.ui_summon_exit_type_raw() {
            3 => Id3f8uiDriverAssistControlUiSummonExitType::Sna,
            0 => Id3f8uiDriverAssistControlUiSummonExitType::Straight,
            2 => Id3f8uiDriverAssistControlUiSummonExitType::TurnLeft,
            1 => Id3f8uiDriverAssistControlUiSummonExitType::TurnRight,
            x => Id3f8uiDriverAssistControlUiSummonExitType::Other(x),
        }
    }
    
    /// Get raw value of UI_summonExitType
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_summon_exit_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_summonExitType
    #[inline(always)]
    pub fn set_ui_summon_exit_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// UI_summonHeartbeat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_summon_heartbeat(&self) -> u8 {
        self.ui_summon_heartbeat_raw()
    }
    
    /// Get raw value of UI_summonHeartbeat
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_summon_heartbeat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_summonHeartbeat
    #[inline(always)]
    pub fn set_ui_summon_heartbeat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// UI_summonReverseDist
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_summon_reverse_dist(&self) -> Id3f8uiDriverAssistControlUiSummonReverseDist {
        match self.ui_summon_reverse_dist_raw() {
            63 => Id3f8uiDriverAssistControlUiSummonReverseDist::Sna,
            x => Id3f8uiDriverAssistControlUiSummonReverseDist::Other(x),
        }
    }
    
    /// Get raw value of UI_summonReverseDist
    ///
    /// - Start bit: 32
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_summon_reverse_dist_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_summonReverseDist
    #[inline(always)]
    pub fn set_ui_summon_reverse_dist(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..38].store_le(value);
        Ok(())
    }
    
    /// UI_ulcBlindSpotConfig
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ulc_blind_spot_config(&self) -> Id3f8uiDriverAssistControlUiUlcBlindSpotConfig {
        match self.ui_ulc_blind_spot_config_raw() {
            1 => Id3f8uiDriverAssistControlUiUlcBlindSpotConfig::Aggressive,
            2 => Id3f8uiDriverAssistControlUiUlcBlindSpotConfig::MadMax,
            0 => Id3f8uiDriverAssistControlUiUlcBlindSpotConfig::Standard,
            x => Id3f8uiDriverAssistControlUiUlcBlindSpotConfig::Other(x),
        }
    }
    
    /// Get raw value of UI_ulcBlindSpotConfig
    ///
    /// - Start bit: 52
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ulc_blind_spot_config_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_ulcBlindSpotConfig
    #[inline(always)]
    pub fn set_ui_ulc_blind_spot_config(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..54].store_le(value);
        Ok(())
    }
    
    /// UI_ulcOffHighway
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ulc_off_highway(&self) -> bool {
        self.ui_ulc_off_highway_raw()
    }
    
    /// Get raw value of UI_ulcOffHighway
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ulc_off_highway_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_ulcOffHighway
    #[inline(always)]
    pub fn set_ui_ulc_off_highway(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// UI_ulcSpeedConfig
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ulc_speed_config(&self) -> Id3f8uiDriverAssistControlUiUlcSpeedConfig {
        match self.ui_ulc_speed_config_raw() {
            2 => Id3f8uiDriverAssistControlUiUlcSpeedConfig::SpeedBasedUlcAverage,
            0 => Id3f8uiDriverAssistControlUiUlcSpeedConfig::SpeedBasedUlcDisabled,
            3 => Id3f8uiDriverAssistControlUiUlcSpeedConfig::SpeedBasedUlcMadMax,
            1 => Id3f8uiDriverAssistControlUiUlcSpeedConfig::SpeedBasedUlcMild,
            x => Id3f8uiDriverAssistControlUiUlcSpeedConfig::Other(x),
        }
    }
    
    /// Get raw value of UI_ulcSpeedConfig
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ulc_speed_config_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_ulcSpeedConfig
    #[inline(always)]
    pub fn set_ui_ulc_speed_config(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..52].store_le(value);
        Ok(())
    }
    
    /// UI_ulcStalkConfirm
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ulc_stalk_confirm(&self) -> bool {
        self.ui_ulc_stalk_confirm_raw()
    }
    
    /// Get raw value of UI_ulcStalkConfirm
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ulc_stalk_confirm_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_ulcStalkConfirm
    #[inline(always)]
    pub fn set_ui_ulc_stalk_confirm(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_undertakeAssistEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_undertake_assist_enable(&self) -> bool {
        self.ui_undertake_assist_enable_raw()
    }
    
    /// Get raw value of UI_undertakeAssistEnable
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_undertake_assist_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_undertakeAssistEnable
    #[inline(always)]
    pub fn set_ui_undertake_assist_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// UI_validationLoop
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_validation_loop(&self) -> bool {
        self.ui_validation_loop_raw()
    }
    
    /// Get raw value of UI_validationLoop
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_validation_loop_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_validationLoop
    #[inline(always)]
    pub fn set_ui_validation_loop(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[57..58].store_le(value);
        Ok(())
    }
    
    /// UI_visionSpeedType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_vision_speed_type(&self) -> Id3f8uiDriverAssistControlUiVisionSpeedType {
        match self.ui_vision_speed_type_raw() {
            0 => Id3f8uiDriverAssistControlUiVisionSpeedType::VisionSpeedDisabled,
            1 => Id3f8uiDriverAssistControlUiVisionSpeedType::VisionSpeedOneSecond,
            3 => Id3f8uiDriverAssistControlUiVisionSpeedType::VisionSpeedOptimized,
            2 => Id3f8uiDriverAssistControlUiVisionSpeedType::VisionSpeedTwoSecond,
            x => Id3f8uiDriverAssistControlUiVisionSpeedType::Other(x),
        }
    }
    
    /// Get raw value of UI_visionSpeedType
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_vision_speed_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_visionSpeedType
    #[inline(always)]
    pub fn set_ui_vision_speed_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1016 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..22].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3f8uiDriverAssistControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3f8uiDriverAssistControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_acc_follow_distance_setting = u.int_in_range(0..=7)?;
        let ui_adaptive_set_speed_enable = u.int_in_range(0..=1)? == 1;
        let ui_alc_off_highway_enable = u.int_in_range(0..=1)? == 1;
        let ui_auto_summon_enable = u.int_in_range(0..=1)? == 1;
        let ui_autopilot_control_request = u.int_in_range(0..=1)? == 1;
        let ui_coast_to_coast = u.int_in_range(0..=1)? == 1;
        let ui_curv_speed_adapt_disable = u.int_in_range(0..=1)? == 1;
        let ui_curvature_database_only = u.int_in_range(0..=1)? == 1;
        let ui_das_developer = u.int_in_range(0..=1)? == 1;
        let ui_drive_on_maps_enable = u.int_in_range(0..=1)? == 1;
        let ui_driving_side = u.int_in_range(0..=2)?;
        let ui_enable_brake_light_pulse = u.int_in_range(0..=1)? == 1;
        let ui_enable_clip_telemetry = u.int_in_range(0..=1)? == 1;
        let ui_enable_road_segment_telemetry = u.int_in_range(0..=1)? == 1;
        let ui_enable_trip_telemetry = u.int_in_range(0..=1)? == 1;
        let ui_enable_vin_association = u.int_in_range(0..=1)? == 1;
        let ui_enable_vision_only_stops = u.int_in_range(0..=1)? == 1;
        let ui_exception_list_enable = u.int_in_range(0..=1)? == 1;
        let ui_follow_nav_route_enable = u.int_in_range(0..=1)? == 1;
        let ui_fuse_hpp_disable = u.int_in_range(0..=1)? == 1;
        let ui_fuse_lanes_disable = u.int_in_range(0..=1)? == 1;
        let ui_fuse_vehicles_disable = u.int_in_range(0..=1)? == 1;
        let ui_hands_on_requirement_disable = u.int_in_range(0..=1)? == 1;
        let ui_has_drive_on_nav = u.int_in_range(0..=1)? == 1;
        let ui_lss_elk_enabled = u.int_in_range(0..=1)? == 1;
        let ui_lss_ldw_enabled = u.int_in_range(0..=1)? == 1;
        let ui_lss_lka_enabled = u.int_in_range(0..=1)? == 1;
        let ui_road_check_disable = u.int_in_range(0..=1)? == 1;
        let ui_self_park_request = u.int_in_range(0..=15)?;
        let ui_smart_summon_type = u.int_in_range(0..=2)?;
        let ui_source3_d = u.int_in_range(0..=2)?;
        let ui_summon_entry_type = u.int_in_range(0..=3)?;
        let ui_summon_exit_type = u.int_in_range(0..=3)?;
        let ui_summon_heartbeat = u.int_in_range(0..=3)?;
        let ui_summon_reverse_dist = u.int_in_range(0..=63)?;
        let ui_ulc_blind_spot_config = u.int_in_range(0..=2)?;
        let ui_ulc_off_highway = u.int_in_range(0..=1)? == 1;
        let ui_ulc_speed_config = u.int_in_range(0..=3)?;
        let ui_ulc_stalk_confirm = u.int_in_range(0..=1)? == 1;
        let ui_undertake_assist_enable = u.int_in_range(0..=1)? == 1;
        let ui_validation_loop = u.int_in_range(0..=1)? == 1;
        let ui_vision_speed_type = u.int_in_range(0..=3)?;
        Id3f8uiDriverAssistControl::new(ui_acc_follow_distance_setting,ui_adaptive_set_speed_enable,ui_alc_off_highway_enable,ui_auto_summon_enable,ui_autopilot_control_request,ui_coast_to_coast,ui_curv_speed_adapt_disable,ui_curvature_database_only,ui_das_developer,ui_drive_on_maps_enable,ui_driving_side,ui_enable_brake_light_pulse,ui_enable_clip_telemetry,ui_enable_road_segment_telemetry,ui_enable_trip_telemetry,ui_enable_vin_association,ui_enable_vision_only_stops,ui_exception_list_enable,ui_follow_nav_route_enable,ui_fuse_hpp_disable,ui_fuse_lanes_disable,ui_fuse_vehicles_disable,ui_hands_on_requirement_disable,ui_has_drive_on_nav,ui_lss_elk_enabled,ui_lss_ldw_enabled,ui_lss_lka_enabled,ui_road_check_disable,ui_self_park_request,ui_smart_summon_type,ui_source3_d,ui_summon_entry_type,ui_summon_exit_type,ui_summon_heartbeat,ui_summon_reverse_dist,ui_ulc_blind_spot_config,ui_ulc_off_highway,ui_ulc_speed_config,ui_ulc_stalk_confirm,ui_undertake_assist_enable,ui_validation_loop,ui_vision_speed_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_accFollowDistanceSetting
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiAccFollowDistanceSetting {
    DistanceSetting1,
    DistanceSetting2,
    DistanceSetting3,
    DistanceSetting4,
    DistanceSetting5,
    DistanceSetting6,
    DistanceSetting7,
    DistanceSettingSna,
    Other(u8),
}
/// Defined values for UI_autopilotControlRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiAutopilotControlRequest {
    LegacyLatCtrl,
    NextGenCtrl,
    Other(bool),
}
/// Defined values for UI_curvSpeedAdaptDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiCurvSpeedAdaptDisable {
    CsaOff,
    CsaOn,
    Other(bool),
}
/// Defined values for UI_curvatureDatabaseOnly
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiCurvatureDatabaseOnly {
    Off,
    On,
    Other(bool),
}
/// Defined values for UI_driveOnMapsEnable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiDriveOnMapsEnable {
    DomOff,
    DomOn,
    Other(bool),
}
/// Defined values for UI_drivingSide
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiDrivingSide {
    DrivingSideLeft,
    DrivingSideRight,
    DrivingSideUnknown,
    Other(u8),
}
/// Defined values for UI_exceptionListEnable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiExceptionListEnable {
    ExceptionListOff,
    ExceptionListOn,
    Other(bool),
}
/// Defined values for UI_followNavRouteEnable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiFollowNavRouteEnable {
    NavRouteOff,
    NavRouteOn,
    Other(bool),
}
/// Defined values for UI_fuseHPPDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiFuseHppDisable {
    FuseHppOff,
    FuseHppOn,
    Other(bool),
}
/// Defined values for UI_fuseLanesDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiFuseLanesDisable {
    FuseLanesOff,
    FuseLanesOn,
    Other(bool),
}
/// Defined values for UI_fuseVehiclesDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiFuseVehiclesDisable {
    FuseVehOff,
    FuseVehOn,
    Other(bool),
}
/// Defined values for UI_handsOnRequirementDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiHandsOnRequirementDisable {
    HandsOnReqOff,
    HandsOnReqOn,
    Other(bool),
}
/// Defined values for UI_lssElkEnabled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiLssElkEnabled {
    ElkOff,
    ElkOn,
    Other(bool),
}
/// Defined values for UI_lssLdwEnabled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiLssLdwEnabled {
    LdwOff,
    LdwOn,
    Other(bool),
}
/// Defined values for UI_lssLkaEnabled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiLssLkaEnabled {
    LkaOff,
    LkaOn,
    Other(bool),
}
/// Defined values for UI_roadCheckDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiRoadCheckDisable {
    RcOff,
    RcOn,
    Other(bool),
}
/// Defined values for UI_selfParkRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiSelfParkRequest {
    Abort,
    AutoSummonCancel,
    AutoSummonForward,
    AutoSummonPrimed,
    AutoSummonReverse,
    None,
    Pause,
    Prime,
    Resume,
    SelfParkForward,
    SelfParkReverse,
    SmartSummon,
    SmartSummonNoOp,
    Sna,
    Other(u8),
}
/// Defined values for UI_smartSummonType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiSmartSummonType {
    FindMe,
    PinDrop,
    SmartAutopark,
    Other(u8),
}
/// Defined values for UI_source3D
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiSource3D {
    XyzPrediction,
    ZFromMap,
    ZFromPathPrediction,
    Other(u8),
}
/// Defined values for UI_summonEntryType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiSummonEntryType {
    Sna,
    Straight,
    TurnLeft,
    TurnRight,
    Other(u8),
}
/// Defined values for UI_summonExitType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiSummonExitType {
    Sna,
    Straight,
    TurnLeft,
    TurnRight,
    Other(u8),
}
/// Defined values for UI_summonReverseDist
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiSummonReverseDist {
    Sna,
    Other(u8),
}
/// Defined values for UI_ulcBlindSpotConfig
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiUlcBlindSpotConfig {
    Aggressive,
    MadMax,
    Standard,
    Other(u8),
}
/// Defined values for UI_ulcSpeedConfig
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiUlcSpeedConfig {
    SpeedBasedUlcAverage,
    SpeedBasedUlcDisabled,
    SpeedBasedUlcMadMax,
    SpeedBasedUlcMild,
    Other(u8),
}
/// Defined values for UI_visionSpeedType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3f8uiDriverAssistControlUiVisionSpeedType {
    VisionSpeedDisabled,
    VisionSpeedOneSecond,
    VisionSpeedOptimized,
    VisionSpeedTwoSecond,
    Other(u8),
}

/// ID3FDUI_autopilotControl
///
/// - ID: 1021 (0x3fd)
/// - Size: 8 bytes
/// - Transmitter: ChassisBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3fduiAutopilotControl {
    raw: [u8; 8],
}

impl Id3fduiAutopilotControl {
    pub const MESSAGE_ID: u32 = 1021;
    
    /// Construct new ID3FDUI_autopilotControl from values
    pub fn new(ui_autopilot_control_index: u8, ui_apmv3_branch: u8, ui_apply_ece_r79: bool, ui_blindspot_distance: u8, ui_blindspot_min_speed: u8, ui_blindspot_ttc: u8, ui_disable_backup: bool, ui_disable_fisheye: bool, ui_disable_left_pillar: bool, ui_disable_left_repeater: bool, ui_disable_main: bool, ui_disable_narrow: bool, ui_disable_radar: bool, ui_disable_right_pillar: bool, ui_disable_right_repeater: bool, ui_don_alc_prog_gore_abort_thres: u8, ui_don_disable_auto_wiper_duration: u8, ui_don_disable_cutin: bool, ui_don_disable_on_auto_wiper_speed: u8, ui_don_min_gore_width_for_abort_map: u8, ui_don_min_gore_width_for_abort_not_map: u8, ui_don_stop_end_of_ramp_buffer: u8, ui_driver_monitor_confirmation: bool, ui_enable_autopilot_stop_warning: bool, ui_enable_cabin_camera: bool, ui_enable_cabin_camera_telemetry: bool, ui_enable_map_stops: bool, ui_factory_summon_enable: bool, ui_fsd_stops_control_enabled: bool, ui_fsd_visualization_enabled: bool, ui_hard_core_summon: bool, ui_homelink_nearby: bool, ui_hov_enabled: bool, ui_no_stalk_confirm_alert_chime: bool, ui_no_stalk_confirm_alert_haptic: bool, ui_show_lane_graph: bool, ui_show_track_labels: bool, ui_ulc_snooze: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_autopilot_control_index(ui_autopilot_control_index)?;
        res.set_ui_apmv3_branch(ui_apmv3_branch)?;
        res.set_ui_apply_ece_r79(ui_apply_ece_r79)?;
        res.set_ui_blindspot_distance(ui_blindspot_distance)?;
        res.set_ui_blindspot_min_speed(ui_blindspot_min_speed)?;
        res.set_ui_blindspot_ttc(ui_blindspot_ttc)?;
        res.set_ui_disable_backup(ui_disable_backup)?;
        res.set_ui_disable_fisheye(ui_disable_fisheye)?;
        res.set_ui_disable_left_pillar(ui_disable_left_pillar)?;
        res.set_ui_disable_left_repeater(ui_disable_left_repeater)?;
        res.set_ui_disable_main(ui_disable_main)?;
        res.set_ui_disable_narrow(ui_disable_narrow)?;
        res.set_ui_disable_radar(ui_disable_radar)?;
        res.set_ui_disable_right_pillar(ui_disable_right_pillar)?;
        res.set_ui_disable_right_repeater(ui_disable_right_repeater)?;
        res.set_ui_don_alc_prog_gore_abort_thres(ui_don_alc_prog_gore_abort_thres)?;
        res.set_ui_don_disable_auto_wiper_duration(ui_don_disable_auto_wiper_duration)?;
        res.set_ui_don_disable_cutin(ui_don_disable_cutin)?;
        res.set_ui_don_disable_on_auto_wiper_speed(ui_don_disable_on_auto_wiper_speed)?;
        res.set_ui_don_min_gore_width_for_abort_map(ui_don_min_gore_width_for_abort_map)?;
        res.set_ui_don_min_gore_width_for_abort_not_map(ui_don_min_gore_width_for_abort_not_map)?;
        res.set_ui_don_stop_end_of_ramp_buffer(ui_don_stop_end_of_ramp_buffer)?;
        res.set_ui_driver_monitor_confirmation(ui_driver_monitor_confirmation)?;
        res.set_ui_enable_autopilot_stop_warning(ui_enable_autopilot_stop_warning)?;
        res.set_ui_enable_cabin_camera(ui_enable_cabin_camera)?;
        res.set_ui_enable_cabin_camera_telemetry(ui_enable_cabin_camera_telemetry)?;
        res.set_ui_enable_map_stops(ui_enable_map_stops)?;
        res.set_ui_factory_summon_enable(ui_factory_summon_enable)?;
        res.set_ui_fsd_stops_control_enabled(ui_fsd_stops_control_enabled)?;
        res.set_ui_fsd_visualization_enabled(ui_fsd_visualization_enabled)?;
        res.set_ui_hard_core_summon(ui_hard_core_summon)?;
        res.set_ui_homelink_nearby(ui_homelink_nearby)?;
        res.set_ui_hov_enabled(ui_hov_enabled)?;
        res.set_ui_no_stalk_confirm_alert_chime(ui_no_stalk_confirm_alert_chime)?;
        res.set_ui_no_stalk_confirm_alert_haptic(ui_no_stalk_confirm_alert_haptic)?;
        res.set_ui_show_lane_graph(ui_show_lane_graph)?;
        res.set_ui_show_track_labels(ui_show_track_labels)?;
        res.set_ui_ulc_snooze(ui_ulc_snooze)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_autopilotControlIndex
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_autopilot_control_index(&self) -> Id3fduiAutopilotControlUiAutopilotControlIndex {
        match self.ui_autopilot_control_index_raw() {
            0 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl0,
            1 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl1,
            2 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl2,
            3 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl3,
            4 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl4,
            5 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl5,
            6 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl6,
            7 => Id3fduiAutopilotControlUiAutopilotControlIndex::AutopilotControl7,
            x => Id3fduiAutopilotControlUiAutopilotControlIndex::Other(x),
        }
    }
    
    /// Get raw value of UI_autopilotControlIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_autopilot_control_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_autopilotControlIndex
    #[inline(always)]
    pub fn set_ui_autopilot_control_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// UI_apmv3Branch
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_apmv3_branch(&self) -> Id3fduiAutopilotControlUiApmv3Branch {
        match self.ui_apmv3_branch_raw() {
            5 => Id3fduiAutopilotControlUiApmv3Branch::Demo,
            2 => Id3fduiAutopilotControlUiApmv3Branch::Dev,
            4 => Id3fduiAutopilotControlUiApmv3Branch::Eap,
            0 => Id3fduiAutopilotControlUiApmv3Branch::Live,
            1 => Id3fduiAutopilotControlUiApmv3Branch::Stage,
            3 => Id3fduiAutopilotControlUiApmv3Branch::Stage2,
            x => Id3fduiAutopilotControlUiApmv3Branch::Other(x),
        }
    }
    
    /// Get raw value of UI_apmv3Branch
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_apmv3_branch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_apmv3Branch
    #[inline(always)]
    pub fn set_ui_apmv3_branch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..43].store_le(value);
        Ok(())
    }
    
    /// UI_applyEceR79
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_apply_ece_r79(&self) -> bool {
        self.ui_apply_ece_r79_raw()
    }
    
    /// Get raw value of UI_applyEceR79
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_apply_ece_r79_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_applyEceR79
    #[inline(always)]
    pub fn set_ui_apply_ece_r79(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
    /// UI_blindspotDistance
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_blindspot_distance(&self) -> Id3fduiAutopilotControlUiBlindspotDistance {
        match self.ui_blindspot_distance_raw() {
            1 => Id3fduiAutopilotControlUiBlindspotDistance::BlindspotDistance0p5M,
            2 => Id3fduiAutopilotControlUiBlindspotDistance::BlindspotDistance1M,
            3 => Id3fduiAutopilotControlUiBlindspotDistance::BlindspotDistance2M,
            4 => Id3fduiAutopilotControlUiBlindspotDistance::BlindspotDistance4M,
            0 => Id3fduiAutopilotControlUiBlindspotDistance::BlindspotDistanceDefault,
            5 => Id3fduiAutopilotControlUiBlindspotDistance::BlindspotDistanceOff,
            x => Id3fduiAutopilotControlUiBlindspotDistance::Other(x),
        }
    }
    
    /// Get raw value of UI_blindspotDistance
    ///
    /// - Start bit: 15
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_blindspot_distance_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[15..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_blindspotDistance
    #[inline(always)]
    pub fn set_ui_blindspot_distance(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[15..18].store_le(value);
        Ok(())
    }
    
    /// UI_blindspotMinSpeed
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_blindspot_min_speed(&self) -> Id3fduiAutopilotControlUiBlindspotMinSpeed {
        match self.ui_blindspot_min_speed_raw() {
            2 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed10Kph,
            3 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed15Kph,
            4 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed20Kph,
            5 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed25Kph,
            6 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed30Kph,
            7 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed35Kph,
            8 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed40Kph,
            9 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed45Kph,
            1 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeed5Kph,
            0 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeedDefault,
            10 => Id3fduiAutopilotControlUiBlindspotMinSpeed::BlindspotMinSpeedOff,
            x => Id3fduiAutopilotControlUiBlindspotMinSpeed::Other(x),
        }
    }
    
    /// Get raw value of UI_blindspotMinSpeed
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_blindspot_min_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_blindspotMinSpeed
    #[inline(always)]
    pub fn set_ui_blindspot_min_speed(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// UI_blindspotTTC
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_blindspot_ttc(&self) -> Id3fduiAutopilotControlUiBlindspotTtc {
        match self.ui_blindspot_ttc_raw() {
            1 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtc0p5S,
            2 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtc1S,
            3 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtc2S,
            5 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtc3S,
            4 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtc4S,
            6 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtc5S,
            0 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtcDefault,
            7 => Id3fduiAutopilotControlUiBlindspotTtc::BlindspotTtcOff,
            x => Id3fduiAutopilotControlUiBlindspotTtc::Other(x),
        }
    }
    
    /// Get raw value of UI_blindspotTTC
    ///
    /// - Start bit: 18
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_blindspot_ttc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_blindspotTTC
    #[inline(always)]
    pub fn set_ui_blindspot_ttc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..21].store_le(value);
        Ok(())
    }
    
    /// UI_disableBackup
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_backup(&self) -> bool {
        self.ui_disable_backup_raw()
    }
    
    /// Get raw value of UI_disableBackup
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_backup_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableBackup
    #[inline(always)]
    pub fn set_ui_disable_backup(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// UI_disableFisheye
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_fisheye(&self) -> bool {
        self.ui_disable_fisheye_raw()
    }
    
    /// Get raw value of UI_disableFisheye
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_fisheye_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableFisheye
    #[inline(always)]
    pub fn set_ui_disable_fisheye(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// UI_disableLeftPillar
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_left_pillar(&self) -> bool {
        self.ui_disable_left_pillar_raw()
    }
    
    /// Get raw value of UI_disableLeftPillar
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_left_pillar_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableLeftPillar
    #[inline(always)]
    pub fn set_ui_disable_left_pillar(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// UI_disableLeftRepeater
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_left_repeater(&self) -> bool {
        self.ui_disable_left_repeater_raw()
    }
    
    /// Get raw value of UI_disableLeftRepeater
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_left_repeater_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableLeftRepeater
    #[inline(always)]
    pub fn set_ui_disable_left_repeater(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// UI_disableMain
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_main(&self) -> bool {
        self.ui_disable_main_raw()
    }
    
    /// Get raw value of UI_disableMain
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_main_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableMain
    #[inline(always)]
    pub fn set_ui_disable_main(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// UI_disableNarrow
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_narrow(&self) -> bool {
        self.ui_disable_narrow_raw()
    }
    
    /// Get raw value of UI_disableNarrow
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_narrow_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableNarrow
    #[inline(always)]
    pub fn set_ui_disable_narrow(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// UI_disableRadar
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_radar(&self) -> bool {
        self.ui_disable_radar_raw()
    }
    
    /// Get raw value of UI_disableRadar
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_radar_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableRadar
    #[inline(always)]
    pub fn set_ui_disable_radar(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// UI_disableRightPillar
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_right_pillar(&self) -> bool {
        self.ui_disable_right_pillar_raw()
    }
    
    /// Get raw value of UI_disableRightPillar
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_right_pillar_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableRightPillar
    #[inline(always)]
    pub fn set_ui_disable_right_pillar(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// UI_disableRightRepeater
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_disable_right_repeater(&self) -> bool {
        self.ui_disable_right_repeater_raw()
    }
    
    /// Get raw value of UI_disableRightRepeater
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_disable_right_repeater_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_disableRightRepeater
    #[inline(always)]
    pub fn set_ui_disable_right_repeater(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// UI_donAlcProgGoreAbortThres
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_alc_prog_gore_abort_thres(&self) -> Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres {
        match self.ui_don_alc_prog_gore_abort_thres_raw() {
            1 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p00,
            2 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p05,
            3 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p10,
            4 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p15,
            5 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p20,
            6 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p25,
            7 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p30,
            8 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p35,
            9 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThreshold0p40,
            0 => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::DonAlcProgressGoreAbortThresholdDefault,
            x => Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres::Other(x),
        }
    }
    
    /// Get raw value of UI_donAlcProgGoreAbortThres
    ///
    /// - Start bit: 29
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_alc_prog_gore_abort_thres_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[29..33].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_donAlcProgGoreAbortThres
    #[inline(always)]
    pub fn set_ui_don_alc_prog_gore_abort_thres(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[29..33].store_le(value);
        Ok(())
    }
    
    /// UI_donDisableAutoWiperDuration
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_disable_auto_wiper_duration(&self) -> Id3fduiAutopilotControlUiDonDisableAutoWiperDuration {
        match self.ui_don_disable_auto_wiper_duration_raw() {
            5 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDuration120S,
            2 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDuration15S,
            3 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDuration30S,
            1 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDuration5S,
            4 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDuration60S,
            0 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDurationDefault,
            6 => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::DonDisableAutoWiperDurationOff,
            x => Id3fduiAutopilotControlUiDonDisableAutoWiperDuration::Other(x),
        }
    }
    
    /// Get raw value of UI_donDisableAutoWiperDuration
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_disable_auto_wiper_duration_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_donDisableAutoWiperDuration
    #[inline(always)]
    pub fn set_ui_don_disable_auto_wiper_duration(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..7].store_le(value);
        Ok(())
    }
    
    /// UI_donDisableCutin
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_disable_cutin(&self) -> Id3fduiAutopilotControlUiDonDisableCutin {
        match self.ui_don_disable_cutin_raw() {
            false => Id3fduiAutopilotControlUiDonDisableCutin::DonDisableCutinOff,
            true => Id3fduiAutopilotControlUiDonDisableCutin::DonDisableCutinOn,
            x => Id3fduiAutopilotControlUiDonDisableCutin::Other(x),
        }
    }
    
    /// Get raw value of UI_donDisableCutin
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_disable_cutin_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_donDisableCutin
    #[inline(always)]
    pub fn set_ui_don_disable_cutin(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// UI_donDisableOnAutoWiperSpeed
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_disable_on_auto_wiper_speed(&self) -> Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed {
        match self.ui_don_disable_on_auto_wiper_speed_raw() {
            1 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed1,
            10 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed10,
            11 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed11,
            12 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed12,
            13 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed13,
            14 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed14,
            2 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed2,
            3 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed3,
            4 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed4,
            5 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed5,
            6 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed6,
            7 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed7,
            8 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed8,
            9 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeed9,
            15 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeedInvalid,
            0 => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::DasWiperSpeedOff,
            x => Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed::Other(x),
        }
    }
    
    /// Get raw value of UI_donDisableOnAutoWiperSpeed
    ///
    /// - Start bit: 7
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_disable_on_auto_wiper_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[7..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_donDisableOnAutoWiperSpeed
    #[inline(always)]
    pub fn set_ui_don_disable_on_auto_wiper_speed(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[7..11].store_le(value);
        Ok(())
    }
    
    /// UI_donMinGoreWidthForAbortMap
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_min_gore_width_for_abort_map(&self) -> Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap {
        match self.ui_don_min_gore_width_for_abort_map_raw() {
            2 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort0p5M,
            1 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort0M,
            4 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort1p5M,
            3 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort1M,
            6 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort2p5M,
            5 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort2M,
            8 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort3p5M,
            7 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort3M,
            10 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort4p5M,
            9 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort4M,
            11 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbort5M,
            0 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::DonMinGoreWidthForAbortDefault,
            x => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap::Other(x),
        }
    }
    
    /// Get raw value of UI_donMinGoreWidthForAbortMap
    ///
    /// - Start bit: 25
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_min_gore_width_for_abort_map_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[25..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_donMinGoreWidthForAbortMap
    #[inline(always)]
    pub fn set_ui_don_min_gore_width_for_abort_map(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[25..29].store_le(value);
        Ok(())
    }
    
    /// UI_donMinGoreWidthForAbortNotMap
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_min_gore_width_for_abort_not_map(&self) -> Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap {
        match self.ui_don_min_gore_width_for_abort_not_map_raw() {
            2 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort0p5M,
            1 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort0M,
            4 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort1p5M,
            3 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort1M,
            6 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort2p5M,
            5 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort2M,
            8 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort3p5M,
            7 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort3M,
            10 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort4p5M,
            9 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort4M,
            11 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbort5M,
            0 => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::DonMinGoreWidthForAbortDefault,
            x => Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap::Other(x),
        }
    }
    
    /// Get raw value of UI_donMinGoreWidthForAbortNotMap
    ///
    /// - Start bit: 33
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_min_gore_width_for_abort_not_map_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[33..37].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_donMinGoreWidthForAbortNotMap
    #[inline(always)]
    pub fn set_ui_don_min_gore_width_for_abort_not_map(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[33..37].store_le(value);
        Ok(())
    }
    
    /// UI_donStopEndOfRampBuffer
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_don_stop_end_of_ramp_buffer(&self) -> Id3fduiAutopilotControlUiDonStopEndOfRampBuffer {
        match self.ui_don_stop_end_of_ramp_buffer_raw() {
            1 => Id3fduiAutopilotControlUiDonStopEndOfRampBuffer::DonStopEndOfRampBuffer15M,
            2 => Id3fduiAutopilotControlUiDonStopEndOfRampBuffer::DonStopEndOfRampBuffer30M,
            3 => Id3fduiAutopilotControlUiDonStopEndOfRampBuffer::DonStopEndOfRampBuffer45M,
            0 => Id3fduiAutopilotControlUiDonStopEndOfRampBuffer::DonStopEndOfRampBufferDefault,
            4 => Id3fduiAutopilotControlUiDonStopEndOfRampBuffer::DonStopEndOfRampBufferOff,
            x => Id3fduiAutopilotControlUiDonStopEndOfRampBuffer::Other(x),
        }
    }
    
    /// Get raw value of UI_donStopEndOfRampBuffer
    ///
    /// - Start bit: 21
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_don_stop_end_of_ramp_buffer_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_donStopEndOfRampBuffer
    #[inline(always)]
    pub fn set_ui_don_stop_end_of_ramp_buffer(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1021 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..24].store_le(value);
        Ok(())
    }
    
    /// UI_driverMonitorConfirmation
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_driver_monitor_confirmation(&self) -> bool {
        self.ui_driver_monitor_confirmation_raw()
    }
    
    /// Get raw value of UI_driverMonitorConfirmation
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_driver_monitor_confirmation_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_driverMonitorConfirmation
    #[inline(always)]
    pub fn set_ui_driver_monitor_confirmation(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// UI_enableAutopilotStopWarning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_autopilot_stop_warning(&self) -> bool {
        self.ui_enable_autopilot_stop_warning_raw()
    }
    
    /// Get raw value of UI_enableAutopilotStopWarning
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_autopilot_stop_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableAutopilotStopWarning
    #[inline(always)]
    pub fn set_ui_enable_autopilot_stop_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[44..45].store_le(value);
        Ok(())
    }
    
    /// UI_enableCabinCamera
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_cabin_camera(&self) -> bool {
        self.ui_enable_cabin_camera_raw()
    }
    
    /// Get raw value of UI_enableCabinCamera
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_cabin_camera_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableCabinCamera
    #[inline(always)]
    pub fn set_ui_enable_cabin_camera(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// UI_enableCabinCameraTelemetry
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_cabin_camera_telemetry(&self) -> bool {
        self.ui_enable_cabin_camera_telemetry_raw()
    }
    
    /// Get raw value of UI_enableCabinCameraTelemetry
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_cabin_camera_telemetry_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableCabinCameraTelemetry
    #[inline(always)]
    pub fn set_ui_enable_cabin_camera_telemetry(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// UI_enableMapStops
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_enable_map_stops(&self) -> bool {
        self.ui_enable_map_stops_raw()
    }
    
    /// Get raw value of UI_enableMapStops
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_enable_map_stops_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_enableMapStops
    #[inline(always)]
    pub fn set_ui_enable_map_stops(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// UI_factorySummonEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_factory_summon_enable(&self) -> bool {
        self.ui_factory_summon_enable_raw()
    }
    
    /// Get raw value of UI_factorySummonEnable
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_factory_summon_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_factorySummonEnable
    #[inline(always)]
    pub fn set_ui_factory_summon_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// UI_fsdStopsControlEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_fsd_stops_control_enabled(&self) -> bool {
        self.ui_fsd_stops_control_enabled_raw()
    }
    
    /// Get raw value of UI_fsdStopsControlEnabled
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_fsd_stops_control_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_fsdStopsControlEnabled
    #[inline(always)]
    pub fn set_ui_fsd_stops_control_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// UI_fsdVisualizationEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_fsd_visualization_enabled(&self) -> bool {
        self.ui_fsd_visualization_enabled_raw()
    }
    
    /// Get raw value of UI_fsdVisualizationEnabled
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_fsd_visualization_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_fsdVisualizationEnabled
    #[inline(always)]
    pub fn set_ui_fsd_visualization_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// UI_hardCoreSummon
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hard_core_summon(&self) -> bool {
        self.ui_hard_core_summon_raw()
    }
    
    /// Get raw value of UI_hardCoreSummon
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hard_core_summon_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_hardCoreSummon
    #[inline(always)]
    pub fn set_ui_hard_core_summon(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[47..48].store_le(value);
        Ok(())
    }
    
    /// UI_homelinkNearby
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_homelink_nearby(&self) -> Id3fduiAutopilotControlUiHomelinkNearby {
        match self.ui_homelink_nearby_raw() {
            true => Id3fduiAutopilotControlUiHomelinkNearby::HomelinkNearby,
            false => Id3fduiAutopilotControlUiHomelinkNearby::HomelinkNotNearby,
            x => Id3fduiAutopilotControlUiHomelinkNearby::Other(x),
        }
    }
    
    /// Get raw value of UI_homelinkNearby
    ///
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_homelink_nearby_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[45..46].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_homelinkNearby
    #[inline(always)]
    pub fn set_ui_homelink_nearby(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[45..46].store_le(value);
        Ok(())
    }
    
    /// UI_hovEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hov_enabled(&self) -> Id3fduiAutopilotControlUiHovEnabled {
        match self.ui_hov_enabled_raw() {
            false => Id3fduiAutopilotControlUiHovEnabled::HovOff,
            true => Id3fduiAutopilotControlUiHovEnabled::HovOn,
            x => Id3fduiAutopilotControlUiHovEnabled::Other(x),
        }
    }
    
    /// Get raw value of UI_hovEnabled
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hov_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_hovEnabled
    #[inline(always)]
    pub fn set_ui_hov_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_noStalkConfirmAlertChime
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_no_stalk_confirm_alert_chime(&self) -> bool {
        self.ui_no_stalk_confirm_alert_chime_raw()
    }
    
    /// Get raw value of UI_noStalkConfirmAlertChime
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_no_stalk_confirm_alert_chime_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_noStalkConfirmAlertChime
    #[inline(always)]
    pub fn set_ui_no_stalk_confirm_alert_chime(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// UI_noStalkConfirmAlertHaptic
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_no_stalk_confirm_alert_haptic(&self) -> bool {
        self.ui_no_stalk_confirm_alert_haptic_raw()
    }
    
    /// Get raw value of UI_noStalkConfirmAlertHaptic
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_no_stalk_confirm_alert_haptic_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_noStalkConfirmAlertHaptic
    #[inline(always)]
    pub fn set_ui_no_stalk_confirm_alert_haptic(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// UI_showLaneGraph
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_show_lane_graph(&self) -> bool {
        self.ui_show_lane_graph_raw()
    }
    
    /// Get raw value of UI_showLaneGraph
    ///
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_show_lane_graph_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[45..46].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_showLaneGraph
    #[inline(always)]
    pub fn set_ui_show_lane_graph(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[45..46].store_le(value);
        Ok(())
    }
    
    /// UI_showTrackLabels
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_show_track_labels(&self) -> bool {
        self.ui_show_track_labels_raw()
    }
    
    /// Get raw value of UI_showTrackLabels
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_show_track_labels_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_showTrackLabels
    #[inline(always)]
    pub fn set_ui_show_track_labels(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[46..47].store_le(value);
        Ok(())
    }
    
    /// UI_ulcSnooze
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ulc_snooze(&self) -> bool {
        self.ui_ulc_snooze_raw()
    }
    
    /// Get raw value of UI_ulcSnooze
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ulc_snooze_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_ulcSnooze
    #[inline(always)]
    pub fn set_ui_ulc_snooze(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3fduiAutopilotControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3fduiAutopilotControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_autopilot_control_index = u.int_in_range(0..=7)?;
        let ui_apmv3_branch = u.int_in_range(0..=5)?;
        let ui_apply_ece_r79 = u.int_in_range(0..=1)? == 1;
        let ui_blindspot_distance = u.int_in_range(0..=5)?;
        let ui_blindspot_min_speed = u.int_in_range(0..=10)?;
        let ui_blindspot_ttc = u.int_in_range(0..=7)?;
        let ui_disable_backup = u.int_in_range(0..=1)? == 1;
        let ui_disable_fisheye = u.int_in_range(0..=1)? == 1;
        let ui_disable_left_pillar = u.int_in_range(0..=1)? == 1;
        let ui_disable_left_repeater = u.int_in_range(0..=1)? == 1;
        let ui_disable_main = u.int_in_range(0..=1)? == 1;
        let ui_disable_narrow = u.int_in_range(0..=1)? == 1;
        let ui_disable_radar = u.int_in_range(0..=1)? == 1;
        let ui_disable_right_pillar = u.int_in_range(0..=1)? == 1;
        let ui_disable_right_repeater = u.int_in_range(0..=1)? == 1;
        let ui_don_alc_prog_gore_abort_thres = u.int_in_range(0..=9)?;
        let ui_don_disable_auto_wiper_duration = u.int_in_range(0..=6)?;
        let ui_don_disable_cutin = u.int_in_range(0..=1)? == 1;
        let ui_don_disable_on_auto_wiper_speed = u.int_in_range(0..=15)?;
        let ui_don_min_gore_width_for_abort_map = u.int_in_range(0..=11)?;
        let ui_don_min_gore_width_for_abort_not_map = u.int_in_range(0..=11)?;
        let ui_don_stop_end_of_ramp_buffer = u.int_in_range(0..=4)?;
        let ui_driver_monitor_confirmation = u.int_in_range(0..=1)? == 1;
        let ui_enable_autopilot_stop_warning = u.int_in_range(0..=1)? == 1;
        let ui_enable_cabin_camera = u.int_in_range(0..=1)? == 1;
        let ui_enable_cabin_camera_telemetry = u.int_in_range(0..=1)? == 1;
        let ui_enable_map_stops = u.int_in_range(0..=1)? == 1;
        let ui_factory_summon_enable = u.int_in_range(0..=1)? == 1;
        let ui_fsd_stops_control_enabled = u.int_in_range(0..=1)? == 1;
        let ui_fsd_visualization_enabled = u.int_in_range(0..=1)? == 1;
        let ui_hard_core_summon = u.int_in_range(0..=1)? == 1;
        let ui_homelink_nearby = u.int_in_range(0..=1)? == 1;
        let ui_hov_enabled = u.int_in_range(0..=1)? == 1;
        let ui_no_stalk_confirm_alert_chime = u.int_in_range(0..=1)? == 1;
        let ui_no_stalk_confirm_alert_haptic = u.int_in_range(0..=1)? == 1;
        let ui_show_lane_graph = u.int_in_range(0..=1)? == 1;
        let ui_show_track_labels = u.int_in_range(0..=1)? == 1;
        let ui_ulc_snooze = u.int_in_range(0..=1)? == 1;
        Id3fduiAutopilotControl::new(ui_autopilot_control_index,ui_apmv3_branch,ui_apply_ece_r79,ui_blindspot_distance,ui_blindspot_min_speed,ui_blindspot_ttc,ui_disable_backup,ui_disable_fisheye,ui_disable_left_pillar,ui_disable_left_repeater,ui_disable_main,ui_disable_narrow,ui_disable_radar,ui_disable_right_pillar,ui_disable_right_repeater,ui_don_alc_prog_gore_abort_thres,ui_don_disable_auto_wiper_duration,ui_don_disable_cutin,ui_don_disable_on_auto_wiper_speed,ui_don_min_gore_width_for_abort_map,ui_don_min_gore_width_for_abort_not_map,ui_don_stop_end_of_ramp_buffer,ui_driver_monitor_confirmation,ui_enable_autopilot_stop_warning,ui_enable_cabin_camera,ui_enable_cabin_camera_telemetry,ui_enable_map_stops,ui_factory_summon_enable,ui_fsd_stops_control_enabled,ui_fsd_visualization_enabled,ui_hard_core_summon,ui_homelink_nearby,ui_hov_enabled,ui_no_stalk_confirm_alert_chime,ui_no_stalk_confirm_alert_haptic,ui_show_lane_graph,ui_show_track_labels,ui_ulc_snooze).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_autopilotControlIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiAutopilotControlIndex {
    AutopilotControl0,
    AutopilotControl1,
    AutopilotControl2,
    AutopilotControl3,
    AutopilotControl4,
    AutopilotControl5,
    AutopilotControl6,
    AutopilotControl7,
    Other(u8),
}
/// Defined values for UI_apmv3Branch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiApmv3Branch {
    Demo,
    Dev,
    Eap,
    Live,
    Stage,
    Stage2,
    Other(u8),
}
/// Defined values for UI_blindspotDistance
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiBlindspotDistance {
    BlindspotDistance0p5M,
    BlindspotDistance1M,
    BlindspotDistance2M,
    BlindspotDistance4M,
    BlindspotDistanceDefault,
    BlindspotDistanceOff,
    Other(u8),
}
/// Defined values for UI_blindspotMinSpeed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiBlindspotMinSpeed {
    BlindspotMinSpeed10Kph,
    BlindspotMinSpeed15Kph,
    BlindspotMinSpeed20Kph,
    BlindspotMinSpeed25Kph,
    BlindspotMinSpeed30Kph,
    BlindspotMinSpeed35Kph,
    BlindspotMinSpeed40Kph,
    BlindspotMinSpeed45Kph,
    BlindspotMinSpeed5Kph,
    BlindspotMinSpeedDefault,
    BlindspotMinSpeedOff,
    Other(u8),
}
/// Defined values for UI_blindspotTTC
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiBlindspotTtc {
    BlindspotTtc0p5S,
    BlindspotTtc1S,
    BlindspotTtc2S,
    BlindspotTtc3S,
    BlindspotTtc4S,
    BlindspotTtc5S,
    BlindspotTtcDefault,
    BlindspotTtcOff,
    Other(u8),
}
/// Defined values for UI_donAlcProgGoreAbortThres
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonAlcProgGoreAbortThres {
    DonAlcProgressGoreAbortThreshold0p00,
    DonAlcProgressGoreAbortThreshold0p05,
    DonAlcProgressGoreAbortThreshold0p10,
    DonAlcProgressGoreAbortThreshold0p15,
    DonAlcProgressGoreAbortThreshold0p20,
    DonAlcProgressGoreAbortThreshold0p25,
    DonAlcProgressGoreAbortThreshold0p30,
    DonAlcProgressGoreAbortThreshold0p35,
    DonAlcProgressGoreAbortThreshold0p40,
    DonAlcProgressGoreAbortThresholdDefault,
    Other(u8),
}
/// Defined values for UI_donDisableAutoWiperDuration
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonDisableAutoWiperDuration {
    DonDisableAutoWiperDuration120S,
    DonDisableAutoWiperDuration15S,
    DonDisableAutoWiperDuration30S,
    DonDisableAutoWiperDuration5S,
    DonDisableAutoWiperDuration60S,
    DonDisableAutoWiperDurationDefault,
    DonDisableAutoWiperDurationOff,
    Other(u8),
}
/// Defined values for UI_donDisableCutin
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonDisableCutin {
    DonDisableCutinOff,
    DonDisableCutinOn,
    Other(bool),
}
/// Defined values for UI_donDisableOnAutoWiperSpeed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonDisableOnAutoWiperSpeed {
    DasWiperSpeed1,
    DasWiperSpeed10,
    DasWiperSpeed11,
    DasWiperSpeed12,
    DasWiperSpeed13,
    DasWiperSpeed14,
    DasWiperSpeed2,
    DasWiperSpeed3,
    DasWiperSpeed4,
    DasWiperSpeed5,
    DasWiperSpeed6,
    DasWiperSpeed7,
    DasWiperSpeed8,
    DasWiperSpeed9,
    DasWiperSpeedInvalid,
    DasWiperSpeedOff,
    Other(u8),
}
/// Defined values for UI_donMinGoreWidthForAbortMap
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonMinGoreWidthForAbortMap {
    DonMinGoreWidthForAbort0p5M,
    DonMinGoreWidthForAbort0M,
    DonMinGoreWidthForAbort1p5M,
    DonMinGoreWidthForAbort1M,
    DonMinGoreWidthForAbort2p5M,
    DonMinGoreWidthForAbort2M,
    DonMinGoreWidthForAbort3p5M,
    DonMinGoreWidthForAbort3M,
    DonMinGoreWidthForAbort4p5M,
    DonMinGoreWidthForAbort4M,
    DonMinGoreWidthForAbort5M,
    DonMinGoreWidthForAbortDefault,
    Other(u8),
}
/// Defined values for UI_donMinGoreWidthForAbortNotMap
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonMinGoreWidthForAbortNotMap {
    DonMinGoreWidthForAbort0p5M,
    DonMinGoreWidthForAbort0M,
    DonMinGoreWidthForAbort1p5M,
    DonMinGoreWidthForAbort1M,
    DonMinGoreWidthForAbort2p5M,
    DonMinGoreWidthForAbort2M,
    DonMinGoreWidthForAbort3p5M,
    DonMinGoreWidthForAbort3M,
    DonMinGoreWidthForAbort4p5M,
    DonMinGoreWidthForAbort4M,
    DonMinGoreWidthForAbort5M,
    DonMinGoreWidthForAbortDefault,
    Other(u8),
}
/// Defined values for UI_donStopEndOfRampBuffer
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiDonStopEndOfRampBuffer {
    DonStopEndOfRampBuffer15M,
    DonStopEndOfRampBuffer30M,
    DonStopEndOfRampBuffer45M,
    DonStopEndOfRampBufferDefault,
    DonStopEndOfRampBufferOff,
    Other(u8),
}
/// Defined values for UI_homelinkNearby
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiHomelinkNearby {
    HomelinkNearby,
    HomelinkNotNearby,
    Other(bool),
}
/// Defined values for UI_hovEnabled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3fduiAutopilotControlUiHovEnabled {
    HovOff,
    HovOn,
    Other(bool),
}

/// ID267DI_vehicleEstimates
///
/// - ID: 615 (0x267)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id267diVehicleEstimates {
    raw: [u8; 8],
}

impl Id267diVehicleEstimates {
    pub const MESSAGE_ID: u32 = 615;
    
    /// Construct new ID267DI_vehicleEstimates from values
    pub fn new(di_grade_est: i8, di_grade_est_internal: i8, di_mass: f32, di_mass_confidence: bool, di_relative_tire_tread_depth: f32, di_steering_angle_offset: f32, di_tire_fitment: u8, di_trailer_detected: bool, di_vehicle_estimates_checksum: u8, di_vehicle_estimates_counter: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_di_grade_est(di_grade_est)?;
        res.set_di_grade_est_internal(di_grade_est_internal)?;
        res.set_di_mass(di_mass)?;
        res.set_di_mass_confidence(di_mass_confidence)?;
        res.set_di_relative_tire_tread_depth(di_relative_tire_tread_depth)?;
        res.set_di_steering_angle_offset(di_steering_angle_offset)?;
        res.set_di_tire_fitment(di_tire_fitment)?;
        res.set_di_trailer_detected(di_trailer_detected)?;
        res.set_di_vehicle_estimates_checksum(di_vehicle_estimates_checksum)?;
        res.set_di_vehicle_estimates_counter(di_vehicle_estimates_counter)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DI_gradeEst
    ///
    /// Estimated Grade
    ///
    /// - Min: -40
    /// - Max: 40
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_grade_est(&self) -> i8 {
        self.di_grade_est_raw()
    }
    
    /// Get raw value of DI_gradeEst
    ///
    /// - Start bit: 33
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn di_grade_est_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[33..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of DI_gradeEst
    #[inline(always)]
    pub fn set_di_grade_est(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_i8 || 40_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[33..40].store_le(value);
        Ok(())
    }
    
    /// DI_gradeEstInternal
    ///
    /// - Min: -40
    /// - Max: 40
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_grade_est_internal(&self) -> i8 {
        self.di_grade_est_internal_raw()
    }
    
    /// Get raw value of DI_gradeEstInternal
    ///
    /// - Start bit: 48
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn di_grade_est_internal_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..55].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of DI_gradeEstInternal
    #[inline(always)]
    pub fn set_di_grade_est_internal(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_i8 || 40_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..55].store_le(value);
        Ok(())
    }
    
    /// DI_mass
    ///
    /// Estimated Mass
    ///
    /// - Min: 1900
    /// - Max: 7010
    /// - Unit: "kg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_mass(&self) -> f32 {
        self.di_mass_raw()
    }
    
    /// Get raw value of DI_mass
    ///
    /// - Start bit: 0
    /// - Signal size: 10 bits
    /// - Factor: 5
    /// - Offset: 1900
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_mass_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..10].load_le::<u16>();
        
        let factor = 5_f32;
        let offset = 1900_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_mass
    #[inline(always)]
    pub fn set_di_mass(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 1900_f32 || 7010_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        let factor = 5_f32;
        let offset = 1900_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..10].store_le(value);
        Ok(())
    }
    
    /// DI_massConfidence
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_mass_confidence(&self) -> Id267diVehicleEstimatesDiMassConfidence {
        match self.di_mass_confidence_raw() {
            true => Id267diVehicleEstimatesDiMassConfidence::MassConfided,
            false => Id267diVehicleEstimatesDiMassConfidence::MassNotConfided,
            x => Id267diVehicleEstimatesDiMassConfidence::Other(x),
        }
    }
    
    /// Get raw value of DI_massConfidence
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_mass_confidence_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_massConfidence
    #[inline(always)]
    pub fn set_di_mass_confidence(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// DI_relativeTireTreadDepth
    ///
    /// - Min: -6.2
    /// - Max: 6.2
    /// - Unit: "mm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_relative_tire_tread_depth(&self) -> Id267diVehicleEstimatesDiRelativeTireTreadDepth {
        match self.di_relative_tire_tread_depth_raw() {
            32 => Id267diVehicleEstimatesDiRelativeTireTreadDepth::Sna,
            x => Id267diVehicleEstimatesDiRelativeTireTreadDepth::Other(x),
        }
    }
    
    /// Get raw value of DI_relativeTireTreadDepth
    ///
    /// - Start bit: 16
    /// - Signal size: 6 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn di_relative_tire_tread_depth_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..22].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_relativeTireTreadDepth
    #[inline(always)]
    pub fn set_di_relative_tire_tread_depth(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -6.2_f32 || 6.2_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..22].store_le(value);
        Ok(())
    }
    
    /// DI_steeringAngleOffset
    ///
    /// - Min: -25.6
    /// - Max: 25.4
    /// - Unit: "Deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_steering_angle_offset(&self) -> f32 {
        self.di_steering_angle_offset_raw()
    }
    
    /// Get raw value of DI_steeringAngleOffset
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn di_steering_angle_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_steeringAngleOffset
    #[inline(always)]
    pub fn set_di_steering_angle_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -25.6_f32 || 25.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DI_tireFitment
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_tire_fitment(&self) -> Id267diVehicleEstimatesDiTireFitment {
        match self.di_tire_fitment_raw() {
            3 => Id267diVehicleEstimatesDiTireFitment::FitmentSna,
            0 => Id267diVehicleEstimatesDiTireFitment::FitmentSquare,
            1 => Id267diVehicleEstimatesDiTireFitment::FitmentStaggered,
            x => Id267diVehicleEstimatesDiTireFitment::Other(x),
        }
    }
    
    /// Get raw value of DI_tireFitment
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_tire_fitment_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DI_tireFitment
    #[inline(always)]
    pub fn set_di_tire_fitment(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// DI_trailerDetected
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_trailer_detected(&self) -> Id267diVehicleEstimatesDiTrailerDetected {
        match self.di_trailer_detected_raw() {
            true => Id267diVehicleEstimatesDiTrailerDetected::TrailerDetected,
            false => Id267diVehicleEstimatesDiTrailerDetected::TrailerNotDetected,
            x => Id267diVehicleEstimatesDiTrailerDetected::Other(x),
        }
    }
    
    /// Get raw value of DI_trailerDetected
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_trailer_detected_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_trailerDetected
    #[inline(always)]
    pub fn set_di_trailer_detected(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// DI_vehicleEstimatesChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_vehicle_estimates_checksum(&self) -> u8 {
        self.di_vehicle_estimates_checksum_raw()
    }
    
    /// Get raw value of DI_vehicleEstimatesChecksum
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_vehicle_estimates_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DI_vehicleEstimatesChecksum
    #[inline(always)]
    pub fn set_di_vehicle_estimates_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DI_vehicleEstimatesCounter
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_vehicle_estimates_counter(&self) -> u8 {
        self.di_vehicle_estimates_counter_raw()
    }
    
    /// Get raw value of DI_vehicleEstimatesCounter
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_vehicle_estimates_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DI_vehicleEstimatesCounter
    #[inline(always)]
    pub fn set_di_vehicle_estimates_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 615 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id267diVehicleEstimates {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id267diVehicleEstimates
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let di_grade_est = u.int_in_range(-40..=40)?;
        let di_grade_est_internal = u.int_in_range(-40..=40)?;
        let di_mass = 1900_f32;
        let di_mass_confidence = u.int_in_range(0..=1)? == 1;
        let di_relative_tire_tread_depth = -6.2_f32;
        let di_steering_angle_offset = -25.6_f32;
        let di_tire_fitment = u.int_in_range(0..=3)?;
        let di_trailer_detected = u.int_in_range(0..=1)? == 1;
        let di_vehicle_estimates_checksum = u.int_in_range(0..=255)?;
        let di_vehicle_estimates_counter = u.int_in_range(0..=7)?;
        Id267diVehicleEstimates::new(di_grade_est,di_grade_est_internal,di_mass,di_mass_confidence,di_relative_tire_tread_depth,di_steering_angle_offset,di_tire_fitment,di_trailer_detected,di_vehicle_estimates_checksum,di_vehicle_estimates_counter).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DI_massConfidence
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id267diVehicleEstimatesDiMassConfidence {
    MassConfided,
    MassNotConfided,
    Other(bool),
}
/// Defined values for DI_relativeTireTreadDepth
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id267diVehicleEstimatesDiRelativeTireTreadDepth {
    Sna,
    Other(f32),
}
/// Defined values for DI_tireFitment
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id267diVehicleEstimatesDiTireFitment {
    FitmentSna,
    FitmentSquare,
    FitmentStaggered,
    Other(u8),
}
/// Defined values for DI_trailerDetected
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id267diVehicleEstimatesDiTrailerDetected {
    TrailerDetected,
    TrailerNotDetected,
    Other(bool),
}

/// ID282VCLEFT_hvacBlowerFeedback
///
/// - ID: 642 (0x282)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id282vcleftHvacBlowerFeedback {
    raw: [u8; 8],
}

impl Id282vcleftHvacBlowerFeedback {
    pub const MESSAGE_ID: u32 = 642;
    
    /// Construct new ID282VCLEFT_hvacBlowerFeedback from values
    pub fn new(vcleft_blower_index: u8, vcleft_hvac_blower_cbc_ctrl_state: u8, vcleft_hvac_blower_cbc_est_state: u8, vcleft_hvac_blower_enabled: bool, vcleft_hvac_blower_fet_temp: f32, vcleft_hvac_blower_fault: bool, vcleft_hvac_blower_i_phase0: f32, vcleft_hvac_blower_i_phase1: f32, vcleft_hvac_blower_i_phase2: f32, vcleft_hvac_blower_i_term: f32, vcleft_hvac_blower_initd: bool, vcleft_hvac_blower_limit_fet_temps: bool, vcleft_hvac_blower_output_duty: u8, vcleft_hvac_blower_power_on: bool, vcleft_hvac_blower_rpm_actual: f32, vcleft_hvac_blower_rpm_target: f32, vcleft_hvac_blower_rs: f32, vcleft_hvac_blower_rs_online_active: bool, vcleft_hvac_blower_spi_error: bool, vcleft_hvac_blower_torque: f32, vcleft_hvac_blower_io_cbc_head: u8, vcleft_hvac_blower_io_cbc_status: bool, vcleft_hvac_blower_io_cbc_tail: u8, vcleft_hvac_blower_io_cbc_tail_va: bool, vcleft_hvac_blower_io_cbc_num_uart: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcleft_blower_index(vcleft_blower_index)?;
        res.set_vcleft_hvac_blower_cbc_ctrl_state(vcleft_hvac_blower_cbc_ctrl_state)?;
        res.set_vcleft_hvac_blower_cbc_est_state(vcleft_hvac_blower_cbc_est_state)?;
        res.set_vcleft_hvac_blower_enabled(vcleft_hvac_blower_enabled)?;
        res.set_vcleft_hvac_blower_fet_temp(vcleft_hvac_blower_fet_temp)?;
        res.set_vcleft_hvac_blower_fault(vcleft_hvac_blower_fault)?;
        res.set_vcleft_hvac_blower_i_phase0(vcleft_hvac_blower_i_phase0)?;
        res.set_vcleft_hvac_blower_i_phase1(vcleft_hvac_blower_i_phase1)?;
        res.set_vcleft_hvac_blower_i_phase2(vcleft_hvac_blower_i_phase2)?;
        res.set_vcleft_hvac_blower_i_term(vcleft_hvac_blower_i_term)?;
        res.set_vcleft_hvac_blower_initd(vcleft_hvac_blower_initd)?;
        res.set_vcleft_hvac_blower_limit_fet_temps(vcleft_hvac_blower_limit_fet_temps)?;
        res.set_vcleft_hvac_blower_output_duty(vcleft_hvac_blower_output_duty)?;
        res.set_vcleft_hvac_blower_power_on(vcleft_hvac_blower_power_on)?;
        res.set_vcleft_hvac_blower_rpm_actual(vcleft_hvac_blower_rpm_actual)?;
        res.set_vcleft_hvac_blower_rpm_target(vcleft_hvac_blower_rpm_target)?;
        res.set_vcleft_hvac_blower_rs(vcleft_hvac_blower_rs)?;
        res.set_vcleft_hvac_blower_rs_online_active(vcleft_hvac_blower_rs_online_active)?;
        res.set_vcleft_hvac_blower_spi_error(vcleft_hvac_blower_spi_error)?;
        res.set_vcleft_hvac_blower_torque(vcleft_hvac_blower_torque)?;
        res.set_vcleft_hvac_blower_io_cbc_head(vcleft_hvac_blower_io_cbc_head)?;
        res.set_vcleft_hvac_blower_io_cbc_status(vcleft_hvac_blower_io_cbc_status)?;
        res.set_vcleft_hvac_blower_io_cbc_tail(vcleft_hvac_blower_io_cbc_tail)?;
        res.set_vcleft_hvac_blower_io_cbc_tail_va(vcleft_hvac_blower_io_cbc_tail_va)?;
        res.set_vcleft_hvac_blower_io_cbc_num_uart(vcleft_hvac_blower_io_cbc_num_uart)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCLEFT_blowerIndex
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_blower_index(&self) -> Id282vcleftHvacBlowerFeedbackVcleftBlowerIndex {
        match self.vcleft_blower_index_raw() {
            0 => Id282vcleftHvacBlowerFeedbackVcleftBlowerIndex::HvacFeedbackSignals,
            1 => Id282vcleftHvacBlowerFeedbackVcleftBlowerIndex::HvacVars,
            x => Id282vcleftHvacBlowerFeedbackVcleftBlowerIndex::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_blowerIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_blower_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_blowerIndex
    #[inline(always)]
    pub fn set_vcleft_blower_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerCBCCtrlState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_cbc_ctrl_state(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState {
        match self.vcleft_hvac_blower_cbc_ctrl_state_raw() {
            4 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState::Count,
            0 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState::Error,
            1 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState::Idle,
            2 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState::Offline,
            3 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState::Online,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerCBCCtrlState
    ///
    /// - Start bit: 58
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_cbc_ctrl_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_hvacBlowerCBCCtrlState
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_cbc_ctrl_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..61].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerCBCEstState
    ///
    /// - Min: 0
    /// - Max: 14
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_cbc_est_state(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState {
        match self.vcleft_hvac_blower_cbc_est_state_raw() {
            14 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Count,
            0 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Error,
            1 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Idle,
            5 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Idrated,
            10 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::InductanceEst,
            9 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Lockrotor,
            12 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::MotorIdentified,
            13 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Online,
            8 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Rampdown,
            4 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Rampup,
            7 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Ratedflux,
            6 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::RatedfluxOl,
            11 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::RotorResistance,
            2 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Roverl,
            3 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Rs,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerCBCEstState
    ///
    /// - Start bit: 54
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_cbc_est_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_hvacBlowerCBCEstState
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_cbc_est_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 14_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..58].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_enabled(&self) -> bool {
        self.vcleft_hvac_blower_enabled_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerEnabled
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerEnabled
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerFETTemp
    ///
    /// - Min: -40
    /// - Max: 149
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_fet_temp(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerFetTemp {
        match self.vcleft_hvac_blower_fet_temp_raw() {
            127 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerFetTemp::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerFetTemp::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerFETTemp
    ///
    /// - Start bit: 44
    /// - Signal size: 7 bits
    /// - Factor: 1.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_fet_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..51].load_le::<u8>();
        
        let factor = 1.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerFETTemp
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_fet_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 149_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 1.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[44..51].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_fault(&self) -> bool {
        self.vcleft_hvac_blower_fault_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerFault
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerFault
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[59..60].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerIPhase0
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_phase0(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase0 {
        match self.vcleft_hvac_blower_i_phase0_raw() {
            255 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase0::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase0::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerIPhase0
    ///
    /// - Start bit: 10
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_phase0_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..18].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerIPhase0
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_i_phase0(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[10..18].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerIPhase1
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_phase1(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase1 {
        match self.vcleft_hvac_blower_i_phase1_raw() {
            255 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase1::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase1::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerIPhase1
    ///
    /// - Start bit: 18
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_phase1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[18..26].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerIPhase1
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_i_phase1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[18..26].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerIPhase2
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_phase2(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase2 {
        match self.vcleft_hvac_blower_i_phase2_raw() {
            255 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase2::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase2::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerIPhase2
    ///
    /// - Start bit: 26
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_phase2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[26..34].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerIPhase2
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_i_phase2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[26..34].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerITerm
    ///
    /// - Min: -1.5
    /// - Max: 4.5
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_term(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerITerm {
        match self.vcleft_hvac_blower_i_term_raw() {
            127 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerITerm::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerITerm::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerITerm
    ///
    /// - Start bit: 51
    /// - Signal size: 7 bits
    /// - Factor: 0.05
    /// - Offset: -1.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_i_term_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..58].load_le::<u8>();
        
        let factor = 0.05_f32;
        let offset = -1.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerITerm
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_i_term(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.5_f32 || 4.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 0.05_f32;
        let offset = -1.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[51..58].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerInitd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_initd(&self) -> bool {
        self.vcleft_hvac_blower_initd_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerInitd
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_initd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerInitd
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_initd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[58..59].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerLimitFETTemps
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_limit_fet_temps(&self) -> bool {
        self.vcleft_hvac_blower_limit_fet_temps_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerLimitFETTemps
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_limit_fet_temps_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerLimitFETTemps
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_limit_fet_temps(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerOutputDuty
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_output_duty(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerOutputDuty {
        match self.vcleft_hvac_blower_output_duty_raw() {
            127 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerOutputDuty::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerOutputDuty::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerOutputDuty
    ///
    /// - Start bit: 3
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_output_duty_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_hvacBlowerOutputDuty
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_output_duty(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..10].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerPowerOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_power_on(&self) -> bool {
        self.vcleft_hvac_blower_power_on_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerPowerOn
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_power_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerPowerOn
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_power_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerRPMActual
    ///
    /// HVAC Blower Speed
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "rpm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_rpm_actual(&self) -> f32 {
        self.vcleft_hvac_blower_rpm_actual_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerRPMActual
    ///
    /// - Start bit: 20
    /// - Signal size: 10 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_rpm_actual_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..30].load_le::<u16>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerRPMActual
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_rpm_actual(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[20..30].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerRPMTarget
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "rpm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_rpm_target(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRpmTarget {
        match self.vcleft_hvac_blower_rpm_target_raw() {
            1023 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRpmTarget::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRpmTarget::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerRPMTarget
    ///
    /// - Start bit: 10
    /// - Signal size: 10 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_rpm_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..20].load_le::<u16>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerRPMTarget
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_rpm_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[10..20].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerRs
    ///
    /// - Min: 0
    /// - Max: 60
    /// - Unit: "mOhm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_rs(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRs {
        match self.vcleft_hvac_blower_rs_raw() {
            255 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRs::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRs::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerRs
    ///
    /// - Start bit: 2
    /// - Signal size: 8 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_rs_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[2..10].load_le::<u8>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerRs
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_rs(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 60_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[2..10].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerRsOnlineActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_rs_online_active(&self) -> bool {
        self.vcleft_hvac_blower_rs_online_active_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerRsOnlineActive
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_rs_online_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerRsOnlineActive
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_rs_online_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerSpiError
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_spi_error(&self) -> bool {
        self.vcleft_hvac_blower_spi_error_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlowerSpiError
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_spi_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlowerSpiError
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_spi_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlowerTorque
    ///
    /// - Min: -1.5
    /// - Max: 4.5
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_torque(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerTorque {
        match self.vcleft_hvac_blower_torque_raw() {
            1023 => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerTorque::Sna,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerTorque::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlowerTorque
    ///
    /// - Start bit: 34
    /// - Signal size: 10 bits
    /// - Factor: 0.006
    /// - Offset: -1.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_torque_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[34..44].load_le::<u16>();
        
        let factor = 0.006_f32;
        let offset = -1.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCLEFT_hvacBlowerTorque
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_torque(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.5_f32 || 4.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        let factor = 0.006_f32;
        let offset = -1.5_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[34..44].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlower_IO_CBC_HEAD
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_head(&self) -> u8 {
        self.vcleft_hvac_blower_io_cbc_head_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlower_IO_CBC_HEAD
    ///
    /// - Start bit: 34
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_head_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_hvacBlower_IO_CBC_HEAD
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_io_cbc_head(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..38].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlower_IO_CBC_Status
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_status(&self) -> Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIoCbcStatus {
        match self.vcleft_hvac_blower_io_cbc_status_raw() {
            false => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIoCbcStatus::Idle,
            true => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIoCbcStatus::Rx,
            x => Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIoCbcStatus::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_hvacBlower_IO_CBC_Status
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlower_IO_CBC_Status
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_io_cbc_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlower_IO_CBC_TAIL
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_tail(&self) -> u8 {
        self.vcleft_hvac_blower_io_cbc_tail_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlower_IO_CBC_TAIL
    ///
    /// - Start bit: 38
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_tail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_hvacBlower_IO_CBC_TAIL
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_io_cbc_tail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..42].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlower_IO_CBC_TAIL_va
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_tail_va(&self) -> bool {
        self.vcleft_hvac_blower_io_cbc_tail_va_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlower_IO_CBC_TAIL_va
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_tail_va_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCLEFT_hvacBlower_IO_CBC_TAIL_va
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_io_cbc_tail_va(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_hvacBlower_IO_CBC_numUart
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_num_uart(&self) -> u8 {
        self.vcleft_hvac_blower_io_cbc_num_uart_raw()
    }
    
    /// Get raw value of VCLEFT_hvacBlower_IO_CBC_numUart
    ///
    /// - Start bit: 46
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_hvac_blower_io_cbc_num_uart_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_hvacBlower_IO_CBC_numUart
    #[inline(always)]
    pub fn set_vcleft_hvac_blower_io_cbc_num_uart(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 642 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..54].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id282vcleftHvacBlowerFeedback {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id282vcleftHvacBlowerFeedback
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcleft_blower_index = u.int_in_range(0..=1)?;
        let vcleft_hvac_blower_cbc_ctrl_state = u.int_in_range(0..=4)?;
        let vcleft_hvac_blower_cbc_est_state = u.int_in_range(0..=14)?;
        let vcleft_hvac_blower_enabled = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_fet_temp = -40_f32;
        let vcleft_hvac_blower_fault = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_i_phase0 = 0_f32;
        let vcleft_hvac_blower_i_phase1 = 0_f32;
        let vcleft_hvac_blower_i_phase2 = 0_f32;
        let vcleft_hvac_blower_i_term = -1.5_f32;
        let vcleft_hvac_blower_initd = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_limit_fet_temps = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_output_duty = u.int_in_range(0..=100)?;
        let vcleft_hvac_blower_power_on = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_rpm_actual = 0_f32;
        let vcleft_hvac_blower_rpm_target = 0_f32;
        let vcleft_hvac_blower_rs = 0_f32;
        let vcleft_hvac_blower_rs_online_active = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_spi_error = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_torque = -1.5_f32;
        let vcleft_hvac_blower_io_cbc_head = u.int_in_range(0..=15)?;
        let vcleft_hvac_blower_io_cbc_status = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_io_cbc_tail = u.int_in_range(0..=15)?;
        let vcleft_hvac_blower_io_cbc_tail_va = u.int_in_range(0..=1)? == 1;
        let vcleft_hvac_blower_io_cbc_num_uart = u.int_in_range(0..=255)?;
        Id282vcleftHvacBlowerFeedback::new(vcleft_blower_index,vcleft_hvac_blower_cbc_ctrl_state,vcleft_hvac_blower_cbc_est_state,vcleft_hvac_blower_enabled,vcleft_hvac_blower_fet_temp,vcleft_hvac_blower_fault,vcleft_hvac_blower_i_phase0,vcleft_hvac_blower_i_phase1,vcleft_hvac_blower_i_phase2,vcleft_hvac_blower_i_term,vcleft_hvac_blower_initd,vcleft_hvac_blower_limit_fet_temps,vcleft_hvac_blower_output_duty,vcleft_hvac_blower_power_on,vcleft_hvac_blower_rpm_actual,vcleft_hvac_blower_rpm_target,vcleft_hvac_blower_rs,vcleft_hvac_blower_rs_online_active,vcleft_hvac_blower_spi_error,vcleft_hvac_blower_torque,vcleft_hvac_blower_io_cbc_head,vcleft_hvac_blower_io_cbc_status,vcleft_hvac_blower_io_cbc_tail,vcleft_hvac_blower_io_cbc_tail_va,vcleft_hvac_blower_io_cbc_num_uart).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCLEFT_blowerIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftBlowerIndex {
    HvacFeedbackSignals,
    HvacVars,
    Other(u8),
}
/// Defined values for VCLEFT_hvacBlowerCBCCtrlState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcCtrlState {
    Count,
    Error,
    Idle,
    Offline,
    Online,
    Other(u8),
}
/// Defined values for VCLEFT_hvacBlowerCBCEstState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerCbcEstState {
    Count,
    Error,
    Idle,
    Idrated,
    InductanceEst,
    Lockrotor,
    MotorIdentified,
    Online,
    Rampdown,
    Rampup,
    Ratedflux,
    RatedfluxOl,
    RotorResistance,
    Roverl,
    Rs,
    Other(u8),
}
/// Defined values for VCLEFT_hvacBlowerFETTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerFetTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerIPhase0
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase0 {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerIPhase1
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase1 {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerIPhase2
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIPhase2 {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerITerm
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerITerm {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerOutputDuty
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerOutputDuty {
    Sna,
    Other(u8),
}
/// Defined values for VCLEFT_hvacBlowerRPMTarget
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRpmTarget {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerRs
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerRs {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlowerTorque
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerTorque {
    Sna,
    Other(f32),
}
/// Defined values for VCLEFT_hvacBlower_IO_CBC_Status
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id282vcleftHvacBlowerFeedbackVcleftHvacBlowerIoCbcStatus {
    Idle,
    Rx,
    Other(bool),
}

/// ID2F3UI_hvacRequest
///
/// - ID: 755 (0x2f3)
/// - Size: 5 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2f3uiHvacRequest {
    raw: [u8; 5],
}

impl Id2f3uiHvacRequest {
    pub const MESSAGE_ID: u32 = 755;
    
    /// Construct new ID2F3UI_hvacRequest from values
    pub fn new(ui_hvac_req_ac_disable: u8, ui_hvac_req_air_distribution_mode: u8, ui_hvac_req_blower_segment: u8, ui_hvac_req_keep_climate_on: u8, ui_hvac_req_manual_defog_state: u8, ui_hvac_req_recirc: u8, ui_hvac_req_second_row_state: u8, ui_hvac_req_temp_setpoint_left: f32, ui_hvac_req_temp_setpoint_right: f32, ui_hvac_req_user_power_state: u8, ui_hvac_use_modeled_duct_temp: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_ui_hvac_req_ac_disable(ui_hvac_req_ac_disable)?;
        res.set_ui_hvac_req_air_distribution_mode(ui_hvac_req_air_distribution_mode)?;
        res.set_ui_hvac_req_blower_segment(ui_hvac_req_blower_segment)?;
        res.set_ui_hvac_req_keep_climate_on(ui_hvac_req_keep_climate_on)?;
        res.set_ui_hvac_req_manual_defog_state(ui_hvac_req_manual_defog_state)?;
        res.set_ui_hvac_req_recirc(ui_hvac_req_recirc)?;
        res.set_ui_hvac_req_second_row_state(ui_hvac_req_second_row_state)?;
        res.set_ui_hvac_req_temp_setpoint_left(ui_hvac_req_temp_setpoint_left)?;
        res.set_ui_hvac_req_temp_setpoint_right(ui_hvac_req_temp_setpoint_right)?;
        res.set_ui_hvac_req_user_power_state(ui_hvac_req_user_power_state)?;
        res.set_ui_hvac_use_modeled_duct_temp(ui_hvac_use_modeled_duct_temp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_hvacReqACDisable
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_ac_disable(&self) -> Id2f3uiHvacRequestUiHvacReqAcDisable {
        match self.ui_hvac_req_ac_disable_raw() {
            0 => Id2f3uiHvacRequestUiHvacReqAcDisable::Auto,
            1 => Id2f3uiHvacRequestUiHvacReqAcDisable::Off,
            2 => Id2f3uiHvacRequestUiHvacReqAcDisable::On,
            x => Id2f3uiHvacRequestUiHvacReqAcDisable::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqACDisable
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_ac_disable_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqACDisable
    #[inline(always)]
    pub fn set_ui_hvac_req_ac_disable(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqAirDistributionMode
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_air_distribution_mode(&self) -> Id2f3uiHvacRequestUiHvacReqAirDistributionMode {
        match self.ui_hvac_req_air_distribution_mode_raw() {
            0 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::Auto,
            4 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualDefrost,
            5 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualDefrostFloor,
            6 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualDefrostPanel,
            7 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualDefrostPanelFloor,
            1 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualFloor,
            2 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualPanel,
            3 => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::ManualPanelFloor,
            x => Id2f3uiHvacRequestUiHvacReqAirDistributionMode::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqAirDistributionMode
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_air_distribution_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqAirDistributionMode
    #[inline(always)]
    pub fn set_ui_hvac_req_air_distribution_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..16].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqBlowerSegment
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_blower_segment(&self) -> Id2f3uiHvacRequestUiHvacReqBlowerSegment {
        match self.ui_hvac_req_blower_segment_raw() {
            1 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X1,
            10 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X10,
            2 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X2,
            3 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X3,
            4 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X4,
            5 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X5,
            6 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X6,
            7 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X7,
            8 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X8,
            9 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::X9,
            11 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::Auto,
            0 => Id2f3uiHvacRequestUiHvacReqBlowerSegment::Off,
            x => Id2f3uiHvacRequestUiHvacReqBlowerSegment::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqBlowerSegment
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_blower_segment_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqBlowerSegment
    #[inline(always)]
    pub fn set_ui_hvac_req_blower_segment(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqKeepClimateOn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_keep_climate_on(&self) -> Id2f3uiHvacRequestUiHvacReqKeepClimateOn {
        match self.ui_hvac_req_keep_climate_on_raw() {
            2 => Id2f3uiHvacRequestUiHvacReqKeepClimateOn::KeepClimateOnReqDog,
            0 => Id2f3uiHvacRequestUiHvacReqKeepClimateOn::KeepClimateOnReqOff,
            1 => Id2f3uiHvacRequestUiHvacReqKeepClimateOn::KeepClimateOnReqOn,
            3 => Id2f3uiHvacRequestUiHvacReqKeepClimateOn::KeepClimateOnReqParty,
            x => Id2f3uiHvacRequestUiHvacReqKeepClimateOn::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqKeepClimateOn
    ///
    /// - Start bit: 33
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_keep_climate_on_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[33..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqKeepClimateOn
    #[inline(always)]
    pub fn set_ui_hvac_req_keep_climate_on(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[33..35].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqManualDefogState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_manual_defog_state(&self) -> Id2f3uiHvacRequestUiHvacReqManualDefogState {
        match self.ui_hvac_req_manual_defog_state_raw() {
            1 => Id2f3uiHvacRequestUiHvacReqManualDefogState::Defog,
            2 => Id2f3uiHvacRequestUiHvacReqManualDefogState::Defrost,
            0 => Id2f3uiHvacRequestUiHvacReqManualDefogState::None,
            x => Id2f3uiHvacRequestUiHvacReqManualDefogState::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqManualDefogState
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_manual_defog_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqManualDefogState
    #[inline(always)]
    pub fn set_ui_hvac_req_manual_defog_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqRecirc
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_recirc(&self) -> Id2f3uiHvacRequestUiHvacReqRecirc {
        match self.ui_hvac_req_recirc_raw() {
            0 => Id2f3uiHvacRequestUiHvacReqRecirc::Auto,
            2 => Id2f3uiHvacRequestUiHvacReqRecirc::Fresh,
            1 => Id2f3uiHvacRequestUiHvacReqRecirc::Recirc,
            x => Id2f3uiHvacRequestUiHvacReqRecirc::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqRecirc
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_recirc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqRecirc
    #[inline(always)]
    pub fn set_ui_hvac_req_recirc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..22].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqSecondRowState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_second_row_state(&self) -> Id2f3uiHvacRequestUiHvacReqSecondRowState {
        match self.ui_hvac_req_second_row_state_raw() {
            0 => Id2f3uiHvacRequestUiHvacReqSecondRowState::Auto,
            4 => Id2f3uiHvacRequestUiHvacReqSecondRowState::High,
            2 => Id2f3uiHvacRequestUiHvacReqSecondRowState::Low,
            3 => Id2f3uiHvacRequestUiHvacReqSecondRowState::Med,
            1 => Id2f3uiHvacRequestUiHvacReqSecondRowState::Off,
            x => Id2f3uiHvacRequestUiHvacReqSecondRowState::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqSecondRowState
    ///
    /// - Start bit: 29
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_second_row_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[29..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqSecondRowState
    #[inline(always)]
    pub fn set_ui_hvac_req_second_row_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[29..32].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqTempSetpointLeft
    ///
    /// - Min: 15
    /// - Max: 28
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_temp_setpoint_left(&self) -> Id2f3uiHvacRequestUiHvacReqTempSetpointLeft {
        match self.ui_hvac_req_temp_setpoint_left_raw() {
            26 => Id2f3uiHvacRequestUiHvacReqTempSetpointLeft::Hi,
            0 => Id2f3uiHvacRequestUiHvacReqTempSetpointLeft::Lo,
            x => Id2f3uiHvacRequestUiHvacReqTempSetpointLeft::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqTempSetpointLeft
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 0.5
    /// - Offset: 15
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_temp_setpoint_left_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..5].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 15_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_hvacReqTempSetpointLeft
    #[inline(always)]
    pub fn set_ui_hvac_req_temp_setpoint_left(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 15_f32 || 28_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        let factor = 0.5_f32;
        let offset = 15_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..5].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqTempSetpointRight
    ///
    /// - Min: 15
    /// - Max: 28
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_temp_setpoint_right(&self) -> Id2f3uiHvacRequestUiHvacReqTempSetpointRight {
        match self.ui_hvac_req_temp_setpoint_right_raw() {
            26 => Id2f3uiHvacRequestUiHvacReqTempSetpointRight::Hi,
            0 => Id2f3uiHvacRequestUiHvacReqTempSetpointRight::Lo,
            x => Id2f3uiHvacRequestUiHvacReqTempSetpointRight::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqTempSetpointRight
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 0.5
    /// - Offset: 15
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_temp_setpoint_right_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..13].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 15_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_hvacReqTempSetpointRight
    #[inline(always)]
    pub fn set_ui_hvac_req_temp_setpoint_right(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 15_f32 || 28_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        let factor = 0.5_f32;
        let offset = 15_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..13].store_le(value);
        Ok(())
    }
    
    /// UI_hvacReqUserPowerState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_req_user_power_state(&self) -> Id2f3uiHvacRequestUiHvacReqUserPowerState {
        match self.ui_hvac_req_user_power_state_raw() {
            0 => Id2f3uiHvacRequestUiHvacReqUserPowerState::Off,
            1 => Id2f3uiHvacRequestUiHvacReqUserPowerState::On,
            4 => Id2f3uiHvacRequestUiHvacReqUserPowerState::OverheatProtect,
            3 => Id2f3uiHvacRequestUiHvacReqUserPowerState::OverheatProtectFanonly,
            2 => Id2f3uiHvacRequestUiHvacReqUserPowerState::Precondition,
            x => Id2f3uiHvacRequestUiHvacReqUserPowerState::Other(x),
        }
    }
    
    /// Get raw value of UI_hvacReqUserPowerState
    ///
    /// - Start bit: 26
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_req_user_power_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_hvacReqUserPowerState
    #[inline(always)]
    pub fn set_ui_hvac_req_user_power_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 755 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..29].store_le(value);
        Ok(())
    }
    
    /// UI_hvacUseModeledDuctTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_hvac_use_modeled_duct_temp(&self) -> bool {
        self.ui_hvac_use_modeled_duct_temp_raw()
    }
    
    /// Get raw value of UI_hvacUseModeledDuctTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_hvac_use_modeled_duct_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_hvacUseModeledDuctTemp
    #[inline(always)]
    pub fn set_ui_hvac_use_modeled_duct_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2f3uiHvacRequest {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2f3uiHvacRequest
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_hvac_req_ac_disable = u.int_in_range(0..=2)?;
        let ui_hvac_req_air_distribution_mode = u.int_in_range(0..=7)?;
        let ui_hvac_req_blower_segment = u.int_in_range(0..=11)?;
        let ui_hvac_req_keep_climate_on = u.int_in_range(0..=3)?;
        let ui_hvac_req_manual_defog_state = u.int_in_range(0..=2)?;
        let ui_hvac_req_recirc = u.int_in_range(0..=2)?;
        let ui_hvac_req_second_row_state = u.int_in_range(0..=4)?;
        let ui_hvac_req_temp_setpoint_left = 15_f32;
        let ui_hvac_req_temp_setpoint_right = 15_f32;
        let ui_hvac_req_user_power_state = u.int_in_range(0..=4)?;
        let ui_hvac_use_modeled_duct_temp = u.int_in_range(0..=1)? == 1;
        Id2f3uiHvacRequest::new(ui_hvac_req_ac_disable,ui_hvac_req_air_distribution_mode,ui_hvac_req_blower_segment,ui_hvac_req_keep_climate_on,ui_hvac_req_manual_defog_state,ui_hvac_req_recirc,ui_hvac_req_second_row_state,ui_hvac_req_temp_setpoint_left,ui_hvac_req_temp_setpoint_right,ui_hvac_req_user_power_state,ui_hvac_use_modeled_duct_temp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_hvacReqACDisable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqAcDisable {
    Auto,
    Off,
    On,
    Other(u8),
}
/// Defined values for UI_hvacReqAirDistributionMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqAirDistributionMode {
    Auto,
    ManualDefrost,
    ManualDefrostFloor,
    ManualDefrostPanel,
    ManualDefrostPanelFloor,
    ManualFloor,
    ManualPanel,
    ManualPanelFloor,
    Other(u8),
}
/// Defined values for UI_hvacReqBlowerSegment
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqBlowerSegment {
    X1,
    X10,
    X2,
    X3,
    X4,
    X5,
    X6,
    X7,
    X8,
    X9,
    Auto,
    Off,
    Other(u8),
}
/// Defined values for UI_hvacReqKeepClimateOn
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqKeepClimateOn {
    KeepClimateOnReqDog,
    KeepClimateOnReqOff,
    KeepClimateOnReqOn,
    KeepClimateOnReqParty,
    Other(u8),
}
/// Defined values for UI_hvacReqManualDefogState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqManualDefogState {
    Defog,
    Defrost,
    None,
    Other(u8),
}
/// Defined values for UI_hvacReqRecirc
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqRecirc {
    Auto,
    Fresh,
    Recirc,
    Other(u8),
}
/// Defined values for UI_hvacReqSecondRowState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqSecondRowState {
    Auto,
    High,
    Low,
    Med,
    Off,
    Other(u8),
}
/// Defined values for UI_hvacReqTempSetpointLeft
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqTempSetpointLeft {
    Hi,
    Lo,
    Other(f32),
}
/// Defined values for UI_hvacReqTempSetpointRight
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqTempSetpointRight {
    Hi,
    Lo,
    Other(f32),
}
/// Defined values for UI_hvacReqUserPowerState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f3uiHvacRequestUiHvacReqUserPowerState {
    Off,
    On,
    OverheatProtect,
    OverheatProtectFanonly,
    Precondition,
    Other(u8),
}

/// ID313UI_trackModeSettings
///
/// - ID: 787 (0x313)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id313uiTrackModeSettings {
    raw: [u8; 8],
}

impl Id313uiTrackModeSettings {
    pub const MESSAGE_ID: u32 = 787;
    
    /// Construct new ID313UI_trackModeSettings from values
    pub fn new(ui_track_cmp_overclock: bool, ui_track_mode_request: u8, ui_track_mode_settings_checksum: u8, ui_track_mode_settings_counter: u8, ui_track_post_cooling: bool, ui_track_rotation_tendency: f32, ui_track_stability_assist: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_track_cmp_overclock(ui_track_cmp_overclock)?;
        res.set_ui_track_mode_request(ui_track_mode_request)?;
        res.set_ui_track_mode_settings_checksum(ui_track_mode_settings_checksum)?;
        res.set_ui_track_mode_settings_counter(ui_track_mode_settings_counter)?;
        res.set_ui_track_post_cooling(ui_track_post_cooling)?;
        res.set_ui_track_rotation_tendency(ui_track_rotation_tendency)?;
        res.set_ui_track_stability_assist(ui_track_stability_assist)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_trackCmpOverclock
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_cmp_overclock(&self) -> Id313uiTrackModeSettingsUiTrackCmpOverclock {
        match self.ui_track_cmp_overclock_raw() {
            false => Id313uiTrackModeSettingsUiTrackCmpOverclock::TrackModeCmpOverclockOff,
            true => Id313uiTrackModeSettingsUiTrackCmpOverclock::TrackModeCmpOverclockOn,
            x => Id313uiTrackModeSettingsUiTrackCmpOverclock::Other(x),
        }
    }
    
    /// Get raw value of UI_trackCmpOverclock
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_cmp_overclock_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_trackCmpOverclock
    #[inline(always)]
    pub fn set_ui_track_cmp_overclock(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// UI_trackModeRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_mode_request(&self) -> Id313uiTrackModeSettingsUiTrackModeRequest {
        match self.ui_track_mode_request_raw() {
            0 => Id313uiTrackModeSettingsUiTrackModeRequest::TrackModeRequestIdle,
            2 => Id313uiTrackModeSettingsUiTrackModeRequest::TrackModeRequestOff,
            1 => Id313uiTrackModeSettingsUiTrackModeRequest::TrackModeRequestOn,
            x => Id313uiTrackModeSettingsUiTrackModeRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_trackModeRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_mode_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_trackModeRequest
    #[inline(always)]
    pub fn set_ui_track_mode_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 787 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// UI_trackModeSettingsChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_mode_settings_checksum(&self) -> u8 {
        self.ui_track_mode_settings_checksum_raw()
    }
    
    /// Get raw value of UI_trackModeSettingsChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_mode_settings_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_trackModeSettingsChecksum
    #[inline(always)]
    pub fn set_ui_track_mode_settings_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 787 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// UI_trackModeSettingsCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_mode_settings_counter(&self) -> u8 {
        self.ui_track_mode_settings_counter_raw()
    }
    
    /// Get raw value of UI_trackModeSettingsCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_mode_settings_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_trackModeSettingsCounter
    #[inline(always)]
    pub fn set_ui_track_mode_settings_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 787 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// UI_trackPostCooling
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_post_cooling(&self) -> Id313uiTrackModeSettingsUiTrackPostCooling {
        match self.ui_track_post_cooling_raw() {
            false => Id313uiTrackModeSettingsUiTrackPostCooling::TrackModePostCoolingOff,
            true => Id313uiTrackModeSettingsUiTrackPostCooling::TrackModePostCoolingOn,
            x => Id313uiTrackModeSettingsUiTrackPostCooling::Other(x),
        }
    }
    
    /// Get raw value of UI_trackPostCooling
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_post_cooling_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_trackPostCooling
    #[inline(always)]
    pub fn set_ui_track_post_cooling(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// UI_trackRotationTendency
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_rotation_tendency(&self) -> f32 {
        self.ui_track_rotation_tendency_raw()
    }
    
    /// Get raw value of UI_trackRotationTendency
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_rotation_tendency_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_trackRotationTendency
    #[inline(always)]
    pub fn set_ui_track_rotation_tendency(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 787 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// UI_trackStabilityAssist
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_track_stability_assist(&self) -> f32 {
        self.ui_track_stability_assist_raw()
    }
    
    /// Get raw value of UI_trackStabilityAssist
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_track_stability_assist_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_trackStabilityAssist
    #[inline(always)]
    pub fn set_ui_track_stability_assist(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 787 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id313uiTrackModeSettings {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id313uiTrackModeSettings
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_track_cmp_overclock = u.int_in_range(0..=1)? == 1;
        let ui_track_mode_request = u.int_in_range(0..=2)?;
        let ui_track_mode_settings_checksum = u.int_in_range(0..=255)?;
        let ui_track_mode_settings_counter = u.int_in_range(0..=15)?;
        let ui_track_post_cooling = u.int_in_range(0..=1)? == 1;
        let ui_track_rotation_tendency = 0_f32;
        let ui_track_stability_assist = 0_f32;
        Id313uiTrackModeSettings::new(ui_track_cmp_overclock,ui_track_mode_request,ui_track_mode_settings_checksum,ui_track_mode_settings_counter,ui_track_post_cooling,ui_track_rotation_tendency,ui_track_stability_assist).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_trackCmpOverclock
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id313uiTrackModeSettingsUiTrackCmpOverclock {
    TrackModeCmpOverclockOff,
    TrackModeCmpOverclockOn,
    Other(bool),
}
/// Defined values for UI_trackModeRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id313uiTrackModeSettingsUiTrackModeRequest {
    TrackModeRequestIdle,
    TrackModeRequestOff,
    TrackModeRequestOn,
    Other(u8),
}
/// Defined values for UI_trackPostCooling
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id313uiTrackModeSettingsUiTrackPostCooling {
    TrackModePostCoolingOff,
    TrackModePostCoolingOn,
    Other(bool),
}

/// ID335RearDIinfo
///
/// - ID: 821 (0x335)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id335RearDIinfo {
    raw: [u8; 8],
}

impl Id335RearDIinfo {
    pub const MESSAGE_ID: u32 = 821;
    
    /// Construct new ID335RearDIinfo from values
    pub fn new(dir_info_index: u8, dir_fpga_version: u8, dir_app_git_hash: u64, dir_application_crc: u32, dir_assembly_id: u8, dir_boot_git_hash: u64, dir_bootloader_crc: u32, dir_build_configuration_id: u16, dir_build_type: u8, dir_component_id: u16, dir_hardware_id: u8, dir_info_boot_ld_uds_protocol_version: u8, dir_oil_pump_app_crc: u32, dir_oil_pump_build_type: u8, dir_pcba_id: u8, dir_platform_typ: u8, dir_sub_usage_id: u16, dir_subcomponent_git_hash: u64, dir_usage_id: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_dir_info_index(dir_info_index)?;
        res.set_dir_fpga_version(dir_fpga_version)?;
        res.set_dir_app_git_hash(dir_app_git_hash)?;
        res.set_dir_application_crc(dir_application_crc)?;
        res.set_dir_assembly_id(dir_assembly_id)?;
        res.set_dir_boot_git_hash(dir_boot_git_hash)?;
        res.set_dir_bootloader_crc(dir_bootloader_crc)?;
        res.set_dir_build_configuration_id(dir_build_configuration_id)?;
        res.set_dir_build_type(dir_build_type)?;
        res.set_dir_component_id(dir_component_id)?;
        res.set_dir_hardware_id(dir_hardware_id)?;
        res.set_dir_info_boot_ld_uds_protocol_version(dir_info_boot_ld_uds_protocol_version)?;
        res.set_dir_oil_pump_app_crc(dir_oil_pump_app_crc)?;
        res.set_dir_oil_pump_build_type(dir_oil_pump_build_type)?;
        res.set_dir_pcba_id(dir_pcba_id)?;
        res.set_dir_platform_typ(dir_platform_typ)?;
        res.set_dir_sub_usage_id(dir_sub_usage_id)?;
        res.set_dir_subcomponent_git_hash(dir_subcomponent_git_hash)?;
        res.set_dir_usage_id(dir_usage_id)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DIR_infoIndex
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_info_index(&self) -> Id335RearDIinfoDirInfoIndex {
        match self.dir_info_index_raw() {
            13 => Id335RearDIinfoDirInfoIndex::DiInfoAppCrc,
            17 => Id335RearDIinfoDirInfoIndex::DiInfoAppGithash,
            15 => Id335RearDIinfoDirInfoIndex::DiInfoBootloaderCrc,
            18 => Id335RearDIinfoDirInfoIndex::DiInfoBootloaderGithash,
            14 => Id335RearDIinfoDirInfoIndex::DiInfoBootloaderSvn,
            10 => Id335RearDIinfoDirInfoIndex::DiInfoBuildHwidComponentid,
            0 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated0,
            1 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated1,
            2 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated2,
            3 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated3,
            4 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated4,
            5 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated5,
            6 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated6,
            7 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated7,
            8 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated8,
            9 => Id335RearDIinfoDirInfoIndex::DiInfoDeprecated9,
            255 => Id335RearDIinfoDirInfoIndex::DiInfoEnd,
            11 => Id335RearDIinfoDirInfoIndex::DiInfoPcbaidAssyidUsageid,
            16 => Id335RearDIinfoDirInfoIndex::DiInfoSubcomponent,
            23 => Id335RearDIinfoDirInfoIndex::DiInfoSubcomponent2,
            31 => Id335RearDIinfoDirInfoIndex::DiInfoSubcomponentGithash,
            20 => Id335RearDIinfoDirInfoIndex::DiInfoUdsProtocolBootcrc,
            19 => Id335RearDIinfoDirInfoIndex::DiInfoVersionDeprecated,
            x => Id335RearDIinfoDirInfoIndex::Other(x),
        }
    }
    
    /// Get raw value of DIR_infoIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_info_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_infoIndex
    #[inline(always)]
    pub fn set_dir_info_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// DIR_FPGA_version
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_fpga_version(&self) -> Id335RearDIinfoDirFpgaVersion {
        match self.dir_fpga_version_raw() {
            254 => Id335RearDIinfoDirFpgaVersion::FpgaVersionLocalBuild,
            255 => Id335RearDIinfoDirFpgaVersion::FpgaVersionSna,
            x => Id335RearDIinfoDirFpgaVersion::Other(x),
        }
    }
    
    /// Get raw value of DIR_FPGA_version
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_fpga_version_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_FPGA_version
    #[inline(always)]
    pub fn set_dir_fpga_version(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_appGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_app_git_hash(&self) -> u64 {
        self.dir_app_git_hash_raw()
    }
    
    /// Get raw value of DIR_appGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_app_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of DIR_appGitHash
    #[inline(always)]
    pub fn set_dir_app_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// DIR_applicationCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_application_crc(&self) -> u32 {
        self.dir_application_crc_raw()
    }
    
    /// Get raw value of DIR_applicationCrc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_application_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIR_applicationCrc
    #[inline(always)]
    pub fn set_dir_application_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIR_assemblyId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_assembly_id(&self) -> u8 {
        self.dir_assembly_id_raw()
    }
    
    /// Get raw value of DIR_assemblyId
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_assembly_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_assemblyId
    #[inline(always)]
    pub fn set_dir_assembly_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_bootGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_boot_git_hash(&self) -> u64 {
        self.dir_boot_git_hash_raw()
    }
    
    /// Get raw value of DIR_bootGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_boot_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of DIR_bootGitHash
    #[inline(always)]
    pub fn set_dir_boot_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// DIR_bootloaderCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_bootloader_crc(&self) -> u32 {
        self.dir_bootloader_crc_raw()
    }
    
    /// Get raw value of DIR_bootloaderCrc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_bootloader_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIR_bootloaderCrc
    #[inline(always)]
    pub fn set_dir_bootloader_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIR_buildConfigurationId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_build_configuration_id(&self) -> u16 {
        self.dir_build_configuration_id_raw()
    }
    
    /// Get raw value of DIR_buildConfigurationId
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_build_configuration_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_buildConfigurationId
    #[inline(always)]
    pub fn set_dir_build_configuration_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_buildType
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_build_type(&self) -> Id335RearDIinfoDirBuildType {
        match self.dir_build_type_raw() {
            2 => Id335RearDIinfoDirBuildType::InfoLocalBuild,
            4 => Id335RearDIinfoDirBuildType::InfoMfgBuild,
            1 => Id335RearDIinfoDirBuildType::InfoPlatformBuild,
            3 => Id335RearDIinfoDirBuildType::InfoTraceableCiBuild,
            0 => Id335RearDIinfoDirBuildType::InfoUnknownBuild,
            x => Id335RearDIinfoDirBuildType::Other(x),
        }
    }
    
    /// Get raw value of DIR_buildType
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_build_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_buildType
    #[inline(always)]
    pub fn set_dir_build_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// DIR_componentId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_component_id(&self) -> u16 {
        self.dir_component_id_raw()
    }
    
    /// Get raw value of DIR_componentId
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_component_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_componentId
    #[inline(always)]
    pub fn set_dir_component_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_hardwareId
    ///
    /// - Min: 0
    /// - Max: 252
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_hardware_id(&self) -> Id335RearDIinfoDirHardwareId {
        match self.dir_hardware_id_raw() {
            252 => Id335RearDIinfoDirHardwareId::ConfigurableHwidPlaceholder,
            x => Id335RearDIinfoDirHardwareId::Other(x),
        }
    }
    
    /// Get raw value of DIR_hardwareId
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_hardware_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_hardwareId
    #[inline(always)]
    pub fn set_dir_hardware_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 252_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_infoBootLdUdsProtocolVersion
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_info_boot_ld_uds_protocol_version(&self) -> u8 {
        self.dir_info_boot_ld_uds_protocol_version_raw()
    }
    
    /// Get raw value of DIR_infoBootLdUdsProtocolVersion
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_info_boot_ld_uds_protocol_version_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_infoBootLdUdsProtocolVersion
    #[inline(always)]
    pub fn set_dir_info_boot_ld_uds_protocol_version(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_oilPumpAppCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_oil_pump_app_crc(&self) -> u32 {
        self.dir_oil_pump_app_crc_raw()
    }
    
    /// Get raw value of DIR_oilPumpAppCrc
    ///
    /// - Start bit: 16
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_oil_pump_app_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..48].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIR_oilPumpAppCrc
    #[inline(always)]
    pub fn set_dir_oil_pump_app_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..48].store_le(value);
        Ok(())
    }
    
    /// DIR_oilPumpBuildType
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_oil_pump_build_type(&self) -> Id335RearDIinfoDirOilPumpBuildType {
        match self.dir_oil_pump_build_type_raw() {
            2 => Id335RearDIinfoDirOilPumpBuildType::InfoLocalBuild,
            4 => Id335RearDIinfoDirOilPumpBuildType::InfoMfgBuild,
            1 => Id335RearDIinfoDirOilPumpBuildType::InfoPlatformBuild,
            3 => Id335RearDIinfoDirOilPumpBuildType::InfoTraceableCiBuild,
            0 => Id335RearDIinfoDirOilPumpBuildType::InfoUnknownBuild,
            x => Id335RearDIinfoDirOilPumpBuildType::Other(x),
        }
    }
    
    /// Get raw value of DIR_oilPumpBuildType
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_oil_pump_build_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_oilPumpBuildType
    #[inline(always)]
    pub fn set_dir_oil_pump_build_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// DIR_pcbaId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pcba_id(&self) -> u8 {
        self.dir_pcba_id_raw()
    }
    
    /// Get raw value of DIR_pcbaId
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pcba_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_pcbaId
    #[inline(always)]
    pub fn set_dir_pcba_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_platformTyp
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_platform_typ(&self) -> u8 {
        self.dir_platform_typ_raw()
    }
    
    /// Get raw value of DIR_platformTyp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_platform_typ_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_platformTyp
    #[inline(always)]
    pub fn set_dir_platform_typ(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_subUsageId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_sub_usage_id(&self) -> u16 {
        self.dir_sub_usage_id_raw()
    }
    
    /// Get raw value of DIR_subUsageId
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_sub_usage_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_subUsageId
    #[inline(always)]
    pub fn set_dir_sub_usage_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_subcomponentGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_subcomponent_git_hash(&self) -> u64 {
        self.dir_subcomponent_git_hash_raw()
    }
    
    /// Get raw value of DIR_subcomponentGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_subcomponent_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of DIR_subcomponentGitHash
    #[inline(always)]
    pub fn set_dir_subcomponent_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// DIR_usageId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_usage_id(&self) -> u16 {
        self.dir_usage_id_raw()
    }
    
    /// Get raw value of DIR_usageId
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_usage_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_usageId
    #[inline(always)]
    pub fn set_dir_usage_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 821 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id335RearDIinfo {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id335RearDIinfo
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let dir_info_index = u.int_in_range(0..=255)?;
        let dir_fpga_version = u.int_in_range(0..=255)?;
        let dir_app_git_hash = u.int_in_range(0..=72057600000000000)?;
        let dir_application_crc = u.int_in_range(0..=4294970000)?;
        let dir_assembly_id = u.int_in_range(0..=255)?;
        let dir_boot_git_hash = u.int_in_range(0..=72057600000000000)?;
        let dir_bootloader_crc = u.int_in_range(0..=4294970000)?;
        let dir_build_configuration_id = u.int_in_range(0..=65535)?;
        let dir_build_type = u.int_in_range(0..=4)?;
        let dir_component_id = u.int_in_range(0..=65535)?;
        let dir_hardware_id = u.int_in_range(0..=252)?;
        let dir_info_boot_ld_uds_protocol_version = u.int_in_range(0..=255)?;
        let dir_oil_pump_app_crc = u.int_in_range(0..=4294970000)?;
        let dir_oil_pump_build_type = u.int_in_range(0..=4)?;
        let dir_pcba_id = u.int_in_range(0..=255)?;
        let dir_platform_typ = u.int_in_range(0..=255)?;
        let dir_sub_usage_id = u.int_in_range(0..=65535)?;
        let dir_subcomponent_git_hash = u.int_in_range(0..=72057600000000000)?;
        let dir_usage_id = u.int_in_range(0..=65535)?;
        Id335RearDIinfo::new(dir_info_index,dir_fpga_version,dir_app_git_hash,dir_application_crc,dir_assembly_id,dir_boot_git_hash,dir_bootloader_crc,dir_build_configuration_id,dir_build_type,dir_component_id,dir_hardware_id,dir_info_boot_ld_uds_protocol_version,dir_oil_pump_app_crc,dir_oil_pump_build_type,dir_pcba_id,dir_platform_typ,dir_sub_usage_id,dir_subcomponent_git_hash,dir_usage_id).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DIR_infoIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id335RearDIinfoDirInfoIndex {
    DiInfoAppCrc,
    DiInfoAppGithash,
    DiInfoBootloaderCrc,
    DiInfoBootloaderGithash,
    DiInfoBootloaderSvn,
    DiInfoBuildHwidComponentid,
    DiInfoDeprecated0,
    DiInfoDeprecated1,
    DiInfoDeprecated2,
    DiInfoDeprecated3,
    DiInfoDeprecated4,
    DiInfoDeprecated5,
    DiInfoDeprecated6,
    DiInfoDeprecated7,
    DiInfoDeprecated8,
    DiInfoDeprecated9,
    DiInfoEnd,
    DiInfoPcbaidAssyidUsageid,
    DiInfoSubcomponent,
    DiInfoSubcomponent2,
    DiInfoSubcomponentGithash,
    DiInfoUdsProtocolBootcrc,
    DiInfoVersionDeprecated,
    Other(u8),
}
/// Defined values for DIR_FPGA_version
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id335RearDIinfoDirFpgaVersion {
    FpgaVersionLocalBuild,
    FpgaVersionSna,
    Other(u8),
}
/// Defined values for DIR_buildType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id335RearDIinfoDirBuildType {
    InfoLocalBuild,
    InfoMfgBuild,
    InfoPlatformBuild,
    InfoTraceableCiBuild,
    InfoUnknownBuild,
    Other(u8),
}
/// Defined values for DIR_hardwareId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id335RearDIinfoDirHardwareId {
    ConfigurableHwidPlaceholder,
    Other(u8),
}
/// Defined values for DIR_oilPumpBuildType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id335RearDIinfoDirOilPumpBuildType {
    InfoLocalBuild,
    InfoMfgBuild,
    InfoPlatformBuild,
    InfoTraceableCiBuild,
    InfoUnknownBuild,
    Other(u8),
}

/// ID383VCRIGHT_thsStatus
///
/// - ID: 899 (0x383)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id383vcrightThsStatus {
    raw: [u8; 8],
}

impl Id383vcrightThsStatus {
    pub const MESSAGE_ID: u32 = 899;
    
    /// Construct new ID383VCRIGHT_thsStatus from values
    pub fn new(vcright_estimated_ths_solar_load: u16, vcright_estimated_vehicle_situatio: u8, vcright_ths_active: bool, vcright_ths_humidity: u8, vcright_ths_solar_load_infrared: u16, vcright_ths_solar_load_visible: u16, vcright_ths_temperature: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcright_estimated_ths_solar_load(vcright_estimated_ths_solar_load)?;
        res.set_vcright_estimated_vehicle_situatio(vcright_estimated_vehicle_situatio)?;
        res.set_vcright_ths_active(vcright_ths_active)?;
        res.set_vcright_ths_humidity(vcright_ths_humidity)?;
        res.set_vcright_ths_solar_load_infrared(vcright_ths_solar_load_infrared)?;
        res.set_vcright_ths_solar_load_visible(vcright_ths_solar_load_visible)?;
        res.set_vcright_ths_temperature(vcright_ths_temperature)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_estimatedThsSolarLoad
    ///
    /// - Min: 0
    /// - Max: 1022
    /// - Unit: "W/m2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_estimated_ths_solar_load(&self) -> Id383vcrightThsStatusVcrightEstimatedThsSolarLoad {
        match self.vcright_estimated_ths_solar_load_raw() {
            1023 => Id383vcrightThsStatusVcrightEstimatedThsSolarLoad::Sna,
            x => Id383vcrightThsStatusVcrightEstimatedThsSolarLoad::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_estimatedThsSolarLoad
    ///
    /// - Start bit: 53
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_estimated_ths_solar_load_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[53..63].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCRIGHT_estimatedThsSolarLoad
    #[inline(always)]
    pub fn set_vcright_estimated_ths_solar_load(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1022_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 899 }); }
        self.raw.view_bits_mut::<LocalBits>()[53..63].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_estimatedVehicleSituatio
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_estimated_vehicle_situatio(&self) -> Id383vcrightThsStatusVcrightEstimatedVehicleSituatio {
        match self.vcright_estimated_vehicle_situatio_raw() {
            1 => Id383vcrightThsStatusVcrightEstimatedVehicleSituatio::VehicleSituationIndoor,
            2 => Id383vcrightThsStatusVcrightEstimatedVehicleSituatio::VehicleSituationOutdoor,
            0 => Id383vcrightThsStatusVcrightEstimatedVehicleSituatio::VehicleSituationUnknown,
            x => Id383vcrightThsStatusVcrightEstimatedVehicleSituatio::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_estimatedVehicleSituatio
    ///
    /// - Start bit: 31
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_estimated_vehicle_situatio_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[31..33].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_estimatedVehicleSituatio
    #[inline(always)]
    pub fn set_vcright_estimated_vehicle_situatio(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 899 }); }
        self.raw.view_bits_mut::<LocalBits>()[31..33].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_thsActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ths_active(&self) -> bool {
        self.vcright_ths_active_raw()
    }
    
    /// Get raw value of VCRIGHT_thsActive
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_ths_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_thsActive
    #[inline(always)]
    pub fn set_vcright_ths_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_thsHumidity
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ths_humidity(&self) -> Id383vcrightThsStatusVcrightThsHumidity {
        match self.vcright_ths_humidity_raw() {
            255 => Id383vcrightThsStatusVcrightThsHumidity::Sna,
            x => Id383vcrightThsStatusVcrightThsHumidity::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_thsHumidity
    ///
    /// - Start bit: 17
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_ths_humidity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[17..25].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_thsHumidity
    #[inline(always)]
    pub fn set_vcright_ths_humidity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 899 }); }
        self.raw.view_bits_mut::<LocalBits>()[17..25].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_thsSolarLoadInfrared
    ///
    /// - Min: 0
    /// - Max: 1022
    /// - Unit: "W/m2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ths_solar_load_infrared(&self) -> Id383vcrightThsStatusVcrightThsSolarLoadInfrared {
        match self.vcright_ths_solar_load_infrared_raw() {
            1023 => Id383vcrightThsStatusVcrightThsSolarLoadInfrared::Sna,
            x => Id383vcrightThsStatusVcrightThsSolarLoadInfrared::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_thsSolarLoadInfrared
    ///
    /// - Start bit: 33
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_ths_solar_load_infrared_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[33..43].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCRIGHT_thsSolarLoadInfrared
    #[inline(always)]
    pub fn set_vcright_ths_solar_load_infrared(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1022_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 899 }); }
        self.raw.view_bits_mut::<LocalBits>()[33..43].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_thsSolarLoadVisible
    ///
    /// - Min: 0
    /// - Max: 1022
    /// - Unit: "W/m2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ths_solar_load_visible(&self) -> Id383vcrightThsStatusVcrightThsSolarLoadVisible {
        match self.vcright_ths_solar_load_visible_raw() {
            1023 => Id383vcrightThsStatusVcrightThsSolarLoadVisible::Sna,
            x => Id383vcrightThsStatusVcrightThsSolarLoadVisible::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_thsSolarLoadVisible
    ///
    /// - Start bit: 43
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_ths_solar_load_visible_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[43..53].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCRIGHT_thsSolarLoadVisible
    #[inline(always)]
    pub fn set_vcright_ths_solar_load_visible(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1022_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 899 }); }
        self.raw.view_bits_mut::<LocalBits>()[43..53].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_thsTemperature
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ths_temperature(&self) -> Id383vcrightThsStatusVcrightThsTemperature {
        match self.vcright_ths_temperature_raw() {
            128 => Id383vcrightThsStatusVcrightThsTemperature::Sna,
            x => Id383vcrightThsStatusVcrightThsTemperature::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_thsTemperature
    ///
    /// - Start bit: 1
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcright_ths_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[1..9].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_thsTemperature
    #[inline(always)]
    pub fn set_vcright_ths_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 899 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[1..9].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id383vcrightThsStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id383vcrightThsStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_estimated_ths_solar_load = u.int_in_range(0..=1022)?;
        let vcright_estimated_vehicle_situatio = u.int_in_range(0..=2)?;
        let vcright_ths_active = u.int_in_range(0..=1)? == 1;
        let vcright_ths_humidity = u.int_in_range(0..=100)?;
        let vcright_ths_solar_load_infrared = u.int_in_range(0..=1022)?;
        let vcright_ths_solar_load_visible = u.int_in_range(0..=1022)?;
        let vcright_ths_temperature = -40_f32;
        Id383vcrightThsStatus::new(vcright_estimated_ths_solar_load,vcright_estimated_vehicle_situatio,vcright_ths_active,vcright_ths_humidity,vcright_ths_solar_load_infrared,vcright_ths_solar_load_visible,vcright_ths_temperature).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_estimatedThsSolarLoad
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id383vcrightThsStatusVcrightEstimatedThsSolarLoad {
    Sna,
    Other(u16),
}
/// Defined values for VCRIGHT_estimatedVehicleSituatio
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id383vcrightThsStatusVcrightEstimatedVehicleSituatio {
    VehicleSituationIndoor,
    VehicleSituationOutdoor,
    VehicleSituationUnknown,
    Other(u8),
}
/// Defined values for VCRIGHT_thsHumidity
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id383vcrightThsStatusVcrightThsHumidity {
    Sna,
    Other(u8),
}
/// Defined values for VCRIGHT_thsSolarLoadInfrared
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id383vcrightThsStatusVcrightThsSolarLoadInfrared {
    Sna,
    Other(u16),
}
/// Defined values for VCRIGHT_thsSolarLoadVisible
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id383vcrightThsStatusVcrightThsSolarLoadVisible {
    Sna,
    Other(u16),
}
/// Defined values for VCRIGHT_thsTemperature
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id383vcrightThsStatusVcrightThsTemperature {
    Sna,
    Other(f32),
}

/// ID3B3UI_vehicleControl2
///
/// - ID: 947 (0x3b3)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3b3uiVehicleControl2 {
    raw: [u8; 4],
}

impl Id3b3uiVehicleControl2 {
    pub const MESSAGE_ID: u32 = 947;
    
    /// Construct new ID3B3UI_vehicleControl2 from values
    pub fn new(ui_pin_to_drive_enabled: bool, ui_pin_to_drive_passed: bool, ui_umc_update_inhibit: bool, ui_vcleft_feature1: bool, ui_vcsec_feature1: bool, ui_wc_update_inhibit: bool, ui_alarm_trigger_request: bool, ui_auto_roll_windows_on_lock_enable: bool, ui_autopilot_power_state_request: u8, ui_battery_preconditioning_request: bool, ui_coast_down_mode: bool, ui_conditional_logging_enabled_vcse: bool, ui_efuse_mx_resistance_est_armed: bool, ui_free_roll_mode_request: bool, ui_glovebox_request: bool, ui_light_switch: u8, ui_locks_panel_active: bool, ui_ready_to_add_key: bool, ui_shorted12_v_cell_test_mode: u8, ui_sound_horn_on_lock: bool, ui_summon_state: u8, ui_trunk_request: bool, ui_user_present: bool, ui_window_request: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_ui_pin_to_drive_enabled(ui_pin_to_drive_enabled)?;
        res.set_ui_pin_to_drive_passed(ui_pin_to_drive_passed)?;
        res.set_ui_umc_update_inhibit(ui_umc_update_inhibit)?;
        res.set_ui_vcleft_feature1(ui_vcleft_feature1)?;
        res.set_ui_vcsec_feature1(ui_vcsec_feature1)?;
        res.set_ui_wc_update_inhibit(ui_wc_update_inhibit)?;
        res.set_ui_alarm_trigger_request(ui_alarm_trigger_request)?;
        res.set_ui_auto_roll_windows_on_lock_enable(ui_auto_roll_windows_on_lock_enable)?;
        res.set_ui_autopilot_power_state_request(ui_autopilot_power_state_request)?;
        res.set_ui_battery_preconditioning_request(ui_battery_preconditioning_request)?;
        res.set_ui_coast_down_mode(ui_coast_down_mode)?;
        res.set_ui_conditional_logging_enabled_vcse(ui_conditional_logging_enabled_vcse)?;
        res.set_ui_efuse_mx_resistance_est_armed(ui_efuse_mx_resistance_est_armed)?;
        res.set_ui_free_roll_mode_request(ui_free_roll_mode_request)?;
        res.set_ui_glovebox_request(ui_glovebox_request)?;
        res.set_ui_light_switch(ui_light_switch)?;
        res.set_ui_locks_panel_active(ui_locks_panel_active)?;
        res.set_ui_ready_to_add_key(ui_ready_to_add_key)?;
        res.set_ui_shorted12_v_cell_test_mode(ui_shorted12_v_cell_test_mode)?;
        res.set_ui_sound_horn_on_lock(ui_sound_horn_on_lock)?;
        res.set_ui_summon_state(ui_summon_state)?;
        res.set_ui_trunk_request(ui_trunk_request)?;
        res.set_ui_user_present(ui_user_present)?;
        res.set_ui_window_request(ui_window_request)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_PINToDriveEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_pin_to_drive_enabled(&self) -> bool {
        self.ui_pin_to_drive_enabled_raw()
    }
    
    /// Get raw value of UI_PINToDriveEnabled
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_pin_to_drive_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_PINToDriveEnabled
    #[inline(always)]
    pub fn set_ui_pin_to_drive_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// UI_PINToDrivePassed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_pin_to_drive_passed(&self) -> bool {
        self.ui_pin_to_drive_passed_raw()
    }
    
    /// Get raw value of UI_PINToDrivePassed
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_pin_to_drive_passed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_PINToDrivePassed
    #[inline(always)]
    pub fn set_ui_pin_to_drive_passed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// UI_UMCUpdateInhibit
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_umc_update_inhibit(&self) -> bool {
        self.ui_umc_update_inhibit_raw()
    }
    
    /// Get raw value of UI_UMCUpdateInhibit
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_umc_update_inhibit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_UMCUpdateInhibit
    #[inline(always)]
    pub fn set_ui_umc_update_inhibit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UI_VCLEFTFeature1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_vcleft_feature1(&self) -> bool {
        self.ui_vcleft_feature1_raw()
    }
    
    /// Get raw value of UI_VCLEFTFeature1
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_vcleft_feature1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_VCLEFTFeature1
    #[inline(always)]
    pub fn set_ui_vcleft_feature1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// UI_VCSECFeature1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_vcsec_feature1(&self) -> bool {
        self.ui_vcsec_feature1_raw()
    }
    
    /// Get raw value of UI_VCSECFeature1
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_vcsec_feature1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_VCSECFeature1
    #[inline(always)]
    pub fn set_ui_vcsec_feature1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// UI_WCUpdateInhibit
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_wc_update_inhibit(&self) -> bool {
        self.ui_wc_update_inhibit_raw()
    }
    
    /// Get raw value of UI_WCUpdateInhibit
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_wc_update_inhibit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_WCUpdateInhibit
    #[inline(always)]
    pub fn set_ui_wc_update_inhibit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_alarmTriggerRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_alarm_trigger_request(&self) -> bool {
        self.ui_alarm_trigger_request_raw()
    }
    
    /// Get raw value of UI_alarmTriggerRequest
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_alarm_trigger_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_alarmTriggerRequest
    #[inline(always)]
    pub fn set_ui_alarm_trigger_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// UI_autoRollWindowsOnLockEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_auto_roll_windows_on_lock_enable(&self) -> bool {
        self.ui_auto_roll_windows_on_lock_enable_raw()
    }
    
    /// Get raw value of UI_autoRollWindowsOnLockEnable
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_auto_roll_windows_on_lock_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_autoRollWindowsOnLockEnable
    #[inline(always)]
    pub fn set_ui_auto_roll_windows_on_lock_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// UI_autopilotPowerStateRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_autopilot_power_state_request(&self) -> Id3b3uiVehicleControl2UiAutopilotPowerStateRequest {
        match self.ui_autopilot_power_state_request_raw() {
            0 => Id3b3uiVehicleControl2UiAutopilotPowerStateRequest::AutopilotNominal,
            1 => Id3b3uiVehicleControl2UiAutopilotPowerStateRequest::AutopilotSentry,
            2 => Id3b3uiVehicleControl2UiAutopilotPowerStateRequest::AutopilotSuspend,
            x => Id3b3uiVehicleControl2UiAutopilotPowerStateRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_autopilotPowerStateRequest
    ///
    /// - Start bit: 25
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_autopilot_power_state_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[25..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_autopilotPowerStateRequest
    #[inline(always)]
    pub fn set_ui_autopilot_power_state_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 947 }); }
        self.raw.view_bits_mut::<LocalBits>()[25..27].store_le(value);
        Ok(())
    }
    
    /// UI_batteryPreconditioningRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_battery_preconditioning_request(&self) -> bool {
        self.ui_battery_preconditioning_request_raw()
    }
    
    /// Get raw value of UI_batteryPreconditioningRequest
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_battery_preconditioning_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_batteryPreconditioningRequest
    #[inline(always)]
    pub fn set_ui_battery_preconditioning_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[23..24].store_le(value);
        Ok(())
    }
    
    /// UI_coastDownMode
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_coast_down_mode(&self) -> bool {
        self.ui_coast_down_mode_raw()
    }
    
    /// Get raw value of UI_coastDownMode
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_coast_down_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_coastDownMode
    #[inline(always)]
    pub fn set_ui_coast_down_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// UI_conditionalLoggingEnabledVCSE
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_conditional_logging_enabled_vcse(&self) -> bool {
        self.ui_conditional_logging_enabled_vcse_raw()
    }
    
    /// Get raw value of UI_conditionalLoggingEnabledVCSE
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_conditional_logging_enabled_vcse_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_conditionalLoggingEnabledVCSE
    #[inline(always)]
    pub fn set_ui_conditional_logging_enabled_vcse(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// UI_efuseMXResistanceEstArmed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_efuse_mx_resistance_est_armed(&self) -> bool {
        self.ui_efuse_mx_resistance_est_armed_raw()
    }
    
    /// Get raw value of UI_efuseMXResistanceEstArmed
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_efuse_mx_resistance_est_armed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_efuseMXResistanceEstArmed
    #[inline(always)]
    pub fn set_ui_efuse_mx_resistance_est_armed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// UI_freeRollModeRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_free_roll_mode_request(&self) -> bool {
        self.ui_free_roll_mode_request_raw()
    }
    
    /// Get raw value of UI_freeRollModeRequest
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_free_roll_mode_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_freeRollModeRequest
    #[inline(always)]
    pub fn set_ui_free_roll_mode_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
    /// UI_gloveboxRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_glovebox_request(&self) -> bool {
        self.ui_glovebox_request_raw()
    }
    
    /// Get raw value of UI_gloveboxRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_glovebox_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_gloveboxRequest
    #[inline(always)]
    pub fn set_ui_glovebox_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_lightSwitch
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_light_switch(&self) -> Id3b3uiVehicleControl2UiLightSwitch {
        match self.ui_light_switch_raw() {
            0 => Id3b3uiVehicleControl2UiLightSwitch::LightSwitchAuto,
            3 => Id3b3uiVehicleControl2UiLightSwitch::LightSwitchOff,
            1 => Id3b3uiVehicleControl2UiLightSwitch::LightSwitchOn,
            2 => Id3b3uiVehicleControl2UiLightSwitch::LightSwitchParking,
            4 => Id3b3uiVehicleControl2UiLightSwitch::LightSwitchSna,
            x => Id3b3uiVehicleControl2UiLightSwitch::Other(x),
        }
    }
    
    /// Get raw value of UI_lightSwitch
    ///
    /// - Start bit: 9
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_light_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[9..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_lightSwitch
    #[inline(always)]
    pub fn set_ui_light_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 947 }); }
        self.raw.view_bits_mut::<LocalBits>()[9..12].store_le(value);
        Ok(())
    }
    
    /// UI_locksPanelActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_locks_panel_active(&self) -> bool {
        self.ui_locks_panel_active_raw()
    }
    
    /// Get raw value of UI_locksPanelActive
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_locks_panel_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_locksPanelActive
    #[inline(always)]
    pub fn set_ui_locks_panel_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// UI_readyToAddKey
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ready_to_add_key(&self) -> bool {
        self.ui_ready_to_add_key_raw()
    }
    
    /// Get raw value of UI_readyToAddKey
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ready_to_add_key_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_readyToAddKey
    #[inline(always)]
    pub fn set_ui_ready_to_add_key(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// UI_shorted12VCellTestMode
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_shorted12_v_cell_test_mode(&self) -> Id3b3uiVehicleControl2UiShorted12VCellTestMode {
        match self.ui_shorted12_v_cell_test_mode_raw() {
            2 => Id3b3uiVehicleControl2UiShorted12VCellTestMode::ShortedCellTestModeActive,
            0 => Id3b3uiVehicleControl2UiShorted12VCellTestMode::ShortedCellTestModeDisabled,
            1 => Id3b3uiVehicleControl2UiShorted12VCellTestMode::ShortedCellTestModeShadow,
            x => Id3b3uiVehicleControl2UiShorted12VCellTestMode::Other(x),
        }
    }
    
    /// Get raw value of UI_shorted12VCellTestMode
    ///
    /// - Start bit: 27
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_shorted12_v_cell_test_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_shorted12VCellTestMode
    #[inline(always)]
    pub fn set_ui_shorted12_v_cell_test_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 947 }); }
        self.raw.view_bits_mut::<LocalBits>()[27..29].store_le(value);
        Ok(())
    }
    
    /// UI_soundHornOnLock
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_sound_horn_on_lock(&self) -> bool {
        self.ui_sound_horn_on_lock_raw()
    }
    
    /// Get raw value of UI_soundHornOnLock
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_sound_horn_on_lock_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_soundHornOnLock
    #[inline(always)]
    pub fn set_ui_sound_horn_on_lock(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_summonState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_summon_state(&self) -> Id3b3uiVehicleControl2UiSummonState {
        match self.ui_summon_state_raw() {
            3 => Id3b3uiVehicleControl2UiSummonState::Active,
            1 => Id3b3uiVehicleControl2UiSummonState::Idle,
            2 => Id3b3uiVehicleControl2UiSummonState::PrePrimed,
            0 => Id3b3uiVehicleControl2UiSummonState::Sna,
            x => Id3b3uiVehicleControl2UiSummonState::Other(x),
        }
    }
    
    /// Get raw value of UI_summonState
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_summon_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_summonState
    #[inline(always)]
    pub fn set_ui_summon_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 947 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// UI_trunkRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_trunk_request(&self) -> bool {
        self.ui_trunk_request_raw()
    }
    
    /// Get raw value of UI_trunkRequest
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_trunk_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_trunkRequest
    #[inline(always)]
    pub fn set_ui_trunk_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_userPresent
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_user_present(&self) -> bool {
        self.ui_user_present_raw()
    }
    
    /// Get raw value of UI_userPresent
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_user_present_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_userPresent
    #[inline(always)]
    pub fn set_ui_user_present(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// UI_windowRequest
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_window_request(&self) -> Id3b3uiVehicleControl2UiWindowRequest {
        match self.ui_window_request_raw() {
            3 => Id3b3uiVehicleControl2UiWindowRequest::WindowRequestGotoClosed,
            4 => Id3b3uiVehicleControl2UiWindowRequest::WindowRequestGotoOpen,
            1 => Id3b3uiVehicleControl2UiWindowRequest::WindowRequestGotoPercent,
            2 => Id3b3uiVehicleControl2UiWindowRequest::WindowRequestGotoVent,
            0 => Id3b3uiVehicleControl2UiWindowRequest::WindowRequestIdle,
            x => Id3b3uiVehicleControl2UiWindowRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_windowRequest
    ///
    /// - Start bit: 20
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_window_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_windowRequest
    #[inline(always)]
    pub fn set_ui_window_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 947 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..23].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3b3uiVehicleControl2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3b3uiVehicleControl2
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_pin_to_drive_enabled = u.int_in_range(0..=1)? == 1;
        let ui_pin_to_drive_passed = u.int_in_range(0..=1)? == 1;
        let ui_umc_update_inhibit = u.int_in_range(0..=1)? == 1;
        let ui_vcleft_feature1 = u.int_in_range(0..=1)? == 1;
        let ui_vcsec_feature1 = u.int_in_range(0..=1)? == 1;
        let ui_wc_update_inhibit = u.int_in_range(0..=1)? == 1;
        let ui_alarm_trigger_request = u.int_in_range(0..=1)? == 1;
        let ui_auto_roll_windows_on_lock_enable = u.int_in_range(0..=1)? == 1;
        let ui_autopilot_power_state_request = u.int_in_range(0..=2)?;
        let ui_battery_preconditioning_request = u.int_in_range(0..=1)? == 1;
        let ui_coast_down_mode = u.int_in_range(0..=1)? == 1;
        let ui_conditional_logging_enabled_vcse = u.int_in_range(0..=1)? == 1;
        let ui_efuse_mx_resistance_est_armed = u.int_in_range(0..=1)? == 1;
        let ui_free_roll_mode_request = u.int_in_range(0..=1)? == 1;
        let ui_glovebox_request = u.int_in_range(0..=1)? == 1;
        let ui_light_switch = u.int_in_range(0..=4)?;
        let ui_locks_panel_active = u.int_in_range(0..=1)? == 1;
        let ui_ready_to_add_key = u.int_in_range(0..=1)? == 1;
        let ui_shorted12_v_cell_test_mode = u.int_in_range(0..=2)?;
        let ui_sound_horn_on_lock = u.int_in_range(0..=1)? == 1;
        let ui_summon_state = u.int_in_range(0..=3)?;
        let ui_trunk_request = u.int_in_range(0..=1)? == 1;
        let ui_user_present = u.int_in_range(0..=1)? == 1;
        let ui_window_request = u.int_in_range(0..=4)?;
        Id3b3uiVehicleControl2::new(ui_pin_to_drive_enabled,ui_pin_to_drive_passed,ui_umc_update_inhibit,ui_vcleft_feature1,ui_vcsec_feature1,ui_wc_update_inhibit,ui_alarm_trigger_request,ui_auto_roll_windows_on_lock_enable,ui_autopilot_power_state_request,ui_battery_preconditioning_request,ui_coast_down_mode,ui_conditional_logging_enabled_vcse,ui_efuse_mx_resistance_est_armed,ui_free_roll_mode_request,ui_glovebox_request,ui_light_switch,ui_locks_panel_active,ui_ready_to_add_key,ui_shorted12_v_cell_test_mode,ui_sound_horn_on_lock,ui_summon_state,ui_trunk_request,ui_user_present,ui_window_request).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_autopilotPowerStateRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3b3uiVehicleControl2UiAutopilotPowerStateRequest {
    AutopilotNominal,
    AutopilotSentry,
    AutopilotSuspend,
    Other(u8),
}
/// Defined values for UI_lightSwitch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3b3uiVehicleControl2UiLightSwitch {
    LightSwitchAuto,
    LightSwitchOff,
    LightSwitchOn,
    LightSwitchParking,
    LightSwitchSna,
    Other(u8),
}
/// Defined values for UI_shorted12VCellTestMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3b3uiVehicleControl2UiShorted12VCellTestMode {
    ShortedCellTestModeActive,
    ShortedCellTestModeDisabled,
    ShortedCellTestModeShadow,
    Other(u8),
}
/// Defined values for UI_summonState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3b3uiVehicleControl2UiSummonState {
    Active,
    Idle,
    PrePrimed,
    Sna,
    Other(u8),
}
/// Defined values for UI_windowRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3b3uiVehicleControl2UiWindowRequest {
    WindowRequestGotoClosed,
    WindowRequestGotoOpen,
    WindowRequestGotoPercent,
    WindowRequestGotoVent,
    WindowRequestIdle,
    Other(u8),
}

/// ID3C3VCRIGHT_switchStatus
///
/// - ID: 963 (0x3c3)
/// - Size: 7 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3c3vcrightSwitchStatus {
    raw: [u8; 7],
}

impl Id3c3vcrightSwitchStatus {
    pub const MESSAGE_ID: u32 = 963;
    
    /// Construct new ID3C3VCRIGHT_switchStatus from values
    pub fn new(vcright_2row_seat_recline_switch: bool, vcright_btn_window_auto_down_rf: bool, vcright_btn_window_auto_down_rr: bool, vcright_btn_window_auto_up_rf: bool, vcright_btn_window_auto_up_rr: bool, vcright_btn_window_down_rf: bool, vcright_btn_window_down_rr: bool, vcright_btn_window_sw_pack_auto_dwn_lf: bool, vcright_btn_window_sw_pack_auto_dwn_lr: bool, vcright_btn_window_sw_pack_auto_dwn_rr: bool, vcright_btn_window_sw_pack_auto_up_lf: bool, vcright_btn_window_sw_pack_auto_up_lr: bool, vcright_btn_window_sw_pack_auto_up_rr: bool, vcright_btn_window_sw_pack_down_lf: bool, vcright_btn_window_sw_pack_down_lr: bool, vcright_btn_window_sw_pack_down_rr: bool, vcright_btn_window_sw_pack_up_lf: bool, vcright_btn_window_sw_pack_up_lr: bool, vcright_btn_window_sw_pack_up_rr: bool, vcright_btn_window_up_rf: bool, vcright_btn_window_up_rr: bool, vcright_front_buckle_switch: u8, vcright_front_occupancy_switch: u8, vcright_front_seat_backrest_back: u8, vcright_front_seat_backrest_forward: u8, vcright_front_seat_lift_down: u8, vcright_front_seat_lift_up: u8, vcright_front_seat_lumbar_down: u8, vcright_front_seat_lumbar_in: u8, vcright_front_seat_lumbar_out: u8, vcright_front_seat_lumbar_up: u8, vcright_front_seat_tilt_down: u8, vcright_front_seat_tilt_up: u8, vcright_front_seat_track_back: u8, vcright_front_seat_track_forward: u8, vcright_liftgate_shutface_switch_pr: bool, vcright_rear_center_buckle_switch: u8, vcright_rear_right_buckle_switch: u8, vcright_trunk_ext_release_pressed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 7] };
        res.set_vcright_2row_seat_recline_switch(vcright_2row_seat_recline_switch)?;
        res.set_vcright_btn_window_auto_down_rf(vcright_btn_window_auto_down_rf)?;
        res.set_vcright_btn_window_auto_down_rr(vcright_btn_window_auto_down_rr)?;
        res.set_vcright_btn_window_auto_up_rf(vcright_btn_window_auto_up_rf)?;
        res.set_vcright_btn_window_auto_up_rr(vcright_btn_window_auto_up_rr)?;
        res.set_vcright_btn_window_down_rf(vcright_btn_window_down_rf)?;
        res.set_vcright_btn_window_down_rr(vcright_btn_window_down_rr)?;
        res.set_vcright_btn_window_sw_pack_auto_dwn_lf(vcright_btn_window_sw_pack_auto_dwn_lf)?;
        res.set_vcright_btn_window_sw_pack_auto_dwn_lr(vcright_btn_window_sw_pack_auto_dwn_lr)?;
        res.set_vcright_btn_window_sw_pack_auto_dwn_rr(vcright_btn_window_sw_pack_auto_dwn_rr)?;
        res.set_vcright_btn_window_sw_pack_auto_up_lf(vcright_btn_window_sw_pack_auto_up_lf)?;
        res.set_vcright_btn_window_sw_pack_auto_up_lr(vcright_btn_window_sw_pack_auto_up_lr)?;
        res.set_vcright_btn_window_sw_pack_auto_up_rr(vcright_btn_window_sw_pack_auto_up_rr)?;
        res.set_vcright_btn_window_sw_pack_down_lf(vcright_btn_window_sw_pack_down_lf)?;
        res.set_vcright_btn_window_sw_pack_down_lr(vcright_btn_window_sw_pack_down_lr)?;
        res.set_vcright_btn_window_sw_pack_down_rr(vcright_btn_window_sw_pack_down_rr)?;
        res.set_vcright_btn_window_sw_pack_up_lf(vcright_btn_window_sw_pack_up_lf)?;
        res.set_vcright_btn_window_sw_pack_up_lr(vcright_btn_window_sw_pack_up_lr)?;
        res.set_vcright_btn_window_sw_pack_up_rr(vcright_btn_window_sw_pack_up_rr)?;
        res.set_vcright_btn_window_up_rf(vcright_btn_window_up_rf)?;
        res.set_vcright_btn_window_up_rr(vcright_btn_window_up_rr)?;
        res.set_vcright_front_buckle_switch(vcright_front_buckle_switch)?;
        res.set_vcright_front_occupancy_switch(vcright_front_occupancy_switch)?;
        res.set_vcright_front_seat_backrest_back(vcright_front_seat_backrest_back)?;
        res.set_vcright_front_seat_backrest_forward(vcright_front_seat_backrest_forward)?;
        res.set_vcright_front_seat_lift_down(vcright_front_seat_lift_down)?;
        res.set_vcright_front_seat_lift_up(vcright_front_seat_lift_up)?;
        res.set_vcright_front_seat_lumbar_down(vcright_front_seat_lumbar_down)?;
        res.set_vcright_front_seat_lumbar_in(vcright_front_seat_lumbar_in)?;
        res.set_vcright_front_seat_lumbar_out(vcright_front_seat_lumbar_out)?;
        res.set_vcright_front_seat_lumbar_up(vcright_front_seat_lumbar_up)?;
        res.set_vcright_front_seat_tilt_down(vcright_front_seat_tilt_down)?;
        res.set_vcright_front_seat_tilt_up(vcright_front_seat_tilt_up)?;
        res.set_vcright_front_seat_track_back(vcright_front_seat_track_back)?;
        res.set_vcright_front_seat_track_forward(vcright_front_seat_track_forward)?;
        res.set_vcright_liftgate_shutface_switch_pr(vcright_liftgate_shutface_switch_pr)?;
        res.set_vcright_rear_center_buckle_switch(vcright_rear_center_buckle_switch)?;
        res.set_vcright_rear_right_buckle_switch(vcright_rear_right_buckle_switch)?;
        res.set_vcright_trunk_ext_release_pressed(vcright_trunk_ext_release_pressed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_2RowSeatReclineSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_2row_seat_recline_switch(&self) -> bool {
        self.vcright_2row_seat_recline_switch_raw()
    }
    
    /// Get raw value of VCRIGHT_2RowSeatReclineSwitch
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_2row_seat_recline_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_2RowSeatReclineSwitch
    #[inline(always)]
    pub fn set_vcright_2row_seat_recline_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[54..55].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowAutoDownRF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_auto_down_rf(&self) -> bool {
        self.vcright_btn_window_auto_down_rf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowAutoDownRF
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_auto_down_rf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowAutoDownRF
    #[inline(always)]
    pub fn set_vcright_btn_window_auto_down_rf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowAutoDownRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_auto_down_rr(&self) -> bool {
        self.vcright_btn_window_auto_down_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowAutoDownRR
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_auto_down_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowAutoDownRR
    #[inline(always)]
    pub fn set_vcright_btn_window_auto_down_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowAutoUpRF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_auto_up_rf(&self) -> bool {
        self.vcright_btn_window_auto_up_rf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowAutoUpRF
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_auto_up_rf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowAutoUpRF
    #[inline(always)]
    pub fn set_vcright_btn_window_auto_up_rf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowAutoUpRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_auto_up_rr(&self) -> bool {
        self.vcright_btn_window_auto_up_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowAutoUpRR
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_auto_up_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowAutoUpRR
    #[inline(always)]
    pub fn set_vcright_btn_window_auto_up_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowDownRF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_down_rf(&self) -> bool {
        self.vcright_btn_window_down_rf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowDownRF
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_down_rf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowDownRF
    #[inline(always)]
    pub fn set_vcright_btn_window_down_rf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowDownRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_down_rr(&self) -> bool {
        self.vcright_btn_window_down_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowDownRR
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_down_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowDownRR
    #[inline(always)]
    pub fn set_vcright_btn_window_down_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackAutoDwnLF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_dwn_lf(&self) -> bool {
        self.vcright_btn_window_sw_pack_auto_dwn_lf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackAutoDwnLF
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_dwn_lf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackAutoDwnLF
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_auto_dwn_lf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[35..36].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackAutoDwnLR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_dwn_lr(&self) -> bool {
        self.vcright_btn_window_sw_pack_auto_dwn_lr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackAutoDwnLR
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_dwn_lr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackAutoDwnLR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_auto_dwn_lr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackAutoDwnRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_dwn_rr(&self) -> bool {
        self.vcright_btn_window_sw_pack_auto_dwn_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackAutoDwnRR
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_dwn_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackAutoDwnRR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_auto_dwn_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[52..53].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackAutoUpLF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_up_lf(&self) -> bool {
        self.vcright_btn_window_sw_pack_auto_up_lf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackAutoUpLF
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_up_lf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackAutoUpLF
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_auto_up_lf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[33..34].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackAutoUpLR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_up_lr(&self) -> bool {
        self.vcright_btn_window_sw_pack_auto_up_lr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackAutoUpLR
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_up_lr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackAutoUpLR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_auto_up_lr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackAutoUpRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_up_rr(&self) -> bool {
        self.vcright_btn_window_sw_pack_auto_up_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackAutoUpRR
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_auto_up_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackAutoUpRR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_auto_up_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackDownLF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_down_lf(&self) -> bool {
        self.vcright_btn_window_sw_pack_down_lf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackDownLF
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_down_lf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackDownLF
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_down_lf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[34..35].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackDownLR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_down_lr(&self) -> bool {
        self.vcright_btn_window_sw_pack_down_lr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackDownLR
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_down_lr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackDownLR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_down_lr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackDownRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_down_rr(&self) -> bool {
        self.vcright_btn_window_sw_pack_down_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackDownRR
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_down_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackDownRR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_down_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackUpLF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_up_lf(&self) -> bool {
        self.vcright_btn_window_sw_pack_up_lf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackUpLF
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_up_lf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackUpLF
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_up_lf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackUpLR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_up_lr(&self) -> bool {
        self.vcright_btn_window_sw_pack_up_lr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackUpLR
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_up_lr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackUpLR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_up_lr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowSwPackUpRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_up_rr(&self) -> bool {
        self.vcright_btn_window_sw_pack_up_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowSwPackUpRR
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_sw_pack_up_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowSwPackUpRR
    #[inline(always)]
    pub fn set_vcright_btn_window_sw_pack_up_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowUpRF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_up_rf(&self) -> bool {
        self.vcright_btn_window_up_rf_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowUpRF
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_up_rf_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowUpRF
    #[inline(always)]
    pub fn set_vcright_btn_window_up_rf(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_btnWindowUpRR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_btn_window_up_rr(&self) -> bool {
        self.vcright_btn_window_up_rr_raw()
    }
    
    /// Get raw value of VCRIGHT_btnWindowUpRR
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_btn_window_up_rr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_btnWindowUpRR
    #[inline(always)]
    pub fn set_vcright_btn_window_up_rr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontBuckleSwitch
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_buckle_switch(&self) -> Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch {
        match self.vcright_front_buckle_switch_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontBuckleSwitch
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_buckle_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontBuckleSwitch
    #[inline(always)]
    pub fn set_vcright_front_buckle_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontOccupancySwitch
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_occupancy_switch(&self) -> Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch {
        match self.vcright_front_occupancy_switch_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontOccupancySwitch
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_occupancy_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontOccupancySwitch
    #[inline(always)]
    pub fn set_vcright_front_occupancy_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..44].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatBackrestBack
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_backrest_back(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack {
        match self.vcright_front_seat_backrest_back_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatBackrestBack
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_backrest_back_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatBackrestBack
    #[inline(always)]
    pub fn set_vcright_front_seat_backrest_back(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatBackrestForward
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_backrest_forward(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward {
        match self.vcright_front_seat_backrest_forward_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatBackrestForward
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_backrest_forward_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatBackrestForward
    #[inline(always)]
    pub fn set_vcright_front_seat_backrest_forward(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatLiftDown
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_lift_down(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown {
        match self.vcright_front_seat_lift_down_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatLiftDown
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_lift_down_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatLiftDown
    #[inline(always)]
    pub fn set_vcright_front_seat_lift_down(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatLiftUp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_lift_up(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp {
        match self.vcright_front_seat_lift_up_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatLiftUp
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_lift_up_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatLiftUp
    #[inline(always)]
    pub fn set_vcright_front_seat_lift_up(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatLumbarDown
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_down(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown {
        match self.vcright_front_seat_lumbar_down_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatLumbarDown
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_down_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatLumbarDown
    #[inline(always)]
    pub fn set_vcright_front_seat_lumbar_down(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatLumbarIn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_in(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn {
        match self.vcright_front_seat_lumbar_in_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatLumbarIn
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_in_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatLumbarIn
    #[inline(always)]
    pub fn set_vcright_front_seat_lumbar_in(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..22].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatLumbarOut
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_out(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut {
        match self.vcright_front_seat_lumbar_out_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatLumbarOut
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_out_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatLumbarOut
    #[inline(always)]
    pub fn set_vcright_front_seat_lumbar_out(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatLumbarUp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_up(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp {
        match self.vcright_front_seat_lumbar_up_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatLumbarUp
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_lumbar_up_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatLumbarUp
    #[inline(always)]
    pub fn set_vcright_front_seat_lumbar_up(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..20].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatTiltDown
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_tilt_down(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown {
        match self.vcright_front_seat_tilt_down_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatTiltDown
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_tilt_down_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatTiltDown
    #[inline(always)]
    pub fn set_vcright_front_seat_tilt_down(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatTiltUp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_tilt_up(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp {
        match self.vcright_front_seat_tilt_up_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatTiltUp
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_tilt_up_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatTiltUp
    #[inline(always)]
    pub fn set_vcright_front_seat_tilt_up(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatTrackBack
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_track_back(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack {
        match self.vcright_front_seat_track_back_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatTrackBack
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_track_back_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatTrackBack
    #[inline(always)]
    pub fn set_vcright_front_seat_track_back(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_frontSeatTrackForward
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_front_seat_track_forward(&self) -> Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward {
        match self.vcright_front_seat_track_forward_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_frontSeatTrackForward
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_front_seat_track_forward_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_frontSeatTrackForward
    #[inline(always)]
    pub fn set_vcright_front_seat_track_forward(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_liftgateShutfaceSwitchPr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_liftgate_shutface_switch_pr(&self) -> bool {
        self.vcright_liftgate_shutface_switch_pr_raw()
    }
    
    /// Get raw value of VCRIGHT_liftgateShutfaceSwitchPr
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_liftgate_shutface_switch_pr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_liftgateShutfaceSwitchPr
    #[inline(always)]
    pub fn set_vcright_liftgate_shutface_switch_pr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[53..54].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearCenterBuckleSwitch
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_center_buckle_switch(&self) -> Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch {
        match self.vcright_rear_center_buckle_switch_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_rearCenterBuckleSwitch
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_center_buckle_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rearCenterBuckleSwitch
    #[inline(always)]
    pub fn set_vcright_rear_center_buckle_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearRightBuckleSwitch
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_right_buckle_switch(&self) -> Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch {
        match self.vcright_rear_right_buckle_switch_raw() {
            3 => Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch::SwitchFault,
            1 => Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch::SwitchOff,
            2 => Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch::SwitchOn,
            0 => Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch::SwitchSna,
            x => Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_rearRightBuckleSwitch
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_right_buckle_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rearRightBuckleSwitch
    #[inline(always)]
    pub fn set_vcright_rear_right_buckle_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 963 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..48].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_trunkExtReleasePressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_trunk_ext_release_pressed(&self) -> bool {
        self.vcright_trunk_ext_release_pressed_raw()
    }
    
    /// Get raw value of VCRIGHT_trunkExtReleasePressed
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_trunk_ext_release_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_trunkExtReleasePressed
    #[inline(always)]
    pub fn set_vcright_trunk_ext_release_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3c3vcrightSwitchStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 7 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 7];
        raw.copy_from_slice(&payload[..7]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3c3vcrightSwitchStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_2row_seat_recline_switch = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_auto_down_rf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_auto_down_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_auto_up_rf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_auto_up_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_down_rf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_down_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_auto_dwn_lf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_auto_dwn_lr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_auto_dwn_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_auto_up_lf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_auto_up_lr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_auto_up_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_down_lf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_down_lr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_down_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_up_lf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_up_lr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_sw_pack_up_rr = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_up_rf = u.int_in_range(0..=1)? == 1;
        let vcright_btn_window_up_rr = u.int_in_range(0..=1)? == 1;
        let vcright_front_buckle_switch = u.int_in_range(0..=3)?;
        let vcright_front_occupancy_switch = u.int_in_range(0..=3)?;
        let vcright_front_seat_backrest_back = u.int_in_range(0..=3)?;
        let vcright_front_seat_backrest_forward = u.int_in_range(0..=3)?;
        let vcright_front_seat_lift_down = u.int_in_range(0..=3)?;
        let vcright_front_seat_lift_up = u.int_in_range(0..=3)?;
        let vcright_front_seat_lumbar_down = u.int_in_range(0..=3)?;
        let vcright_front_seat_lumbar_in = u.int_in_range(0..=3)?;
        let vcright_front_seat_lumbar_out = u.int_in_range(0..=3)?;
        let vcright_front_seat_lumbar_up = u.int_in_range(0..=3)?;
        let vcright_front_seat_tilt_down = u.int_in_range(0..=3)?;
        let vcright_front_seat_tilt_up = u.int_in_range(0..=3)?;
        let vcright_front_seat_track_back = u.int_in_range(0..=3)?;
        let vcright_front_seat_track_forward = u.int_in_range(0..=3)?;
        let vcright_liftgate_shutface_switch_pr = u.int_in_range(0..=1)? == 1;
        let vcright_rear_center_buckle_switch = u.int_in_range(0..=3)?;
        let vcright_rear_right_buckle_switch = u.int_in_range(0..=3)?;
        let vcright_trunk_ext_release_pressed = u.int_in_range(0..=1)? == 1;
        Id3c3vcrightSwitchStatus::new(vcright_2row_seat_recline_switch,vcright_btn_window_auto_down_rf,vcright_btn_window_auto_down_rr,vcright_btn_window_auto_up_rf,vcright_btn_window_auto_up_rr,vcright_btn_window_down_rf,vcright_btn_window_down_rr,vcright_btn_window_sw_pack_auto_dwn_lf,vcright_btn_window_sw_pack_auto_dwn_lr,vcright_btn_window_sw_pack_auto_dwn_rr,vcright_btn_window_sw_pack_auto_up_lf,vcright_btn_window_sw_pack_auto_up_lr,vcright_btn_window_sw_pack_auto_up_rr,vcright_btn_window_sw_pack_down_lf,vcright_btn_window_sw_pack_down_lr,vcright_btn_window_sw_pack_down_rr,vcright_btn_window_sw_pack_up_lf,vcright_btn_window_sw_pack_up_lr,vcright_btn_window_sw_pack_up_rr,vcright_btn_window_up_rf,vcright_btn_window_up_rr,vcright_front_buckle_switch,vcright_front_occupancy_switch,vcright_front_seat_backrest_back,vcright_front_seat_backrest_forward,vcright_front_seat_lift_down,vcright_front_seat_lift_up,vcright_front_seat_lumbar_down,vcright_front_seat_lumbar_in,vcright_front_seat_lumbar_out,vcright_front_seat_lumbar_up,vcright_front_seat_tilt_down,vcright_front_seat_tilt_up,vcright_front_seat_track_back,vcright_front_seat_track_forward,vcright_liftgate_shutface_switch_pr,vcright_rear_center_buckle_switch,vcright_rear_right_buckle_switch,vcright_trunk_ext_release_pressed).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_frontBuckleSwitch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontBuckleSwitch {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontOccupancySwitch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontOccupancySwitch {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatBackrestBack
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestBack {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatBackrestForward
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatBackrestForward {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatLiftDown
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatLiftDown {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatLiftUp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatLiftUp {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatLumbarDown
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarDown {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatLumbarIn
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarIn {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatLumbarOut
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarOut {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatLumbarUp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatLumbarUp {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatTiltDown
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatTiltDown {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatTiltUp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatTiltUp {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatTrackBack
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatTrackBack {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_frontSeatTrackForward
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightFrontSeatTrackForward {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_rearCenterBuckleSwitch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightRearCenterBuckleSwitch {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}
/// Defined values for VCRIGHT_rearRightBuckleSwitch
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3c3vcrightSwitchStatusVcrightRearRightBuckleSwitch {
    SwitchFault,
    SwitchOff,
    SwitchOn,
    SwitchSna,
    Other(u8),
}

/// ID3E3VCRIGHT_lightStatus
///
/// - ID: 995 (0x3e3)
/// - Size: 2 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3e3vcrightLightStatus {
    raw: [u8; 2],
}

impl Id3e3vcrightLightStatus {
    pub const MESSAGE_ID: u32 = 995;
    
    /// Construct new ID3E3VCRIGHT_lightStatus from values
    pub fn new(vcright_brake_light_status: u8, vcright_interior_trunk_light_status: u8, vcright_rear_fog_light_status: u8, vcright_reverse_light_status: u8, vcright_tail_light_status: u8, vcright_turn_signal_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_vcright_brake_light_status(vcright_brake_light_status)?;
        res.set_vcright_interior_trunk_light_status(vcright_interior_trunk_light_status)?;
        res.set_vcright_rear_fog_light_status(vcright_rear_fog_light_status)?;
        res.set_vcright_reverse_light_status(vcright_reverse_light_status)?;
        res.set_vcright_tail_light_status(vcright_tail_light_status)?;
        res.set_vcright_turn_signal_status(vcright_turn_signal_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_brakeLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_brake_light_status(&self) -> Id3e3vcrightLightStatusVcrightBrakeLightStatus {
        match self.vcright_brake_light_status_raw() {
            2 => Id3e3vcrightLightStatusVcrightBrakeLightStatus::LightFault,
            0 => Id3e3vcrightLightStatusVcrightBrakeLightStatus::LightOff,
            1 => Id3e3vcrightLightStatusVcrightBrakeLightStatus::LightOn,
            3 => Id3e3vcrightLightStatusVcrightBrakeLightStatus::LightSna,
            x => Id3e3vcrightLightStatusVcrightBrakeLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_brakeLightStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_brake_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_brakeLightStatus
    #[inline(always)]
    pub fn set_vcright_brake_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 995 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_interiorTrunkLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_interior_trunk_light_status(&self) -> Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus {
        match self.vcright_interior_trunk_light_status_raw() {
            2 => Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus::LightFault,
            0 => Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus::LightOff,
            1 => Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus::LightOn,
            3 => Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus::LightSna,
            x => Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_interiorTrunkLightStatus
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_interior_trunk_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_interiorTrunkLightStatus
    #[inline(always)]
    pub fn set_vcright_interior_trunk_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 995 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearFogLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_fog_light_status(&self) -> Id3e3vcrightLightStatusVcrightRearFogLightStatus {
        match self.vcright_rear_fog_light_status_raw() {
            2 => Id3e3vcrightLightStatusVcrightRearFogLightStatus::LightFault,
            0 => Id3e3vcrightLightStatusVcrightRearFogLightStatus::LightOff,
            1 => Id3e3vcrightLightStatusVcrightRearFogLightStatus::LightOn,
            3 => Id3e3vcrightLightStatusVcrightRearFogLightStatus::LightSna,
            x => Id3e3vcrightLightStatusVcrightRearFogLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_rearFogLightStatus
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_fog_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rearFogLightStatus
    #[inline(always)]
    pub fn set_vcright_rear_fog_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 995 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_reverseLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_reverse_light_status(&self) -> Id3e3vcrightLightStatusVcrightReverseLightStatus {
        match self.vcright_reverse_light_status_raw() {
            2 => Id3e3vcrightLightStatusVcrightReverseLightStatus::LightFault,
            0 => Id3e3vcrightLightStatusVcrightReverseLightStatus::LightOff,
            1 => Id3e3vcrightLightStatusVcrightReverseLightStatus::LightOn,
            3 => Id3e3vcrightLightStatusVcrightReverseLightStatus::LightSna,
            x => Id3e3vcrightLightStatusVcrightReverseLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_reverseLightStatus
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_reverse_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_reverseLightStatus
    #[inline(always)]
    pub fn set_vcright_reverse_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 995 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tailLightStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_tail_light_status(&self) -> Id3e3vcrightLightStatusVcrightTailLightStatus {
        match self.vcright_tail_light_status_raw() {
            2 => Id3e3vcrightLightStatusVcrightTailLightStatus::LightFault,
            0 => Id3e3vcrightLightStatusVcrightTailLightStatus::LightOff,
            1 => Id3e3vcrightLightStatusVcrightTailLightStatus::LightOn,
            3 => Id3e3vcrightLightStatusVcrightTailLightStatus::LightSna,
            x => Id3e3vcrightLightStatusVcrightTailLightStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tailLightStatus
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_tail_light_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_tailLightStatus
    #[inline(always)]
    pub fn set_vcright_tail_light_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 995 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_turnSignalStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_turn_signal_status(&self) -> Id3e3vcrightLightStatusVcrightTurnSignalStatus {
        match self.vcright_turn_signal_status_raw() {
            2 => Id3e3vcrightLightStatusVcrightTurnSignalStatus::LightFault,
            0 => Id3e3vcrightLightStatusVcrightTurnSignalStatus::LightOff,
            1 => Id3e3vcrightLightStatusVcrightTurnSignalStatus::LightOn,
            3 => Id3e3vcrightLightStatusVcrightTurnSignalStatus::LightSna,
            x => Id3e3vcrightLightStatusVcrightTurnSignalStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_turnSignalStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_turn_signal_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_turnSignalStatus
    #[inline(always)]
    pub fn set_vcright_turn_signal_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 995 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3e3vcrightLightStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3e3vcrightLightStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_brake_light_status = u.int_in_range(0..=3)?;
        let vcright_interior_trunk_light_status = u.int_in_range(0..=3)?;
        let vcright_rear_fog_light_status = u.int_in_range(0..=3)?;
        let vcright_reverse_light_status = u.int_in_range(0..=3)?;
        let vcright_tail_light_status = u.int_in_range(0..=3)?;
        let vcright_turn_signal_status = u.int_in_range(0..=3)?;
        Id3e3vcrightLightStatus::new(vcright_brake_light_status,vcright_interior_trunk_light_status,vcright_rear_fog_light_status,vcright_reverse_light_status,vcright_tail_light_status,vcright_turn_signal_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_brakeLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e3vcrightLightStatusVcrightBrakeLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCRIGHT_interiorTrunkLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e3vcrightLightStatusVcrightInteriorTrunkLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCRIGHT_rearFogLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e3vcrightLightStatusVcrightRearFogLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCRIGHT_reverseLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e3vcrightLightStatusVcrightReverseLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCRIGHT_tailLightStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e3vcrightLightStatusVcrightTailLightStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}
/// Defined values for VCRIGHT_turnSignalStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id3e3vcrightLightStatusVcrightTurnSignalStatus {
    LightFault,
    LightOff,
    LightOn,
    LightSna,
    Other(u8),
}

/// ID656FrontDIinfo
///
/// - ID: 1622 (0x656)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id656FrontDIinfo {
    raw: [u8; 8],
}

impl Id656FrontDIinfo {
    pub const MESSAGE_ID: u32 = 1622;
    
    /// Construct new ID656FrontDIinfo from values
    pub fn new(dif_info_index: u8, dif_fpga_version: u8, dif_app_git_hash: u64, dif_application_crc: u32, dif_assembly_id: u8, dif_boot_git_hash: u64, dif_bootloader_crc: u32, dif_build_configuration_id: u16, dif_build_type: u8, dif_component_id: u16, dif_hardware_id: u8, dif_info_boot_ld_uds_protocol_version: u8, dif_oil_pump_app_crc: u32, dif_oil_pump_build_type: u8, dif_pcba_id: u8, dif_platform_typ: u8, dif_sub_usage_id: u16, dif_subcomponent_git_hash: u64, dif_usage_id: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_dif_info_index(dif_info_index)?;
        res.set_dif_fpga_version(dif_fpga_version)?;
        res.set_dif_app_git_hash(dif_app_git_hash)?;
        res.set_dif_application_crc(dif_application_crc)?;
        res.set_dif_assembly_id(dif_assembly_id)?;
        res.set_dif_boot_git_hash(dif_boot_git_hash)?;
        res.set_dif_bootloader_crc(dif_bootloader_crc)?;
        res.set_dif_build_configuration_id(dif_build_configuration_id)?;
        res.set_dif_build_type(dif_build_type)?;
        res.set_dif_component_id(dif_component_id)?;
        res.set_dif_hardware_id(dif_hardware_id)?;
        res.set_dif_info_boot_ld_uds_protocol_version(dif_info_boot_ld_uds_protocol_version)?;
        res.set_dif_oil_pump_app_crc(dif_oil_pump_app_crc)?;
        res.set_dif_oil_pump_build_type(dif_oil_pump_build_type)?;
        res.set_dif_pcba_id(dif_pcba_id)?;
        res.set_dif_platform_typ(dif_platform_typ)?;
        res.set_dif_sub_usage_id(dif_sub_usage_id)?;
        res.set_dif_subcomponent_git_hash(dif_subcomponent_git_hash)?;
        res.set_dif_usage_id(dif_usage_id)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DIF_infoIndex
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_info_index(&self) -> Id656FrontDIinfoDifInfoIndex {
        match self.dif_info_index_raw() {
            13 => Id656FrontDIinfoDifInfoIndex::DiInfoAppCrc,
            17 => Id656FrontDIinfoDifInfoIndex::DiInfoAppGithash,
            15 => Id656FrontDIinfoDifInfoIndex::DiInfoBootloaderCrc,
            18 => Id656FrontDIinfoDifInfoIndex::DiInfoBootloaderGithash,
            14 => Id656FrontDIinfoDifInfoIndex::DiInfoBootloaderSvn,
            10 => Id656FrontDIinfoDifInfoIndex::DiInfoBuildHwidComponentid,
            0 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated0,
            1 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated1,
            2 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated2,
            3 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated3,
            4 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated4,
            5 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated5,
            6 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated6,
            7 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated7,
            8 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated8,
            9 => Id656FrontDIinfoDifInfoIndex::DiInfoDeprecated9,
            255 => Id656FrontDIinfoDifInfoIndex::DiInfoEnd,
            11 => Id656FrontDIinfoDifInfoIndex::DiInfoPcbaidAssyidUsageid,
            16 => Id656FrontDIinfoDifInfoIndex::DiInfoSubcomponent,
            23 => Id656FrontDIinfoDifInfoIndex::DiInfoSubcomponent2,
            31 => Id656FrontDIinfoDifInfoIndex::DiInfoSubcomponentGithash,
            20 => Id656FrontDIinfoDifInfoIndex::DiInfoUdsProtocolBootcrc,
            19 => Id656FrontDIinfoDifInfoIndex::DiInfoVersionDeprecated,
            x => Id656FrontDIinfoDifInfoIndex::Other(x),
        }
    }
    
    /// Get raw value of DIF_infoIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_info_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_infoIndex
    #[inline(always)]
    pub fn set_dif_info_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// DIF_FPGA_version
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_fpga_version(&self) -> Id656FrontDIinfoDifFpgaVersion {
        match self.dif_fpga_version_raw() {
            254 => Id656FrontDIinfoDifFpgaVersion::FpgaVersionLocalBuild,
            255 => Id656FrontDIinfoDifFpgaVersion::FpgaVersionSna,
            x => Id656FrontDIinfoDifFpgaVersion::Other(x),
        }
    }
    
    /// Get raw value of DIF_FPGA_version
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_fpga_version_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_FPGA_version
    #[inline(always)]
    pub fn set_dif_fpga_version(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_appGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_app_git_hash(&self) -> u64 {
        self.dif_app_git_hash_raw()
    }
    
    /// Get raw value of DIF_appGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_app_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of DIF_appGitHash
    #[inline(always)]
    pub fn set_dif_app_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// DIF_applicationCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_application_crc(&self) -> u32 {
        self.dif_application_crc_raw()
    }
    
    /// Get raw value of DIF_applicationCrc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_application_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIF_applicationCrc
    #[inline(always)]
    pub fn set_dif_application_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIF_assemblyId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_assembly_id(&self) -> u8 {
        self.dif_assembly_id_raw()
    }
    
    /// Get raw value of DIF_assemblyId
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_assembly_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_assemblyId
    #[inline(always)]
    pub fn set_dif_assembly_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_bootGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_boot_git_hash(&self) -> u64 {
        self.dif_boot_git_hash_raw()
    }
    
    /// Get raw value of DIF_bootGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_boot_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of DIF_bootGitHash
    #[inline(always)]
    pub fn set_dif_boot_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// DIF_bootloaderCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_bootloader_crc(&self) -> u32 {
        self.dif_bootloader_crc_raw()
    }
    
    /// Get raw value of DIF_bootloaderCrc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_bootloader_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIF_bootloaderCrc
    #[inline(always)]
    pub fn set_dif_bootloader_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIF_buildConfigurationId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_build_configuration_id(&self) -> u16 {
        self.dif_build_configuration_id_raw()
    }
    
    /// Get raw value of DIF_buildConfigurationId
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_build_configuration_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_buildConfigurationId
    #[inline(always)]
    pub fn set_dif_build_configuration_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_buildType
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_build_type(&self) -> Id656FrontDIinfoDifBuildType {
        match self.dif_build_type_raw() {
            2 => Id656FrontDIinfoDifBuildType::InfoLocalBuild,
            4 => Id656FrontDIinfoDifBuildType::InfoMfgBuild,
            1 => Id656FrontDIinfoDifBuildType::InfoPlatformBuild,
            3 => Id656FrontDIinfoDifBuildType::InfoTraceableCiBuild,
            0 => Id656FrontDIinfoDifBuildType::InfoUnknownBuild,
            x => Id656FrontDIinfoDifBuildType::Other(x),
        }
    }
    
    /// Get raw value of DIF_buildType
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_build_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_buildType
    #[inline(always)]
    pub fn set_dif_build_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// DIF_componentId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_component_id(&self) -> u16 {
        self.dif_component_id_raw()
    }
    
    /// Get raw value of DIF_componentId
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_component_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_componentId
    #[inline(always)]
    pub fn set_dif_component_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_hardwareId
    ///
    /// - Min: 0
    /// - Max: 252
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_hardware_id(&self) -> Id656FrontDIinfoDifHardwareId {
        match self.dif_hardware_id_raw() {
            252 => Id656FrontDIinfoDifHardwareId::ConfigurableHwidPlaceholder,
            x => Id656FrontDIinfoDifHardwareId::Other(x),
        }
    }
    
    /// Get raw value of DIF_hardwareId
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_hardware_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_hardwareId
    #[inline(always)]
    pub fn set_dif_hardware_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 252_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_infoBootLdUdsProtocolVersion
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_info_boot_ld_uds_protocol_version(&self) -> u8 {
        self.dif_info_boot_ld_uds_protocol_version_raw()
    }
    
    /// Get raw value of DIF_infoBootLdUdsProtocolVersion
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_info_boot_ld_uds_protocol_version_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_infoBootLdUdsProtocolVersion
    #[inline(always)]
    pub fn set_dif_info_boot_ld_uds_protocol_version(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_oilPumpAppCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_oil_pump_app_crc(&self) -> u32 {
        self.dif_oil_pump_app_crc_raw()
    }
    
    /// Get raw value of DIF_oilPumpAppCrc
    ///
    /// - Start bit: 16
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_oil_pump_app_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..48].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIF_oilPumpAppCrc
    #[inline(always)]
    pub fn set_dif_oil_pump_app_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..48].store_le(value);
        Ok(())
    }
    
    /// DIF_oilPumpBuildType
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_oil_pump_build_type(&self) -> Id656FrontDIinfoDifOilPumpBuildType {
        match self.dif_oil_pump_build_type_raw() {
            2 => Id656FrontDIinfoDifOilPumpBuildType::InfoLocalBuild,
            4 => Id656FrontDIinfoDifOilPumpBuildType::InfoMfgBuild,
            1 => Id656FrontDIinfoDifOilPumpBuildType::InfoPlatformBuild,
            3 => Id656FrontDIinfoDifOilPumpBuildType::InfoTraceableCiBuild,
            0 => Id656FrontDIinfoDifOilPumpBuildType::InfoUnknownBuild,
            x => Id656FrontDIinfoDifOilPumpBuildType::Other(x),
        }
    }
    
    /// Get raw value of DIF_oilPumpBuildType
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_oil_pump_build_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_oilPumpBuildType
    #[inline(always)]
    pub fn set_dif_oil_pump_build_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// DIF_pcbaId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pcba_id(&self) -> u8 {
        self.dif_pcba_id_raw()
    }
    
    /// Get raw value of DIF_pcbaId
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pcba_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_pcbaId
    #[inline(always)]
    pub fn set_dif_pcba_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_platformTyp
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_platform_typ(&self) -> u8 {
        self.dif_platform_typ_raw()
    }
    
    /// Get raw value of DIF_platformTyp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_platform_typ_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_platformTyp
    #[inline(always)]
    pub fn set_dif_platform_typ(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_subUsageId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_sub_usage_id(&self) -> u16 {
        self.dif_sub_usage_id_raw()
    }
    
    /// Get raw value of DIF_subUsageId
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_sub_usage_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_subUsageId
    #[inline(always)]
    pub fn set_dif_sub_usage_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_subcomponentGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_subcomponent_git_hash(&self) -> u64 {
        self.dif_subcomponent_git_hash_raw()
    }
    
    /// Get raw value of DIF_subcomponentGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_subcomponent_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of DIF_subcomponentGitHash
    #[inline(always)]
    pub fn set_dif_subcomponent_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// DIF_usageId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_usage_id(&self) -> u16 {
        self.dif_usage_id_raw()
    }
    
    /// Get raw value of DIF_usageId
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_usage_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_usageId
    #[inline(always)]
    pub fn set_dif_usage_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1622 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id656FrontDIinfo {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id656FrontDIinfo
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let dif_info_index = u.int_in_range(0..=255)?;
        let dif_fpga_version = u.int_in_range(0..=255)?;
        let dif_app_git_hash = u.int_in_range(0..=72057600000000000)?;
        let dif_application_crc = u.int_in_range(0..=4294970000)?;
        let dif_assembly_id = u.int_in_range(0..=255)?;
        let dif_boot_git_hash = u.int_in_range(0..=72057600000000000)?;
        let dif_bootloader_crc = u.int_in_range(0..=4294970000)?;
        let dif_build_configuration_id = u.int_in_range(0..=65535)?;
        let dif_build_type = u.int_in_range(0..=4)?;
        let dif_component_id = u.int_in_range(0..=65535)?;
        let dif_hardware_id = u.int_in_range(0..=252)?;
        let dif_info_boot_ld_uds_protocol_version = u.int_in_range(0..=255)?;
        let dif_oil_pump_app_crc = u.int_in_range(0..=4294970000)?;
        let dif_oil_pump_build_type = u.int_in_range(0..=4)?;
        let dif_pcba_id = u.int_in_range(0..=255)?;
        let dif_platform_typ = u.int_in_range(0..=255)?;
        let dif_sub_usage_id = u.int_in_range(0..=65535)?;
        let dif_subcomponent_git_hash = u.int_in_range(0..=72057600000000000)?;
        let dif_usage_id = u.int_in_range(0..=65535)?;
        Id656FrontDIinfo::new(dif_info_index,dif_fpga_version,dif_app_git_hash,dif_application_crc,dif_assembly_id,dif_boot_git_hash,dif_bootloader_crc,dif_build_configuration_id,dif_build_type,dif_component_id,dif_hardware_id,dif_info_boot_ld_uds_protocol_version,dif_oil_pump_app_crc,dif_oil_pump_build_type,dif_pcba_id,dif_platform_typ,dif_sub_usage_id,dif_subcomponent_git_hash,dif_usage_id).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DIF_infoIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id656FrontDIinfoDifInfoIndex {
    DiInfoAppCrc,
    DiInfoAppGithash,
    DiInfoBootloaderCrc,
    DiInfoBootloaderGithash,
    DiInfoBootloaderSvn,
    DiInfoBuildHwidComponentid,
    DiInfoDeprecated0,
    DiInfoDeprecated1,
    DiInfoDeprecated2,
    DiInfoDeprecated3,
    DiInfoDeprecated4,
    DiInfoDeprecated5,
    DiInfoDeprecated6,
    DiInfoDeprecated7,
    DiInfoDeprecated8,
    DiInfoDeprecated9,
    DiInfoEnd,
    DiInfoPcbaidAssyidUsageid,
    DiInfoSubcomponent,
    DiInfoSubcomponent2,
    DiInfoSubcomponentGithash,
    DiInfoUdsProtocolBootcrc,
    DiInfoVersionDeprecated,
    Other(u8),
}
/// Defined values for DIF_FPGA_version
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id656FrontDIinfoDifFpgaVersion {
    FpgaVersionLocalBuild,
    FpgaVersionSna,
    Other(u8),
}
/// Defined values for DIF_buildType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id656FrontDIinfoDifBuildType {
    InfoLocalBuild,
    InfoMfgBuild,
    InfoPlatformBuild,
    InfoTraceableCiBuild,
    InfoUnknownBuild,
    Other(u8),
}
/// Defined values for DIF_hardwareId
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id656FrontDIinfoDifHardwareId {
    ConfigurableHwidPlaceholder,
    Other(u8),
}
/// Defined values for DIF_oilPumpBuildType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id656FrontDIinfoDifOilPumpBuildType {
    InfoLocalBuild,
    InfoMfgBuild,
    InfoPlatformBuild,
    InfoTraceableCiBuild,
    InfoUnknownBuild,
    Other(u8),
}

/// ID300BMS_info
///
/// - ID: 768 (0x300)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id300bmsInfo {
    raw: [u8; 8],
}

impl Id300bmsInfo {
    pub const MESSAGE_ID: u32 = 768;
    
    /// Construct new ID300BMS_info from values
    pub fn new(bms_info_index: u8, bms_app_crc: u32, bms_app_git_hash: u64, bms_assembly_id: u8, bms_boot_crc: u32, bms_boot_git_hash: u64, bms_boot_uds_proto_version: u8, bms_build_config_id: u16, bms_build_type: u8, bms_component_id: u16, bms_hardware_id: u16, bms_pcba_id: u8, bms_platform_type: u8, bms_sub_usage_id: u16, bms_usage_id: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_bms_info_index(bms_info_index)?;
        res.set_bms_app_crc(bms_app_crc)?;
        res.set_bms_app_git_hash(bms_app_git_hash)?;
        res.set_bms_assembly_id(bms_assembly_id)?;
        res.set_bms_boot_crc(bms_boot_crc)?;
        res.set_bms_boot_git_hash(bms_boot_git_hash)?;
        res.set_bms_boot_uds_proto_version(bms_boot_uds_proto_version)?;
        res.set_bms_build_config_id(bms_build_config_id)?;
        res.set_bms_build_type(bms_build_type)?;
        res.set_bms_component_id(bms_component_id)?;
        res.set_bms_hardware_id(bms_hardware_id)?;
        res.set_bms_pcba_id(bms_pcba_id)?;
        res.set_bms_platform_type(bms_platform_type)?;
        res.set_bms_sub_usage_id(bms_sub_usage_id)?;
        res.set_bms_usage_id(bms_usage_id)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// BMS_infoIndex
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_info_index(&self) -> Id300bmsInfoBmsInfoIndex {
        match self.bms_info_index_raw() {
            13 => Id300bmsInfoBmsInfoIndex::InfoAppCrc,
            17 => Id300bmsInfoBmsInfoIndex::InfoAppGithash,
            15 => Id300bmsInfoBmsInfoIndex::InfoBootloaderCrc,
            18 => Id300bmsInfoBmsInfoIndex::InfoBootloaderGithash,
            14 => Id300bmsInfoBmsInfoIndex::InfoBootloaderSvn,
            10 => Id300bmsInfoBmsInfoIndex::InfoBuildHwidComponentid,
            0 => Id300bmsInfoBmsInfoIndex::InfoDeprecated0,
            1 => Id300bmsInfoBmsInfoIndex::InfoDeprecated1,
            2 => Id300bmsInfoBmsInfoIndex::InfoDeprecated2,
            3 => Id300bmsInfoBmsInfoIndex::InfoDeprecated3,
            4 => Id300bmsInfoBmsInfoIndex::InfoDeprecated4,
            5 => Id300bmsInfoBmsInfoIndex::InfoDeprecated5,
            6 => Id300bmsInfoBmsInfoIndex::InfoDeprecated6,
            7 => Id300bmsInfoBmsInfoIndex::InfoDeprecated7,
            8 => Id300bmsInfoBmsInfoIndex::InfoDeprecated8,
            9 => Id300bmsInfoBmsInfoIndex::InfoDeprecated9,
            255 => Id300bmsInfoBmsInfoIndex::InfoEnd,
            27 => Id300bmsInfoBmsInfoIndex::InfoPackagePn1520,
            25 => Id300bmsInfoBmsInfoIndex::InfoPackagePn17,
            26 => Id300bmsInfoBmsInfoIndex::InfoPackagePn814,
            29 => Id300bmsInfoBmsInfoIndex::InfoPackageSn17,
            30 => Id300bmsInfoBmsInfoIndex::InfoPackageSn814,
            11 => Id300bmsInfoBmsInfoIndex::InfoPcbaidAssyidUsageid,
            16 => Id300bmsInfoBmsInfoIndex::InfoSubcomponent,
            31 => Id300bmsInfoBmsInfoIndex::InfoSubcomponentGithash,
            20 => Id300bmsInfoBmsInfoIndex::InfoUdsProtocolBootcrc,
            22 => Id300bmsInfoBmsInfoIndex::InfoVariantcrc,
            19 => Id300bmsInfoBmsInfoIndex::InfoVersionDeprecated,
            x => Id300bmsInfoBmsInfoIndex::Other(x),
        }
    }
    
    /// Get raw value of BMS_infoIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_info_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_infoIndex
    #[inline(always)]
    pub fn set_bms_info_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// BMS_appCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_app_crc(&self) -> u32 {
        self.bms_app_crc_raw()
    }
    
    /// Get raw value of BMS_appCrc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_app_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of BMS_appCrc
    #[inline(always)]
    pub fn set_bms_app_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// BMS_appGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_app_git_hash(&self) -> u64 {
        self.bms_app_git_hash_raw()
    }
    
    /// Get raw value of BMS_appGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_app_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of BMS_appGitHash
    #[inline(always)]
    pub fn set_bms_app_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// BMS_assemblyId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_assembly_id(&self) -> u8 {
        self.bms_assembly_id_raw()
    }
    
    /// Get raw value of BMS_assemblyId
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_assembly_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_assemblyId
    #[inline(always)]
    pub fn set_bms_assembly_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// BMS_bootCrc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_boot_crc(&self) -> u32 {
        self.bms_boot_crc_raw()
    }
    
    /// Get raw value of BMS_bootCrc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_boot_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of BMS_bootCrc
    #[inline(always)]
    pub fn set_bms_boot_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// BMS_bootGitHash
    ///
    /// - Min: 0
    /// - Max: 72057600000000000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_boot_git_hash(&self) -> u64 {
        self.bms_boot_git_hash_raw()
    }
    
    /// Get raw value of BMS_bootGitHash
    ///
    /// - Start bit: 8
    /// - Signal size: 56 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_boot_git_hash_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<LocalBits>()[8..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of BMS_bootGitHash
    #[inline(always)]
    pub fn set_bms_boot_git_hash(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 72057600000000000_u64 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..64].store_le(value);
        Ok(())
    }
    
    /// BMS_bootUdsProtoVersion
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_boot_uds_proto_version(&self) -> u8 {
        self.bms_boot_uds_proto_version_raw()
    }
    
    /// Get raw value of BMS_bootUdsProtoVersion
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_boot_uds_proto_version_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_bootUdsProtoVersion
    #[inline(always)]
    pub fn set_bms_boot_uds_proto_version(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// BMS_buildConfigId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_build_config_id(&self) -> u16 {
        self.bms_build_config_id_raw()
    }
    
    /// Get raw value of BMS_buildConfigId
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_build_config_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of BMS_buildConfigId
    #[inline(always)]
    pub fn set_bms_build_config_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// BMS_buildType
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_build_type(&self) -> Id300bmsInfoBmsBuildType {
        match self.bms_build_type_raw() {
            2 => Id300bmsInfoBmsBuildType::InfoLocalBuild,
            4 => Id300bmsInfoBmsBuildType::InfoMfgBuild,
            1 => Id300bmsInfoBmsBuildType::InfoPlatformBuild,
            3 => Id300bmsInfoBmsBuildType::InfoTraceableCiBuild,
            0 => Id300bmsInfoBmsBuildType::InfoUnknownBuild,
            x => Id300bmsInfoBmsBuildType::Other(x),
        }
    }
    
    /// Get raw value of BMS_buildType
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_build_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_buildType
    #[inline(always)]
    pub fn set_bms_build_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// BMS_componentId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_component_id(&self) -> u16 {
        self.bms_component_id_raw()
    }
    
    /// Get raw value of BMS_componentId
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_component_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of BMS_componentId
    #[inline(always)]
    pub fn set_bms_component_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// BMS_hardwareId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_hardware_id(&self) -> u16 {
        self.bms_hardware_id_raw()
    }
    
    /// Get raw value of BMS_hardwareId
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_hardware_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of BMS_hardwareId
    #[inline(always)]
    pub fn set_bms_hardware_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// BMS_pcbaId
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_pcba_id(&self) -> u8 {
        self.bms_pcba_id_raw()
    }
    
    /// Get raw value of BMS_pcbaId
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_pcba_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_pcbaId
    #[inline(always)]
    pub fn set_bms_pcba_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// BMS_platformType
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_platform_type(&self) -> u8 {
        self.bms_platform_type_raw()
    }
    
    /// Get raw value of BMS_platformType
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_platform_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_platformType
    #[inline(always)]
    pub fn set_bms_platform_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// BMS_subUsageId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_sub_usage_id(&self) -> u16 {
        self.bms_sub_usage_id_raw()
    }
    
    /// Get raw value of BMS_subUsageId
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_sub_usage_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of BMS_subUsageId
    #[inline(always)]
    pub fn set_bms_sub_usage_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// BMS_usageId
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_usage_id(&self) -> u16 {
        self.bms_usage_id_raw()
    }
    
    /// Get raw value of BMS_usageId
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_usage_id_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of BMS_usageId
    #[inline(always)]
    pub fn set_bms_usage_id(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 768 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id300bmsInfo {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id300bmsInfo
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let bms_info_index = u.int_in_range(0..=255)?;
        let bms_app_crc = u.int_in_range(0..=4294970000)?;
        let bms_app_git_hash = u.int_in_range(0..=72057600000000000)?;
        let bms_assembly_id = u.int_in_range(0..=255)?;
        let bms_boot_crc = u.int_in_range(0..=4294970000)?;
        let bms_boot_git_hash = u.int_in_range(0..=72057600000000000)?;
        let bms_boot_uds_proto_version = u.int_in_range(0..=255)?;
        let bms_build_config_id = u.int_in_range(0..=65535)?;
        let bms_build_type = u.int_in_range(0..=4)?;
        let bms_component_id = u.int_in_range(0..=65535)?;
        let bms_hardware_id = u.int_in_range(0..=65535)?;
        let bms_pcba_id = u.int_in_range(0..=255)?;
        let bms_platform_type = u.int_in_range(0..=255)?;
        let bms_sub_usage_id = u.int_in_range(0..=65535)?;
        let bms_usage_id = u.int_in_range(0..=65535)?;
        Id300bmsInfo::new(bms_info_index,bms_app_crc,bms_app_git_hash,bms_assembly_id,bms_boot_crc,bms_boot_git_hash,bms_boot_uds_proto_version,bms_build_config_id,bms_build_type,bms_component_id,bms_hardware_id,bms_pcba_id,bms_platform_type,bms_sub_usage_id,bms_usage_id).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for BMS_infoIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id300bmsInfoBmsInfoIndex {
    InfoAppCrc,
    InfoAppGithash,
    InfoBootloaderCrc,
    InfoBootloaderGithash,
    InfoBootloaderSvn,
    InfoBuildHwidComponentid,
    InfoDeprecated0,
    InfoDeprecated1,
    InfoDeprecated2,
    InfoDeprecated3,
    InfoDeprecated4,
    InfoDeprecated5,
    InfoDeprecated6,
    InfoDeprecated7,
    InfoDeprecated8,
    InfoDeprecated9,
    InfoEnd,
    InfoPackagePn1520,
    InfoPackagePn17,
    InfoPackagePn814,
    InfoPackageSn17,
    InfoPackageSn814,
    InfoPcbaidAssyidUsageid,
    InfoSubcomponent,
    InfoSubcomponentGithash,
    InfoUdsProtocolBootcrc,
    InfoVariantcrc,
    InfoVersionDeprecated,
    Other(u8),
}
/// Defined values for BMS_buildType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id300bmsInfoBmsBuildType {
    InfoLocalBuild,
    InfoMfgBuild,
    InfoPlatformBuild,
    InfoTraceableCiBuild,
    InfoUnknownBuild,
    Other(u8),
}

/// ID212BMS_status
///
/// - ID: 530 (0x212)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id212bmsStatus {
    raw: [u8; 8],
}

impl Id212bmsStatus {
    pub const MESSAGE_ID: u32 = 530;
    
    /// Construct new ID212BMS_status from values
    pub fn new(bms_active_heating_worthwhile: bool, bms_charge_request: bool, bms_charge_retry_count: u8, bms_chg_power_available: f32, bms_contactor_state: u8, bms_cp_mia_on_hvs: bool, bms_di_limp_request: bool, bms_ecu_log_upload_request: u8, bms_hv_state: u8, bms_hvac_power_request: bool, bms_isolation_resistance: f32, bms_keep_warm_request: bool, bms_not_enough_power_for_drive: bool, bms_not_enough_power_for_support: bool, bms_ok_to_ship_by_air: bool, bms_ok_to_ship_by_land: bool, bms_pcs_pwm_enabled: bool, bms_precondition_allowed: bool, bms_sm_state_request: u8, bms_state: u8, bms_ui_charge_status: u8, bms_update_allowed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_bms_active_heating_worthwhile(bms_active_heating_worthwhile)?;
        res.set_bms_charge_request(bms_charge_request)?;
        res.set_bms_charge_retry_count(bms_charge_retry_count)?;
        res.set_bms_chg_power_available(bms_chg_power_available)?;
        res.set_bms_contactor_state(bms_contactor_state)?;
        res.set_bms_cp_mia_on_hvs(bms_cp_mia_on_hvs)?;
        res.set_bms_di_limp_request(bms_di_limp_request)?;
        res.set_bms_ecu_log_upload_request(bms_ecu_log_upload_request)?;
        res.set_bms_hv_state(bms_hv_state)?;
        res.set_bms_hvac_power_request(bms_hvac_power_request)?;
        res.set_bms_isolation_resistance(bms_isolation_resistance)?;
        res.set_bms_keep_warm_request(bms_keep_warm_request)?;
        res.set_bms_not_enough_power_for_drive(bms_not_enough_power_for_drive)?;
        res.set_bms_not_enough_power_for_support(bms_not_enough_power_for_support)?;
        res.set_bms_ok_to_ship_by_air(bms_ok_to_ship_by_air)?;
        res.set_bms_ok_to_ship_by_land(bms_ok_to_ship_by_land)?;
        res.set_bms_pcs_pwm_enabled(bms_pcs_pwm_enabled)?;
        res.set_bms_precondition_allowed(bms_precondition_allowed)?;
        res.set_bms_sm_state_request(bms_sm_state_request)?;
        res.set_bms_state(bms_state)?;
        res.set_bms_ui_charge_status(bms_ui_charge_status)?;
        res.set_bms_update_allowed(bms_update_allowed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// BMS_activeHeatingWorthwhile
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_active_heating_worthwhile(&self) -> bool {
        self.bms_active_heating_worthwhile_raw()
    }
    
    /// Get raw value of BMS_activeHeatingWorthwhile
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_active_heating_worthwhile_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_activeHeatingWorthwhile
    #[inline(always)]
    pub fn set_bms_active_heating_worthwhile(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// BMS_chargeRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_charge_request(&self) -> bool {
        self.bms_charge_request_raw()
    }
    
    /// Get raw value of BMS_chargeRequest
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_charge_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_chargeRequest
    #[inline(always)]
    pub fn set_bms_charge_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// BMS_chargeRetryCount
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_charge_retry_count(&self) -> u8 {
        self.bms_charge_retry_count_raw()
    }
    
    /// Get raw value of BMS_chargeRetryCount
    ///
    /// - Start bit: 51
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_charge_retry_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[51..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_chargeRetryCount
    #[inline(always)]
    pub fn set_bms_charge_retry_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[51..54].store_le(value);
        Ok(())
    }
    
    /// BMS_chgPowerAvailable
    ///
    /// - Min: 0
    /// - Max: 255.75
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_chg_power_available(&self) -> Id212bmsStatusBmsChgPowerAvailable {
        match self.bms_chg_power_available_raw() {
            2047 => Id212bmsStatusBmsChgPowerAvailable::Sna,
            x => Id212bmsStatusBmsChgPowerAvailable::Other(x),
        }
    }
    
    /// Get raw value of BMS_chgPowerAvailable
    ///
    /// - Start bit: 40
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_chg_power_available_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..51].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BMS_chgPowerAvailable
    #[inline(always)]
    pub fn set_bms_chg_power_available(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 255.75_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        let factor = 0.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..51].store_le(value);
        Ok(())
    }
    
    /// BMS_contactorState
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_contactor_state(&self) -> Id212bmsStatusBmsContactorState {
        match self.bms_contactor_state_raw() {
            6 => Id212bmsStatusBmsContactorState::BmsCtrsetBlocked,
            4 => Id212bmsStatusBmsContactorState::BmsCtrsetClosed,
            3 => Id212bmsStatusBmsContactorState::BmsCtrsetClosing,
            1 => Id212bmsStatusBmsContactorState::BmsCtrsetOpen,
            2 => Id212bmsStatusBmsContactorState::BmsCtrsetOpening,
            0 => Id212bmsStatusBmsContactorState::BmsCtrsetSna,
            5 => Id212bmsStatusBmsContactorState::BmsCtrsetWelded,
            x => Id212bmsStatusBmsContactorState::Other(x),
        }
    }
    
    /// Get raw value of BMS_contactorState
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_contactor_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_contactorState
    #[inline(always)]
    pub fn set_bms_contactor_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// BMS_cpMiaOnHvs
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_cp_mia_on_hvs(&self) -> bool {
        self.bms_cp_mia_on_hvs_raw()
    }
    
    /// Get raw value of BMS_cpMiaOnHvs
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_cp_mia_on_hvs_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_cpMiaOnHvs
    #[inline(always)]
    pub fn set_bms_cp_mia_on_hvs(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// BMS_diLimpRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_di_limp_request(&self) -> Id212bmsStatusBmsDiLimpRequest {
        match self.bms_di_limp_request_raw() {
            false => Id212bmsStatusBmsDiLimpRequest::LimpRequestNone,
            true => Id212bmsStatusBmsDiLimpRequest::LimpRequestWelded,
            x => Id212bmsStatusBmsDiLimpRequest::Other(x),
        }
    }
    
    /// Get raw value of BMS_diLimpRequest
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_di_limp_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_diLimpRequest
    #[inline(always)]
    pub fn set_bms_di_limp_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[36..37].store_le(value);
        Ok(())
    }
    
    /// BMS_ecuLogUploadRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_ecu_log_upload_request(&self) -> Id212bmsStatusBmsEcuLogUploadRequest {
        match self.bms_ecu_log_upload_request_raw() {
            1 => Id212bmsStatusBmsEcuLogUploadRequest::RequestPriority1,
            2 => Id212bmsStatusBmsEcuLogUploadRequest::RequestPriority2,
            3 => Id212bmsStatusBmsEcuLogUploadRequest::RequestPriority3,
            0 => Id212bmsStatusBmsEcuLogUploadRequest::RequestPriorityNone,
            x => Id212bmsStatusBmsEcuLogUploadRequest::Other(x),
        }
    }
    
    /// Get raw value of BMS_ecuLogUploadRequest
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_ecu_log_upload_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_ecuLogUploadRequest
    #[inline(always)]
    pub fn set_bms_ecu_log_upload_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// BMS_hvState
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_hv_state(&self) -> Id212bmsStatusBmsHvState {
        match self.bms_hv_state_raw() {
            1 => Id212bmsStatusBmsHvState::HvComingUp,
            0 => Id212bmsStatusBmsHvState::HvDown,
            2 => Id212bmsStatusBmsHvState::HvGoingDown,
            6 => Id212bmsStatusBmsHvState::HvUp,
            4 => Id212bmsStatusBmsHvState::HvUpForCharge,
            5 => Id212bmsStatusBmsHvState::HvUpForDcCharge,
            3 => Id212bmsStatusBmsHvState::HvUpForDrive,
            x => Id212bmsStatusBmsHvState::Other(x),
        }
    }
    
    /// Get raw value of BMS_hvState
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_hv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_hvState
    #[inline(always)]
    pub fn set_bms_hv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..19].store_le(value);
        Ok(())
    }
    
    /// BMS_hvacPowerRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_hvac_power_request(&self) -> bool {
        self.bms_hvac_power_request_raw()
    }
    
    /// Get raw value of BMS_hvacPowerRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_hvac_power_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_hvacPowerRequest
    #[inline(always)]
    pub fn set_bms_hvac_power_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// BMS_isolationResistance
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "kOhm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_isolation_resistance(&self) -> Id212bmsStatusBmsIsolationResistance {
        match self.bms_isolation_resistance_raw() {
            1023 => Id212bmsStatusBmsIsolationResistance::Sna,
            x => Id212bmsStatusBmsIsolationResistance::Other(x),
        }
    }
    
    /// Get raw value of BMS_isolationResistance
    ///
    /// - Start bit: 19
    /// - Signal size: 10 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_isolation_resistance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[19..29].load_le::<u16>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BMS_isolationResistance
    #[inline(always)]
    pub fn set_bms_isolation_resistance(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[19..29].store_le(value);
        Ok(())
    }
    
    /// BMS_keepWarmRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_keep_warm_request(&self) -> bool {
        self.bms_keep_warm_request_raw()
    }
    
    /// Get raw value of BMS_keepWarmRequest
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_keep_warm_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_keepWarmRequest
    #[inline(always)]
    pub fn set_bms_keep_warm_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// BMS_notEnoughPowerForDrive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_not_enough_power_for_drive(&self) -> bool {
        self.bms_not_enough_power_for_drive_raw()
    }
    
    /// Get raw value of BMS_notEnoughPowerForDrive
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_not_enough_power_for_drive_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_notEnoughPowerForDrive
    #[inline(always)]
    pub fn set_bms_not_enough_power_for_drive(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// BMS_notEnoughPowerForSupport
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_not_enough_power_for_support(&self) -> bool {
        self.bms_not_enough_power_for_support_raw()
    }
    
    /// Get raw value of BMS_notEnoughPowerForSupport
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_not_enough_power_for_support_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_notEnoughPowerForSupport
    #[inline(always)]
    pub fn set_bms_not_enough_power_for_support(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// BMS_okToShipByAir
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_ok_to_ship_by_air(&self) -> bool {
        self.bms_ok_to_ship_by_air_raw()
    }
    
    /// Get raw value of BMS_okToShipByAir
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_ok_to_ship_by_air_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_okToShipByAir
    #[inline(always)]
    pub fn set_bms_ok_to_ship_by_air(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// BMS_okToShipByLand
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_ok_to_ship_by_land(&self) -> bool {
        self.bms_ok_to_ship_by_land_raw()
    }
    
    /// Get raw value of BMS_okToShipByLand
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_ok_to_ship_by_land_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_okToShipByLand
    #[inline(always)]
    pub fn set_bms_ok_to_ship_by_land(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// BMS_pcsPwmEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_pcs_pwm_enabled(&self) -> bool {
        self.bms_pcs_pwm_enabled_raw()
    }
    
    /// Get raw value of BMS_pcsPwmEnabled
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_pcs_pwm_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_pcsPwmEnabled
    #[inline(always)]
    pub fn set_bms_pcs_pwm_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// BMS_preconditionAllowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_precondition_allowed(&self) -> bool {
        self.bms_precondition_allowed_raw()
    }
    
    /// Get raw value of BMS_preconditionAllowed
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_precondition_allowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_preconditionAllowed
    #[inline(always)]
    pub fn set_bms_precondition_allowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// BMS_smStateRequest
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_sm_state_request(&self) -> Id212bmsStatusBmsSmStateRequest {
        match self.bms_sm_state_request_raw() {
            3 => Id212bmsStatusBmsSmStateRequest::BmsCharge,
            5 => Id212bmsStatusBmsSmStateRequest::BmsClearFault,
            10 => Id212bmsStatusBmsSmStateRequest::BmsDiag,
            1 => Id212bmsStatusBmsSmStateRequest::BmsDrive,
            6 => Id212bmsStatusBmsSmStateRequest::BmsFault,
            4 => Id212bmsStatusBmsSmStateRequest::BmsFeim,
            9 => Id212bmsStatusBmsSmStateRequest::BmsSna,
            0 => Id212bmsStatusBmsSmStateRequest::BmsStandby,
            2 => Id212bmsStatusBmsSmStateRequest::BmsSupport,
            8 => Id212bmsStatusBmsSmStateRequest::BmsTest,
            7 => Id212bmsStatusBmsSmStateRequest::BmsWeld,
            x => Id212bmsStatusBmsSmStateRequest::Other(x),
        }
    }
    
    /// Get raw value of BMS_smStateRequest
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_sm_state_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_smStateRequest
    #[inline(always)]
    pub fn set_bms_sm_state_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..60].store_le(value);
        Ok(())
    }
    
    /// BMS_state
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_state(&self) -> Id212bmsStatusBmsState {
        match self.bms_state_raw() {
            3 => Id212bmsStatusBmsState::BmsCharge,
            5 => Id212bmsStatusBmsState::BmsClearFault,
            10 => Id212bmsStatusBmsState::BmsDiag,
            1 => Id212bmsStatusBmsState::BmsDrive,
            6 => Id212bmsStatusBmsState::BmsFault,
            4 => Id212bmsStatusBmsState::BmsFeim,
            9 => Id212bmsStatusBmsState::BmsSna,
            0 => Id212bmsStatusBmsState::BmsStandby,
            2 => Id212bmsStatusBmsState::BmsSupport,
            8 => Id212bmsStatusBmsState::BmsTest,
            7 => Id212bmsStatusBmsState::BmsWeld,
            x => Id212bmsStatusBmsState::Other(x),
        }
    }
    
    /// Get raw value of BMS_state
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_state
    #[inline(always)]
    pub fn set_bms_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..36].store_le(value);
        Ok(())
    }
    
    /// BMS_uiChargeStatus
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_ui_charge_status(&self) -> Id212bmsStatusBmsUiChargeStatus {
        match self.bms_ui_charge_status_raw() {
            2 => Id212bmsStatusBmsUiChargeStatus::BmsAboutToCharge,
            4 => Id212bmsStatusBmsUiChargeStatus::BmsChargeComplete,
            5 => Id212bmsStatusBmsUiChargeStatus::BmsChargeStopped,
            3 => Id212bmsStatusBmsUiChargeStatus::BmsCharging,
            0 => Id212bmsStatusBmsUiChargeStatus::BmsDisconnected,
            1 => Id212bmsStatusBmsUiChargeStatus::BmsNoPower,
            x => Id212bmsStatusBmsUiChargeStatus::Other(x),
        }
    }
    
    /// Get raw value of BMS_uiChargeStatus
    ///
    /// - Start bit: 11
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_ui_charge_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BMS_uiChargeStatus
    #[inline(always)]
    pub fn set_bms_ui_charge_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 530 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..14].store_le(value);
        Ok(())
    }
    
    /// BMS_updateAllowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn bms_update_allowed(&self) -> bool {
        self.bms_update_allowed_raw()
    }
    
    /// Get raw value of BMS_updateAllowed
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bms_update_allowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BMS_updateAllowed
    #[inline(always)]
    pub fn set_bms_update_allowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id212bmsStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id212bmsStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let bms_active_heating_worthwhile = u.int_in_range(0..=1)? == 1;
        let bms_charge_request = u.int_in_range(0..=1)? == 1;
        let bms_charge_retry_count = u.int_in_range(0..=7)?;
        let bms_chg_power_available = 0_f32;
        let bms_contactor_state = u.int_in_range(0..=6)?;
        let bms_cp_mia_on_hvs = u.int_in_range(0..=1)? == 1;
        let bms_di_limp_request = u.int_in_range(0..=1)? == 1;
        let bms_ecu_log_upload_request = u.int_in_range(0..=3)?;
        let bms_hv_state = u.int_in_range(0..=6)?;
        let bms_hvac_power_request = u.int_in_range(0..=1)? == 1;
        let bms_isolation_resistance = 0_f32;
        let bms_keep_warm_request = u.int_in_range(0..=1)? == 1;
        let bms_not_enough_power_for_drive = u.int_in_range(0..=1)? == 1;
        let bms_not_enough_power_for_support = u.int_in_range(0..=1)? == 1;
        let bms_ok_to_ship_by_air = u.int_in_range(0..=1)? == 1;
        let bms_ok_to_ship_by_land = u.int_in_range(0..=1)? == 1;
        let bms_pcs_pwm_enabled = u.int_in_range(0..=1)? == 1;
        let bms_precondition_allowed = u.int_in_range(0..=1)? == 1;
        let bms_sm_state_request = u.int_in_range(0..=9)?;
        let bms_state = u.int_in_range(0..=10)?;
        let bms_ui_charge_status = u.int_in_range(0..=5)?;
        let bms_update_allowed = u.int_in_range(0..=1)? == 1;
        Id212bmsStatus::new(bms_active_heating_worthwhile,bms_charge_request,bms_charge_retry_count,bms_chg_power_available,bms_contactor_state,bms_cp_mia_on_hvs,bms_di_limp_request,bms_ecu_log_upload_request,bms_hv_state,bms_hvac_power_request,bms_isolation_resistance,bms_keep_warm_request,bms_not_enough_power_for_drive,bms_not_enough_power_for_support,bms_ok_to_ship_by_air,bms_ok_to_ship_by_land,bms_pcs_pwm_enabled,bms_precondition_allowed,bms_sm_state_request,bms_state,bms_ui_charge_status,bms_update_allowed).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for BMS_chgPowerAvailable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsChgPowerAvailable {
    Sna,
    Other(f32),
}
/// Defined values for BMS_contactorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsContactorState {
    BmsCtrsetBlocked,
    BmsCtrsetClosed,
    BmsCtrsetClosing,
    BmsCtrsetOpen,
    BmsCtrsetOpening,
    BmsCtrsetSna,
    BmsCtrsetWelded,
    Other(u8),
}
/// Defined values for BMS_diLimpRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsDiLimpRequest {
    LimpRequestNone,
    LimpRequestWelded,
    Other(bool),
}
/// Defined values for BMS_ecuLogUploadRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsEcuLogUploadRequest {
    RequestPriority1,
    RequestPriority2,
    RequestPriority3,
    RequestPriorityNone,
    Other(u8),
}
/// Defined values for BMS_hvState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsHvState {
    HvComingUp,
    HvDown,
    HvGoingDown,
    HvUp,
    HvUpForCharge,
    HvUpForDcCharge,
    HvUpForDrive,
    Other(u8),
}
/// Defined values for BMS_isolationResistance
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsIsolationResistance {
    Sna,
    Other(f32),
}
/// Defined values for BMS_smStateRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsSmStateRequest {
    BmsCharge,
    BmsClearFault,
    BmsDiag,
    BmsDrive,
    BmsFault,
    BmsFeim,
    BmsSna,
    BmsStandby,
    BmsSupport,
    BmsTest,
    BmsWeld,
    Other(u8),
}
/// Defined values for BMS_state
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsState {
    BmsCharge,
    BmsClearFault,
    BmsDiag,
    BmsDrive,
    BmsFault,
    BmsFeim,
    BmsSna,
    BmsStandby,
    BmsSupport,
    BmsTest,
    BmsWeld,
    Other(u8),
}
/// Defined values for BMS_uiChargeStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id212bmsStatusBmsUiChargeStatus {
    BmsAboutToCharge,
    BmsChargeComplete,
    BmsChargeStopped,
    BmsCharging,
    BmsDisconnected,
    BmsNoPower,
    Other(u8),
}

/// ID31CCC_chgStatus
///
/// - ID: 796 (0x31c)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id31cccChgStatus {
    raw: [u8; 8],
}

impl Id31cccChgStatus {
    pub const MESSAGE_ID: u32 = 796;
    
    /// Construct new ID31CCC_chgStatus from values
    pub fn new(cc_current_limit: f32, cc_delta_transformer: u8, cc_grid_grounding: u8, cc_line1_voltage: u16, cc_line2_voltage: u16, cc_line3_voltage: u16, cc_num_phases: u8, cc_num_veh_charging: u8, cc_pilot_state: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cc_current_limit(cc_current_limit)?;
        res.set_cc_delta_transformer(cc_delta_transformer)?;
        res.set_cc_grid_grounding(cc_grid_grounding)?;
        res.set_cc_line1_voltage(cc_line1_voltage)?;
        res.set_cc_line2_voltage(cc_line2_voltage)?;
        res.set_cc_line3_voltage(cc_line3_voltage)?;
        res.set_cc_num_phases(cc_num_phases)?;
        res.set_cc_num_veh_charging(cc_num_veh_charging)?;
        res.set_cc_pilot_state(cc_pilot_state)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CC_currentLimit
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_current_limit(&self) -> Id31cccChgStatusCcCurrentLimit {
        match self.cc_current_limit_raw() {
            255 => Id31cccChgStatusCcCurrentLimit::Sna,
            x => Id31cccChgStatusCcCurrentLimit::Other(x),
        }
    }
    
    /// Get raw value of CC_currentLimit
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CC_currentLimit
    #[inline(always)]
    pub fn set_cc_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CC_deltaTransformer
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_delta_transformer(&self) -> u8 {
        self.cc_delta_transformer_raw()
    }
    
    /// Get raw value of CC_deltaTransformer
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_delta_transformer_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CC_deltaTransformer
    #[inline(always)]
    pub fn set_cc_delta_transformer(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..30].store_le(value);
        Ok(())
    }
    
    /// CC_gridGrounding
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_grid_grounding(&self) -> Id31cccChgStatusCcGridGrounding {
        match self.cc_grid_grounding_raw() {
            1 => Id31cccChgStatusCcGridGrounding::CcGridGroundingItSplitPhase,
            2 => Id31cccChgStatusCcGridGrounding::CcGridGroundingSna,
            0 => Id31cccChgStatusCcGridGrounding::CcGridGroundingTnTt,
            x => Id31cccChgStatusCcGridGrounding::Other(x),
        }
    }
    
    /// Get raw value of CC_gridGrounding
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_grid_grounding_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CC_gridGrounding
    #[inline(always)]
    pub fn set_cc_grid_grounding(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..28].store_le(value);
        Ok(())
    }
    
    /// CC_line1Voltage
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_line1_voltage(&self) -> Id31cccChgStatusCcLine1Voltage {
        match self.cc_line1_voltage_raw() {
            511 => Id31cccChgStatusCcLine1Voltage::Sna,
            x => Id31cccChgStatusCcLine1Voltage::Other(x),
        }
    }
    
    /// Get raw value of CC_line1Voltage
    ///
    /// - Start bit: 16
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_line1_voltage_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..25].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CC_line1Voltage
    #[inline(always)]
    pub fn set_cc_line1_voltage(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..25].store_le(value);
        Ok(())
    }
    
    /// CC_line2Voltage
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_line2_voltage(&self) -> Id31cccChgStatusCcLine2Voltage {
        match self.cc_line2_voltage_raw() {
            511 => Id31cccChgStatusCcLine2Voltage::Sna,
            x => Id31cccChgStatusCcLine2Voltage::Other(x),
        }
    }
    
    /// Get raw value of CC_line2Voltage
    ///
    /// - Start bit: 33
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_line2_voltage_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[33..42].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CC_line2Voltage
    #[inline(always)]
    pub fn set_cc_line2_voltage(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[33..42].store_le(value);
        Ok(())
    }
    
    /// CC_line3Voltage
    ///
    /// - Min: 0
    /// - Max: 511
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_line3_voltage(&self) -> Id31cccChgStatusCcLine3Voltage {
        match self.cc_line3_voltage_raw() {
            511 => Id31cccChgStatusCcLine3Voltage::Sna,
            x => Id31cccChgStatusCcLine3Voltage::Other(x),
        }
    }
    
    /// Get raw value of CC_line3Voltage
    ///
    /// - Start bit: 42
    /// - Signal size: 9 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_line3_voltage_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[42..51].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CC_line3Voltage
    #[inline(always)]
    pub fn set_cc_line3_voltage(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 511_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..51].store_le(value);
        Ok(())
    }
    
    /// CC_numPhases
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_num_phases(&self) -> Id31cccChgStatusCcNumPhases {
        match self.cc_num_phases_raw() {
            0 => Id31cccChgStatusCcNumPhases::Sna,
            x => Id31cccChgStatusCcNumPhases::Other(x),
        }
    }
    
    /// Get raw value of CC_numPhases
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_num_phases_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CC_numPhases
    #[inline(always)]
    pub fn set_cc_num_phases(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// CC_numVehCharging
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_num_veh_charging(&self) -> u8 {
        self.cc_num_veh_charging_raw()
    }
    
    /// Get raw value of CC_numVehCharging
    ///
    /// - Start bit: 30
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_num_veh_charging_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..33].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CC_numVehCharging
    #[inline(always)]
    pub fn set_cc_num_veh_charging(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..33].store_le(value);
        Ok(())
    }
    
    /// CC_pilotState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cc_pilot_state(&self) -> Id31cccChgStatusCcPilotState {
        match self.cc_pilot_state_raw() {
            2 => Id31cccChgStatusCcPilotState::CcPilotStateFaulted,
            1 => Id31cccChgStatusCcPilotState::CcPilotStateIdle,
            0 => Id31cccChgStatusCcPilotState::CcPilotStateReady,
            3 => Id31cccChgStatusCcPilotState::CcPilotStateSna,
            x => Id31cccChgStatusCcPilotState::Other(x),
        }
    }
    
    /// Get raw value of CC_pilotState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_pilot_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CC_pilotState
    #[inline(always)]
    pub fn set_cc_pilot_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 796 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id31cccChgStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id31cccChgStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cc_current_limit = 0_f32;
        let cc_delta_transformer = u.int_in_range(0..=3)?;
        let cc_grid_grounding = u.int_in_range(0..=2)?;
        let cc_line1_voltage = u.int_in_range(0..=511)?;
        let cc_line2_voltage = u.int_in_range(0..=511)?;
        let cc_line3_voltage = u.int_in_range(0..=511)?;
        let cc_num_phases = u.int_in_range(0..=3)?;
        let cc_num_veh_charging = u.int_in_range(0..=7)?;
        let cc_pilot_state = u.int_in_range(0..=3)?;
        Id31cccChgStatus::new(cc_current_limit,cc_delta_transformer,cc_grid_grounding,cc_line1_voltage,cc_line2_voltage,cc_line3_voltage,cc_num_phases,cc_num_veh_charging,cc_pilot_state).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CC_currentLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcCurrentLimit {
    Sna,
    Other(f32),
}
/// Defined values for CC_gridGrounding
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcGridGrounding {
    CcGridGroundingItSplitPhase,
    CcGridGroundingSna,
    CcGridGroundingTnTt,
    Other(u8),
}
/// Defined values for CC_line1Voltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcLine1Voltage {
    Sna,
    Other(u16),
}
/// Defined values for CC_line2Voltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcLine2Voltage {
    Sna,
    Other(u16),
}
/// Defined values for CC_line3Voltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcLine3Voltage {
    Sna,
    Other(u16),
}
/// Defined values for CC_numPhases
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcNumPhases {
    Sna,
    Other(u8),
}
/// Defined values for CC_pilotState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id31cccChgStatusCcPilotState {
    CcPilotStateFaulted,
    CcPilotStateIdle,
    CcPilotStateReady,
    CcPilotStateSna,
    Other(u8),
}

/// ID23DCP_chargeStatus
///
/// - ID: 573 (0x23d)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id23dcpChargeStatus {
    raw: [u8; 4],
}

impl Id23dcpChargeStatus {
    pub const MESSAGE_ID: u32 = 573;
    
    /// Construct new ID23DCP_chargeStatus from values
    pub fn new(cp_ac_charge_current_limit: f32, cp_charge_shutdown_request: u8, cp_hv_charge_status: u8, cp_internal_max_current_limit: f32, cp_vehicle_iso_check_required: bool, cp_vehicle_precharge_required: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cp_ac_charge_current_limit(cp_ac_charge_current_limit)?;
        res.set_cp_charge_shutdown_request(cp_charge_shutdown_request)?;
        res.set_cp_hv_charge_status(cp_hv_charge_status)?;
        res.set_cp_internal_max_current_limit(cp_internal_max_current_limit)?;
        res.set_cp_vehicle_iso_check_required(cp_vehicle_iso_check_required)?;
        res.set_cp_vehicle_precharge_required(cp_vehicle_precharge_required)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_acChargeCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_ac_charge_current_limit(&self) -> f32 {
        self.cp_ac_charge_current_limit_raw()
    }
    
    /// Get raw value of CP_acChargeCurrentLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_ac_charge_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_acChargeCurrentLimit
    #[inline(always)]
    pub fn set_cp_ac_charge_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 573 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CP_chargeShutdownRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_shutdown_request(&self) -> Id23dcpChargeStatusCpChargeShutdownRequest {
        match self.cp_charge_shutdown_request_raw() {
            2 => Id23dcpChargeStatusCpChargeShutdownRequest::EmergencyShutdownRequested,
            1 => Id23dcpChargeStatusCpChargeShutdownRequest::GracefulShutdownRequested,
            0 => Id23dcpChargeStatusCpChargeShutdownRequest::NoShutdownRequested,
            x => Id23dcpChargeStatusCpChargeShutdownRequest::Other(x),
        }
    }
    
    /// Get raw value of CP_chargeShutdownRequest
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_shutdown_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_chargeShutdownRequest
    #[inline(always)]
    pub fn set_cp_charge_shutdown_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 573 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..5].store_le(value);
        Ok(())
    }
    
    /// CP_hvChargeStatus
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_hv_charge_status(&self) -> Id23dcpChargeStatusCpHvChargeStatus {
        match self.cp_hv_charge_status_raw() {
            1 => Id23dcpChargeStatusCpHvChargeStatus::CpChargeConnected,
            5 => Id23dcpChargeStatusCpHvChargeStatus::CpChargeEnabled,
            6 => Id23dcpChargeStatusCpHvChargeStatus::CpChargeFaulted,
            0 => Id23dcpChargeStatusCpHvChargeStatus::CpChargeInactive,
            2 => Id23dcpChargeStatusCpHvChargeStatus::CpChargeStandby,
            4 => Id23dcpChargeStatusCpHvChargeStatus::CpEvseTestPassed,
            3 => Id23dcpChargeStatusCpHvChargeStatus::CpExtEvseTestActive,
            x => Id23dcpChargeStatusCpHvChargeStatus::Other(x),
        }
    }
    
    /// Get raw value of CP_hvChargeStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_hv_charge_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_hvChargeStatus
    #[inline(always)]
    pub fn set_cp_hv_charge_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 573 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CP_internalMaxCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 1200
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_internal_max_current_limit(&self) -> f32 {
        self.cp_internal_max_current_limit_raw()
    }
    
    /// Get raw value of CP_internalMaxCurrentLimit
    ///
    /// - Start bit: 16
    /// - Signal size: 13 bits
    /// - Factor: 0.146502
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_internal_max_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..29].load_le::<u16>();
        
        let factor = 0.146502_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_internalMaxCurrentLimit
    #[inline(always)]
    pub fn set_cp_internal_max_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 573 }); }
        let factor = 0.146502_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..29].store_le(value);
        Ok(())
    }
    
    /// CP_vehicleIsoCheckRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_iso_check_required(&self) -> bool {
        self.cp_vehicle_iso_check_required_raw()
    }
    
    /// Get raw value of CP_vehicleIsoCheckRequired
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_iso_check_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehicleIsoCheckRequired
    #[inline(always)]
    pub fn set_cp_vehicle_iso_check_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// CP_vehiclePrechargeRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_precharge_required(&self) -> bool {
        self.cp_vehicle_precharge_required_raw()
    }
    
    /// Get raw value of CP_vehiclePrechargeRequired
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_precharge_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehiclePrechargeRequired
    #[inline(always)]
    pub fn set_cp_vehicle_precharge_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id23dcpChargeStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id23dcpChargeStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_ac_charge_current_limit = 0_f32;
        let cp_charge_shutdown_request = u.int_in_range(0..=2)?;
        let cp_hv_charge_status = u.int_in_range(0..=6)?;
        let cp_internal_max_current_limit = 0_f32;
        let cp_vehicle_iso_check_required = u.int_in_range(0..=1)? == 1;
        let cp_vehicle_precharge_required = u.int_in_range(0..=1)? == 1;
        Id23dcpChargeStatus::new(cp_ac_charge_current_limit,cp_charge_shutdown_request,cp_hv_charge_status,cp_internal_max_current_limit,cp_vehicle_iso_check_required,cp_vehicle_precharge_required).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CP_chargeShutdownRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id23dcpChargeStatusCpChargeShutdownRequest {
    EmergencyShutdownRequested,
    GracefulShutdownRequested,
    NoShutdownRequested,
    Other(u8),
}
/// Defined values for CP_hvChargeStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id23dcpChargeStatusCpHvChargeStatus {
    CpChargeConnected,
    CpChargeEnabled,
    CpChargeFaulted,
    CpChargeInactive,
    CpChargeStandby,
    CpEvseTestPassed,
    CpExtEvseTestActive,
    Other(u8),
}

/// ID13DCP_chargeStatus
///
/// - ID: 317 (0x13d)
/// - Size: 6 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id13dcpChargeStatus {
    raw: [u8; 6],
}

impl Id13dcpChargeStatus {
    pub const MESSAGE_ID: u32 = 317;
    
    /// Construct new ID13DCP_chargeStatus from values
    pub fn new(cp_ac_charge_current_limit: f32, cp_charge_shutdown_request: u8, cp_evse_charge_type: u8, cp_hv_charge_status: u8, cp_internal_max_ac_current_limit: f32, cp_internal_max_dc_current_limit: f32, cp_vehicle_iso_check_required: bool, cp_vehicle_precharge_required: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_cp_ac_charge_current_limit(cp_ac_charge_current_limit)?;
        res.set_cp_charge_shutdown_request(cp_charge_shutdown_request)?;
        res.set_cp_evse_charge_type(cp_evse_charge_type)?;
        res.set_cp_hv_charge_status(cp_hv_charge_status)?;
        res.set_cp_internal_max_ac_current_limit(cp_internal_max_ac_current_limit)?;
        res.set_cp_internal_max_dc_current_limit(cp_internal_max_dc_current_limit)?;
        res.set_cp_vehicle_iso_check_required(cp_vehicle_iso_check_required)?;
        res.set_cp_vehicle_precharge_required(cp_vehicle_precharge_required)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_acChargeCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_ac_charge_current_limit(&self) -> f32 {
        self.cp_ac_charge_current_limit_raw()
    }
    
    /// Get raw value of CP_acChargeCurrentLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_ac_charge_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_acChargeCurrentLimit
    #[inline(always)]
    pub fn set_cp_ac_charge_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 317 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CP_chargeShutdownRequest
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_shutdown_request(&self) -> Id13dcpChargeStatusCpChargeShutdownRequest {
        match self.cp_charge_shutdown_request_raw() {
            2 => Id13dcpChargeStatusCpChargeShutdownRequest::EmergencyShutdownRequested,
            1 => Id13dcpChargeStatusCpChargeShutdownRequest::GracefulShutdownRequested,
            0 => Id13dcpChargeStatusCpChargeShutdownRequest::NoShutdownRequested,
            x => Id13dcpChargeStatusCpChargeShutdownRequest::Other(x),
        }
    }
    
    /// Get raw value of CP_chargeShutdownRequest
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_shutdown_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_chargeShutdownRequest
    #[inline(always)]
    pub fn set_cp_charge_shutdown_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 317 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..5].store_le(value);
        Ok(())
    }
    
    /// CP_evseChargeType
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_charge_type(&self) -> Id13dcpChargeStatusCpEvseChargeType {
        match self.cp_evse_charge_type_raw() {
            2 => Id13dcpChargeStatusCpEvseChargeType::AcChargerPresent,
            1 => Id13dcpChargeStatusCpEvseChargeType::DcChargerPresent,
            0 => Id13dcpChargeStatusCpEvseChargeType::NoChargerPresent,
            x => Id13dcpChargeStatusCpEvseChargeType::Other(x),
        }
    }
    
    /// Get raw value of CP_evseChargeType
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_charge_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_evseChargeType
    #[inline(always)]
    pub fn set_cp_evse_charge_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 317 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// CP_hvChargeStatus
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_hv_charge_status(&self) -> Id13dcpChargeStatusCpHvChargeStatus {
        match self.cp_hv_charge_status_raw() {
            1 => Id13dcpChargeStatusCpHvChargeStatus::CpChargeConnected,
            5 => Id13dcpChargeStatusCpHvChargeStatus::CpChargeEnabled,
            6 => Id13dcpChargeStatusCpHvChargeStatus::CpChargeFaulted,
            0 => Id13dcpChargeStatusCpHvChargeStatus::CpChargeInactive,
            2 => Id13dcpChargeStatusCpHvChargeStatus::CpChargeStandby,
            4 => Id13dcpChargeStatusCpHvChargeStatus::CpEvseTestPassed,
            3 => Id13dcpChargeStatusCpHvChargeStatus::CpExtEvseTestActive,
            x => Id13dcpChargeStatusCpHvChargeStatus::Other(x),
        }
    }
    
    /// Get raw value of CP_hvChargeStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_hv_charge_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_hvChargeStatus
    #[inline(always)]
    pub fn set_cp_hv_charge_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 317 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CP_internalMaxAcCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_internal_max_ac_current_limit(&self) -> f32 {
        self.cp_internal_max_ac_current_limit_raw()
    }
    
    /// Get raw value of CP_internalMaxAcCurrentLimit
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_internal_max_ac_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_internalMaxAcCurrentLimit
    #[inline(always)]
    pub fn set_cp_internal_max_ac_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 317 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CP_internalMaxDcCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 1200
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_internal_max_dc_current_limit(&self) -> f32 {
        self.cp_internal_max_dc_current_limit_raw()
    }
    
    /// Get raw value of CP_internalMaxDcCurrentLimit
    ///
    /// - Start bit: 16
    /// - Signal size: 13 bits
    /// - Factor: 0.146502
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_internal_max_dc_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..29].load_le::<u16>();
        
        let factor = 0.146502_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_internalMaxDcCurrentLimit
    #[inline(always)]
    pub fn set_cp_internal_max_dc_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 317 }); }
        let factor = 0.146502_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..29].store_le(value);
        Ok(())
    }
    
    /// CP_vehicleIsoCheckRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_iso_check_required(&self) -> bool {
        self.cp_vehicle_iso_check_required_raw()
    }
    
    /// Get raw value of CP_vehicleIsoCheckRequired
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_iso_check_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehicleIsoCheckRequired
    #[inline(always)]
    pub fn set_cp_vehicle_iso_check_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// CP_vehiclePrechargeRequired
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_precharge_required(&self) -> bool {
        self.cp_vehicle_precharge_required_raw()
    }
    
    /// Get raw value of CP_vehiclePrechargeRequired
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_precharge_required_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehiclePrechargeRequired
    #[inline(always)]
    pub fn set_cp_vehicle_precharge_required(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id13dcpChargeStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id13dcpChargeStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_ac_charge_current_limit = 0_f32;
        let cp_charge_shutdown_request = u.int_in_range(0..=2)?;
        let cp_evse_charge_type = u.int_in_range(0..=2)?;
        let cp_hv_charge_status = u.int_in_range(0..=6)?;
        let cp_internal_max_ac_current_limit = 0_f32;
        let cp_internal_max_dc_current_limit = 0_f32;
        let cp_vehicle_iso_check_required = u.int_in_range(0..=1)? == 1;
        let cp_vehicle_precharge_required = u.int_in_range(0..=1)? == 1;
        Id13dcpChargeStatus::new(cp_ac_charge_current_limit,cp_charge_shutdown_request,cp_evse_charge_type,cp_hv_charge_status,cp_internal_max_ac_current_limit,cp_internal_max_dc_current_limit,cp_vehicle_iso_check_required,cp_vehicle_precharge_required).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CP_chargeShutdownRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id13dcpChargeStatusCpChargeShutdownRequest {
    EmergencyShutdownRequested,
    GracefulShutdownRequested,
    NoShutdownRequested,
    Other(u8),
}
/// Defined values for CP_evseChargeType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id13dcpChargeStatusCpEvseChargeType {
    AcChargerPresent,
    DcChargerPresent,
    NoChargerPresent,
    Other(u8),
}
/// Defined values for CP_hvChargeStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id13dcpChargeStatusCpHvChargeStatus {
    CpChargeConnected,
    CpChargeEnabled,
    CpChargeFaulted,
    CpChargeInactive,
    CpChargeStandby,
    CpEvseTestPassed,
    CpExtEvseTestActive,
    Other(u8),
}

/// ID43DCP_chargeStatusLog
///
/// - ID: 1085 (0x43d)
/// - Size: 6 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id43dcpChargeStatusLog {
    raw: [u8; 6],
}

impl Id43dcpChargeStatusLog {
    pub const MESSAGE_ID: u32 = 1085;
    
    /// Construct new ID43DCP_chargeStatusLog from values
    pub fn new(cp_ac_charge_current_limit_log: f32, cp_charge_shutdown_request_log: u8, cp_evse_charge_type_log: u8, cp_hv_charge_status_log: u8, cp_internal_max_ac_current_limit_log: f32, cp_internal_max_dc_current_limit_log: f32, cp_vehicle_iso_check_required_log: bool, cp_vehicle_precharge_required_log: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_cp_ac_charge_current_limit_log(cp_ac_charge_current_limit_log)?;
        res.set_cp_charge_shutdown_request_log(cp_charge_shutdown_request_log)?;
        res.set_cp_evse_charge_type_log(cp_evse_charge_type_log)?;
        res.set_cp_hv_charge_status_log(cp_hv_charge_status_log)?;
        res.set_cp_internal_max_ac_current_limit_log(cp_internal_max_ac_current_limit_log)?;
        res.set_cp_internal_max_dc_current_limit_log(cp_internal_max_dc_current_limit_log)?;
        res.set_cp_vehicle_iso_check_required_log(cp_vehicle_iso_check_required_log)?;
        res.set_cp_vehicle_precharge_required_log(cp_vehicle_precharge_required_log)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_acChargeCurrentLimit_log
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_ac_charge_current_limit_log(&self) -> f32 {
        self.cp_ac_charge_current_limit_log_raw()
    }
    
    /// Get raw value of CP_acChargeCurrentLimit_log
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_ac_charge_current_limit_log_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_acChargeCurrentLimit_log
    #[inline(always)]
    pub fn set_cp_ac_charge_current_limit_log(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1085 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CP_chargeShutdownRequest_log
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_charge_shutdown_request_log(&self) -> Id43dcpChargeStatusLogCpChargeShutdownRequestLog {
        match self.cp_charge_shutdown_request_log_raw() {
            2 => Id43dcpChargeStatusLogCpChargeShutdownRequestLog::EmergencyShutdownRequested,
            1 => Id43dcpChargeStatusLogCpChargeShutdownRequestLog::GracefulShutdownRequested,
            0 => Id43dcpChargeStatusLogCpChargeShutdownRequestLog::NoShutdownRequested,
            x => Id43dcpChargeStatusLogCpChargeShutdownRequestLog::Other(x),
        }
    }
    
    /// Get raw value of CP_chargeShutdownRequest_log
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_charge_shutdown_request_log_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_chargeShutdownRequest_log
    #[inline(always)]
    pub fn set_cp_charge_shutdown_request_log(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1085 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..5].store_le(value);
        Ok(())
    }
    
    /// CP_evseChargeType_log
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_charge_type_log(&self) -> Id43dcpChargeStatusLogCpEvseChargeTypeLog {
        match self.cp_evse_charge_type_log_raw() {
            2 => Id43dcpChargeStatusLogCpEvseChargeTypeLog::AcChargerPresent,
            1 => Id43dcpChargeStatusLogCpEvseChargeTypeLog::DcChargerPresent,
            0 => Id43dcpChargeStatusLogCpEvseChargeTypeLog::NoChargerPresent,
            x => Id43dcpChargeStatusLogCpEvseChargeTypeLog::Other(x),
        }
    }
    
    /// Get raw value of CP_evseChargeType_log
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_charge_type_log_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_evseChargeType_log
    #[inline(always)]
    pub fn set_cp_evse_charge_type_log(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1085 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// CP_hvChargeStatus_log
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_hv_charge_status_log(&self) -> Id43dcpChargeStatusLogCpHvChargeStatusLog {
        match self.cp_hv_charge_status_log_raw() {
            1 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpChargeConnected,
            5 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpChargeEnabled,
            6 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpChargeFaulted,
            0 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpChargeInactive,
            2 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpChargeStandby,
            4 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpEvseTestPassed,
            3 => Id43dcpChargeStatusLogCpHvChargeStatusLog::CpExtEvseTestActive,
            x => Id43dcpChargeStatusLogCpHvChargeStatusLog::Other(x),
        }
    }
    
    /// Get raw value of CP_hvChargeStatus_log
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_hv_charge_status_log_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_hvChargeStatus_log
    #[inline(always)]
    pub fn set_cp_hv_charge_status_log(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1085 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CP_internalMaxAcCurrentLimit_log
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_internal_max_ac_current_limit_log(&self) -> f32 {
        self.cp_internal_max_ac_current_limit_log_raw()
    }
    
    /// Get raw value of CP_internalMaxAcCurrentLimit_log
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_internal_max_ac_current_limit_log_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_internalMaxAcCurrentLimit_log
    #[inline(always)]
    pub fn set_cp_internal_max_ac_current_limit_log(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1085 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CP_internalMaxDcCurrentLimit_log
    ///
    /// - Min: 0
    /// - Max: 1200
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_internal_max_dc_current_limit_log(&self) -> f32 {
        self.cp_internal_max_dc_current_limit_log_raw()
    }
    
    /// Get raw value of CP_internalMaxDcCurrentLimit_log
    ///
    /// - Start bit: 16
    /// - Signal size: 13 bits
    /// - Factor: 0.146502
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_internal_max_dc_current_limit_log_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..29].load_le::<u16>();
        
        let factor = 0.146502_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_internalMaxDcCurrentLimit_log
    #[inline(always)]
    pub fn set_cp_internal_max_dc_current_limit_log(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1085 }); }
        let factor = 0.146502_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..29].store_le(value);
        Ok(())
    }
    
    /// CP_vehicleIsoCheckRequired_log
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_iso_check_required_log(&self) -> bool {
        self.cp_vehicle_iso_check_required_log_raw()
    }
    
    /// Get raw value of CP_vehicleIsoCheckRequired_log
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_iso_check_required_log_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehicleIsoCheckRequired_log
    #[inline(always)]
    pub fn set_cp_vehicle_iso_check_required_log(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// CP_vehiclePrechargeRequired_log
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_vehicle_precharge_required_log(&self) -> bool {
        self.cp_vehicle_precharge_required_log_raw()
    }
    
    /// Get raw value of CP_vehiclePrechargeRequired_log
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_vehicle_precharge_required_log_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_vehiclePrechargeRequired_log
    #[inline(always)]
    pub fn set_cp_vehicle_precharge_required_log(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id43dcpChargeStatusLog {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id43dcpChargeStatusLog
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_ac_charge_current_limit_log = 0_f32;
        let cp_charge_shutdown_request_log = u.int_in_range(0..=2)?;
        let cp_evse_charge_type_log = u.int_in_range(0..=2)?;
        let cp_hv_charge_status_log = u.int_in_range(0..=6)?;
        let cp_internal_max_ac_current_limit_log = 0_f32;
        let cp_internal_max_dc_current_limit_log = 0_f32;
        let cp_vehicle_iso_check_required_log = u.int_in_range(0..=1)? == 1;
        let cp_vehicle_precharge_required_log = u.int_in_range(0..=1)? == 1;
        Id43dcpChargeStatusLog::new(cp_ac_charge_current_limit_log,cp_charge_shutdown_request_log,cp_evse_charge_type_log,cp_hv_charge_status_log,cp_internal_max_ac_current_limit_log,cp_internal_max_dc_current_limit_log,cp_vehicle_iso_check_required_log,cp_vehicle_precharge_required_log).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CP_chargeShutdownRequest_log
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id43dcpChargeStatusLogCpChargeShutdownRequestLog {
    EmergencyShutdownRequested,
    GracefulShutdownRequested,
    NoShutdownRequested,
    Other(u8),
}
/// Defined values for CP_evseChargeType_log
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id43dcpChargeStatusLogCpEvseChargeTypeLog {
    AcChargerPresent,
    DcChargerPresent,
    NoChargerPresent,
    Other(u8),
}
/// Defined values for CP_hvChargeStatus_log
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id43dcpChargeStatusLogCpHvChargeStatusLog {
    CpChargeConnected,
    CpChargeEnabled,
    CpChargeFaulted,
    CpChargeInactive,
    CpChargeStandby,
    CpEvseTestPassed,
    CpExtEvseTestActive,
    Other(u8),
}

/// ID21DCP_evseStatus
///
/// - ID: 541 (0x21d)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id21dcpEvseStatus {
    raw: [u8; 8],
}

impl Id21dcpEvseStatus {
    pub const MESSAGE_ID: u32 = 541;
    
    /// Construct new ID21DCP_evseStatus from values
    pub fn new(cp_ac_charge_state: u8, cp_ac_num_retries: u8, cp_cable_current_limit: u8, cp_cable_type: u8, cp_digital_comms_attempts: u8, cp_digital_comms_established: bool, cp_evse_accept: bool, cp_evse_charge_type_ui: u8, cp_evse_request: bool, cp_gb_state: u8, cp_gbdc_charge_attempts: u8, cp_gbdc_failure_reason: u8, cp_gbdc_stop_charge_reason: u8, cp_iec_combo_state: u8, cp_pilot: u8, cp_pilot_current: f32, cp_proximity: u8, cp_tesla_dc_state: u8, cp_tesla_swcan_state: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cp_ac_charge_state(cp_ac_charge_state)?;
        res.set_cp_ac_num_retries(cp_ac_num_retries)?;
        res.set_cp_cable_current_limit(cp_cable_current_limit)?;
        res.set_cp_cable_type(cp_cable_type)?;
        res.set_cp_digital_comms_attempts(cp_digital_comms_attempts)?;
        res.set_cp_digital_comms_established(cp_digital_comms_established)?;
        res.set_cp_evse_accept(cp_evse_accept)?;
        res.set_cp_evse_charge_type_ui(cp_evse_charge_type_ui)?;
        res.set_cp_evse_request(cp_evse_request)?;
        res.set_cp_gb_state(cp_gb_state)?;
        res.set_cp_gbdc_charge_attempts(cp_gbdc_charge_attempts)?;
        res.set_cp_gbdc_failure_reason(cp_gbdc_failure_reason)?;
        res.set_cp_gbdc_stop_charge_reason(cp_gbdc_stop_charge_reason)?;
        res.set_cp_iec_combo_state(cp_iec_combo_state)?;
        res.set_cp_pilot(cp_pilot)?;
        res.set_cp_pilot_current(cp_pilot_current)?;
        res.set_cp_proximity(cp_proximity)?;
        res.set_cp_tesla_dc_state(cp_tesla_dc_state)?;
        res.set_cp_tesla_swcan_state(cp_tesla_swcan_state)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_acChargeState
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_ac_charge_state(&self) -> Id21dcpEvseStatusCpAcChargeState {
        match self.cp_ac_charge_state_raw() {
            1 => Id21dcpEvseStatusCpAcChargeState::AcChargeConnectedChargeBlocked,
            3 => Id21dcpEvseStatusCpAcChargeState::AcChargeEnabled,
            6 => Id21dcpEvseStatusCpAcChargeState::AcChargeFault,
            0 => Id21dcpEvseStatusCpAcChargeState::AcChargeInactive,
            4 => Id21dcpEvseStatusCpAcChargeState::AcChargeOnboardChargerShutdown,
            2 => Id21dcpEvseStatusCpAcChargeState::AcChargeStandby,
            5 => Id21dcpEvseStatusCpAcChargeState::AcChargeVehShutdown,
            x => Id21dcpEvseStatusCpAcChargeState::Other(x),
        }
    }
    
    /// Get raw value of CP_acChargeState
    ///
    /// - Start bit: 53
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_ac_charge_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[53..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_acChargeState
    #[inline(always)]
    pub fn set_cp_ac_charge_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[53..56].store_le(value);
        Ok(())
    }
    
    /// CP_acNumRetries
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_ac_num_retries(&self) -> u8 {
        self.cp_ac_num_retries_raw()
    }
    
    /// Get raw value of CP_acNumRetries
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_ac_num_retries_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_acNumRetries
    #[inline(always)]
    pub fn set_cp_ac_num_retries(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// CP_cableCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_cable_current_limit(&self) -> u8 {
        self.cp_cable_current_limit_raw()
    }
    
    /// Get raw value of CP_cableCurrentLimit
    ///
    /// - Start bit: 24
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_cable_current_limit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_cableCurrentLimit
    #[inline(always)]
    pub fn set_cp_cable_current_limit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..31].store_le(value);
        Ok(())
    }
    
    /// CP_cableType
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_cable_type(&self) -> Id21dcpEvseStatusCpCableType {
        match self.cp_cable_type_raw() {
            2 => Id21dcpEvseStatusCpCableType::ChgCableTypeGbAc,
            3 => Id21dcpEvseStatusCpCableType::ChgCableTypeGbDc,
            0 => Id21dcpEvseStatusCpCableType::ChgCableTypeIec,
            1 => Id21dcpEvseStatusCpCableType::ChgCableTypeSae,
            4 => Id21dcpEvseStatusCpCableType::ChgCableTypeSna,
            x => Id21dcpEvseStatusCpCableType::Other(x),
        }
    }
    
    /// Get raw value of CP_cableType
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_cable_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_cableType
    #[inline(always)]
    pub fn set_cp_cable_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..19].store_le(value);
        Ok(())
    }
    
    /// CP_digitalCommsAttempts
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_digital_comms_attempts(&self) -> u8 {
        self.cp_digital_comms_attempts_raw()
    }
    
    /// Get raw value of CP_digitalCommsAttempts
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_digital_comms_attempts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_digitalCommsAttempts
    #[inline(always)]
    pub fn set_cp_digital_comms_attempts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// CP_digitalCommsEstablished
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_digital_comms_established(&self) -> bool {
        self.cp_digital_comms_established_raw()
    }
    
    /// Get raw value of CP_digitalCommsEstablished
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_digital_comms_established_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_digitalCommsEstablished
    #[inline(always)]
    pub fn set_cp_digital_comms_established(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[37..38].store_le(value);
        Ok(())
    }
    
    /// CP_evseAccept
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_accept(&self) -> bool {
        self.cp_evse_accept_raw()
    }
    
    /// Get raw value of CP_evseAccept
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_accept_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_evseAccept
    #[inline(always)]
    pub fn set_cp_evse_accept(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CP_evseChargeType_UI
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_charge_type_ui(&self) -> Id21dcpEvseStatusCpEvseChargeTypeUi {
        match self.cp_evse_charge_type_ui_raw() {
            2 => Id21dcpEvseStatusCpEvseChargeTypeUi::AcChargerPresent,
            1 => Id21dcpEvseStatusCpEvseChargeTypeUi::DcChargerPresent,
            0 => Id21dcpEvseStatusCpEvseChargeTypeUi::NoChargerPresent,
            x => Id21dcpEvseStatusCpEvseChargeTypeUi::Other(x),
        }
    }
    
    /// Get raw value of CP_evseChargeType_UI
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_charge_type_ui_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_evseChargeType_UI
    #[inline(always)]
    pub fn set_cp_evse_charge_type_ui(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// CP_evseRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_evse_request(&self) -> bool {
        self.cp_evse_request_raw()
    }
    
    /// Get raw value of CP_evseRequest
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_evse_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_evseRequest
    #[inline(always)]
    pub fn set_cp_evse_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CP_gbState
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_gb_state(&self) -> Id21dcpEvseStatusCpGbState {
        match self.cp_gb_state_raw() {
            10 => Id21dcpEvseStatusCpGbState::GbdcChargeDisabling,
            5 => Id21dcpEvseStatusCpGbState::GbdcChargeParamConfig,
            8 => Id21dcpEvseStatusCpGbState::GbdcCharging,
            2 => Id21dcpEvseStatusCpGbState::GbdcCommsReceived,
            11 => Id21dcpEvseStatusCpGbState::GbdcEndOfCharge,
            12 => Id21dcpEvseStatusCpGbState::GbdcErrorHandling,
            14 => Id21dcpEvseStatusCpGbState::GbdcFaulted,
            3 => Id21dcpEvseStatusCpGbState::GbdcHandshakingExtIso,
            0 => Id21dcpEvseStatusCpGbState::GbdcInactive,
            7 => Id21dcpEvseStatusCpGbState::GbdcReadyToCharge,
            4 => Id21dcpEvseStatusCpGbState::GbdcRecognition,
            13 => Id21dcpEvseStatusCpGbState::GbdcRetryCharge,
            9 => Id21dcpEvseStatusCpGbState::GbdcStopChargeRequested,
            15 => Id21dcpEvseStatusCpGbState::GbdcTesterPresent,
            6 => Id21dcpEvseStatusCpGbState::GbdcVehPackPrecharge,
            1 => Id21dcpEvseStatusCpGbState::GbdcWaitForComms,
            x => Id21dcpEvseStatusCpGbState::Other(x),
        }
    }
    
    /// Get raw value of CP_gbState
    ///
    /// - Start bit: 42
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_gb_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_gbState
    #[inline(always)]
    pub fn set_cp_gb_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..46].store_le(value);
        Ok(())
    }
    
    /// CP_gbdcChargeAttempts
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_gbdc_charge_attempts(&self) -> u8 {
        self.cp_gbdc_charge_attempts_raw()
    }
    
    /// Get raw value of CP_gbdcChargeAttempts
    ///
    /// - Start bit: 51
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_gbdc_charge_attempts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[51..53].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_gbdcChargeAttempts
    #[inline(always)]
    pub fn set_cp_gbdc_charge_attempts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[51..53].store_le(value);
        Ok(())
    }
    
    /// CP_gbdcFailureReason
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_gbdc_failure_reason(&self) -> Id21dcpEvseStatusCpGbdcFailureReason {
        match self.cp_gbdc_failure_reason_raw() {
            1 => Id21dcpEvseStatusCpGbdcFailureReason::GbdcAttemptsExpired,
            3 => Id21dcpEvseStatusCpGbdcFailureReason::GbdcCriticalFailure,
            0 => Id21dcpEvseStatusCpGbdcFailureReason::GbdcFailureNone,
            2 => Id21dcpEvseStatusCpGbdcFailureReason::GbdcShutdownFailure,
            x => Id21dcpEvseStatusCpGbdcFailureReason::Other(x),
        }
    }
    
    /// Get raw value of CP_gbdcFailureReason
    ///
    /// - Start bit: 49
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_gbdc_failure_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[49..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_gbdcFailureReason
    #[inline(always)]
    pub fn set_cp_gbdc_failure_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..51].store_le(value);
        Ok(())
    }
    
    /// CP_gbdcStopChargeReason
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_gbdc_stop_charge_reason(&self) -> Id21dcpEvseStatusCpGbdcStopChargeReason {
        match self.cp_gbdc_stop_charge_reason_raw() {
            3 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcCommsTimeout,
            5 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcEvseCriticalFault,
            4 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcEvseFault,
            2 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcEvseRequested,
            6 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcLiveDisconnect,
            0 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcStopReasonNone,
            7 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcSuperchargerCommsTimeout,
            1 => Id21dcpEvseStatusCpGbdcStopChargeReason::GbdcVehRequested,
            x => Id21dcpEvseStatusCpGbdcStopChargeReason::Other(x),
        }
    }
    
    /// Get raw value of CP_gbdcStopChargeReason
    ///
    /// - Start bit: 46
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_gbdc_stop_charge_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..49].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_gbdcStopChargeReason
    #[inline(always)]
    pub fn set_cp_gbdc_stop_charge_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..49].store_le(value);
        Ok(())
    }
    
    /// CP_iecComboState
    ///
    /// - Min: 0
    /// - Max: 12
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_iec_combo_state(&self) -> Id21dcpEvseStatusCpIecComboState {
        match self.cp_iec_combo_state_raw() {
            6 => Id21dcpEvseStatusCpIecComboState::IecComboCableCheck,
            5 => Id21dcpEvseStatusCpIecComboState::IecComboChargeParamDiscovery,
            1 => Id21dcpEvseStatusCpIecComboState::IecComboConnected,
            8 => Id21dcpEvseStatusCpIecComboState::IecComboEnabled,
            10 => Id21dcpEvseStatusCpIecComboState::IecComboEndOfCharge,
            11 => Id21dcpEvseStatusCpIecComboState::IecComboFault,
            0 => Id21dcpEvseStatusCpIecComboState::IecComboInactive,
            4 => Id21dcpEvseStatusCpIecComboState::IecComboPaymentSelection,
            7 => Id21dcpEvseStatusCpIecComboState::IecComboPrecharge,
            3 => Id21dcpEvseStatusCpIecComboState::IecComboServiceDiscovery,
            9 => Id21dcpEvseStatusCpIecComboState::IecComboShutdown,
            2 => Id21dcpEvseStatusCpIecComboState::IecComboV2gSessionSetup,
            12 => Id21dcpEvseStatusCpIecComboState::IecComboWaitRestart,
            x => Id21dcpEvseStatusCpIecComboState::Other(x),
        }
    }
    
    /// Get raw value of CP_iecComboState
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_iec_combo_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_iecComboState
    #[inline(always)]
    pub fn set_cp_iec_combo_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 12_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[60..64].store_le(value);
        Ok(())
    }
    
    /// CP_pilot
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot(&self) -> Id21dcpEvseStatusCpPilot {
        match self.cp_pilot_raw() {
            3 => Id21dcpEvseStatusCpPilot::ChgPilotFastCharge,
            1 => Id21dcpEvseStatusCpPilot::ChgPilotFaulted,
            4 => Id21dcpEvseStatusCpPilot::ChgPilotIdle,
            5 => Id21dcpEvseStatusCpPilot::ChgPilotInvalid,
            2 => Id21dcpEvseStatusCpPilot::ChgPilotLineCharge,
            0 => Id21dcpEvseStatusCpPilot::ChgPilotNone,
            7 => Id21dcpEvseStatusCpPilot::ChgPilotSna,
            6 => Id21dcpEvseStatusCpPilot::ChgPilotUnused6,
            x => Id21dcpEvseStatusCpPilot::Other(x),
        }
    }
    
    /// Get raw value of CP_pilot
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pilot_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_pilot
    #[inline(always)]
    pub fn set_cp_pilot(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..7].store_le(value);
        Ok(())
    }
    
    /// CP_pilotCurrent
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_current(&self) -> f32 {
        self.cp_pilot_current_raw()
    }
    
    /// Get raw value of CP_pilotCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pilot_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotCurrent
    #[inline(always)]
    pub fn set_cp_pilot_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CP_proximity
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_proximity(&self) -> Id21dcpEvseStatusCpProximity {
        match self.cp_proximity_raw() {
            1 => Id21dcpEvseStatusCpProximity::ChgProximityDisconnected,
            3 => Id21dcpEvseStatusCpProximity::ChgProximityLatched,
            0 => Id21dcpEvseStatusCpProximity::ChgProximitySna,
            2 => Id21dcpEvseStatusCpProximity::ChgProximityUnlatched,
            x => Id21dcpEvseStatusCpProximity::Other(x),
        }
    }
    
    /// Get raw value of CP_proximity
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_proximity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_proximity
    #[inline(always)]
    pub fn set_cp_proximity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CP_teslaDcState
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_tesla_dc_state(&self) -> Id21dcpEvseStatusCpTeslaDcState {
        match self.cp_tesla_dc_state_raw() {
            1 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcConnectedChargeBlocked,
            9 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcEmergencyShutdown,
            6 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcEnabled,
            7 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcEvseShutdown,
            5 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcExtPrechargeActive,
            3 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcExtTestsEnabled,
            4 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcExtTestActive,
            10 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcFault,
            0 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcInactive,
            2 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcStandby,
            8 => Id21dcpEvseStatusCpTeslaDcState::TeslaDcVehShutdown,
            x => Id21dcpEvseStatusCpTeslaDcState::Other(x),
        }
    }
    
    /// Get raw value of CP_teslaDcState
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_tesla_dc_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_teslaDcState
    #[inline(always)]
    pub fn set_cp_tesla_dc_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..60].store_le(value);
        Ok(())
    }
    
    /// CP_teslaSwcanState
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_tesla_swcan_state(&self) -> Id21dcpEvseStatusCpTeslaSwcanState {
        match self.cp_tesla_swcan_state_raw() {
            1 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanAccept,
            3 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanEstablished,
            4 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanFault,
            5 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanGoToSleep,
            0 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanInactive,
            6 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanOffboardUpdateInProgress,
            2 => Id21dcpEvseStatusCpTeslaSwcanState::TeslaSwcanReceive,
            x => Id21dcpEvseStatusCpTeslaSwcanState::Other(x),
        }
    }
    
    /// Get raw value of CP_teslaSwcanState
    ///
    /// - Start bit: 34
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_tesla_swcan_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..37].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_teslaSwcanState
    #[inline(always)]
    pub fn set_cp_tesla_swcan_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 541 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..37].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id21dcpEvseStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id21dcpEvseStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_ac_charge_state = u.int_in_range(0..=6)?;
        let cp_ac_num_retries = u.int_in_range(0..=3)?;
        let cp_cable_current_limit = u.int_in_range(0..=127)?;
        let cp_cable_type = u.int_in_range(0..=4)?;
        let cp_digital_comms_attempts = u.int_in_range(0..=3)?;
        let cp_digital_comms_established = u.int_in_range(0..=1)? == 1;
        let cp_evse_accept = u.int_in_range(0..=1)? == 1;
        let cp_evse_charge_type_ui = u.int_in_range(0..=2)?;
        let cp_evse_request = u.int_in_range(0..=1)? == 1;
        let cp_gb_state = u.int_in_range(0..=15)?;
        let cp_gbdc_charge_attempts = u.int_in_range(0..=3)?;
        let cp_gbdc_failure_reason = u.int_in_range(0..=3)?;
        let cp_gbdc_stop_charge_reason = u.int_in_range(0..=7)?;
        let cp_iec_combo_state = u.int_in_range(0..=12)?;
        let cp_pilot = u.int_in_range(0..=7)?;
        let cp_pilot_current = 0_f32;
        let cp_proximity = u.int_in_range(0..=3)?;
        let cp_tesla_dc_state = u.int_in_range(0..=10)?;
        let cp_tesla_swcan_state = u.int_in_range(0..=6)?;
        Id21dcpEvseStatus::new(cp_ac_charge_state,cp_ac_num_retries,cp_cable_current_limit,cp_cable_type,cp_digital_comms_attempts,cp_digital_comms_established,cp_evse_accept,cp_evse_charge_type_ui,cp_evse_request,cp_gb_state,cp_gbdc_charge_attempts,cp_gbdc_failure_reason,cp_gbdc_stop_charge_reason,cp_iec_combo_state,cp_pilot,cp_pilot_current,cp_proximity,cp_tesla_dc_state,cp_tesla_swcan_state).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CP_acChargeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpAcChargeState {
    AcChargeConnectedChargeBlocked,
    AcChargeEnabled,
    AcChargeFault,
    AcChargeInactive,
    AcChargeOnboardChargerShutdown,
    AcChargeStandby,
    AcChargeVehShutdown,
    Other(u8),
}
/// Defined values for CP_cableType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpCableType {
    ChgCableTypeGbAc,
    ChgCableTypeGbDc,
    ChgCableTypeIec,
    ChgCableTypeSae,
    ChgCableTypeSna,
    Other(u8),
}
/// Defined values for CP_evseChargeType_UI
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpEvseChargeTypeUi {
    AcChargerPresent,
    DcChargerPresent,
    NoChargerPresent,
    Other(u8),
}
/// Defined values for CP_gbState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpGbState {
    GbdcChargeDisabling,
    GbdcChargeParamConfig,
    GbdcCharging,
    GbdcCommsReceived,
    GbdcEndOfCharge,
    GbdcErrorHandling,
    GbdcFaulted,
    GbdcHandshakingExtIso,
    GbdcInactive,
    GbdcReadyToCharge,
    GbdcRecognition,
    GbdcRetryCharge,
    GbdcStopChargeRequested,
    GbdcTesterPresent,
    GbdcVehPackPrecharge,
    GbdcWaitForComms,
    Other(u8),
}
/// Defined values for CP_gbdcFailureReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpGbdcFailureReason {
    GbdcAttemptsExpired,
    GbdcCriticalFailure,
    GbdcFailureNone,
    GbdcShutdownFailure,
    Other(u8),
}
/// Defined values for CP_gbdcStopChargeReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpGbdcStopChargeReason {
    GbdcCommsTimeout,
    GbdcEvseCriticalFault,
    GbdcEvseFault,
    GbdcEvseRequested,
    GbdcLiveDisconnect,
    GbdcStopReasonNone,
    GbdcSuperchargerCommsTimeout,
    GbdcVehRequested,
    Other(u8),
}
/// Defined values for CP_iecComboState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpIecComboState {
    IecComboCableCheck,
    IecComboChargeParamDiscovery,
    IecComboConnected,
    IecComboEnabled,
    IecComboEndOfCharge,
    IecComboFault,
    IecComboInactive,
    IecComboPaymentSelection,
    IecComboPrecharge,
    IecComboServiceDiscovery,
    IecComboShutdown,
    IecComboV2gSessionSetup,
    IecComboWaitRestart,
    Other(u8),
}
/// Defined values for CP_pilot
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpPilot {
    ChgPilotFastCharge,
    ChgPilotFaulted,
    ChgPilotIdle,
    ChgPilotInvalid,
    ChgPilotLineCharge,
    ChgPilotNone,
    ChgPilotSna,
    ChgPilotUnused6,
    Other(u8),
}
/// Defined values for CP_proximity
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpProximity {
    ChgProximityDisconnected,
    ChgProximityLatched,
    ChgProximitySna,
    ChgProximityUnlatched,
    Other(u8),
}
/// Defined values for CP_teslaDcState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpTeslaDcState {
    TeslaDcConnectedChargeBlocked,
    TeslaDcEmergencyShutdown,
    TeslaDcEnabled,
    TeslaDcEvseShutdown,
    TeslaDcExtPrechargeActive,
    TeslaDcExtTestsEnabled,
    TeslaDcExtTestActive,
    TeslaDcFault,
    TeslaDcInactive,
    TeslaDcStandby,
    TeslaDcVehShutdown,
    Other(u8),
}
/// Defined values for CP_teslaSwcanState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id21dcpEvseStatusCpTeslaSwcanState {
    TeslaSwcanAccept,
    TeslaSwcanEstablished,
    TeslaSwcanFault,
    TeslaSwcanGoToSleep,
    TeslaSwcanInactive,
    TeslaSwcanOffboardUpdateInProgress,
    TeslaSwcanReceive,
    Other(u8),
}

/// ID743VCRIGHT_recallStatus
///
/// - ID: 1859 (0x743)
/// - Size: 1 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id743vcrightRecallStatus {
    raw: [u8; 1],
}

impl Id743vcrightRecallStatus {
    pub const MESSAGE_ID: u32 = 1859;
    
    /// Construct new ID743VCRIGHT_recallStatus from values
    pub fn new(vcright_mirror_recall_status: u8, vcright_seat_recall_status: u8, vcright_system_recall_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 1] };
        res.set_vcright_mirror_recall_status(vcright_mirror_recall_status)?;
        res.set_vcright_seat_recall_status(vcright_seat_recall_status)?;
        res.set_vcright_system_recall_status(vcright_system_recall_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_mirrorRecallStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_mirror_recall_status(&self) -> Id743vcrightRecallStatusVcrightMirrorRecallStatus {
        match self.vcright_mirror_recall_status_raw() {
            2 => Id743vcrightRecallStatusVcrightMirrorRecallStatus::RecallComplete,
            3 => Id743vcrightRecallStatusVcrightMirrorRecallStatus::RecallInterrupted,
            1 => Id743vcrightRecallStatusVcrightMirrorRecallStatus::RecallInProgress,
            0 => Id743vcrightRecallStatusVcrightMirrorRecallStatus::RecallSna,
            x => Id743vcrightRecallStatusVcrightMirrorRecallStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_mirrorRecallStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_mirror_recall_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_mirrorRecallStatus
    #[inline(always)]
    pub fn set_vcright_mirror_recall_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1859 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_seatRecallStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_seat_recall_status(&self) -> Id743vcrightRecallStatusVcrightSeatRecallStatus {
        match self.vcright_seat_recall_status_raw() {
            2 => Id743vcrightRecallStatusVcrightSeatRecallStatus::RecallComplete,
            3 => Id743vcrightRecallStatusVcrightSeatRecallStatus::RecallInterrupted,
            1 => Id743vcrightRecallStatusVcrightSeatRecallStatus::RecallInProgress,
            0 => Id743vcrightRecallStatusVcrightSeatRecallStatus::RecallSna,
            x => Id743vcrightRecallStatusVcrightSeatRecallStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_seatRecallStatus
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_seat_recall_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_seatRecallStatus
    #[inline(always)]
    pub fn set_vcright_seat_recall_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1859 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_systemRecallStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_system_recall_status(&self) -> Id743vcrightRecallStatusVcrightSystemRecallStatus {
        match self.vcright_system_recall_status_raw() {
            2 => Id743vcrightRecallStatusVcrightSystemRecallStatus::RecallComplete,
            3 => Id743vcrightRecallStatusVcrightSystemRecallStatus::RecallInterrupted,
            1 => Id743vcrightRecallStatusVcrightSystemRecallStatus::RecallInProgress,
            0 => Id743vcrightRecallStatusVcrightSystemRecallStatus::RecallSna,
            x => Id743vcrightRecallStatusVcrightSystemRecallStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_systemRecallStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_system_recall_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_systemRecallStatus
    #[inline(always)]
    pub fn set_vcright_system_recall_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1859 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id743vcrightRecallStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 1 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 1];
        raw.copy_from_slice(&payload[..1]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id743vcrightRecallStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_mirror_recall_status = u.int_in_range(0..=3)?;
        let vcright_seat_recall_status = u.int_in_range(0..=3)?;
        let vcright_system_recall_status = u.int_in_range(0..=3)?;
        Id743vcrightRecallStatus::new(vcright_mirror_recall_status,vcright_seat_recall_status,vcright_system_recall_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_mirrorRecallStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id743vcrightRecallStatusVcrightMirrorRecallStatus {
    RecallComplete,
    RecallInterrupted,
    RecallInProgress,
    RecallSna,
    Other(u8),
}
/// Defined values for VCRIGHT_seatRecallStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id743vcrightRecallStatusVcrightSeatRecallStatus {
    RecallComplete,
    RecallInterrupted,
    RecallInProgress,
    RecallSna,
    Other(u8),
}
/// Defined values for VCRIGHT_systemRecallStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id743vcrightRecallStatusVcrightSystemRecallStatus {
    RecallComplete,
    RecallInterrupted,
    RecallInProgress,
    RecallSna,
    Other(u8),
}

/// ID75DCP_sensorData
///
/// - ID: 1885 (0x75d)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id75dcpSensorData {
    raw: [u8; 8],
}

impl Id75dcpSensorData {
    pub const MESSAGE_ID: u32 = 1885;
    
    /// Construct new ID75DCP_sensorData from values
    pub fn new(cp_sensor_data_select: u8, cp_uhf_chip_state: u8, cp_uhf_fifo_data: u8, cp_uhf_rssi: u8, cp_uhf_rx_num_bytes: u8, cp_uhf_rx_overflow: bool, cp_uhf_self_test_rssi: u8, cp_back_cover2_counts: f32, cp_back_cover_counts: f32, cp_board_temperature: f32, cp_door_counts_debounced: f32, cp_door_counts_filtered: f32, cp_door_i: f32, cp_door_last_request_max_i: f32, cp_door_pot: f32, cp_fault_line_v: f32, cp_inductive_sensor_raw: u32, cp_inlet1_harness_id_state: u8, cp_inlet1_harness_id_value: u8, cp_inlet1_harness_v: f32, cp_inlet2_harness_id_state: u8, cp_inlet2_harness_id_value: u8, cp_inlet2_harness_v: f32, cp_latch2_i: f32, cp_latch_i: f32, cp_pilot_high_value: f32, cp_pilot_high_value_interval_max10s: f32, cp_pilot_high_value_interval_min10s: f32, cp_pilot_low_value: f32, cp_pilot_low_value_interval_max10s: f32, cp_pilot_low_value_interval_min10s: f32, cp_pilot_period: u16, cp_pilot_pulse_width: u16, cp_pin_temperature1: f32, cp_pin_temperature2: f32, cp_pin_temperature3: f32, cp_prox_conn1_sense: bool, cp_prox_en: bool, cp_proximity_v: f32, cp_proximity_v_gbcc1: f32, cp_proximity_v_gbcc2: f32, cp_proximity_v_interval_max10s: f32, cp_proximity_v_interval_min10s: f32, cp_ref_voltage: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cp_sensor_data_select(cp_sensor_data_select)?;
        res.set_cp_uhf_chip_state(cp_uhf_chip_state)?;
        res.set_cp_uhf_fifo_data(cp_uhf_fifo_data)?;
        res.set_cp_uhf_rssi(cp_uhf_rssi)?;
        res.set_cp_uhf_rx_num_bytes(cp_uhf_rx_num_bytes)?;
        res.set_cp_uhf_rx_overflow(cp_uhf_rx_overflow)?;
        res.set_cp_uhf_self_test_rssi(cp_uhf_self_test_rssi)?;
        res.set_cp_back_cover2_counts(cp_back_cover2_counts)?;
        res.set_cp_back_cover_counts(cp_back_cover_counts)?;
        res.set_cp_board_temperature(cp_board_temperature)?;
        res.set_cp_door_counts_debounced(cp_door_counts_debounced)?;
        res.set_cp_door_counts_filtered(cp_door_counts_filtered)?;
        res.set_cp_door_i(cp_door_i)?;
        res.set_cp_door_last_request_max_i(cp_door_last_request_max_i)?;
        res.set_cp_door_pot(cp_door_pot)?;
        res.set_cp_fault_line_v(cp_fault_line_v)?;
        res.set_cp_inductive_sensor_raw(cp_inductive_sensor_raw)?;
        res.set_cp_inlet1_harness_id_state(cp_inlet1_harness_id_state)?;
        res.set_cp_inlet1_harness_id_value(cp_inlet1_harness_id_value)?;
        res.set_cp_inlet1_harness_v(cp_inlet1_harness_v)?;
        res.set_cp_inlet2_harness_id_state(cp_inlet2_harness_id_state)?;
        res.set_cp_inlet2_harness_id_value(cp_inlet2_harness_id_value)?;
        res.set_cp_inlet2_harness_v(cp_inlet2_harness_v)?;
        res.set_cp_latch2_i(cp_latch2_i)?;
        res.set_cp_latch_i(cp_latch_i)?;
        res.set_cp_pilot_high_value(cp_pilot_high_value)?;
        res.set_cp_pilot_high_value_interval_max10s(cp_pilot_high_value_interval_max10s)?;
        res.set_cp_pilot_high_value_interval_min10s(cp_pilot_high_value_interval_min10s)?;
        res.set_cp_pilot_low_value(cp_pilot_low_value)?;
        res.set_cp_pilot_low_value_interval_max10s(cp_pilot_low_value_interval_max10s)?;
        res.set_cp_pilot_low_value_interval_min10s(cp_pilot_low_value_interval_min10s)?;
        res.set_cp_pilot_period(cp_pilot_period)?;
        res.set_cp_pilot_pulse_width(cp_pilot_pulse_width)?;
        res.set_cp_pin_temperature1(cp_pin_temperature1)?;
        res.set_cp_pin_temperature2(cp_pin_temperature2)?;
        res.set_cp_pin_temperature3(cp_pin_temperature3)?;
        res.set_cp_prox_conn1_sense(cp_prox_conn1_sense)?;
        res.set_cp_prox_en(cp_prox_en)?;
        res.set_cp_proximity_v(cp_proximity_v)?;
        res.set_cp_proximity_v_gbcc1(cp_proximity_v_gbcc1)?;
        res.set_cp_proximity_v_gbcc2(cp_proximity_v_gbcc2)?;
        res.set_cp_proximity_v_interval_max10s(cp_proximity_v_interval_max10s)?;
        res.set_cp_proximity_v_interval_min10s(cp_proximity_v_interval_min10s)?;
        res.set_cp_ref_voltage(cp_ref_voltage)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// CP_sensorDataSelect
    ///
    /// - Min: 0
    /// - Max: 12
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_sensor_data_select(&self) -> Id75dcpSensorDataCpSensorDataSelect {
        match self.cp_sensor_data_select_raw() {
            2 => Id75dcpSensorDataCpSensorDataSelect::CpSensorDoor,
            0 => Id75dcpSensorDataCpSensorDataSelect::CpSensorDoorCounts,
            4 => Id75dcpSensorDataCpSensorDataSelect::CpSensorInductiveDoor,
            12 => Id75dcpSensorDataCpSensorDataSelect::CpSensorInletHarnessId,
            3 => Id75dcpSensorDataCpSensorDataSelect::CpSensorLatch,
            9 => Id75dcpSensorDataCpSensorDataSelect::CpSensorPilot,
            10 => Id75dcpSensorDataCpSensorDataSelect::CpSensorPilot2,
            1 => Id75dcpSensorDataCpSensorDataSelect::CpSensorPinTemp,
            8 => Id75dcpSensorDataCpSensorDataSelect::CpSensorProx,
            11 => Id75dcpSensorDataCpSensorDataSelect::CpSensorProxGb,
            7 => Id75dcpSensorDataCpSensorDataSelect::CpSensorRails,
            5 => Id75dcpSensorDataCpSensorDataSelect::CpSensorSafety,
            6 => Id75dcpSensorDataCpSensorDataSelect::CpSensorUhf,
            x => Id75dcpSensorDataCpSensorDataSelect::Other(x),
        }
    }
    
    /// Get raw value of CP_sensorDataSelect
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_sensor_data_select_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_sensorDataSelect
    #[inline(always)]
    pub fn set_cp_sensor_data_select(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 12_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_chipState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_chip_state(&self) -> u8 {
        self.cp_uhf_chip_state_raw()
    }
    
    /// Get raw value of CP_UHF_chipState
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_chip_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_UHF_chipState
    #[inline(always)]
    pub fn set_cp_uhf_chip_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..7].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_fifoData
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_fifo_data(&self) -> u8 {
        self.cp_uhf_fifo_data_raw()
    }
    
    /// Get raw value of CP_UHF_fifoData
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_fifo_data_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_UHF_fifoData
    #[inline(always)]
    pub fn set_cp_uhf_fifo_data(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_rssi
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_rssi(&self) -> u8 {
        self.cp_uhf_rssi_raw()
    }
    
    /// Get raw value of CP_UHF_rssi
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_rssi_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_UHF_rssi
    #[inline(always)]
    pub fn set_cp_uhf_rssi(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_rxNumBytes
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_rx_num_bytes(&self) -> u8 {
        self.cp_uhf_rx_num_bytes_raw()
    }
    
    /// Get raw value of CP_UHF_rxNumBytes
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_rx_num_bytes_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_UHF_rxNumBytes
    #[inline(always)]
    pub fn set_cp_uhf_rx_num_bytes(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_rxOverflow
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_rx_overflow(&self) -> bool {
        self.cp_uhf_rx_overflow_raw()
    }
    
    /// Get raw value of CP_UHF_rxOverflow
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_rx_overflow_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_UHF_rxOverflow
    #[inline(always)]
    pub fn set_cp_uhf_rx_overflow(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// CP_UHF_selfTestRssi
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_uhf_self_test_rssi(&self) -> u8 {
        self.cp_uhf_self_test_rssi_raw()
    }
    
    /// Get raw value of CP_UHF_selfTestRssi
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_uhf_self_test_rssi_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_UHF_selfTestRssi
    #[inline(always)]
    pub fn set_cp_uhf_self_test_rssi(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CP_backCover2Counts
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_back_cover2_counts(&self) -> f32 {
        self.cp_back_cover2_counts_raw()
    }
    
    /// Get raw value of CP_backCover2Counts
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.0015259
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_back_cover2_counts_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_backCover2Counts
    #[inline(always)]
    pub fn set_cp_back_cover2_counts(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// CP_backCoverCounts
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_back_cover_counts(&self) -> f32 {
        self.cp_back_cover_counts_raw()
    }
    
    /// Get raw value of CP_backCoverCounts
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.0015259
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_back_cover_counts_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_backCoverCounts
    #[inline(always)]
    pub fn set_cp_back_cover_counts(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// CP_boardTemperature
    ///
    /// - Min: -50
    /// - Max: 280
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_board_temperature(&self) -> f32 {
        self.cp_board_temperature_raw()
    }
    
    /// Get raw value of CP_boardTemperature
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1.29412
    /// - Offset: -50
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_board_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1.29412_f32;
        let offset = -50_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_boardTemperature
    #[inline(always)]
    pub fn set_cp_board_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -50_f32 || 280_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 1.29412_f32;
        let offset = -50_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CP_doorCountsDebounced
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_counts_debounced(&self) -> f32 {
        self.cp_door_counts_debounced_raw()
    }
    
    /// Get raw value of CP_doorCountsDebounced
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.0015259
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_counts_debounced_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..40].load_le::<u16>();
        
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_doorCountsDebounced
    #[inline(always)]
    pub fn set_cp_door_counts_debounced(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..40].store_le(value);
        Ok(())
    }
    
    /// CP_doorCountsFiltered
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_counts_filtered(&self) -> f32 {
        self.cp_door_counts_filtered_raw()
    }
    
    /// Get raw value of CP_doorCountsFiltered
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.0015259
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_counts_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..24].load_le::<u16>();
        
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_doorCountsFiltered
    #[inline(always)]
    pub fn set_cp_door_counts_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0015259_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..24].store_le(value);
        Ok(())
    }
    
    /// CP_doorI
    ///
    /// - Min: 0
    /// - Max: 10.2375
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_i(&self) -> f32 {
        self.cp_door_i_raw()
    }
    
    /// Get raw value of CP_doorI
    ///
    /// - Start bit: 16
    /// - Signal size: 12 bits
    /// - Factor: 0.0025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_i_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..28].load_le::<u16>();
        
        let factor = 0.0025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_doorI
    #[inline(always)]
    pub fn set_cp_door_i(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10.2375_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..28].store_le(value);
        Ok(())
    }
    
    /// CP_doorLastRequestMaxI
    ///
    /// - Min: 0
    /// - Max: 10.2375
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_last_request_max_i(&self) -> f32 {
        self.cp_door_last_request_max_i_raw()
    }
    
    /// Get raw value of CP_doorLastRequestMaxI
    ///
    /// - Start bit: 28
    /// - Signal size: 12 bits
    /// - Factor: 0.0025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_last_request_max_i_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..40].load_le::<u16>();
        
        let factor = 0.0025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_doorLastRequestMaxI
    #[inline(always)]
    pub fn set_cp_door_last_request_max_i(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10.2375_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[28..40].store_le(value);
        Ok(())
    }
    
    /// CP_doorPot
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_door_pot(&self) -> f32 {
        self.cp_door_pot_raw()
    }
    
    /// Get raw value of CP_doorPot
    ///
    /// - Start bit: 4
    /// - Signal size: 12 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_door_pot_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[4..16].load_le::<u16>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_doorPot
    #[inline(always)]
    pub fn set_cp_door_pot(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[4..16].store_le(value);
        Ok(())
    }
    
    /// CP_faultLineV
    ///
    /// - Min: 0
    /// - Max: 4.65524
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_fault_line_v(&self) -> f32 {
        self.cp_fault_line_v_raw()
    }
    
    /// Get raw value of CP_faultLineV
    ///
    /// - Start bit: 4
    /// - Signal size: 12 bits
    /// - Factor: 0.00114
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_fault_line_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[4..16].load_le::<u16>();
        
        let factor = 0.00114_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_faultLineV
    #[inline(always)]
    pub fn set_cp_fault_line_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 4.65524_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.00114_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[4..16].store_le(value);
        Ok(())
    }
    
    /// CP_inductiveSensor_raw
    ///
    /// - Min: 0
    /// - Max: 268435000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inductive_sensor_raw(&self) -> u32 {
        self.cp_inductive_sensor_raw_raw()
    }
    
    /// Get raw value of CP_inductiveSensor_raw
    ///
    /// - Start bit: 4
    /// - Signal size: 28 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inductive_sensor_raw_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[4..32].load_le::<u32>();
        
        signal
    }
    
    /// Set value of CP_inductiveSensor_raw
    #[inline(always)]
    pub fn set_cp_inductive_sensor_raw(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 268435000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..32].store_le(value);
        Ok(())
    }
    
    /// CP_inlet1HarnessIdState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inlet1_harness_id_state(&self) -> Id75dcpSensorDataCpInlet1HarnessIdState {
        match self.cp_inlet1_harness_id_state_raw() {
            1 => Id75dcpSensorDataCpInlet1HarnessIdState::HarnessPedigreeInvalid,
            0 => Id75dcpSensorDataCpInlet1HarnessIdState::HarnessPedigreeUnknownSna,
            2 => Id75dcpSensorDataCpInlet1HarnessIdState::HarnessPedigreeValid,
            x => Id75dcpSensorDataCpInlet1HarnessIdState::Other(x),
        }
    }
    
    /// Get raw value of CP_inlet1HarnessIdState
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inlet1_harness_id_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_inlet1HarnessIdState
    #[inline(always)]
    pub fn set_cp_inlet1_harness_id_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CP_inlet1HarnessIdValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inlet1_harness_id_value(&self) -> u8 {
        self.cp_inlet1_harness_id_value_raw()
    }
    
    /// Get raw value of CP_inlet1HarnessIdValue
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inlet1_harness_id_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_inlet1HarnessIdValue
    #[inline(always)]
    pub fn set_cp_inlet1_harness_id_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..11].store_le(value);
        Ok(())
    }
    
    /// CP_inlet1HarnessV
    ///
    /// - Min: 0
    /// - Max: 13.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inlet1_harness_v(&self) -> f32 {
        self.cp_inlet1_harness_v_raw()
    }
    
    /// Get raw value of CP_inlet1HarnessV
    ///
    /// - Start bit: 16
    /// - Signal size: 14 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inlet1_harness_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..30].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_inlet1HarnessV
    #[inline(always)]
    pub fn set_cp_inlet1_harness_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 13.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..30].store_le(value);
        Ok(())
    }
    
    /// CP_inlet2HarnessIdState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inlet2_harness_id_state(&self) -> Id75dcpSensorDataCpInlet2HarnessIdState {
        match self.cp_inlet2_harness_id_state_raw() {
            1 => Id75dcpSensorDataCpInlet2HarnessIdState::HarnessPedigreeInvalid,
            0 => Id75dcpSensorDataCpInlet2HarnessIdState::HarnessPedigreeUnknownSna,
            2 => Id75dcpSensorDataCpInlet2HarnessIdState::HarnessPedigreeValid,
            x => Id75dcpSensorDataCpInlet2HarnessIdState::Other(x),
        }
    }
    
    /// Get raw value of CP_inlet2HarnessIdState
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inlet2_harness_id_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_inlet2HarnessIdState
    #[inline(always)]
    pub fn set_cp_inlet2_harness_id_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..32].store_le(value);
        Ok(())
    }
    
    /// CP_inlet2HarnessIdValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inlet2_harness_id_value(&self) -> u8 {
        self.cp_inlet2_harness_id_value_raw()
    }
    
    /// Get raw value of CP_inlet2HarnessIdValue
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inlet2_harness_id_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CP_inlet2HarnessIdValue
    #[inline(always)]
    pub fn set_cp_inlet2_harness_id_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..35].store_le(value);
        Ok(())
    }
    
    /// CP_inlet2HarnessV
    ///
    /// - Min: 0
    /// - Max: 13.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_inlet2_harness_v(&self) -> f32 {
        self.cp_inlet2_harness_v_raw()
    }
    
    /// Get raw value of CP_inlet2HarnessV
    ///
    /// - Start bit: 40
    /// - Signal size: 14 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_inlet2_harness_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..54].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_inlet2HarnessV
    #[inline(always)]
    pub fn set_cp_inlet2_harness_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 13.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..54].store_le(value);
        Ok(())
    }
    
    /// CP_latch2I
    ///
    /// - Min: 0
    /// - Max: 10.2375
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch2_i(&self) -> f32 {
        self.cp_latch2_i_raw()
    }
    
    /// Get raw value of CP_latch2I
    ///
    /// - Start bit: 16
    /// - Signal size: 12 bits
    /// - Factor: 0.0025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch2_i_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..28].load_le::<u16>();
        
        let factor = 0.0025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_latch2I
    #[inline(always)]
    pub fn set_cp_latch2_i(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10.2375_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..28].store_le(value);
        Ok(())
    }
    
    /// CP_latchI
    ///
    /// - Min: 0
    /// - Max: 10.2375
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_latch_i(&self) -> f32 {
        self.cp_latch_i_raw()
    }
    
    /// Get raw value of CP_latchI
    ///
    /// - Start bit: 4
    /// - Signal size: 12 bits
    /// - Factor: 0.0025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_latch_i_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[4..16].load_le::<u16>();
        
        let factor = 0.0025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_latchI
    #[inline(always)]
    pub fn set_cp_latch_i(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10.2375_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[4..16].store_le(value);
        Ok(())
    }
    
    /// CP_pilotHighValue
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_high_value(&self) -> f32 {
        self.cp_pilot_high_value_raw()
    }
    
    /// Get raw value of CP_pilotHighValue
    ///
    /// - Start bit: 40
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_pilot_high_value_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..52].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotHighValue
    #[inline(always)]
    pub fn set_cp_pilot_high_value(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..52].store_le(value);
        Ok(())
    }
    
    /// CP_pilotHighValue_intervalMax10s
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_high_value_interval_max10s(&self) -> f32 {
        self.cp_pilot_high_value_interval_max10s_raw()
    }
    
    /// Get raw value of CP_pilotHighValue_intervalMax10s
    ///
    /// - Start bit: 28
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_pilot_high_value_interval_max10s_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..40].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotHighValue_intervalMax10s
    #[inline(always)]
    pub fn set_cp_pilot_high_value_interval_max10s(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[28..40].store_le(value);
        Ok(())
    }
    
    /// CP_pilotHighValue_intervalMin10s
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_high_value_interval_min10s(&self) -> f32 {
        self.cp_pilot_high_value_interval_min10s_raw()
    }
    
    /// Get raw value of CP_pilotHighValue_intervalMin10s
    ///
    /// - Start bit: 40
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_pilot_high_value_interval_min10s_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..52].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotHighValue_intervalMin10s
    #[inline(always)]
    pub fn set_cp_pilot_high_value_interval_min10s(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..52].store_le(value);
        Ok(())
    }
    
    /// CP_pilotLowValue
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_low_value(&self) -> f32 {
        self.cp_pilot_low_value_raw()
    }
    
    /// Get raw value of CP_pilotLowValue
    ///
    /// - Start bit: 28
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_pilot_low_value_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..40].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotLowValue
    #[inline(always)]
    pub fn set_cp_pilot_low_value(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[28..40].store_le(value);
        Ok(())
    }
    
    /// CP_pilotLowValue_intervalMax10s
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_low_value_interval_max10s(&self) -> f32 {
        self.cp_pilot_low_value_interval_max10s_raw()
    }
    
    /// Get raw value of CP_pilotLowValue_intervalMax10s
    ///
    /// - Start bit: 4
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_pilot_low_value_interval_max10s_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[4..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotLowValue_intervalMax10s
    #[inline(always)]
    pub fn set_cp_pilot_low_value_interval_max10s(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[4..16].store_le(value);
        Ok(())
    }
    
    /// CP_pilotLowValue_intervalMin10s
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_low_value_interval_min10s(&self) -> f32 {
        self.cp_pilot_low_value_interval_min10s_raw()
    }
    
    /// Get raw value of CP_pilotLowValue_intervalMin10s
    ///
    /// - Start bit: 16
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cp_pilot_low_value_interval_min10s_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..28].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pilotLowValue_intervalMin10s
    #[inline(always)]
    pub fn set_cp_pilot_low_value_interval_min10s(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..28].store_le(value);
        Ok(())
    }
    
    /// CP_pilotPeriod
    ///
    /// - Min: 0
    /// - Max: 4095
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_period(&self) -> u16 {
        self.cp_pilot_period_raw()
    }
    
    /// Get raw value of CP_pilotPeriod
    ///
    /// - Start bit: 16
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pilot_period_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..28].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CP_pilotPeriod
    #[inline(always)]
    pub fn set_cp_pilot_period(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 4095_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..28].store_le(value);
        Ok(())
    }
    
    /// CP_pilotPulseWidth
    ///
    /// - Min: 0
    /// - Max: 4095
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pilot_pulse_width(&self) -> u16 {
        self.cp_pilot_pulse_width_raw()
    }
    
    /// Get raw value of CP_pilotPulseWidth
    ///
    /// - Start bit: 4
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pilot_pulse_width_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[4..16].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CP_pilotPulseWidth
    #[inline(always)]
    pub fn set_cp_pilot_pulse_width(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 4095_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..16].store_le(value);
        Ok(())
    }
    
    /// CP_pinTemperature1
    ///
    /// - Min: -55
    /// - Max: 149.99
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pin_temperature1(&self) -> f32 {
        self.cp_pin_temperature1_raw()
    }
    
    /// Get raw value of CP_pinTemperature1
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.803922
    /// - Offset: -55
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pin_temperature1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.803922_f32;
        let offset = -55_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pinTemperature1
    #[inline(always)]
    pub fn set_cp_pin_temperature1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -55_f32 || 149.99_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.803922_f32;
        let offset = -55_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CP_pinTemperature2
    ///
    /// - Min: -55
    /// - Max: 149.99
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pin_temperature2(&self) -> f32 {
        self.cp_pin_temperature2_raw()
    }
    
    /// Get raw value of CP_pinTemperature2
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.803922
    /// - Offset: -55
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pin_temperature2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.803922_f32;
        let offset = -55_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pinTemperature2
    #[inline(always)]
    pub fn set_cp_pin_temperature2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -55_f32 || 149.99_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.803922_f32;
        let offset = -55_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CP_pinTemperature3
    ///
    /// - Min: -55
    /// - Max: 149.99
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_pin_temperature3(&self) -> f32 {
        self.cp_pin_temperature3_raw()
    }
    
    /// Get raw value of CP_pinTemperature3
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.803922
    /// - Offset: -55
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_pin_temperature3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.803922_f32;
        let offset = -55_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_pinTemperature3
    #[inline(always)]
    pub fn set_cp_pin_temperature3(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -55_f32 || 149.99_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.803922_f32;
        let offset = -55_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CP_proxConn1Sense
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_prox_conn1_sense(&self) -> bool {
        self.cp_prox_conn1_sense_raw()
    }
    
    /// Get raw value of CP_proxConn1Sense
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_prox_conn1_sense_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_proxConn1Sense
    #[inline(always)]
    pub fn set_cp_prox_conn1_sense(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CP_proxEn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_prox_en(&self) -> bool {
        self.cp_prox_en_raw()
    }
    
    /// Get raw value of CP_proxEn
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_prox_en_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CP_proxEn
    #[inline(always)]
    pub fn set_cp_prox_en(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[57..58].store_le(value);
        Ok(())
    }
    
    /// CP_proximityV
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_proximity_v(&self) -> f32 {
        self.cp_proximity_v_raw()
    }
    
    /// Get raw value of CP_proximityV
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_proximity_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..24].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_proximityV
    #[inline(always)]
    pub fn set_cp_proximity_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..24].store_le(value);
        Ok(())
    }
    
    /// CP_proximityV_GBCC1
    ///
    /// - Min: 0
    /// - Max: 13.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_proximity_v_gbcc1(&self) -> f32 {
        self.cp_proximity_v_gbcc1_raw()
    }
    
    /// Get raw value of CP_proximityV_GBCC1
    ///
    /// - Start bit: 8
    /// - Signal size: 14 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_proximity_v_gbcc1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..22].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_proximityV_GBCC1
    #[inline(always)]
    pub fn set_cp_proximity_v_gbcc1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 13.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..22].store_le(value);
        Ok(())
    }
    
    /// CP_proximityV_GBCC2
    ///
    /// - Min: 0
    /// - Max: 13.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_proximity_v_gbcc2(&self) -> f32 {
        self.cp_proximity_v_gbcc2_raw()
    }
    
    /// Get raw value of CP_proximityV_GBCC2
    ///
    /// - Start bit: 24
    /// - Signal size: 14 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_proximity_v_gbcc2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..38].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_proximityV_GBCC2
    #[inline(always)]
    pub fn set_cp_proximity_v_gbcc2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 13.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..38].store_le(value);
        Ok(())
    }
    
    /// CP_proximityV_intervalMax10s
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_proximity_v_interval_max10s(&self) -> f32 {
        self.cp_proximity_v_interval_max10s_raw()
    }
    
    /// Get raw value of CP_proximityV_intervalMax10s
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_proximity_v_interval_max10s_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..56].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_proximityV_intervalMax10s
    #[inline(always)]
    pub fn set_cp_proximity_v_interval_max10s(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..56].store_le(value);
        Ok(())
    }
    
    /// CP_proximityV_intervalMin10s
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_proximity_v_interval_min10s(&self) -> f32 {
        self.cp_proximity_v_interval_min10s_raw()
    }
    
    /// Get raw value of CP_proximityV_intervalMin10s
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_proximity_v_interval_min10s_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..40].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_proximityV_intervalMin10s
    #[inline(always)]
    pub fn set_cp_proximity_v_interval_min10s(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..40].store_le(value);
        Ok(())
    }
    
    /// CP_refVoltage
    ///
    /// - Min: 0
    /// - Max: 1.8
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn cp_ref_voltage(&self) -> f32 {
        self.cp_ref_voltage_raw()
    }
    
    /// Get raw value of CP_refVoltage
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.00705882
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cp_ref_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.00705882_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CP_refVoltage
    #[inline(always)]
    pub fn set_cp_ref_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.8_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1885 }); }
        let factor = 0.00705882_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id75dcpSensorData {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id75dcpSensorData
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cp_sensor_data_select = u.int_in_range(0..=12)?;
        let cp_uhf_chip_state = u.int_in_range(0..=7)?;
        let cp_uhf_fifo_data = u.int_in_range(0..=255)?;
        let cp_uhf_rssi = u.int_in_range(0..=255)?;
        let cp_uhf_rx_num_bytes = u.int_in_range(0..=255)?;
        let cp_uhf_rx_overflow = u.int_in_range(0..=1)? == 1;
        let cp_uhf_self_test_rssi = u.int_in_range(0..=255)?;
        let cp_back_cover2_counts = 0_f32;
        let cp_back_cover_counts = 0_f32;
        let cp_board_temperature = -50_f32;
        let cp_door_counts_debounced = 0_f32;
        let cp_door_counts_filtered = 0_f32;
        let cp_door_i = 0_f32;
        let cp_door_last_request_max_i = 0_f32;
        let cp_door_pot = 0_f32;
        let cp_fault_line_v = 0_f32;
        let cp_inductive_sensor_raw = u.int_in_range(0..=268435000)?;
        let cp_inlet1_harness_id_state = u.int_in_range(0..=2)?;
        let cp_inlet1_harness_id_value = u.int_in_range(0..=7)?;
        let cp_inlet1_harness_v = 0_f32;
        let cp_inlet2_harness_id_state = u.int_in_range(0..=2)?;
        let cp_inlet2_harness_id_value = u.int_in_range(0..=7)?;
        let cp_inlet2_harness_v = 0_f32;
        let cp_latch2_i = 0_f32;
        let cp_latch_i = 0_f32;
        let cp_pilot_high_value = -20.48_f32;
        let cp_pilot_high_value_interval_max10s = -20.48_f32;
        let cp_pilot_high_value_interval_min10s = -20.48_f32;
        let cp_pilot_low_value = -20.48_f32;
        let cp_pilot_low_value_interval_max10s = -20.48_f32;
        let cp_pilot_low_value_interval_min10s = -20.48_f32;
        let cp_pilot_period = u.int_in_range(0..=4095)?;
        let cp_pilot_pulse_width = u.int_in_range(0..=4095)?;
        let cp_pin_temperature1 = -55_f32;
        let cp_pin_temperature2 = -55_f32;
        let cp_pin_temperature3 = -55_f32;
        let cp_prox_conn1_sense = u.int_in_range(0..=1)? == 1;
        let cp_prox_en = u.int_in_range(0..=1)? == 1;
        let cp_proximity_v = 0_f32;
        let cp_proximity_v_gbcc1 = 0_f32;
        let cp_proximity_v_gbcc2 = 0_f32;
        let cp_proximity_v_interval_max10s = 0_f32;
        let cp_proximity_v_interval_min10s = 0_f32;
        let cp_ref_voltage = 0_f32;
        Id75dcpSensorData::new(cp_sensor_data_select,cp_uhf_chip_state,cp_uhf_fifo_data,cp_uhf_rssi,cp_uhf_rx_num_bytes,cp_uhf_rx_overflow,cp_uhf_self_test_rssi,cp_back_cover2_counts,cp_back_cover_counts,cp_board_temperature,cp_door_counts_debounced,cp_door_counts_filtered,cp_door_i,cp_door_last_request_max_i,cp_door_pot,cp_fault_line_v,cp_inductive_sensor_raw,cp_inlet1_harness_id_state,cp_inlet1_harness_id_value,cp_inlet1_harness_v,cp_inlet2_harness_id_state,cp_inlet2_harness_id_value,cp_inlet2_harness_v,cp_latch2_i,cp_latch_i,cp_pilot_high_value,cp_pilot_high_value_interval_max10s,cp_pilot_high_value_interval_min10s,cp_pilot_low_value,cp_pilot_low_value_interval_max10s,cp_pilot_low_value_interval_min10s,cp_pilot_period,cp_pilot_pulse_width,cp_pin_temperature1,cp_pin_temperature2,cp_pin_temperature3,cp_prox_conn1_sense,cp_prox_en,cp_proximity_v,cp_proximity_v_gbcc1,cp_proximity_v_gbcc2,cp_proximity_v_interval_max10s,cp_proximity_v_interval_min10s,cp_ref_voltage).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CP_sensorDataSelect
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id75dcpSensorDataCpSensorDataSelect {
    CpSensorDoor,
    CpSensorDoorCounts,
    CpSensorInductiveDoor,
    CpSensorInletHarnessId,
    CpSensorLatch,
    CpSensorPilot,
    CpSensorPilot2,
    CpSensorPinTemp,
    CpSensorProx,
    CpSensorProxGb,
    CpSensorRails,
    CpSensorSafety,
    CpSensorUhf,
    Other(u8),
}
/// Defined values for CP_inlet1HarnessIdState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id75dcpSensorDataCpInlet1HarnessIdState {
    HarnessPedigreeInvalid,
    HarnessPedigreeUnknownSna,
    HarnessPedigreeValid,
    Other(u8),
}
/// Defined values for CP_inlet2HarnessIdState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id75dcpSensorDataCpInlet2HarnessIdState {
    HarnessPedigreeInvalid,
    HarnessPedigreeUnknownSna,
    HarnessPedigreeValid,
    Other(u8),
}

/// ID287PTCcabinHeatSensorStatus
///
/// - ID: 647 (0x287)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id287ptCcabinHeatSensorStatus {
    raw: [u8; 8],
}

impl Id287ptCcabinHeatSensorStatus {
    pub const MESSAGE_ID: u32 = 647;
    
    /// Construct new ID287PTCcabinHeatSensorStatus from values
    pub fn new(ptc_left_current_hv: f32, ptc_left_temp_igbt: f32, ptc_right_current_hv: f32, ptc_right_temp_igbt: f32, ptc_temp_ocp: f32, ptc_temp_pcb: f32, ptc_voltage_hv: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ptc_left_current_hv(ptc_left_current_hv)?;
        res.set_ptc_left_temp_igbt(ptc_left_temp_igbt)?;
        res.set_ptc_right_current_hv(ptc_right_current_hv)?;
        res.set_ptc_right_temp_igbt(ptc_right_temp_igbt)?;
        res.set_ptc_temp_ocp(ptc_temp_ocp)?;
        res.set_ptc_temp_pcb(ptc_temp_pcb)?;
        res.set_ptc_voltage_hv(ptc_voltage_hv)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// PTC_leftCurrentHV
    ///
    /// Heater Left Current
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_left_current_hv(&self) -> f32 {
        self.ptc_left_current_hv_raw()
    }
    
    /// Get raw value of PTC_leftCurrentHV
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_left_current_hv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_leftCurrentHV
    #[inline(always)]
    pub fn set_ptc_left_current_hv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// PTC_leftTempIGBT
    ///
    /// - Min: -40
    /// - Max: 200
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_left_temp_igbt(&self) -> f32 {
        self.ptc_left_temp_igbt_raw()
    }
    
    /// Get raw value of PTC_leftTempIGBT
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_left_temp_igbt_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_leftTempIGBT
    #[inline(always)]
    pub fn set_ptc_left_temp_igbt(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// PTC_rightCurrentHV
    ///
    /// Heater Right Current
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_right_current_hv(&self) -> f32 {
        self.ptc_right_current_hv_raw()
    }
    
    /// Get raw value of PTC_rightCurrentHV
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_right_current_hv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_rightCurrentHV
    #[inline(always)]
    pub fn set_ptc_right_current_hv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// PTC_rightTempIGBT
    ///
    /// - Min: -40
    /// - Max: 200
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_right_temp_igbt(&self) -> f32 {
        self.ptc_right_temp_igbt_raw()
    }
    
    /// Get raw value of PTC_rightTempIGBT
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_right_temp_igbt_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_rightTempIGBT
    #[inline(always)]
    pub fn set_ptc_right_temp_igbt(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// PTC_tempOCP
    ///
    /// - Min: -40
    /// - Max: 200
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_temp_ocp(&self) -> f32 {
        self.ptc_temp_ocp_raw()
    }
    
    /// Get raw value of PTC_tempOCP
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_temp_ocp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_tempOCP
    #[inline(always)]
    pub fn set_ptc_temp_ocp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// PTC_tempPCB
    ///
    /// - Min: -40
    /// - Max: 200
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_temp_pcb(&self) -> f32 {
        self.ptc_temp_pcb_raw()
    }
    
    /// Get raw value of PTC_tempPCB
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_temp_pcb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_tempPCB
    #[inline(always)]
    pub fn set_ptc_temp_pcb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// PTC_voltageHV
    ///
    /// Heater Voltage
    ///
    /// - Min: 0
    /// - Max: 511.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ptc_voltage_hv(&self) -> f32 {
        self.ptc_voltage_hv_raw()
    }
    
    /// Get raw value of PTC_voltageHV
    ///
    /// - Start bit: 32
    /// - Signal size: 10 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ptc_voltage_hv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..42].load_le::<u16>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PTC_voltageHV
    #[inline(always)]
    pub fn set_ptc_voltage_hv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 647 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..42].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id287ptCcabinHeatSensorStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id287ptCcabinHeatSensorStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ptc_left_current_hv = 0_f32;
        let ptc_left_temp_igbt = -40_f32;
        let ptc_right_current_hv = 0_f32;
        let ptc_right_temp_igbt = -40_f32;
        let ptc_temp_ocp = -40_f32;
        let ptc_temp_pcb = -40_f32;
        let ptc_voltage_hv = 0_f32;
        Id287ptCcabinHeatSensorStatus::new(ptc_left_current_hv,ptc_left_temp_igbt,ptc_right_current_hv,ptc_right_temp_igbt,ptc_temp_ocp,ptc_temp_pcb,ptc_voltage_hv).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID333UI_chargeRequest
///
/// - ID: 819 (0x333)
/// - Size: 5 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id333uiChargeRequest {
    raw: [u8; 5],
}

impl Id333uiChargeRequest {
    pub const MESSAGE_ID: u32 = 819;
    
    /// Construct new ID333UI_chargeRequest from values
    pub fn new(ui_ac_charge_current_limit: u8, ui_brick_balancing_disabled: bool, ui_brick_v_logging_request: bool, ui_charge_enable_request: bool, ui_charge_termination_pct: f32, ui_close_charge_port_door_request: bool, ui_open_charge_port_door_request: bool, ui_scheduled_departure_enabled: bool, ui_smart_ac_charging_enabled: bool, ui_cp_inlet_heater_request: bool, ui_soc_snapshot_expiration_time: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_ui_ac_charge_current_limit(ui_ac_charge_current_limit)?;
        res.set_ui_brick_balancing_disabled(ui_brick_balancing_disabled)?;
        res.set_ui_brick_v_logging_request(ui_brick_v_logging_request)?;
        res.set_ui_charge_enable_request(ui_charge_enable_request)?;
        res.set_ui_charge_termination_pct(ui_charge_termination_pct)?;
        res.set_ui_close_charge_port_door_request(ui_close_charge_port_door_request)?;
        res.set_ui_open_charge_port_door_request(ui_open_charge_port_door_request)?;
        res.set_ui_scheduled_departure_enabled(ui_scheduled_departure_enabled)?;
        res.set_ui_smart_ac_charging_enabled(ui_smart_ac_charging_enabled)?;
        res.set_ui_cp_inlet_heater_request(ui_cp_inlet_heater_request)?;
        res.set_ui_soc_snapshot_expiration_time(ui_soc_snapshot_expiration_time)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_acChargeCurrentLimit
    ///
    /// UI Charge Current Limit
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ac_charge_current_limit(&self) -> Id333uiChargeRequestUiAcChargeCurrentLimit {
        match self.ui_ac_charge_current_limit_raw() {
            127 => Id333uiChargeRequestUiAcChargeCurrentLimit::Sna,
            x => Id333uiChargeRequestUiAcChargeCurrentLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_acChargeCurrentLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ac_charge_current_limit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_acChargeCurrentLimit
    #[inline(always)]
    pub fn set_ui_ac_charge_current_limit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 819 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..15].store_le(value);
        Ok(())
    }
    
    /// UI_brickBalancingDisabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_brick_balancing_disabled(&self) -> Id333uiChargeRequestUiBrickBalancingDisabled {
        match self.ui_brick_balancing_disabled_raw() {
            false => Id333uiChargeRequestUiBrickBalancingDisabled::False,
            true => Id333uiChargeRequestUiBrickBalancingDisabled::True,
            x => Id333uiChargeRequestUiBrickBalancingDisabled::Other(x),
        }
    }
    
    /// Get raw value of UI_brickBalancingDisabled
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_brick_balancing_disabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_brickBalancingDisabled
    #[inline(always)]
    pub fn set_ui_brick_balancing_disabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UI_brickVLoggingRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_brick_v_logging_request(&self) -> Id333uiChargeRequestUiBrickVLoggingRequest {
        match self.ui_brick_v_logging_request_raw() {
            false => Id333uiChargeRequestUiBrickVLoggingRequest::False,
            true => Id333uiChargeRequestUiBrickVLoggingRequest::True,
            x => Id333uiChargeRequestUiBrickVLoggingRequest::Other(x),
        }
    }
    
    /// Get raw value of UI_brickVLoggingRequest
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_brick_v_logging_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_brickVLoggingRequest
    #[inline(always)]
    pub fn set_ui_brick_v_logging_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UI_chargeEnableRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_charge_enable_request(&self) -> bool {
        self.ui_charge_enable_request_raw()
    }
    
    /// Get raw value of UI_chargeEnableRequest
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_charge_enable_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_chargeEnableRequest
    #[inline(always)]
    pub fn set_ui_charge_enable_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UI_chargeTerminationPct
    ///
    /// - Min: 25
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_charge_termination_pct(&self) -> f32 {
        self.ui_charge_termination_pct_raw()
    }
    
    /// Get raw value of UI_chargeTerminationPct
    ///
    /// - Start bit: 16
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_charge_termination_pct_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..26].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_chargeTerminationPct
    #[inline(always)]
    pub fn set_ui_charge_termination_pct(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 25_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 819 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..26].store_le(value);
        Ok(())
    }
    
    /// UI_closeChargePortDoorRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_close_charge_port_door_request(&self) -> bool {
        self.ui_close_charge_port_door_request_raw()
    }
    
    /// Get raw value of UI_closeChargePortDoorRequest
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_close_charge_port_door_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_closeChargePortDoorRequest
    #[inline(always)]
    pub fn set_ui_close_charge_port_door_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UI_openChargePortDoorRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_open_charge_port_door_request(&self) -> bool {
        self.ui_open_charge_port_door_request_raw()
    }
    
    /// Get raw value of UI_openChargePortDoorRequest
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_open_charge_port_door_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_openChargePortDoorRequest
    #[inline(always)]
    pub fn set_ui_open_charge_port_door_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UI_scheduledDepartureEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_scheduled_departure_enabled(&self) -> bool {
        self.ui_scheduled_departure_enabled_raw()
    }
    
    /// Get raw value of UI_scheduledDepartureEnabled
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_scheduled_departure_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_scheduledDepartureEnabled
    #[inline(always)]
    pub fn set_ui_scheduled_departure_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// UI_smartAcChargingEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_smart_ac_charging_enabled(&self) -> bool {
        self.ui_smart_ac_charging_enabled_raw()
    }
    
    /// Get raw value of UI_smartAcChargingEnabled
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_smart_ac_charging_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_smartAcChargingEnabled
    #[inline(always)]
    pub fn set_ui_smart_ac_charging_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// UI_cpInletHeaterRequest
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_cp_inlet_heater_request(&self) -> bool {
        self.ui_cp_inlet_heater_request_raw()
    }
    
    /// Get raw value of UI_cpInletHeaterRequest
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_cp_inlet_heater_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UI_cpInletHeaterRequest
    #[inline(always)]
    pub fn set_ui_cp_inlet_heater_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// UI_socSnapshotExpirationTime
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "weeks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_soc_snapshot_expiration_time(&self) -> f32 {
        self.ui_soc_snapshot_expiration_time_raw()
    }
    
    /// Get raw value of UI_socSnapshotExpirationTime
    ///
    /// - Start bit: 28
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 2
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_soc_snapshot_expiration_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = 2_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_socSnapshotExpirationTime
    #[inline(always)]
    pub fn set_ui_soc_snapshot_expiration_time(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 819 }); }
        let factor = 1_f32;
        let offset = 2_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[28..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id333uiChargeRequest {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id333uiChargeRequest
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_ac_charge_current_limit = u.int_in_range(0..=127)?;
        let ui_brick_balancing_disabled = u.int_in_range(0..=1)? == 1;
        let ui_brick_v_logging_request = u.int_in_range(0..=1)? == 1;
        let ui_charge_enable_request = u.int_in_range(0..=1)? == 1;
        let ui_charge_termination_pct = 25_f32;
        let ui_close_charge_port_door_request = u.int_in_range(0..=1)? == 1;
        let ui_open_charge_port_door_request = u.int_in_range(0..=1)? == 1;
        let ui_scheduled_departure_enabled = u.int_in_range(0..=1)? == 1;
        let ui_smart_ac_charging_enabled = u.int_in_range(0..=1)? == 1;
        let ui_cp_inlet_heater_request = u.int_in_range(0..=1)? == 1;
        let ui_soc_snapshot_expiration_time = 0_f32;
        Id333uiChargeRequest::new(ui_ac_charge_current_limit,ui_brick_balancing_disabled,ui_brick_v_logging_request,ui_charge_enable_request,ui_charge_termination_pct,ui_close_charge_port_door_request,ui_open_charge_port_door_request,ui_scheduled_departure_enabled,ui_smart_ac_charging_enabled,ui_cp_inlet_heater_request,ui_soc_snapshot_expiration_time).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_acChargeCurrentLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id333uiChargeRequestUiAcChargeCurrentLimit {
    Sna,
    Other(u8),
}
/// Defined values for UI_brickBalancingDisabled
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id333uiChargeRequestUiBrickBalancingDisabled {
    False,
    True,
    Other(bool),
}
/// Defined values for UI_brickVLoggingRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id333uiChargeRequestUiBrickVLoggingRequest {
    False,
    True,
    Other(bool),
}

/// ID334UI_powertrainControl
///
/// - ID: 820 (0x334)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id334uiPowertrainControl {
    raw: [u8; 8],
}

impl Id334uiPowertrainControl {
    pub const MESSAGE_ID: u32 = 820;
    
    /// Construct new ID334UI_powertrainControl from values
    pub fn new(ui_di_app_slider_debug: u8, ui_limit_mode: u8, ui_motor_on_mode: u8, ui_pedal_map: u8, ui_powertrain_control_checksum: u8, ui_powertrain_control_counter: u8, ui_regen_torque_max: f32, ui_speed_limit: f32, ui_stopping_mode: u8, ui_system_power_limit: f32, ui_system_torque_limit: f32, ui_waste_mode: u8, ui_waste_mode_regen_limit: u8, ui_closure_confirmed: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_di_app_slider_debug(ui_di_app_slider_debug)?;
        res.set_ui_limit_mode(ui_limit_mode)?;
        res.set_ui_motor_on_mode(ui_motor_on_mode)?;
        res.set_ui_pedal_map(ui_pedal_map)?;
        res.set_ui_powertrain_control_checksum(ui_powertrain_control_checksum)?;
        res.set_ui_powertrain_control_counter(ui_powertrain_control_counter)?;
        res.set_ui_regen_torque_max(ui_regen_torque_max)?;
        res.set_ui_speed_limit(ui_speed_limit)?;
        res.set_ui_stopping_mode(ui_stopping_mode)?;
        res.set_ui_system_power_limit(ui_system_power_limit)?;
        res.set_ui_system_torque_limit(ui_system_torque_limit)?;
        res.set_ui_waste_mode(ui_waste_mode)?;
        res.set_ui_waste_mode_regen_limit(ui_waste_mode_regen_limit)?;
        res.set_ui_closure_confirmed(ui_closure_confirmed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_DIAppSliderDebug
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_di_app_slider_debug(&self) -> u8 {
        self.ui_di_app_slider_debug_raw()
    }
    
    /// Get raw value of UI_DIAppSliderDebug
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_di_app_slider_debug_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_DIAppSliderDebug
    #[inline(always)]
    pub fn set_ui_di_app_slider_debug(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..44].store_le(value);
        Ok(())
    }
    
    /// UI_limitMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_limit_mode(&self) -> Id334uiPowertrainControlUiLimitMode {
        match self.ui_limit_mode_raw() {
            2 => Id334uiPowertrainControlUiLimitMode::LimitFactory,
            0 => Id334uiPowertrainControlUiLimitMode::LimitNormal,
            3 => Id334uiPowertrainControlUiLimitMode::LimitService,
            1 => Id334uiPowertrainControlUiLimitMode::LimitValet,
            x => Id334uiPowertrainControlUiLimitMode::Other(x),
        }
    }
    
    /// Get raw value of UI_limitMode
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_limit_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_limitMode
    #[inline(always)]
    pub fn set_ui_limit_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// UI_motorOnMode
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_motor_on_mode(&self) -> Id334uiPowertrainControlUiMotorOnMode {
        match self.ui_motor_on_mode_raw() {
            1 => Id334uiPowertrainControlUiMotorOnMode::MotoronmodeFrontOnly,
            0 => Id334uiPowertrainControlUiMotorOnMode::MotoronmodeNormal,
            2 => Id334uiPowertrainControlUiMotorOnMode::MotoronmodeRearOnly,
            x => Id334uiPowertrainControlUiMotorOnMode::Other(x),
        }
    }
    
    /// Get raw value of UI_motorOnMode
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_motor_on_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_motorOnMode
    #[inline(always)]
    pub fn set_ui_motor_on_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// UI_pedalMap
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_pedal_map(&self) -> Id334uiPowertrainControlUiPedalMap {
        match self.ui_pedal_map_raw() {
            0 => Id334uiPowertrainControlUiPedalMap::Chill,
            2 => Id334uiPowertrainControlUiPedalMap::Performance,
            1 => Id334uiPowertrainControlUiPedalMap::Sport,
            x => Id334uiPowertrainControlUiPedalMap::Other(x),
        }
    }
    
    /// Get raw value of UI_pedalMap
    ///
    /// - Start bit: 5
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_pedal_map_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[5..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_pedalMap
    #[inline(always)]
    pub fn set_ui_pedal_map(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..7].store_le(value);
        Ok(())
    }
    
    /// UI_powertrainControlChecksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_powertrain_control_checksum(&self) -> u8 {
        self.ui_powertrain_control_checksum_raw()
    }
    
    /// Get raw value of UI_powertrainControlChecksum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_powertrain_control_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_powertrainControlChecksum
    #[inline(always)]
    pub fn set_ui_powertrain_control_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// UI_powertrainControlCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_powertrain_control_counter(&self) -> u8 {
        self.ui_powertrain_control_counter_raw()
    }
    
    /// Get raw value of UI_powertrainControlCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_powertrain_control_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_powertrainControlCounter
    #[inline(always)]
    pub fn set_ui_powertrain_control_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..56].store_le(value);
        Ok(())
    }
    
    /// UI_regenTorqueMax
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_regen_torque_max(&self) -> f32 {
        self.ui_regen_torque_max_raw()
    }
    
    /// Get raw value of UI_regenTorqueMax
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_regen_torque_max_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_regenTorqueMax
    #[inline(always)]
    pub fn set_ui_regen_torque_max(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// UI_speedLimit
    ///
    /// - Min: 50
    /// - Max: 285
    /// - Unit: "kph"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_speed_limit(&self) -> Id334uiPowertrainControlUiSpeedLimit {
        match self.ui_speed_limit_raw() {
            255 => Id334uiPowertrainControlUiSpeedLimit::Sna,
            x => Id334uiPowertrainControlUiSpeedLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_speedLimit
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 50
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_speed_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = 50_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_speedLimit
    #[inline(always)]
    pub fn set_ui_speed_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 50_f32 || 285_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        let factor = 1_f32;
        let offset = 50_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// UI_stoppingMode
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_stopping_mode(&self) -> Id334uiPowertrainControlUiStoppingMode {
        match self.ui_stopping_mode_raw() {
            1 => Id334uiPowertrainControlUiStoppingMode::Creep,
            2 => Id334uiPowertrainControlUiStoppingMode::Hold,
            0 => Id334uiPowertrainControlUiStoppingMode::Standard,
            x => Id334uiPowertrainControlUiStoppingMode::Other(x),
        }
    }
    
    /// Get raw value of UI_stoppingMode
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_stopping_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_stoppingMode
    #[inline(always)]
    pub fn set_ui_stopping_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// UI_systemPowerLimit
    ///
    /// - Min: 20
    /// - Max: 640
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_system_power_limit(&self) -> Id334uiPowertrainControlUiSystemPowerLimit {
        match self.ui_system_power_limit_raw() {
            31 => Id334uiPowertrainControlUiSystemPowerLimit::Sna,
            x => Id334uiPowertrainControlUiSystemPowerLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_systemPowerLimit
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 20
    /// - Offset: 20
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_system_power_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..5].load_le::<u8>();
        
        let factor = 20_f32;
        let offset = 20_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_systemPowerLimit
    #[inline(always)]
    pub fn set_ui_system_power_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 20_f32 || 640_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        let factor = 20_f32;
        let offset = 20_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..5].store_le(value);
        Ok(())
    }
    
    /// UI_systemTorqueLimit
    ///
    /// - Min: 4000
    /// - Max: 10300
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_system_torque_limit(&self) -> Id334uiPowertrainControlUiSystemTorqueLimit {
        match self.ui_system_torque_limit_raw() {
            63 => Id334uiPowertrainControlUiSystemTorqueLimit::Sna,
            x => Id334uiPowertrainControlUiSystemTorqueLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_systemTorqueLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 100
    /// - Offset: 4000
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_system_torque_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..14].load_le::<u8>();
        
        let factor = 100_f32;
        let offset = 4000_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of UI_systemTorqueLimit
    #[inline(always)]
    pub fn set_ui_system_torque_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 4000_f32 || 10300_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        let factor = 100_f32;
        let offset = 4000_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..14].store_le(value);
        Ok(())
    }
    
    /// UI_wasteMode
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_waste_mode(&self) -> Id334uiPowertrainControlUiWasteMode {
        match self.ui_waste_mode_raw() {
            2 => Id334uiPowertrainControlUiWasteMode::WasteTypeFull,
            0 => Id334uiPowertrainControlUiWasteMode::WasteTypeNone,
            1 => Id334uiPowertrainControlUiWasteMode::WasteTypePartial,
            x => Id334uiPowertrainControlUiWasteMode::Other(x),
        }
    }
    
    /// Get raw value of UI_wasteMode
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_waste_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_wasteMode
    #[inline(always)]
    pub fn set_ui_waste_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..38].store_le(value);
        Ok(())
    }
    
    /// UI_wasteModeRegenLimit
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_waste_mode_regen_limit(&self) -> Id334uiPowertrainControlUiWasteModeRegenLimit {
        match self.ui_waste_mode_regen_limit_raw() {
            3 => Id334uiPowertrainControlUiWasteModeRegenLimit::MaxRegenCurrent0a,
            2 => Id334uiPowertrainControlUiWasteModeRegenLimit::MaxRegenCurrent10a,
            1 => Id334uiPowertrainControlUiWasteModeRegenLimit::MaxRegenCurrent30a,
            0 => Id334uiPowertrainControlUiWasteModeRegenLimit::MaxRegenCurrentMax,
            x => Id334uiPowertrainControlUiWasteModeRegenLimit::Other(x),
        }
    }
    
    /// Get raw value of UI_wasteModeRegenLimit
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_waste_mode_regen_limit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_wasteModeRegenLimit
    #[inline(always)]
    pub fn set_ui_waste_mode_regen_limit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// UI_closureConfirmed
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_closure_confirmed(&self) -> Id334uiPowertrainControlUiClosureConfirmed {
        match self.ui_closure_confirmed_raw() {
            1 => Id334uiPowertrainControlUiClosureConfirmed::ConfirmedFrunk,
            0 => Id334uiPowertrainControlUiClosureConfirmed::ConfirmedNone,
            2 => Id334uiPowertrainControlUiClosureConfirmed::ConfirmedProx,
            x => Id334uiPowertrainControlUiClosureConfirmed::Other(x),
        }
    }
    
    /// Get raw value of UI_closureConfirmed
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_closure_confirmed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_closureConfirmed
    #[inline(always)]
    pub fn set_ui_closure_confirmed(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 820 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id334uiPowertrainControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id334uiPowertrainControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_di_app_slider_debug = u.int_in_range(0..=3)?;
        let ui_limit_mode = u.int_in_range(0..=3)?;
        let ui_motor_on_mode = u.int_in_range(0..=2)?;
        let ui_pedal_map = u.int_in_range(0..=2)?;
        let ui_powertrain_control_checksum = u.int_in_range(0..=255)?;
        let ui_powertrain_control_counter = u.int_in_range(0..=15)?;
        let ui_regen_torque_max = 0_f32;
        let ui_speed_limit = 50_f32;
        let ui_stopping_mode = u.int_in_range(0..=2)?;
        let ui_system_power_limit = 20_f32;
        let ui_system_torque_limit = 4000_f32;
        let ui_waste_mode = u.int_in_range(0..=2)?;
        let ui_waste_mode_regen_limit = u.int_in_range(0..=3)?;
        let ui_closure_confirmed = u.int_in_range(0..=2)?;
        Id334uiPowertrainControl::new(ui_di_app_slider_debug,ui_limit_mode,ui_motor_on_mode,ui_pedal_map,ui_powertrain_control_checksum,ui_powertrain_control_counter,ui_regen_torque_max,ui_speed_limit,ui_stopping_mode,ui_system_power_limit,ui_system_torque_limit,ui_waste_mode,ui_waste_mode_regen_limit,ui_closure_confirmed).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for UI_limitMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiLimitMode {
    LimitFactory,
    LimitNormal,
    LimitService,
    LimitValet,
    Other(u8),
}
/// Defined values for UI_motorOnMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiMotorOnMode {
    MotoronmodeFrontOnly,
    MotoronmodeNormal,
    MotoronmodeRearOnly,
    Other(u8),
}
/// Defined values for UI_pedalMap
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiPedalMap {
    Chill,
    Performance,
    Sport,
    Other(u8),
}
/// Defined values for UI_speedLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiSpeedLimit {
    Sna,
    Other(f32),
}
/// Defined values for UI_stoppingMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiStoppingMode {
    Creep,
    Hold,
    Standard,
    Other(u8),
}
/// Defined values for UI_systemPowerLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiSystemPowerLimit {
    Sna,
    Other(f32),
}
/// Defined values for UI_systemTorqueLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiSystemTorqueLimit {
    Sna,
    Other(f32),
}
/// Defined values for UI_wasteMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiWasteMode {
    WasteTypeFull,
    WasteTypeNone,
    WasteTypePartial,
    Other(u8),
}
/// Defined values for UI_wasteModeRegenLimit
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiWasteModeRegenLimit {
    MaxRegenCurrent0a,
    MaxRegenCurrent10a,
    MaxRegenCurrent30a,
    MaxRegenCurrentMax,
    Other(u8),
}
/// Defined values for UI_closureConfirmed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id334uiPowertrainControlUiClosureConfirmed {
    ConfirmedFrunk,
    ConfirmedNone,
    ConfirmedProx,
    Other(u8),
}

/// ID33AUI_rangeSOC
///
/// - ID: 826 (0x33a)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id33auiRangeSoc {
    raw: [u8; 8],
}

impl Id33auiRangeSoc {
    pub const MESSAGE_ID: u32 = 826;
    
    /// Construct new ID33AUI_rangeSOC from values
    pub fn new(ui_ideal_range: u16, ui_range: u16, ui_soc: u8, ui_u_soe: u8, ui_rated_w_hp_m: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ui_ideal_range(ui_ideal_range)?;
        res.set_ui_range(ui_range)?;
        res.set_ui_soc(ui_soc)?;
        res.set_ui_u_soe(ui_u_soe)?;
        res.set_ui_rated_w_hp_m(ui_rated_w_hp_m)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_idealRange
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "mi"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_ideal_range(&self) -> u16 {
        self.ui_ideal_range_raw()
    }
    
    /// Get raw value of UI_idealRange
    ///
    /// - Start bit: 16
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_ideal_range_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..26].load_le::<u16>();
        
        signal
    }
    
    /// Set value of UI_idealRange
    #[inline(always)]
    pub fn set_ui_ideal_range(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 826 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..26].store_le(value);
        Ok(())
    }
    
    /// UI_Range
    ///
    /// Range
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "mi"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_range(&self) -> u16 {
        self.ui_range_raw()
    }
    
    /// Get raw value of UI_Range
    ///
    /// - Start bit: 0
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_range_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[0..10].load_le::<u16>();
        
        signal
    }
    
    /// Set value of UI_Range
    #[inline(always)]
    pub fn set_ui_range(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 826 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..10].store_le(value);
        Ok(())
    }
    
    /// UI_SOC
    ///
    /// State of Charge UI
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_soc(&self) -> u8 {
        self.ui_soc_raw()
    }
    
    /// Get raw value of UI_SOC
    ///
    /// - Start bit: 48
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_soc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..55].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_SOC
    #[inline(always)]
    pub fn set_ui_soc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 826 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..55].store_le(value);
        Ok(())
    }
    
    /// UI_uSOE
    ///
    /// UI fine SOC
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_u_soe(&self) -> u8 {
        self.ui_u_soe_raw()
    }
    
    /// Get raw value of UI_uSOE
    ///
    /// - Start bit: 56
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_u_soe_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_uSOE
    #[inline(always)]
    pub fn set_ui_u_soe(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 826 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..63].store_le(value);
        Ok(())
    }
    
    /// UI_ratedWHpM
    ///
    /// WHM Rating
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "WHpM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_rated_w_hp_m(&self) -> u16 {
        self.ui_rated_w_hp_m_raw()
    }
    
    /// Get raw value of UI_ratedWHpM
    ///
    /// - Start bit: 32
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_rated_w_hp_m_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..42].load_le::<u16>();
        
        signal
    }
    
    /// Set value of UI_ratedWHpM
    #[inline(always)]
    pub fn set_ui_rated_w_hp_m(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 826 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..42].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id33auiRangeSoc {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id33auiRangeSoc
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_ideal_range = u.int_in_range(0..=1023)?;
        let ui_range = u.int_in_range(0..=1023)?;
        let ui_soc = u.int_in_range(0..=127)?;
        let ui_u_soe = u.int_in_range(0..=127)?;
        let ui_rated_w_hp_m = u.int_in_range(0..=1023)?;
        Id33auiRangeSoc::new(ui_ideal_range,ui_range,ui_soc,ui_u_soe,ui_rated_w_hp_m).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID241VCFRONT_coolant
///
/// - ID: 577 (0x241)
/// - Size: 7 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id241vcfrontCoolant {
    raw: [u8; 7],
}

impl Id241vcfrontCoolant {
    pub const MESSAGE_ID: u32 = 577;
    
    /// Construct new ID241VCFRONT_coolant from values
    pub fn new(vcfront_coolant_air_purge_bat_state: u8, vcfront_coolant_flow_bat_actual: f32, vcfront_coolant_flow_bat_reason: u8, vcfront_coolant_flow_bat_target: f32, vcfront_coolant_flow_pt_actual: f32, vcfront_coolant_flow_pt_reason: u8, vcfront_coolant_flow_pt_target: f32, vcfront_coolant_has_been_filled: bool, vcfront_radiator_ineffective: bool, vcfront_waste_heat_request_type: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 7] };
        res.set_vcfront_coolant_air_purge_bat_state(vcfront_coolant_air_purge_bat_state)?;
        res.set_vcfront_coolant_flow_bat_actual(vcfront_coolant_flow_bat_actual)?;
        res.set_vcfront_coolant_flow_bat_reason(vcfront_coolant_flow_bat_reason)?;
        res.set_vcfront_coolant_flow_bat_target(vcfront_coolant_flow_bat_target)?;
        res.set_vcfront_coolant_flow_pt_actual(vcfront_coolant_flow_pt_actual)?;
        res.set_vcfront_coolant_flow_pt_reason(vcfront_coolant_flow_pt_reason)?;
        res.set_vcfront_coolant_flow_pt_target(vcfront_coolant_flow_pt_target)?;
        res.set_vcfront_coolant_has_been_filled(vcfront_coolant_has_been_filled)?;
        res.set_vcfront_radiator_ineffective(vcfront_radiator_ineffective)?;
        res.set_vcfront_waste_heat_request_type(vcfront_waste_heat_request_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_coolantAirPurgeBatState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_air_purge_bat_state(&self) -> Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState {
        match self.vcfront_coolant_air_purge_bat_state_raw() {
            1 => Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState::AirPurgeStateActive,
            2 => Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState::AirPurgeStateComplete,
            0 => Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState::AirPurgeStateInactive,
            3 => Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState::AirPurgeStateInterrupted,
            4 => Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState::AirPurgeStatePending,
            x => Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantAirPurgeBatState
    ///
    /// - Start bit: 48
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_air_purge_bat_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantAirPurgeBatState
    #[inline(always)]
    pub fn set_vcfront_coolant_air_purge_bat_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..51].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFlowBatActual
    ///
    /// Battery Coolant Flow
    ///
    /// - Min: 0
    /// - Max: 40
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_flow_bat_actual(&self) -> f32 {
        self.vcfront_coolant_flow_bat_actual_raw()
    }
    
    /// Get raw value of VCFRONT_coolantFlowBatActual
    ///
    /// - Start bit: 0
    /// - Signal size: 9 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_flow_bat_actual_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..9].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantFlowBatActual
    #[inline(always)]
    pub fn set_vcfront_coolant_flow_bat_actual(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 40_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFlowBatReason
    ///
    /// - Min: 0
    /// - Max: 14
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_flow_bat_reason(&self) -> Id241vcfrontCoolantVcfrontCoolantFlowBatReason {
        match self.vcfront_coolant_flow_bat_reason_raw() {
            4 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::ActiveManagerBatt,
            9 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::ActiveManagerPt,
            6 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::BmsFlowReq,
            1 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::CoolantAirPurge,
            7 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::DasFlowReq,
            13 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::DisFlowReq,
            12 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::DiFlowReq,
            14 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::HpFlowReq,
            0 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::None,
            2 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::NoFlowReq,
            3 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::OverrideBatt,
            8 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::OverridePt,
            5 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::PassiveManagerBatt,
            10 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::PassiveManagerPt,
            11 => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::PcsFlowReq,
            x => Id241vcfrontCoolantVcfrontCoolantFlowBatReason::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantFlowBatReason
    ///
    /// - Start bit: 18
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_flow_bat_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantFlowBatReason
    #[inline(always)]
    pub fn set_vcfront_coolant_flow_bat_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 14_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFlowBatTarget
    ///
    /// - Min: 0
    /// - Max: 40
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_flow_bat_target(&self) -> f32 {
        self.vcfront_coolant_flow_bat_target_raw()
    }
    
    /// Get raw value of VCFRONT_coolantFlowBatTarget
    ///
    /// - Start bit: 9
    /// - Signal size: 9 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_flow_bat_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[9..18].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantFlowBatTarget
    #[inline(always)]
    pub fn set_vcfront_coolant_flow_bat_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 40_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[9..18].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFlowPTActual
    ///
    /// Powertrain Coolant Flow
    ///
    /// - Min: 0
    /// - Max: 40
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_flow_pt_actual(&self) -> f32 {
        self.vcfront_coolant_flow_pt_actual_raw()
    }
    
    /// Get raw value of VCFRONT_coolantFlowPTActual
    ///
    /// - Start bit: 22
    /// - Signal size: 9 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_flow_pt_actual_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[22..31].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantFlowPTActual
    #[inline(always)]
    pub fn set_vcfront_coolant_flow_pt_actual(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 40_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[22..31].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFlowPTReason
    ///
    /// - Min: 0
    /// - Max: 14
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_flow_pt_reason(&self) -> Id241vcfrontCoolantVcfrontCoolantFlowPtReason {
        match self.vcfront_coolant_flow_pt_reason_raw() {
            4 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::ActiveManagerBatt,
            9 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::ActiveManagerPt,
            6 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::BmsFlowReq,
            1 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::CoolantAirPurge,
            7 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::DasFlowReq,
            13 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::DisFlowReq,
            12 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::DiFlowReq,
            14 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::HpFlowReq,
            0 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::None,
            2 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::NoFlowReq,
            3 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::OverrideBatt,
            8 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::OverridePt,
            5 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::PassiveManagerBatt,
            10 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::PassiveManagerPt,
            11 => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::PcsFlowReq,
            x => Id241vcfrontCoolantVcfrontCoolantFlowPtReason::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantFlowPTReason
    ///
    /// - Start bit: 40
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_flow_pt_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantFlowPTReason
    #[inline(always)]
    pub fn set_vcfront_coolant_flow_pt_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 14_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFlowPTTarget
    ///
    /// - Min: 0
    /// - Max: 40
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_flow_pt_target(&self) -> f32 {
        self.vcfront_coolant_flow_pt_target_raw()
    }
    
    /// Get raw value of VCFRONT_coolantFlowPTTarget
    ///
    /// - Start bit: 31
    /// - Signal size: 9 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_flow_pt_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..40].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantFlowPTTarget
    #[inline(always)]
    pub fn set_vcfront_coolant_flow_pt_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 40_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantHasBeenFilled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_has_been_filled(&self) -> bool {
        self.vcfront_coolant_has_been_filled_raw()
    }
    
    /// Get raw value of VCFRONT_coolantHasBeenFilled
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_has_been_filled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_coolantHasBeenFilled
    #[inline(always)]
    pub fn set_vcfront_coolant_has_been_filled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[46..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radiatorIneffective
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_radiator_ineffective(&self) -> bool {
        self.vcfront_radiator_ineffective_raw()
    }
    
    /// Get raw value of VCFRONT_radiatorIneffective
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_radiator_ineffective_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_radiatorIneffective
    #[inline(always)]
    pub fn set_vcfront_radiator_ineffective(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[47..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_wasteHeatRequestType
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_waste_heat_request_type(&self) -> Id241vcfrontCoolantVcfrontWasteHeatRequestType {
        match self.vcfront_waste_heat_request_type_raw() {
            2 => Id241vcfrontCoolantVcfrontWasteHeatRequestType::WasteTypeFull,
            0 => Id241vcfrontCoolantVcfrontWasteHeatRequestType::WasteTypeNone,
            1 => Id241vcfrontCoolantVcfrontWasteHeatRequestType::WasteTypePartial,
            x => Id241vcfrontCoolantVcfrontWasteHeatRequestType::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_wasteHeatRequestType
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_waste_heat_request_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_wasteHeatRequestType
    #[inline(always)]
    pub fn set_vcfront_waste_heat_request_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 577 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id241vcfrontCoolant {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 7 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 7];
        raw.copy_from_slice(&payload[..7]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id241vcfrontCoolant
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_coolant_air_purge_bat_state = u.int_in_range(0..=4)?;
        let vcfront_coolant_flow_bat_actual = 0_f32;
        let vcfront_coolant_flow_bat_reason = u.int_in_range(0..=14)?;
        let vcfront_coolant_flow_bat_target = 0_f32;
        let vcfront_coolant_flow_pt_actual = 0_f32;
        let vcfront_coolant_flow_pt_reason = u.int_in_range(0..=14)?;
        let vcfront_coolant_flow_pt_target = 0_f32;
        let vcfront_coolant_has_been_filled = u.int_in_range(0..=1)? == 1;
        let vcfront_radiator_ineffective = u.int_in_range(0..=1)? == 1;
        let vcfront_waste_heat_request_type = u.int_in_range(0..=2)?;
        Id241vcfrontCoolant::new(vcfront_coolant_air_purge_bat_state,vcfront_coolant_flow_bat_actual,vcfront_coolant_flow_bat_reason,vcfront_coolant_flow_bat_target,vcfront_coolant_flow_pt_actual,vcfront_coolant_flow_pt_reason,vcfront_coolant_flow_pt_target,vcfront_coolant_has_been_filled,vcfront_radiator_ineffective,vcfront_waste_heat_request_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_coolantAirPurgeBatState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id241vcfrontCoolantVcfrontCoolantAirPurgeBatState {
    AirPurgeStateActive,
    AirPurgeStateComplete,
    AirPurgeStateInactive,
    AirPurgeStateInterrupted,
    AirPurgeStatePending,
    Other(u8),
}
/// Defined values for VCFRONT_coolantFlowBatReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id241vcfrontCoolantVcfrontCoolantFlowBatReason {
    ActiveManagerBatt,
    ActiveManagerPt,
    BmsFlowReq,
    CoolantAirPurge,
    DasFlowReq,
    DisFlowReq,
    DiFlowReq,
    HpFlowReq,
    None,
    NoFlowReq,
    OverrideBatt,
    OverridePt,
    PassiveManagerBatt,
    PassiveManagerPt,
    PcsFlowReq,
    Other(u8),
}
/// Defined values for VCFRONT_coolantFlowPTReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id241vcfrontCoolantVcfrontCoolantFlowPtReason {
    ActiveManagerBatt,
    ActiveManagerPt,
    BmsFlowReq,
    CoolantAirPurge,
    DasFlowReq,
    DisFlowReq,
    DiFlowReq,
    HpFlowReq,
    None,
    NoFlowReq,
    OverrideBatt,
    OverridePt,
    PassiveManagerBatt,
    PassiveManagerPt,
    PcsFlowReq,
    Other(u8),
}
/// Defined values for VCFRONT_wasteHeatRequestType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id241vcfrontCoolantVcfrontWasteHeatRequestType {
    WasteTypeFull,
    WasteTypeNone,
    WasteTypePartial,
    Other(u8),
}

/// ID3BBUI_power
///
/// - ID: 955 (0x3bb)
/// - Size: 2 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id3bbuiPower {
    raw: [u8; 2],
}

impl Id3bbuiPower {
    pub const MESSAGE_ID: u32 = 955;
    
    /// Construct new ID3BBUI_power from values
    pub fn new(ui_power_expected: u8, ui_power_ideal: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ui_power_expected(ui_power_expected)?;
        res.set_ui_power_ideal(ui_power_ideal)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UI_powerExpected
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_power_expected(&self) -> u8 {
        self.ui_power_expected_raw()
    }
    
    /// Get raw value of UI_powerExpected
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_power_expected_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_powerExpected
    #[inline(always)]
    pub fn set_ui_power_expected(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 955 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// UI_powerIdeal
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ui_power_ideal(&self) -> u8 {
        self.ui_power_ideal_raw()
    }
    
    /// Get raw value of UI_powerIdeal
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ui_power_ideal_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UI_powerIdeal
    #[inline(always)]
    pub fn set_ui_power_ideal(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 955 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id3bbuiPower {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id3bbuiPower
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ui_power_expected = u.int_in_range(0..=100)?;
        let ui_power_ideal = u.int_in_range(0..=100)?;
        Id3bbuiPower::new(ui_power_expected,ui_power_ideal).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID5D5RearDItemps
///
/// - ID: 1493 (0x5d5)
/// - Size: 5 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id5d5RearDItemps {
    raw: [u8; 5],
}

impl Id5d5RearDItemps {
    pub const MESSAGE_ID: u32 = 1493;
    
    /// Construct new ID5D5RearDItemps from values
    pub fn new(di_ph1_temp: f32, di_ph2_temp: f32, di_ph3_temp: f32, di_pcb_temp2: f32, di_igbt_junct_temp: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_di_ph1_temp(di_ph1_temp)?;
        res.set_di_ph2_temp(di_ph2_temp)?;
        res.set_di_ph3_temp(di_ph3_temp)?;
        res.set_di_pcb_temp2(di_pcb_temp2)?;
        res.set_di_igbt_junct_temp(di_igbt_junct_temp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DI_ph1Temp
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_ph1_temp(&self) -> f32 {
        self.di_ph1_temp_raw()
    }
    
    /// Get raw value of DI_ph1Temp
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_ph1_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_ph1Temp
    #[inline(always)]
    pub fn set_di_ph1_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1493 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// DI_ph2Temp
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_ph2_temp(&self) -> f32 {
        self.di_ph2_temp_raw()
    }
    
    /// Get raw value of DI_ph2Temp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_ph2_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_ph2Temp
    #[inline(always)]
    pub fn set_di_ph2_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1493 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DI_ph3Temp
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_ph3_temp(&self) -> f32 {
        self.di_ph3_temp_raw()
    }
    
    /// Get raw value of DI_ph3Temp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_ph3_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_ph3Temp
    #[inline(always)]
    pub fn set_di_ph3_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1493 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DI_pcbTemp2
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_pcb_temp2(&self) -> f32 {
        self.di_pcb_temp2_raw()
    }
    
    /// Get raw value of DI_pcbTemp2
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_pcb_temp2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_pcbTemp2
    #[inline(always)]
    pub fn set_di_pcb_temp2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1493 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DI_IGBTJunctTemp
    ///
    /// - Min: -40
    /// - Max: 200
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_igbt_junct_temp(&self) -> Id5d5RearDItempsDiIgbtJunctTemp {
        match self.di_igbt_junct_temp_raw() {
            255 => Id5d5RearDItempsDiIgbtJunctTemp::Sna,
            x => Id5d5RearDItempsDiIgbtJunctTemp::Other(x),
        }
    }
    
    /// Get raw value of DI_IGBTJunctTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_igbt_junct_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_IGBTJunctTemp
    #[inline(always)]
    pub fn set_di_igbt_junct_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1493 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id5d5RearDItemps {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id5d5RearDItemps
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let di_ph1_temp = -40_f32;
        let di_ph2_temp = -40_f32;
        let di_ph3_temp = -40_f32;
        let di_pcb_temp2 = -40_f32;
        let di_igbt_junct_temp = -40_f32;
        Id5d5RearDItemps::new(di_ph1_temp,di_ph2_temp,di_ph3_temp,di_pcb_temp2,di_igbt_junct_temp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DI_IGBTJunctTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id5d5RearDItempsDiIgbtJunctTemp {
    Sna,
    Other(f32),
}

/// ID556FrontDItemps
///
/// - ID: 1366 (0x556)
/// - Size: 7 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id556FrontDItemps {
    raw: [u8; 7],
}

impl Id556FrontDItemps {
    pub const MESSAGE_ID: u32 = 1366;
    
    /// Construct new ID556FrontDItemps from values
    pub fn new(dif_ph1_temp: f32, dif_ph2_temp: f32, dif_ph3_temp: f32, dif_pcb_temp2: f32, dif_igbt_junct_temp: f32, dif_lash_angle: f32, dif_lash_check_count: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 7] };
        res.set_dif_ph1_temp(dif_ph1_temp)?;
        res.set_dif_ph2_temp(dif_ph2_temp)?;
        res.set_dif_ph3_temp(dif_ph3_temp)?;
        res.set_dif_pcb_temp2(dif_pcb_temp2)?;
        res.set_dif_igbt_junct_temp(dif_igbt_junct_temp)?;
        res.set_dif_lash_angle(dif_lash_angle)?;
        res.set_dif_lash_check_count(dif_lash_check_count)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DIF_ph1Temp
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_ph1_temp(&self) -> f32 {
        self.dif_ph1_temp_raw()
    }
    
    /// Get raw value of DIF_ph1Temp
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_ph1_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_ph1Temp
    #[inline(always)]
    pub fn set_dif_ph1_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// DIF_ph2Temp
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_ph2_temp(&self) -> f32 {
        self.dif_ph2_temp_raw()
    }
    
    /// Get raw value of DIF_ph2Temp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_ph2_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_ph2Temp
    #[inline(always)]
    pub fn set_dif_ph2_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_ph3Temp
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_ph3_temp(&self) -> f32 {
        self.dif_ph3_temp_raw()
    }
    
    /// Get raw value of DIF_ph3Temp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_ph3_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_ph3Temp
    #[inline(always)]
    pub fn set_dif_ph3_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_pcbTemp2
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pcb_temp2(&self) -> f32 {
        self.dif_pcb_temp2_raw()
    }
    
    /// Get raw value of DIF_pcbTemp2
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pcb_temp2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pcbTemp2
    #[inline(always)]
    pub fn set_dif_pcb_temp2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_IGBTJunctTemp
    ///
    /// - Min: -40
    /// - Max: 200
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_igbt_junct_temp(&self) -> Id556FrontDItempsDifIgbtJunctTemp {
        match self.dif_igbt_junct_temp_raw() {
            255 => Id556FrontDItempsDifIgbtJunctTemp::Sna,
            x => Id556FrontDItempsDifIgbtJunctTemp::Other(x),
        }
    }
    
    /// Get raw value of DIF_IGBTJunctTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_igbt_junct_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_IGBTJunctTemp
    #[inline(always)]
    pub fn set_dif_igbt_junct_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_lashAngle
    ///
    /// - Min: 0
    /// - Max: 60
    /// - Unit: "Deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_lash_angle(&self) -> f32 {
        self.dif_lash_angle_raw()
    }
    
    /// Get raw value of DIF_lashAngle
    ///
    /// - Start bit: 40
    /// - Signal size: 10 bits
    /// - Factor: 0.06
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_lash_angle_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..50].load_le::<u16>();
        
        let factor = 0.06_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_lashAngle
    #[inline(always)]
    pub fn set_dif_lash_angle(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 60_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        let factor = 0.06_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..50].store_le(value);
        Ok(())
    }
    
    /// DIF_lashCheckCount
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_lash_check_count(&self) -> u8 {
        self.dif_lash_check_count_raw()
    }
    
    /// Get raw value of DIF_lashCheckCount
    ///
    /// - Start bit: 50
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_lash_check_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_lashCheckCount
    #[inline(always)]
    pub fn set_dif_lash_check_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1366 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id556FrontDItemps {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 7 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 7];
        raw.copy_from_slice(&payload[..7]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id556FrontDItemps
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let dif_ph1_temp = -40_f32;
        let dif_ph2_temp = -40_f32;
        let dif_ph3_temp = -40_f32;
        let dif_pcb_temp2 = -40_f32;
        let dif_igbt_junct_temp = -40_f32;
        let dif_lash_angle = 0_f32;
        let dif_lash_check_count = u.int_in_range(0..=63)?;
        Id556FrontDItemps::new(dif_ph1_temp,dif_ph2_temp,dif_ph3_temp,dif_pcb_temp2,dif_igbt_junct_temp,dif_lash_angle,dif_lash_check_count).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DIF_IGBTJunctTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id556FrontDItempsDifIgbtJunctTemp {
    Sna,
    Other(f32),
}

/// ID557FrontThermalControl
///
/// - ID: 1367 (0x557)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
///
/// swapped with 5D7 in old firmware
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id557FrontThermalControl {
    raw: [u8; 4],
}

impl Id557FrontThermalControl {
    pub const MESSAGE_ID: u32 = 1367;
    
    /// Construct new ID557FrontThermalControl from values
    pub fn new(dis_active_inlet_temp_req: f32, dis_coolant_flow_req: f32, dis_oil_flow_req: f32, dis_passive_inlet_temp_req: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_dis_active_inlet_temp_req(dis_active_inlet_temp_req)?;
        res.set_dis_coolant_flow_req(dis_coolant_flow_req)?;
        res.set_dis_oil_flow_req(dis_oil_flow_req)?;
        res.set_dis_passive_inlet_temp_req(dis_passive_inlet_temp_req)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DIS_activeInletTempReq
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dis_active_inlet_temp_req(&self) -> f32 {
        self.dis_active_inlet_temp_req_raw()
    }
    
    /// Get raw value of DIS_activeInletTempReq
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dis_active_inlet_temp_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIS_activeInletTempReq
    #[inline(always)]
    pub fn set_dis_active_inlet_temp_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1367 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIS_coolantFlowReq
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dis_coolant_flow_req(&self) -> f32 {
        self.dis_coolant_flow_req_raw()
    }
    
    /// Get raw value of DIS_coolantFlowReq
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dis_coolant_flow_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIS_coolantFlowReq
    #[inline(always)]
    pub fn set_dis_coolant_flow_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1367 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIS_oilFlowReq
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dis_oil_flow_req(&self) -> f32 {
        self.dis_oil_flow_req_raw()
    }
    
    /// Get raw value of DIS_oilFlowReq
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.06
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dis_oil_flow_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.06_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIS_oilFlowReq
    #[inline(always)]
    pub fn set_dis_oil_flow_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 15_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1367 }); }
        let factor = 0.06_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIS_passiveInletTempReq
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dis_passive_inlet_temp_req(&self) -> f32 {
        self.dis_passive_inlet_temp_req_raw()
    }
    
    /// Get raw value of DIS_passiveInletTempReq
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dis_passive_inlet_temp_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIS_passiveInletTempReq
    #[inline(always)]
    pub fn set_dis_passive_inlet_temp_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1367 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id557FrontThermalControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id557FrontThermalControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let dis_active_inlet_temp_req = -40_f32;
        let dis_coolant_flow_req = 0_f32;
        let dis_oil_flow_req = 0_f32;
        let dis_passive_inlet_temp_req = -40_f32;
        Id557FrontThermalControl::new(dis_active_inlet_temp_req,dis_coolant_flow_req,dis_oil_flow_req,dis_passive_inlet_temp_req).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID5D7RearThermalControl
///
/// - ID: 1495 (0x5d7)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
///
/// swapped with 557 in old firmware
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id5d7RearThermalControl {
    raw: [u8; 4],
}

impl Id5d7RearThermalControl {
    pub const MESSAGE_ID: u32 = 1495;
    
    /// Construct new ID5D7RearThermalControl from values
    pub fn new(di_active_inlet_temp_req: f32, di_coolant_flow_req: f32, di_oil_flow_req: f32, di_passive_inlet_temp_req: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_di_active_inlet_temp_req(di_active_inlet_temp_req)?;
        res.set_di_coolant_flow_req(di_coolant_flow_req)?;
        res.set_di_oil_flow_req(di_oil_flow_req)?;
        res.set_di_passive_inlet_temp_req(di_passive_inlet_temp_req)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DI_activeInletTempReq
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_active_inlet_temp_req(&self) -> f32 {
        self.di_active_inlet_temp_req_raw()
    }
    
    /// Get raw value of DI_activeInletTempReq
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_active_inlet_temp_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_activeInletTempReq
    #[inline(always)]
    pub fn set_di_active_inlet_temp_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1495 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DI_coolantFlowReq
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_coolant_flow_req(&self) -> f32 {
        self.di_coolant_flow_req_raw()
    }
    
    /// Get raw value of DI_coolantFlowReq
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_coolant_flow_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_coolantFlowReq
    #[inline(always)]
    pub fn set_di_coolant_flow_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1495 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DI_oilFlowReq
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: "LPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_oil_flow_req(&self) -> f32 {
        self.di_oil_flow_req_raw()
    }
    
    /// Get raw value of DI_oilFlowReq
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.06
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_oil_flow_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.06_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_oilFlowReq
    #[inline(always)]
    pub fn set_di_oil_flow_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 15_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1495 }); }
        let factor = 0.06_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DI_passiveInletTempReq
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_passive_inlet_temp_req(&self) -> f32 {
        self.di_passive_inlet_temp_req_raw()
    }
    
    /// Get raw value of DI_passiveInletTempReq
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_passive_inlet_temp_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DI_passiveInletTempReq
    #[inline(always)]
    pub fn set_di_passive_inlet_temp_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1495 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id5d7RearThermalControl {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id5d7RearThermalControl
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let di_active_inlet_temp_req = -40_f32;
        let di_coolant_flow_req = 0_f32;
        let di_oil_flow_req = 0_f32;
        let di_passive_inlet_temp_req = -40_f32;
        Id5d7RearThermalControl::new(di_active_inlet_temp_req,di_coolant_flow_req,di_oil_flow_req,di_passive_inlet_temp_req).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID7D5DIR_debug
///
/// - ID: 2005 (0x7d5)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
///
/// swapped with 757 in old firmware
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id7d5dirDebug {
    raw: [u8; 8],
}

impl Id7d5dirDebug {
    pub const MESSAGE_ID: u32 = 2005;
    
    /// Construct new ID7D5DIR_debug from values
    pub fn new(dir_debug_selector: u8, dir_brake_switch_nc: bool, dir_brake_switch_no: bool, dir_busbar_temp: f32, dir_control_stack: f32, dir_cpu100_hz_avg: f32, dir_cpu100_hz_min: f32, dir_cpu10_hz_avg: f32, dir_cpu10_hz_min: f32, dir_cpu10ms_min: f32, dir_cpu1_hz_avg: f32, dir_cpu1_hz_min: f32, dir_cpu1k_hz_avg: f32, dir_cpu1k_hz_min: f32, dir_cpu20k_hz_avg: f32, dir_cpu20k_hz_min: f32, dir_cpu_id_word0: u16, dir_cpu_id_word1: u16, dir_cpu_id_word2: u16, dir_cpu_id_word3: u16, dir_crc: u32, dir_current_limit: f32, dir_dc_cable_current_est: f32, dir_dc_cable_heat: f32, dir_dc_cap_temp: f32, dir_dc_link_cap_temp: f32, dir_decode_hardware_stack: f32, dir_drive_unit_odometer: f32, dir_eeprom_stack: f32, dir_flux_state: u8, dir_gain_scale: f32, dir_gate_drive_state: u8, dir_gate_drive_supply_state: u8, dir_hv_dc_cable_temp: f32, dir_hw_fault_count: u8, dir_idle_stack: f32, dir_immobilizer_stack: f32, dir_internal_angle_filt: f32, dir_llr_scale: f32, dir_lls_scale: f32, dir_lm_scale: f32, dir_load_angle: f32, dir_load_angle_margin: f32, dir_magnet_temp_est: f32, dir_module10_hz_stack: f32, dir_motor_ia: f32, dir_motor_i_aavg: f32, dir_motor_ib: f32, dir_motor_i_bavg: f32, dir_motor_ic: f32, dir_motor_type: u8, dir_motor_v: f32, dir_neg_dc_busbar_temp: f32, dir_offset_a: f32, dir_offset_b: f32, dir_oil_pump_motor_speed: f32, dir_oil_pump_phase_voltage: f32, dir_oil_pump_pressure_estimate_max: f32, dir_oil_pump_pressure_expected_min: f32, dir_pcs_temp: f32, dir_peak_flux: f32, dir_peak_i_qref: f32, dir_phase_out_busbar_temp: f32, dir_phase_out_busbar_weld_temp: f32, dir_phase_out_lug_temp: f32, dir_pos_dc_busbar_temp: f32, dir_power_stage_safe_state: u8, dir_pwm_state: u8, dir_pwr_sat_charge_current: f32, dir_pwr_sat_discharge_current: f32, dir_pwr_sat_max_bus_voltage: f32, dir_pwr_sat_max_discharge_power: f32, dir_pwr_sat_max_regen_power: f32, dir_pwr_sat_min_bus_voltage: f32, dir_resolver_cla_mia: bool, dir_resolver_common_gain: f32, dir_resolver_cos_filtered: f32, dir_resolver_cos_rms_squared: f32, dir_resolver_error_rms_squared: f32, dir_resolver_no_carrier: bool, dir_resolver_no_phase_lock: bool, dir_resolver_offset_cos: f32, dir_resolver_offset_sin: f32, dir_resolver_phase_offset: f32, dir_resolver_ready: bool, dir_resolver_sin_filtered: f32, dir_resolver_sin_rms_squared: f32, dir_rotor_flux: f32, dir_rotor_max_magnet_temp: f32, dir_rotor_offset_est: f32, dir_rotor_offset_learning_state: u8, dir_rotor_offset_mean: f32, dir_rs_scale: f32, dir_sopt_max_current_mag_sqrd: f32, dir_sopt_time_to_off: f32, dir_sopt_time_to_trip: f32, dir_sopt_trip_delay: f32, dir_ssm_state: u8, dir_stator_end_winding_temp: f32, dir_stator_flux_fdb: f32, dir_stator_flux_ref: f32, dir_stator_i_dfdb: f32, dir_stator_i_dref: f32, dir_stator_i_qfdb: f32, dir_stator_i_qref: f32, dir_stator_temp1: f32, dir_stator_temp2: f32, dir_stator_vd: f32, dir_stator_vd_filtered: f32, dir_stator_vq: f32, dir_stator_vq_filtered: f32, dir_sys_heat_power_optimal: f32, dir_system_stack: f32, dir_system_torque_command: f32, dir_tc_max_request: f32, dir_tc_min_request: f32, dir_torque_per_amp: f32, dir_tq_sat_motor_current: f32, dir_tq_sat_motor_voltage: f32, dir_tq_sat_thermal: f32, dir_tq_sat_ui_drive_torque: f32, dir_tq_sat_ui_regen_torque: f32, dir_tq_scale_differential: f32, dir_tq_scale_max_motor_speed: f32, dir_tq_scale_shift: f32, dir_uds_stack: f32, dir_usm_state: u8, dir_ve_mass_inv_raw: f32, dir_ve_res_force: f32, dir_waste_current_limit: f32, dir_xcp_stack: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_dir_debug_selector(dir_debug_selector)?;
        res.set_dir_brake_switch_nc(dir_brake_switch_nc)?;
        res.set_dir_brake_switch_no(dir_brake_switch_no)?;
        res.set_dir_busbar_temp(dir_busbar_temp)?;
        res.set_dir_control_stack(dir_control_stack)?;
        res.set_dir_cpu100_hz_avg(dir_cpu100_hz_avg)?;
        res.set_dir_cpu100_hz_min(dir_cpu100_hz_min)?;
        res.set_dir_cpu10_hz_avg(dir_cpu10_hz_avg)?;
        res.set_dir_cpu10_hz_min(dir_cpu10_hz_min)?;
        res.set_dir_cpu10ms_min(dir_cpu10ms_min)?;
        res.set_dir_cpu1_hz_avg(dir_cpu1_hz_avg)?;
        res.set_dir_cpu1_hz_min(dir_cpu1_hz_min)?;
        res.set_dir_cpu1k_hz_avg(dir_cpu1k_hz_avg)?;
        res.set_dir_cpu1k_hz_min(dir_cpu1k_hz_min)?;
        res.set_dir_cpu20k_hz_avg(dir_cpu20k_hz_avg)?;
        res.set_dir_cpu20k_hz_min(dir_cpu20k_hz_min)?;
        res.set_dir_cpu_id_word0(dir_cpu_id_word0)?;
        res.set_dir_cpu_id_word1(dir_cpu_id_word1)?;
        res.set_dir_cpu_id_word2(dir_cpu_id_word2)?;
        res.set_dir_cpu_id_word3(dir_cpu_id_word3)?;
        res.set_dir_crc(dir_crc)?;
        res.set_dir_current_limit(dir_current_limit)?;
        res.set_dir_dc_cable_current_est(dir_dc_cable_current_est)?;
        res.set_dir_dc_cable_heat(dir_dc_cable_heat)?;
        res.set_dir_dc_cap_temp(dir_dc_cap_temp)?;
        res.set_dir_dc_link_cap_temp(dir_dc_link_cap_temp)?;
        res.set_dir_decode_hardware_stack(dir_decode_hardware_stack)?;
        res.set_dir_drive_unit_odometer(dir_drive_unit_odometer)?;
        res.set_dir_eeprom_stack(dir_eeprom_stack)?;
        res.set_dir_flux_state(dir_flux_state)?;
        res.set_dir_gain_scale(dir_gain_scale)?;
        res.set_dir_gate_drive_state(dir_gate_drive_state)?;
        res.set_dir_gate_drive_supply_state(dir_gate_drive_supply_state)?;
        res.set_dir_hv_dc_cable_temp(dir_hv_dc_cable_temp)?;
        res.set_dir_hw_fault_count(dir_hw_fault_count)?;
        res.set_dir_idle_stack(dir_idle_stack)?;
        res.set_dir_immobilizer_stack(dir_immobilizer_stack)?;
        res.set_dir_internal_angle_filt(dir_internal_angle_filt)?;
        res.set_dir_llr_scale(dir_llr_scale)?;
        res.set_dir_lls_scale(dir_lls_scale)?;
        res.set_dir_lm_scale(dir_lm_scale)?;
        res.set_dir_load_angle(dir_load_angle)?;
        res.set_dir_load_angle_margin(dir_load_angle_margin)?;
        res.set_dir_magnet_temp_est(dir_magnet_temp_est)?;
        res.set_dir_module10_hz_stack(dir_module10_hz_stack)?;
        res.set_dir_motor_ia(dir_motor_ia)?;
        res.set_dir_motor_i_aavg(dir_motor_i_aavg)?;
        res.set_dir_motor_ib(dir_motor_ib)?;
        res.set_dir_motor_i_bavg(dir_motor_i_bavg)?;
        res.set_dir_motor_ic(dir_motor_ic)?;
        res.set_dir_motor_type(dir_motor_type)?;
        res.set_dir_motor_v(dir_motor_v)?;
        res.set_dir_neg_dc_busbar_temp(dir_neg_dc_busbar_temp)?;
        res.set_dir_offset_a(dir_offset_a)?;
        res.set_dir_offset_b(dir_offset_b)?;
        res.set_dir_oil_pump_motor_speed(dir_oil_pump_motor_speed)?;
        res.set_dir_oil_pump_phase_voltage(dir_oil_pump_phase_voltage)?;
        res.set_dir_oil_pump_pressure_estimate_max(dir_oil_pump_pressure_estimate_max)?;
        res.set_dir_oil_pump_pressure_expected_min(dir_oil_pump_pressure_expected_min)?;
        res.set_dir_pcs_temp(dir_pcs_temp)?;
        res.set_dir_peak_flux(dir_peak_flux)?;
        res.set_dir_peak_i_qref(dir_peak_i_qref)?;
        res.set_dir_phase_out_busbar_temp(dir_phase_out_busbar_temp)?;
        res.set_dir_phase_out_busbar_weld_temp(dir_phase_out_busbar_weld_temp)?;
        res.set_dir_phase_out_lug_temp(dir_phase_out_lug_temp)?;
        res.set_dir_pos_dc_busbar_temp(dir_pos_dc_busbar_temp)?;
        res.set_dir_power_stage_safe_state(dir_power_stage_safe_state)?;
        res.set_dir_pwm_state(dir_pwm_state)?;
        res.set_dir_pwr_sat_charge_current(dir_pwr_sat_charge_current)?;
        res.set_dir_pwr_sat_discharge_current(dir_pwr_sat_discharge_current)?;
        res.set_dir_pwr_sat_max_bus_voltage(dir_pwr_sat_max_bus_voltage)?;
        res.set_dir_pwr_sat_max_discharge_power(dir_pwr_sat_max_discharge_power)?;
        res.set_dir_pwr_sat_max_regen_power(dir_pwr_sat_max_regen_power)?;
        res.set_dir_pwr_sat_min_bus_voltage(dir_pwr_sat_min_bus_voltage)?;
        res.set_dir_resolver_cla_mia(dir_resolver_cla_mia)?;
        res.set_dir_resolver_common_gain(dir_resolver_common_gain)?;
        res.set_dir_resolver_cos_filtered(dir_resolver_cos_filtered)?;
        res.set_dir_resolver_cos_rms_squared(dir_resolver_cos_rms_squared)?;
        res.set_dir_resolver_error_rms_squared(dir_resolver_error_rms_squared)?;
        res.set_dir_resolver_no_carrier(dir_resolver_no_carrier)?;
        res.set_dir_resolver_no_phase_lock(dir_resolver_no_phase_lock)?;
        res.set_dir_resolver_offset_cos(dir_resolver_offset_cos)?;
        res.set_dir_resolver_offset_sin(dir_resolver_offset_sin)?;
        res.set_dir_resolver_phase_offset(dir_resolver_phase_offset)?;
        res.set_dir_resolver_ready(dir_resolver_ready)?;
        res.set_dir_resolver_sin_filtered(dir_resolver_sin_filtered)?;
        res.set_dir_resolver_sin_rms_squared(dir_resolver_sin_rms_squared)?;
        res.set_dir_rotor_flux(dir_rotor_flux)?;
        res.set_dir_rotor_max_magnet_temp(dir_rotor_max_magnet_temp)?;
        res.set_dir_rotor_offset_est(dir_rotor_offset_est)?;
        res.set_dir_rotor_offset_learning_state(dir_rotor_offset_learning_state)?;
        res.set_dir_rotor_offset_mean(dir_rotor_offset_mean)?;
        res.set_dir_rs_scale(dir_rs_scale)?;
        res.set_dir_sopt_max_current_mag_sqrd(dir_sopt_max_current_mag_sqrd)?;
        res.set_dir_sopt_time_to_off(dir_sopt_time_to_off)?;
        res.set_dir_sopt_time_to_trip(dir_sopt_time_to_trip)?;
        res.set_dir_sopt_trip_delay(dir_sopt_trip_delay)?;
        res.set_dir_ssm_state(dir_ssm_state)?;
        res.set_dir_stator_end_winding_temp(dir_stator_end_winding_temp)?;
        res.set_dir_stator_flux_fdb(dir_stator_flux_fdb)?;
        res.set_dir_stator_flux_ref(dir_stator_flux_ref)?;
        res.set_dir_stator_i_dfdb(dir_stator_i_dfdb)?;
        res.set_dir_stator_i_dref(dir_stator_i_dref)?;
        res.set_dir_stator_i_qfdb(dir_stator_i_qfdb)?;
        res.set_dir_stator_i_qref(dir_stator_i_qref)?;
        res.set_dir_stator_temp1(dir_stator_temp1)?;
        res.set_dir_stator_temp2(dir_stator_temp2)?;
        res.set_dir_stator_vd(dir_stator_vd)?;
        res.set_dir_stator_vd_filtered(dir_stator_vd_filtered)?;
        res.set_dir_stator_vq(dir_stator_vq)?;
        res.set_dir_stator_vq_filtered(dir_stator_vq_filtered)?;
        res.set_dir_sys_heat_power_optimal(dir_sys_heat_power_optimal)?;
        res.set_dir_system_stack(dir_system_stack)?;
        res.set_dir_system_torque_command(dir_system_torque_command)?;
        res.set_dir_tc_max_request(dir_tc_max_request)?;
        res.set_dir_tc_min_request(dir_tc_min_request)?;
        res.set_dir_torque_per_amp(dir_torque_per_amp)?;
        res.set_dir_tq_sat_motor_current(dir_tq_sat_motor_current)?;
        res.set_dir_tq_sat_motor_voltage(dir_tq_sat_motor_voltage)?;
        res.set_dir_tq_sat_thermal(dir_tq_sat_thermal)?;
        res.set_dir_tq_sat_ui_drive_torque(dir_tq_sat_ui_drive_torque)?;
        res.set_dir_tq_sat_ui_regen_torque(dir_tq_sat_ui_regen_torque)?;
        res.set_dir_tq_scale_differential(dir_tq_scale_differential)?;
        res.set_dir_tq_scale_max_motor_speed(dir_tq_scale_max_motor_speed)?;
        res.set_dir_tq_scale_shift(dir_tq_scale_shift)?;
        res.set_dir_uds_stack(dir_uds_stack)?;
        res.set_dir_usm_state(dir_usm_state)?;
        res.set_dir_ve_mass_inv_raw(dir_ve_mass_inv_raw)?;
        res.set_dir_ve_res_force(dir_ve_res_force)?;
        res.set_dir_waste_current_limit(dir_waste_current_limit)?;
        res.set_dir_xcp_stack(dir_xcp_stack)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DIR_debugSelector
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_debug_selector(&self) -> u8 {
        self.dir_debug_selector_raw()
    }
    
    /// Get raw value of DIR_debugSelector
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_debug_selector_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_debugSelector
    #[inline(always)]
    pub fn set_dir_debug_selector(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// DIR_brakeSwitchNC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_brake_switch_nc(&self) -> bool {
        self.dir_brake_switch_nc_raw()
    }
    
    /// Get raw value of DIR_brakeSwitchNC
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_brake_switch_nc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIR_brakeSwitchNC
    #[inline(always)]
    pub fn set_dir_brake_switch_nc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// DIR_brakeSwitchNO
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_brake_switch_no(&self) -> bool {
        self.dir_brake_switch_no_raw()
    }
    
    /// Get raw value of DIR_brakeSwitchNO
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_brake_switch_no_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIR_brakeSwitchNO
    #[inline(always)]
    pub fn set_dir_brake_switch_no(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// DIR_busbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_busbar_temp(&self) -> f32 {
        self.dir_busbar_temp_raw()
    }
    
    /// Get raw value of DIR_busbarTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_busbarTemp
    #[inline(always)]
    pub fn set_dir_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_controlStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_control_stack(&self) -> f32 {
        self.dir_control_stack_raw()
    }
    
    /// Get raw value of DIR_controlStack
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_control_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_controlStack
    #[inline(always)]
    pub fn set_dir_control_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu100HzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu100_hz_avg(&self) -> f32 {
        self.dir_cpu100_hz_avg_raw()
    }
    
    /// Get raw value of DIR_cpu100HzAvg
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu100_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu100HzAvg
    #[inline(always)]
    pub fn set_dir_cpu100_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu100HzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu100_hz_min(&self) -> f32 {
        self.dir_cpu100_hz_min_raw()
    }
    
    /// Get raw value of DIR_cpu100HzMin
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu100_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu100HzMin
    #[inline(always)]
    pub fn set_dir_cpu100_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu10HzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu10_hz_avg(&self) -> f32 {
        self.dir_cpu10_hz_avg_raw()
    }
    
    /// Get raw value of DIR_cpu10HzAvg
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu10_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu10HzAvg
    #[inline(always)]
    pub fn set_dir_cpu10_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu10HzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu10_hz_min(&self) -> f32 {
        self.dir_cpu10_hz_min_raw()
    }
    
    /// Get raw value of DIR_cpu10HzMin
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu10_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu10HzMin
    #[inline(always)]
    pub fn set_dir_cpu10_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu10msMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu10ms_min(&self) -> f32 {
        self.dir_cpu10ms_min_raw()
    }
    
    /// Get raw value of DIR_cpu10msMin
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu10ms_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu10msMin
    #[inline(always)]
    pub fn set_dir_cpu10ms_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu1HzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu1_hz_avg(&self) -> f32 {
        self.dir_cpu1_hz_avg_raw()
    }
    
    /// Get raw value of DIR_cpu1HzAvg
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu1_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu1HzAvg
    #[inline(always)]
    pub fn set_dir_cpu1_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu1HzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu1_hz_min(&self) -> f32 {
        self.dir_cpu1_hz_min_raw()
    }
    
    /// Get raw value of DIR_cpu1HzMin
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu1_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu1HzMin
    #[inline(always)]
    pub fn set_dir_cpu1_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu1kHzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu1k_hz_avg(&self) -> f32 {
        self.dir_cpu1k_hz_avg_raw()
    }
    
    /// Get raw value of DIR_cpu1kHzAvg
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu1k_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu1kHzAvg
    #[inline(always)]
    pub fn set_dir_cpu1k_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu1kHzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu1k_hz_min(&self) -> f32 {
        self.dir_cpu1k_hz_min_raw()
    }
    
    /// Get raw value of DIR_cpu1kHzMin
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu1k_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu1kHzMin
    #[inline(always)]
    pub fn set_dir_cpu1k_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu20kHzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu20k_hz_avg(&self) -> f32 {
        self.dir_cpu20k_hz_avg_raw()
    }
    
    /// Get raw value of DIR_cpu20kHzAvg
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu20k_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu20kHzAvg
    #[inline(always)]
    pub fn set_dir_cpu20k_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_cpu20kHzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu20k_hz_min(&self) -> f32 {
        self.dir_cpu20k_hz_min_raw()
    }
    
    /// Get raw value of DIR_cpu20kHzMin
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu20k_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_cpu20kHzMin
    #[inline(always)]
    pub fn set_dir_cpu20k_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_cpuIDWord0
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu_id_word0(&self) -> u16 {
        self.dir_cpu_id_word0_raw()
    }
    
    /// Get raw value of DIR_cpuIDWord0
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu_id_word0_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_cpuIDWord0
    #[inline(always)]
    pub fn set_dir_cpu_id_word0(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_cpuIDWord1
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu_id_word1(&self) -> u16 {
        self.dir_cpu_id_word1_raw()
    }
    
    /// Get raw value of DIR_cpuIDWord1
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu_id_word1_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_cpuIDWord1
    #[inline(always)]
    pub fn set_dir_cpu_id_word1(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_cpuIDWord2
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu_id_word2(&self) -> u16 {
        self.dir_cpu_id_word2_raw()
    }
    
    /// Get raw value of DIR_cpuIDWord2
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu_id_word2_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_cpuIDWord2
    #[inline(always)]
    pub fn set_dir_cpu_id_word2(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_cpuIDWord3
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_cpu_id_word3(&self) -> u16 {
        self.dir_cpu_id_word3_raw()
    }
    
    /// Get raw value of DIR_cpuIDWord3
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_cpu_id_word3_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIR_cpuIDWord3
    #[inline(always)]
    pub fn set_dir_cpu_id_word3(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_crc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_crc(&self) -> u32 {
        self.dir_crc_raw()
    }
    
    /// Get raw value of DIR_crc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIR_crc
    #[inline(always)]
    pub fn set_dir_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIR_currentLimit
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_current_limit(&self) -> f32 {
        self.dir_current_limit_raw()
    }
    
    /// Get raw value of DIR_currentLimit
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_currentLimit
    #[inline(always)]
    pub fn set_dir_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_dcCableCurrentEst
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_dc_cable_current_est(&self) -> f32 {
        self.dir_dc_cable_current_est_raw()
    }
    
    /// Get raw value of DIR_dcCableCurrentEst
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_dc_cable_current_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_dcCableCurrentEst
    #[inline(always)]
    pub fn set_dir_dc_cable_current_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_dcCableHeat
    ///
    /// - Min: 0
    /// - Max: 65.535
    /// - Unit: "kA2s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_dc_cable_heat(&self) -> f32 {
        self.dir_dc_cable_heat_raw()
    }
    
    /// Get raw value of DIR_dcCableHeat
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_dc_cable_heat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_dcCableHeat
    #[inline(always)]
    pub fn set_dir_dc_cable_heat(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 65.535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_dcCapTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_dc_cap_temp(&self) -> f32 {
        self.dir_dc_cap_temp_raw()
    }
    
    /// Get raw value of DIR_dcCapTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_dc_cap_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_dcCapTemp
    #[inline(always)]
    pub fn set_dir_dc_cap_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_dcLinkCapTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_dc_link_cap_temp(&self) -> f32 {
        self.dir_dc_link_cap_temp_raw()
    }
    
    /// Get raw value of DIR_dcLinkCapTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_dc_link_cap_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_dcLinkCapTemp
    #[inline(always)]
    pub fn set_dir_dc_link_cap_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_decodeHardwareStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_decode_hardware_stack(&self) -> f32 {
        self.dir_decode_hardware_stack_raw()
    }
    
    /// Get raw value of DIR_decodeHardwareStack
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_decode_hardware_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_decodeHardwareStack
    #[inline(always)]
    pub fn set_dir_decode_hardware_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_driveUnitOdometer
    ///
    /// - Min: 0
    /// - Max: 42949700000
    /// - Unit: "rev"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_drive_unit_odometer(&self) -> f32 {
        self.dir_drive_unit_odometer_raw()
    }
    
    /// Get raw value of DIR_driveUnitOdometer
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_drive_unit_odometer_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_driveUnitOdometer
    #[inline(always)]
    pub fn set_dir_drive_unit_odometer(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 42949700000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIR_eepromStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_eeprom_stack(&self) -> f32 {
        self.dir_eeprom_stack_raw()
    }
    
    /// Get raw value of DIR_eepromStack
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_eeprom_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_eepromStack
    #[inline(always)]
    pub fn set_dir_eeprom_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_fluxState
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_flux_state(&self) -> Id7d5dirDebugDirFluxState {
        match self.dir_flux_state_raw() {
            5 => Id7d5dirDebugDirFluxState::DiFluxstateEnabled,
            9 => Id7d5dirDebugDirFluxState::DiFluxstateFault,
            4 => Id7d5dirDebugDirFluxState::DiFluxstateFluxDown,
            3 => Id7d5dirDebugDirFluxState::DiFluxstateFluxUp,
            6 => Id7d5dirDebugDirFluxState::DiFluxstateIcontrol,
            2 => Id7d5dirDebugDirFluxState::DiFluxstateStandby,
            0 => Id7d5dirDebugDirFluxState::DiFluxstateStart,
            10 => Id7d5dirDebugDirFluxState::DiFluxstateStationaryWaste,
            1 => Id7d5dirDebugDirFluxState::DiFluxstateTest,
            7 => Id7d5dirDebugDirFluxState::DiFluxstateVcontrol,
            x => Id7d5dirDebugDirFluxState::Other(x),
        }
    }
    
    /// Get raw value of DIR_fluxState
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_flux_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_fluxState
    #[inline(always)]
    pub fn set_dir_flux_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DIR_gainScale
    ///
    /// - Min: 0
    /// - Max: 2.55
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_gain_scale(&self) -> f32 {
        self.dir_gain_scale_raw()
    }
    
    /// Get raw value of DIR_gainScale
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_gain_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_gainScale
    #[inline(always)]
    pub fn set_dir_gain_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.55_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_gateDriveState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_gate_drive_state(&self) -> Id7d5dirDebugDirGateDriveState {
        match self.dir_gate_drive_state_raw() {
            3 => Id7d5dirDebugDirGateDriveState::PstgGdStateConfigured,
            2 => Id7d5dirDebugDirGateDriveState::PstgGdStateConfiguring,
            0 => Id7d5dirDebugDirGateDriveState::PstgGdStateInit,
            4 => Id7d5dirDebugDirGateDriveState::PstgGdStateNotConfigured,
            1 => Id7d5dirDebugDirGateDriveState::PstgGdStateSelftest,
            x => Id7d5dirDebugDirGateDriveState::Other(x),
        }
    }
    
    /// Get raw value of DIR_gateDriveState
    ///
    /// - Start bit: 10
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_gate_drive_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_gateDriveState
    #[inline(always)]
    pub fn set_dir_gate_drive_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..13].store_le(value);
        Ok(())
    }
    
    /// DIR_gateDriveSupplyState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_gate_drive_supply_state(&self) -> Id7d5dirDebugDirGateDriveSupplyState {
        match self.dir_gate_drive_supply_state_raw() {
            0 => Id7d5dirDebugDirGateDriveSupplyState::PstgGdSupplyDown,
            3 => Id7d5dirDebugDirGateDriveSupplyState::PstgGdSupplyFalling,
            1 => Id7d5dirDebugDirGateDriveSupplyState::PstgGdSupplyRising,
            2 => Id7d5dirDebugDirGateDriveSupplyState::PstgGdSupplyUp,
            x => Id7d5dirDebugDirGateDriveSupplyState::Other(x),
        }
    }
    
    /// Get raw value of DIR_gateDriveSupplyState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_gate_drive_supply_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_gateDriveSupplyState
    #[inline(always)]
    pub fn set_dir_gate_drive_supply_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// DIR_hvDcCableTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_hv_dc_cable_temp(&self) -> f32 {
        self.dir_hv_dc_cable_temp_raw()
    }
    
    /// Get raw value of DIR_hvDcCableTemp
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_hv_dc_cable_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_hvDcCableTemp
    #[inline(always)]
    pub fn set_dir_hv_dc_cable_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_hwFaultCount
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_hw_fault_count(&self) -> u8 {
        self.dir_hw_fault_count_raw()
    }
    
    /// Get raw value of DIR_hwFaultCount
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_hw_fault_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_hwFaultCount
    #[inline(always)]
    pub fn set_dir_hw_fault_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// DIR_idleStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_idle_stack(&self) -> f32 {
        self.dir_idle_stack_raw()
    }
    
    /// Get raw value of DIR_idleStack
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_idle_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_idleStack
    #[inline(always)]
    pub fn set_dir_idle_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_immobilizerStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_immobilizer_stack(&self) -> f32 {
        self.dir_immobilizer_stack_raw()
    }
    
    /// Get raw value of DIR_immobilizerStack
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_immobilizer_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_immobilizerStack
    #[inline(always)]
    pub fn set_dir_immobilizer_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIR_internalAngleFilt
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_internal_angle_filt(&self) -> f32 {
        self.dir_internal_angle_filt_raw()
    }
    
    /// Get raw value of DIR_internalAngleFilt
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0003
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_internal_angle_filt_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.0003_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_internalAngleFilt
    #[inline(always)]
    pub fn set_dir_internal_angle_filt(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 8_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0003_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_llrScale
    ///
    /// - Min: 0
    /// - Max: 3.825
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_llr_scale(&self) -> f32 {
        self.dir_llr_scale_raw()
    }
    
    /// Get raw value of DIR_llrScale
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.015
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_llr_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.015_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_llrScale
    #[inline(always)]
    pub fn set_dir_llr_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3.825_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.015_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_llsScale
    ///
    /// - Min: 0
    /// - Max: 1.02
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_lls_scale(&self) -> f32 {
        self.dir_lls_scale_raw()
    }
    
    /// Get raw value of DIR_llsScale
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_lls_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_llsScale
    #[inline(always)]
    pub fn set_dir_lls_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.02_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_lmScale
    ///
    /// - Min: 0
    /// - Max: 1.02
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_lm_scale(&self) -> f32 {
        self.dir_lm_scale_raw()
    }
    
    /// Get raw value of DIR_lmScale
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_lm_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_lmScale
    #[inline(always)]
    pub fn set_dir_lm_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.02_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_loadAngle
    ///
    /// - Min: -4
    /// - Max: 4
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_load_angle(&self) -> f32 {
        self.dir_load_angle_raw()
    }
    
    /// Get raw value of DIR_loadAngle
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.0003
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_load_angle_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..56].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0003_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_loadAngle
    #[inline(always)]
    pub fn set_dir_load_angle(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4_f32 || 4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0003_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..56].store_le(value);
        Ok(())
    }
    
    /// DIR_loadAngleMargin
    ///
    /// - Min: -4
    /// - Max: 4
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_load_angle_margin(&self) -> f32 {
        self.dir_load_angle_margin_raw()
    }
    
    /// Get raw value of DIR_loadAngleMargin
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.0003
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_load_angle_margin_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0003_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_loadAngleMargin
    #[inline(always)]
    pub fn set_dir_load_angle_margin(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4_f32 || 4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0003_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_magnetTempEst
    ///
    /// - Min: -40
    /// - Max: 180
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_magnet_temp_est(&self) -> Id7d5dirDebugDirMagnetTempEst {
        match self.dir_magnet_temp_est_raw() {
            0 => Id7d5dirDebugDirMagnetTempEst::Sna,
            x => Id7d5dirDebugDirMagnetTempEst::Other(x),
        }
    }
    
    /// Get raw value of DIR_magnetTempEst
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_magnet_temp_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_magnetTempEst
    #[inline(always)]
    pub fn set_dir_magnet_temp_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 180_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_module10HzStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_module10_hz_stack(&self) -> f32 {
        self.dir_module10_hz_stack_raw()
    }
    
    /// Get raw value of DIR_module10HzStack
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_module10_hz_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_module10HzStack
    #[inline(always)]
    pub fn set_dir_module10_hz_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_motorIA
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_ia(&self) -> f32 {
        self.dir_motor_ia_raw()
    }
    
    /// Get raw value of DIR_motorIA
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_motor_ia_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_motorIA
    #[inline(always)]
    pub fn set_dir_motor_ia(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_motorIAavg
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_i_aavg(&self) -> f32 {
        self.dir_motor_i_aavg_raw()
    }
    
    /// Get raw value of DIR_motorIAavg
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_motor_i_aavg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_motorIAavg
    #[inline(always)]
    pub fn set_dir_motor_i_aavg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_motorIB
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_ib(&self) -> f32 {
        self.dir_motor_ib_raw()
    }
    
    /// Get raw value of DIR_motorIB
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_motor_ib_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_motorIB
    #[inline(always)]
    pub fn set_dir_motor_ib(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_motorIBavg
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_i_bavg(&self) -> f32 {
        self.dir_motor_i_bavg_raw()
    }
    
    /// Get raw value of DIR_motorIBavg
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_motor_i_bavg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_motorIBavg
    #[inline(always)]
    pub fn set_dir_motor_i_bavg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_motorIC
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_ic(&self) -> f32 {
        self.dir_motor_ic_raw()
    }
    
    /// Get raw value of DIR_motorIC
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_motor_ic_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_motorIC
    #[inline(always)]
    pub fn set_dir_motor_ic(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_motorType
    ///
    /// - Min: 0
    /// - Max: 32
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_type(&self) -> Id7d5dirDebugDirMotorType {
        match self.dir_motor_type_raw() {
            8 => Id7d5dirDebugDirMotorType::DiMotorF1a,
            10 => Id7d5dirDebugDirMotorType::DiMotorF1ac,
            11 => Id7d5dirDebugDirMotorType::DiMotorF2ab,
            12 => Id7d5dirDebugDirMotorType::DiMotorF2ac,
            13 => Id7d5dirDebugDirMotorType::DiMotorF2ad,
            14 => Id7d5dirDebugDirMotorType::DiMotorF2ae,
            26 => Id7d5dirDebugDirMotorType::DiMotorF2aeAl,
            15 => Id7d5dirDebugDirMotorType::DiMotorF2apmsrm,
            17 => Id7d5dirDebugDirMotorType::DiMotorIm100a,
            19 => Id7d5dirDebugDirMotorType::DiMotorIm100b,
            22 => Id7d5dirDebugDirMotorType::DiMotorIm130c,
            24 => Id7d5dirDebugDirMotorType::DiMotorIm130d,
            25 => Id7d5dirDebugDirMotorType::DiMotorIm130dAl,
            27 => Id7d5dirDebugDirMotorType::DiMotorIm130dAlPosco,
            20 => Id7d5dirDebugDirMotorType::DiMotorIm216a,
            3 => Id7d5dirDebugDirMotorType::DiMotorM7m3,
            4 => Id7d5dirDebugDirMotorType::DiMotorM7m4,
            5 => Id7d5dirDebugDirMotorType::DiMotorM7m5,
            7 => Id7d5dirDebugDirMotorType::DiMotorM7m6,
            6 => Id7d5dirDebugDirMotorType::DiMotorM8a,
            16 => Id7d5dirDebugDirMotorType::DiMotorPm216a,
            18 => Id7d5dirDebugDirMotorType::DiMotorPm216b,
            21 => Id7d5dirDebugDirMotorType::DiMotorPm216c,
            30 => Id7d5dirDebugDirMotorType::DiMotorPm216csr,
            31 => Id7d5dirDebugDirMotorType::DiMotorPm216csrN42,
            23 => Id7d5dirDebugDirMotorType::DiMotorPm216d,
            32 => Id7d5dirDebugDirMotorType::DiMotorPm228b,
            28 => Id7d5dirDebugDirMotorType::DiMotorPm275b,
            29 => Id7d5dirDebugDirMotorType::DiMotorPm350b,
            1 => Id7d5dirDebugDirMotorType::DiMotorRoadsterBase,
            2 => Id7d5dirDebugDirMotorType::DiMotorRoadsterSport,
            0 => Id7d5dirDebugDirMotorType::DiMotorSna,
            9 => Id7d5dirDebugDirMotorType::DiMotorSsr1a,
            x => Id7d5dirDebugDirMotorType::Other(x),
        }
    }
    
    /// Get raw value of DIR_motorType
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_motor_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_motorType
    #[inline(always)]
    pub fn set_dir_motor_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 32_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..14].store_le(value);
        Ok(())
    }
    
    /// DIR_motorV
    ///
    /// - Min: 0
    /// - Max: 1.3107
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_motor_v(&self) -> f32 {
        self.dir_motor_v_raw()
    }
    
    /// Get raw value of DIR_motorV
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.00002
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_motor_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.00002_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_motorV
    #[inline(always)]
    pub fn set_dir_motor_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.3107_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.00002_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_negDcBusbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_neg_dc_busbar_temp(&self) -> f32 {
        self.dir_neg_dc_busbar_temp_raw()
    }
    
    /// Get raw value of DIR_negDcBusbarTemp
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_neg_dc_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_negDcBusbarTemp
    #[inline(always)]
    pub fn set_dir_neg_dc_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_offsetA
    ///
    /// - Min: -12.8
    /// - Max: 12.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_offset_a(&self) -> f32 {
        self.dir_offset_a_raw()
    }
    
    /// Get raw value of DIR_offsetA
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_offset_a_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_offsetA
    #[inline(always)]
    pub fn set_dir_offset_a(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -12.8_f32 || 12.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_offsetB
    ///
    /// - Min: -12.8
    /// - Max: 12.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_offset_b(&self) -> f32 {
        self.dir_offset_b_raw()
    }
    
    /// Get raw value of DIR_offsetB
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_offset_b_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_offsetB
    #[inline(always)]
    pub fn set_dir_offset_b(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -12.8_f32 || 12.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_oilPumpMotorSpeed
    ///
    /// - Min: 0
    /// - Max: 10200
    /// - Unit: "RPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_oil_pump_motor_speed(&self) -> f32 {
        self.dir_oil_pump_motor_speed_raw()
    }
    
    /// Get raw value of DIR_oilPumpMotorSpeed
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 40
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_oil_pump_motor_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 40_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_oilPumpMotorSpeed
    #[inline(always)]
    pub fn set_dir_oil_pump_motor_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 40_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_oilPumpPhaseVoltage
    ///
    /// - Min: 0
    /// - Max: 25.4
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_oil_pump_phase_voltage(&self) -> Id7d5dirDebugDirOilPumpPhaseVoltage {
        match self.dir_oil_pump_phase_voltage_raw() {
            255 => Id7d5dirDebugDirOilPumpPhaseVoltage::Sna,
            x => Id7d5dirDebugDirOilPumpPhaseVoltage::Other(x),
        }
    }
    
    /// Get raw value of DIR_oilPumpPhaseVoltage
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_oil_pump_phase_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_oilPumpPhaseVoltage
    #[inline(always)]
    pub fn set_dir_oil_pump_phase_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_oilPumpPressureEstimateMax
    ///
    /// - Min: 0
    /// - Max: 500
    /// - Unit: "kPa"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_oil_pump_pressure_estimate_max(&self) -> Id7d5dirDebugDirOilPumpPressureEstimateMax {
        match self.dir_oil_pump_pressure_estimate_max_raw() {
            255 => Id7d5dirDebugDirOilPumpPressureEstimateMax::Sna,
            x => Id7d5dirDebugDirOilPumpPressureEstimateMax::Other(x),
        }
    }
    
    /// Get raw value of DIR_oilPumpPressureEstimateMax
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_oil_pump_pressure_estimate_max_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_oilPumpPressureEstimateMax
    #[inline(always)]
    pub fn set_dir_oil_pump_pressure_estimate_max(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_oilPumpPressureExpectedMin
    ///
    /// - Min: 0
    /// - Max: 500
    /// - Unit: "kPa"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_oil_pump_pressure_expected_min(&self) -> Id7d5dirDebugDirOilPumpPressureExpectedMin {
        match self.dir_oil_pump_pressure_expected_min_raw() {
            255 => Id7d5dirDebugDirOilPumpPressureExpectedMin::Sna,
            x => Id7d5dirDebugDirOilPumpPressureExpectedMin::Other(x),
        }
    }
    
    /// Get raw value of DIR_oilPumpPressureExpectedMin
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_oil_pump_pressure_expected_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_oilPumpPressureExpectedMin
    #[inline(always)]
    pub fn set_dir_oil_pump_pressure_expected_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_pcsTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pcs_temp(&self) -> f32 {
        self.dir_pcs_temp_raw()
    }
    
    /// Get raw value of DIR_pcsTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pcs_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pcsTemp
    #[inline(always)]
    pub fn set_dir_pcs_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_peakFlux
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_peak_flux(&self) -> f32 {
        self.dir_peak_flux_raw()
    }
    
    /// Get raw value of DIR_peakFlux
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_peak_flux_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_peakFlux
    #[inline(always)]
    pub fn set_dir_peak_flux(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_peakIQref
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_peak_i_qref(&self) -> f32 {
        self.dir_peak_i_qref_raw()
    }
    
    /// Get raw value of DIR_peakIQref
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_peak_i_qref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_peakIQref
    #[inline(always)]
    pub fn set_dir_peak_i_qref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_phaseOutBusbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_phase_out_busbar_temp(&self) -> f32 {
        self.dir_phase_out_busbar_temp_raw()
    }
    
    /// Get raw value of DIR_phaseOutBusbarTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_phase_out_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_phaseOutBusbarTemp
    #[inline(always)]
    pub fn set_dir_phase_out_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_phaseOutBusbarWeldTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_phase_out_busbar_weld_temp(&self) -> f32 {
        self.dir_phase_out_busbar_weld_temp_raw()
    }
    
    /// Get raw value of DIR_phaseOutBusbarWeldTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_phase_out_busbar_weld_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_phaseOutBusbarWeldTemp
    #[inline(always)]
    pub fn set_dir_phase_out_busbar_weld_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_phaseOutLugTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_phase_out_lug_temp(&self) -> f32 {
        self.dir_phase_out_lug_temp_raw()
    }
    
    /// Get raw value of DIR_phaseOutLugTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_phase_out_lug_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_phaseOutLugTemp
    #[inline(always)]
    pub fn set_dir_phase_out_lug_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_posDcBusbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pos_dc_busbar_temp(&self) -> f32 {
        self.dir_pos_dc_busbar_temp_raw()
    }
    
    /// Get raw value of DIR_posDcBusbarTemp
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pos_dc_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_posDcBusbarTemp
    #[inline(always)]
    pub fn set_dir_pos_dc_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIR_powerStageSafeState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_power_stage_safe_state(&self) -> Id7d5dirDebugDirPowerStageSafeState {
        match self.dir_power_stage_safe_state_raw() {
            2 => Id7d5dirDebugDirPowerStageSafeState::PstgSafestate3psHigh,
            3 => Id7d5dirDebugDirPowerStageSafeState::PstgSafestate3psLow,
            1 => Id7d5dirDebugDirPowerStageSafeState::PstgSafestateAllOff,
            0 => Id7d5dirDebugDirPowerStageSafeState::PstgSafestateNone,
            x => Id7d5dirDebugDirPowerStageSafeState::Other(x),
        }
    }
    
    /// Get raw value of DIR_powerStageSafeState
    ///
    /// - Start bit: 13
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_power_stage_safe_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_powerStageSafeState
    #[inline(always)]
    pub fn set_dir_power_stage_safe_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..15].store_le(value);
        Ok(())
    }
    
    /// DIR_pwmState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwm_state(&self) -> Id7d5dirDebugDirPwmState {
        match self.dir_pwm_state_raw() {
            1 => Id7d5dirDebugDirPwmState::PwmstateDpwm2,
            2 => Id7d5dirDebugDirPwmState::PwmstateOpwm1,
            3 => Id7d5dirDebugDirPwmState::PwmstateOpwm2,
            0 => Id7d5dirDebugDirPwmState::PwmstateSvpwm,
            x => Id7d5dirDebugDirPwmState::Other(x),
        }
    }
    
    /// Get raw value of DIR_pwmState
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_pwmState
    #[inline(always)]
    pub fn set_dir_pwm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// DIR_pwrSatChargeCurrent
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwr_sat_charge_current(&self) -> f32 {
        self.dir_pwr_sat_charge_current_raw()
    }
    
    /// Get raw value of DIR_pwrSatChargeCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwr_sat_charge_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pwrSatChargeCurrent
    #[inline(always)]
    pub fn set_dir_pwr_sat_charge_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_pwrSatDischargeCurrent
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwr_sat_discharge_current(&self) -> f32 {
        self.dir_pwr_sat_discharge_current_raw()
    }
    
    /// Get raw value of DIR_pwrSatDischargeCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwr_sat_discharge_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pwrSatDischargeCurrent
    #[inline(always)]
    pub fn set_dir_pwr_sat_discharge_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_pwrSatMaxBusVoltage
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwr_sat_max_bus_voltage(&self) -> f32 {
        self.dir_pwr_sat_max_bus_voltage_raw()
    }
    
    /// Get raw value of DIR_pwrSatMaxBusVoltage
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwr_sat_max_bus_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pwrSatMaxBusVoltage
    #[inline(always)]
    pub fn set_dir_pwr_sat_max_bus_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_pwrSatMaxDischargePower
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwr_sat_max_discharge_power(&self) -> f32 {
        self.dir_pwr_sat_max_discharge_power_raw()
    }
    
    /// Get raw value of DIR_pwrSatMaxDischargePower
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwr_sat_max_discharge_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pwrSatMaxDischargePower
    #[inline(always)]
    pub fn set_dir_pwr_sat_max_discharge_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_pwrSatMaxRegenPower
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwr_sat_max_regen_power(&self) -> f32 {
        self.dir_pwr_sat_max_regen_power_raw()
    }
    
    /// Get raw value of DIR_pwrSatMaxRegenPower
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwr_sat_max_regen_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pwrSatMaxRegenPower
    #[inline(always)]
    pub fn set_dir_pwr_sat_max_regen_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_pwrSatMinBusVoltage
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_pwr_sat_min_bus_voltage(&self) -> f32 {
        self.dir_pwr_sat_min_bus_voltage_raw()
    }
    
    /// Get raw value of DIR_pwrSatMinBusVoltage
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_pwr_sat_min_bus_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_pwrSatMinBusVoltage
    #[inline(always)]
    pub fn set_dir_pwr_sat_min_bus_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverClaMIA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_cla_mia(&self) -> bool {
        self.dir_resolver_cla_mia_raw()
    }
    
    /// Get raw value of DIR_resolverClaMIA
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_cla_mia_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIR_resolverClaMIA
    #[inline(always)]
    pub fn set_dir_resolver_cla_mia(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverCommonGain
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_common_gain(&self) -> f32 {
        self.dir_resolver_common_gain_raw()
    }
    
    /// Get raw value of DIR_resolverCommonGain
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_common_gain_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverCommonGain
    #[inline(always)]
    pub fn set_dir_resolver_common_gain(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverCosFiltered
    ///
    /// - Min: -1
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_cos_filtered(&self) -> f32 {
        self.dir_resolver_cos_filtered_raw()
    }
    
    /// Get raw value of DIR_resolverCosFiltered
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_resolver_cos_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverCosFiltered
    #[inline(always)]
    pub fn set_dir_resolver_cos_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverCosRmsSquared
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_cos_rms_squared(&self) -> f32 {
        self.dir_resolver_cos_rms_squared_raw()
    }
    
    /// Get raw value of DIR_resolverCosRmsSquared
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_cos_rms_squared_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverCosRmsSquared
    #[inline(always)]
    pub fn set_dir_resolver_cos_rms_squared(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverErrorRmsSquared
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_error_rms_squared(&self) -> f32 {
        self.dir_resolver_error_rms_squared_raw()
    }
    
    /// Get raw value of DIR_resolverErrorRmsSquared
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_error_rms_squared_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverErrorRmsSquared
    #[inline(always)]
    pub fn set_dir_resolver_error_rms_squared(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverNoCarrier
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_no_carrier(&self) -> bool {
        self.dir_resolver_no_carrier_raw()
    }
    
    /// Get raw value of DIR_resolverNoCarrier
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_no_carrier_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIR_resolverNoCarrier
    #[inline(always)]
    pub fn set_dir_resolver_no_carrier(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverNoPhaseLock
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_no_phase_lock(&self) -> bool {
        self.dir_resolver_no_phase_lock_raw()
    }
    
    /// Get raw value of DIR_resolverNoPhaseLock
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_no_phase_lock_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIR_resolverNoPhaseLock
    #[inline(always)]
    pub fn set_dir_resolver_no_phase_lock(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverOffsetCos
    ///
    /// - Min: 0
    /// - Max: 3.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_offset_cos(&self) -> f32 {
        self.dir_resolver_offset_cos_raw()
    }
    
    /// Get raw value of DIR_resolverOffsetCos
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.015
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_offset_cos_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.015_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverOffsetCos
    #[inline(always)]
    pub fn set_dir_resolver_offset_cos(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.015_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverOffsetSin
    ///
    /// - Min: 0
    /// - Max: 3.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_offset_sin(&self) -> f32 {
        self.dir_resolver_offset_sin_raw()
    }
    
    /// Get raw value of DIR_resolverOffsetSin
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.015
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_offset_sin_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.015_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverOffsetSin
    #[inline(always)]
    pub fn set_dir_resolver_offset_sin(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.015_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverPhaseOffset
    ///
    /// - Min: 7.5
    /// - Max: 32.5
    /// - Unit: "us"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_phase_offset(&self) -> f32 {
        self.dir_resolver_phase_offset_raw()
    }
    
    /// Get raw value of DIR_resolverPhaseOffset
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 7.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_phase_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 7.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverPhaseOffset
    #[inline(always)]
    pub fn set_dir_resolver_phase_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 7.5_f32 || 32.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 7.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverReady
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_ready(&self) -> bool {
        self.dir_resolver_ready_raw()
    }
    
    /// Get raw value of DIR_resolverReady
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_ready_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIR_resolverReady
    #[inline(always)]
    pub fn set_dir_resolver_ready(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverSinFiltered
    ///
    /// - Min: -1
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_sin_filtered(&self) -> f32 {
        self.dir_resolver_sin_filtered_raw()
    }
    
    /// Get raw value of DIR_resolverSinFiltered
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_resolver_sin_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverSinFiltered
    #[inline(always)]
    pub fn set_dir_resolver_sin_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_resolverSinRmsSquared
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_resolver_sin_rms_squared(&self) -> f32 {
        self.dir_resolver_sin_rms_squared_raw()
    }
    
    /// Get raw value of DIR_resolverSinRmsSquared
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_resolver_sin_rms_squared_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_resolverSinRmsSquared
    #[inline(always)]
    pub fn set_dir_resolver_sin_rms_squared(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_rotorFlux
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_rotor_flux(&self) -> f32 {
        self.dir_rotor_flux_raw()
    }
    
    /// Get raw value of DIR_rotorFlux
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_rotor_flux_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_rotorFlux
    #[inline(always)]
    pub fn set_dir_rotor_flux(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_rotorMaxMagnetTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_rotor_max_magnet_temp(&self) -> f32 {
        self.dir_rotor_max_magnet_temp_raw()
    }
    
    /// Get raw value of DIR_rotorMaxMagnetTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_rotor_max_magnet_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_rotorMaxMagnetTemp
    #[inline(always)]
    pub fn set_dir_rotor_max_magnet_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_rotorOffsetEst
    ///
    /// - Min: -20
    /// - Max: 20
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_rotor_offset_est(&self) -> f32 {
        self.dir_rotor_offset_est_raw()
    }
    
    /// Get raw value of DIR_rotorOffsetEst
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_rotor_offset_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..20].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_rotorOffsetEst
    #[inline(always)]
    pub fn set_dir_rotor_offset_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..20].store_le(value);
        Ok(())
    }
    
    /// DIR_rotorOffsetLearningState
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_rotor_offset_learning_state(&self) -> Id7d5dirDebugDirRotorOffsetLearningState {
        match self.dir_rotor_offset_learning_state_raw() {
            9 => Id7d5dirDebugDirRotorOffsetLearningState::RolNumStates,
            2 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateAccelerate,
            5 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateCorrect,
            8 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateDone,
            0 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateInit,
            4 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateMeasure,
            3 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateShift,
            6 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateVerify,
            1 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateWait,
            7 => Id7d5dirDebugDirRotorOffsetLearningState::RolStateWrite,
            x => Id7d5dirDebugDirRotorOffsetLearningState::Other(x),
        }
    }
    
    /// Get raw value of DIR_rotorOffsetLearningState
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_rotor_offset_learning_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_rotorOffsetLearningState
    #[inline(always)]
    pub fn set_dir_rotor_offset_learning_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// DIR_rotorOffsetMean
    ///
    /// - Min: -20
    /// - Max: 20
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_rotor_offset_mean(&self) -> f32 {
        self.dir_rotor_offset_mean_raw()
    }
    
    /// Get raw value of DIR_rotorOffsetMean
    ///
    /// - Start bit: 20
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_rotor_offset_mean_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_rotorOffsetMean
    #[inline(always)]
    pub fn set_dir_rotor_offset_mean(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[20..32].store_le(value);
        Ok(())
    }
    
    /// DIR_rsScale
    ///
    /// - Min: 0
    /// - Max: 2.55
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_rs_scale(&self) -> f32 {
        self.dir_rs_scale_raw()
    }
    
    /// Get raw value of DIR_rsScale
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_rs_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_rsScale
    #[inline(always)]
    pub fn set_dir_rs_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.55_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_soptMaxCurrentMagSqrd
    ///
    /// - Min: 0
    /// - Max: 6553500
    /// - Unit: "A2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_sopt_max_current_mag_sqrd(&self) -> f32 {
        self.dir_sopt_max_current_mag_sqrd_raw()
    }
    
    /// Get raw value of DIR_soptMaxCurrentMagSqrd
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 100
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_sopt_max_current_mag_sqrd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..56].load_le::<u16>();
        
        let factor = 100_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_soptMaxCurrentMagSqrd
    #[inline(always)]
    pub fn set_dir_sopt_max_current_mag_sqrd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 100_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..56].store_le(value);
        Ok(())
    }
    
    /// DIR_soptTimeToOff
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "ms"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_sopt_time_to_off(&self) -> f32 {
        self.dir_sopt_time_to_off_raw()
    }
    
    /// Get raw value of DIR_soptTimeToOff
    ///
    /// - Start bit: 24
    /// - Signal size: 11 bits
    /// - Factor: 0.05
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_sopt_time_to_off_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..35].load_le::<u16>();
        
        let factor = 0.05_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_soptTimeToOff
    #[inline(always)]
    pub fn set_dir_sopt_time_to_off(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.05_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..35].store_le(value);
        Ok(())
    }
    
    /// DIR_soptTimeToTrip
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: "ms"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_sopt_time_to_trip(&self) -> f32 {
        self.dir_sopt_time_to_trip_raw()
    }
    
    /// Get raw value of DIR_soptTimeToTrip
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.05
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_sopt_time_to_trip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.05_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_soptTimeToTrip
    #[inline(always)]
    pub fn set_dir_sopt_time_to_trip(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.05_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_soptTripDelay
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: "ms"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_sopt_trip_delay(&self) -> f32 {
        self.dir_sopt_trip_delay_raw()
    }
    
    /// Get raw value of DIR_soptTripDelay
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.05
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_sopt_trip_delay_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.05_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_soptTripDelay
    #[inline(always)]
    pub fn set_dir_sopt_trip_delay(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.05_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_ssmState
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_ssm_state(&self) -> Id7d5dirDebugDirSsmState {
        match self.dir_ssm_state_raw() {
            5 => Id7d5dirDebugDirSsmState::SsmStateAbort,
            4 => Id7d5dirDebugDirSsmState::SsmStateEnable,
            8 => Id7d5dirDebugDirSsmState::SsmStateFault,
            2 => Id7d5dirDebugDirSsmState::SsmStateIdle,
            7 => Id7d5dirDebugDirSsmState::SsmStateRetry,
            3 => Id7d5dirDebugDirSsmState::SsmStateStandby,
            0 => Id7d5dirDebugDirSsmState::SsmStateStart,
            1 => Id7d5dirDebugDirSsmState::SsmStateUnavailable,
            6 => Id7d5dirDebugDirSsmState::SsmStateWaitForRetry,
            x => Id7d5dirDebugDirSsmState::Other(x),
        }
    }
    
    /// Get raw value of DIR_ssmState
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_ssm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_ssmState
    #[inline(always)]
    pub fn set_dir_ssm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// DIR_statorEndWindingTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_end_winding_temp(&self) -> f32 {
        self.dir_stator_end_winding_temp_raw()
    }
    
    /// Get raw value of DIR_statorEndWindingTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_stator_end_winding_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorEndWindingTemp
    #[inline(always)]
    pub fn set_dir_stator_end_winding_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_statorFluxFdb
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_flux_fdb(&self) -> f32 {
        self.dir_stator_flux_fdb_raw()
    }
    
    /// Get raw value of DIR_statorFluxFdb
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_stator_flux_fdb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorFluxFdb
    #[inline(always)]
    pub fn set_dir_stator_flux_fdb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_statorFluxRef
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_flux_ref(&self) -> f32 {
        self.dir_stator_flux_ref_raw()
    }
    
    /// Get raw value of DIR_statorFluxRef
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_stator_flux_ref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorFluxRef
    #[inline(always)]
    pub fn set_dir_stator_flux_ref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_statorIDfdb
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_i_dfdb(&self) -> f32 {
        self.dir_stator_i_dfdb_raw()
    }
    
    /// Get raw value of DIR_statorIDfdb
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_i_dfdb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorIDfdb
    #[inline(always)]
    pub fn set_dir_stator_i_dfdb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_statorIDref
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_i_dref(&self) -> f32 {
        self.dir_stator_i_dref_raw()
    }
    
    /// Get raw value of DIR_statorIDref
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_i_dref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorIDref
    #[inline(always)]
    pub fn set_dir_stator_i_dref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_statorIQfdb
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_i_qfdb(&self) -> f32 {
        self.dir_stator_i_qfdb_raw()
    }
    
    /// Get raw value of DIR_statorIQfdb
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_i_qfdb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorIQfdb
    #[inline(always)]
    pub fn set_dir_stator_i_qfdb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_statorIQref
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_i_qref(&self) -> f32 {
        self.dir_stator_i_qref_raw()
    }
    
    /// Get raw value of DIR_statorIQref
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_i_qref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorIQref
    #[inline(always)]
    pub fn set_dir_stator_i_qref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_statorTemp1
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_temp1(&self) -> f32 {
        self.dir_stator_temp1_raw()
    }
    
    /// Get raw value of DIR_statorTemp1
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_stator_temp1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorTemp1
    #[inline(always)]
    pub fn set_dir_stator_temp1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_statorTemp2
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_temp2(&self) -> f32 {
        self.dir_stator_temp2_raw()
    }
    
    /// Get raw value of DIR_statorTemp2
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_stator_temp2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorTemp2
    #[inline(always)]
    pub fn set_dir_stator_temp2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_statorVD
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_vd(&self) -> f32 {
        self.dir_stator_vd_raw()
    }
    
    /// Get raw value of DIR_statorVD
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_vd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorVD
    #[inline(always)]
    pub fn set_dir_stator_vd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_statorVDFiltered
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_vd_filtered(&self) -> f32 {
        self.dir_stator_vd_filtered_raw()
    }
    
    /// Get raw value of DIR_statorVDFiltered
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_vd_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorVDFiltered
    #[inline(always)]
    pub fn set_dir_stator_vd_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_statorVQ
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_vq(&self) -> f32 {
        self.dir_stator_vq_raw()
    }
    
    /// Get raw value of DIR_statorVQ
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_vq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorVQ
    #[inline(always)]
    pub fn set_dir_stator_vq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIR_statorVQFiltered
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_stator_vq_filtered(&self) -> f32 {
        self.dir_stator_vq_filtered_raw()
    }
    
    /// Get raw value of DIR_statorVQFiltered
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_stator_vq_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_statorVQFiltered
    #[inline(always)]
    pub fn set_dir_stator_vq_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIR_sysHeatPowerOptimal
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_sys_heat_power_optimal(&self) -> f32 {
        self.dir_sys_heat_power_optimal_raw()
    }
    
    /// Get raw value of DIR_sysHeatPowerOptimal
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.08
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_sys_heat_power_optimal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.08_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_sysHeatPowerOptimal
    #[inline(always)]
    pub fn set_dir_sys_heat_power_optimal(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.08_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_systemStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_system_stack(&self) -> f32 {
        self.dir_system_stack_raw()
    }
    
    /// Get raw value of DIR_systemStack
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_system_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_systemStack
    #[inline(always)]
    pub fn set_dir_system_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_systemTorqueCommand
    ///
    /// - Min: -1146.88
    /// - Max: 1146.85
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_system_torque_command(&self) -> f32 {
        self.dir_system_torque_command_raw()
    }
    
    /// Get raw value of DIR_systemTorqueCommand
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.035
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_system_torque_command_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.035_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_systemTorqueCommand
    #[inline(always)]
    pub fn set_dir_system_torque_command(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1146.88_f32 || 1146.85_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.035_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_tcMaxRequest
    ///
    /// - Min: 0
    /// - Max: 1275
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tc_max_request(&self) -> Id7d5dirDebugDirTcMaxRequest {
        match self.dir_tc_max_request_raw() {
            255 => Id7d5dirDebugDirTcMaxRequest::Sna,
            x => Id7d5dirDebugDirTcMaxRequest::Other(x),
        }
    }
    
    /// Get raw value of DIR_tcMaxRequest
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tc_max_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tcMaxRequest
    #[inline(always)]
    pub fn set_dir_tc_max_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1275_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIR_tcMinRequest
    ///
    /// - Min: 0
    /// - Max: 1275
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tc_min_request(&self) -> Id7d5dirDebugDirTcMinRequest {
        match self.dir_tc_min_request_raw() {
            255 => Id7d5dirDebugDirTcMinRequest::Sna,
            x => Id7d5dirDebugDirTcMinRequest::Other(x),
        }
    }
    
    /// Get raw value of DIR_tcMinRequest
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tc_min_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tcMinRequest
    #[inline(always)]
    pub fn set_dir_tc_min_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1275_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIR_torquePerAmp
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Nm/A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_torque_per_amp(&self) -> f32 {
        self.dir_torque_per_amp_raw()
    }
    
    /// Get raw value of DIR_torquePerAmp
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_torque_per_amp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_torquePerAmp
    #[inline(always)]
    pub fn set_dir_torque_per_amp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_tqSatMotorCurrent
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_sat_motor_current(&self) -> f32 {
        self.dir_tq_sat_motor_current_raw()
    }
    
    /// Get raw value of DIR_tqSatMotorCurrent
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_sat_motor_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqSatMotorCurrent
    #[inline(always)]
    pub fn set_dir_tq_sat_motor_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_tqSatMotorVoltage
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_sat_motor_voltage(&self) -> f32 {
        self.dir_tq_sat_motor_voltage_raw()
    }
    
    /// Get raw value of DIR_tqSatMotorVoltage
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_sat_motor_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqSatMotorVoltage
    #[inline(always)]
    pub fn set_dir_tq_sat_motor_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_tqSatThermal
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_sat_thermal(&self) -> f32 {
        self.dir_tq_sat_thermal_raw()
    }
    
    /// Get raw value of DIR_tqSatThermal
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_sat_thermal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqSatThermal
    #[inline(always)]
    pub fn set_dir_tq_sat_thermal(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_tqSatUiDriveTorque
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_sat_ui_drive_torque(&self) -> f32 {
        self.dir_tq_sat_ui_drive_torque_raw()
    }
    
    /// Get raw value of DIR_tqSatUiDriveTorque
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_sat_ui_drive_torque_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqSatUiDriveTorque
    #[inline(always)]
    pub fn set_dir_tq_sat_ui_drive_torque(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIR_tqSatUiRegenTorque
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_sat_ui_regen_torque(&self) -> f32 {
        self.dir_tq_sat_ui_regen_torque_raw()
    }
    
    /// Get raw value of DIR_tqSatUiRegenTorque
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_sat_ui_regen_torque_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqSatUiRegenTorque
    #[inline(always)]
    pub fn set_dir_tq_sat_ui_regen_torque(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_tqScaleDifferential
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_scale_differential(&self) -> f32 {
        self.dir_tq_scale_differential_raw()
    }
    
    /// Get raw value of DIR_tqScaleDifferential
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_scale_differential_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqScaleDifferential
    #[inline(always)]
    pub fn set_dir_tq_scale_differential(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIR_tqScaleMaxMotorSpeed
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_scale_max_motor_speed(&self) -> f32 {
        self.dir_tq_scale_max_motor_speed_raw()
    }
    
    /// Get raw value of DIR_tqScaleMaxMotorSpeed
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_scale_max_motor_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqScaleMaxMotorSpeed
    #[inline(always)]
    pub fn set_dir_tq_scale_max_motor_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIR_tqScaleShift
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_tq_scale_shift(&self) -> f32 {
        self.dir_tq_scale_shift_raw()
    }
    
    /// Get raw value of DIR_tqScaleShift
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_tq_scale_shift_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_tqScaleShift
    #[inline(always)]
    pub fn set_dir_tq_scale_shift(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIR_udsStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_uds_stack(&self) -> f32 {
        self.dir_uds_stack_raw()
    }
    
    /// Get raw value of DIR_udsStack
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_uds_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_udsStack
    #[inline(always)]
    pub fn set_dir_uds_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIR_usmState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_usm_state(&self) -> Id7d5dirDebugDirUsmState {
        match self.dir_usm_state_raw() {
            3 => Id7d5dirDebugDirUsmState::UsmStateAbort,
            4 => Id7d5dirDebugDirUsmState::UsmStateEnable,
            5 => Id7d5dirDebugDirUsmState::UsmStateFault,
            2 => Id7d5dirDebugDirUsmState::UsmStateRetry,
            1 => Id7d5dirDebugDirUsmState::UsmStateStandby,
            0 => Id7d5dirDebugDirUsmState::UsmStateStart,
            6 => Id7d5dirDebugDirUsmState::UsmStateUnavailable,
            7 => Id7d5dirDebugDirUsmState::UsmStateWaitForRetry,
            x => Id7d5dirDebugDirUsmState::Other(x),
        }
    }
    
    /// Get raw value of DIR_usmState
    ///
    /// - Start bit: 12
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_usm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIR_usmState
    #[inline(always)]
    pub fn set_dir_usm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..15].store_le(value);
        Ok(())
    }
    
    /// DIR_veMassInvRaw
    ///
    /// - Min: 0.0001
    /// - Max: 0.0005
    /// - Unit: "1/kg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_ve_mass_inv_raw(&self) -> f32 {
        self.dir_ve_mass_inv_raw_raw()
    }
    
    /// Get raw value of DIR_veMassInvRaw
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.0000001
    /// - Offset: 0.0001
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_ve_mass_inv_raw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..20].load_le::<u16>();
        
        let factor = 0.0000001_f32;
        let offset = 0.0001_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_veMassInvRaw
    #[inline(always)]
    pub fn set_dir_ve_mass_inv_raw(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0.0001_f32 || 0.0005_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0000001_f32;
        let offset = 0.0001_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..20].store_le(value);
        Ok(())
    }
    
    /// DIR_veResForce
    ///
    /// - Min: -1.024
    /// - Max: 1.0235
    /// - Unit: "G"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_ve_res_force(&self) -> f32 {
        self.dir_ve_res_force_raw()
    }
    
    /// Get raw value of DIR_veResForce
    ///
    /// - Start bit: 20
    /// - Signal size: 12 bits
    /// - Factor: 0.0005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dir_ve_res_force_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_veResForce
    #[inline(always)]
    pub fn set_dir_ve_res_force(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.024_f32 || 1.0235_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.0005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[20..32].store_le(value);
        Ok(())
    }
    
    /// DIR_wasteCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_waste_current_limit(&self) -> f32 {
        self.dir_waste_current_limit_raw()
    }
    
    /// Get raw value of DIR_wasteCurrentLimit
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_waste_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_wasteCurrentLimit
    #[inline(always)]
    pub fn set_dir_waste_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIR_xcpStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dir_xcp_stack(&self) -> f32 {
        self.dir_xcp_stack_raw()
    }
    
    /// Get raw value of DIR_xcpStack
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dir_xcp_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIR_xcpStack
    #[inline(always)]
    pub fn set_dir_xcp_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 2005 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id7d5dirDebug {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id7d5dirDebug
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let dir_debug_selector = u.int_in_range(0..=255)?;
        let dir_brake_switch_nc = u.int_in_range(0..=1)? == 1;
        let dir_brake_switch_no = u.int_in_range(0..=1)? == 1;
        let dir_busbar_temp = -40_f32;
        let dir_control_stack = 0_f32;
        let dir_cpu100_hz_avg = 0_f32;
        let dir_cpu100_hz_min = 0_f32;
        let dir_cpu10_hz_avg = 0_f32;
        let dir_cpu10_hz_min = 0_f32;
        let dir_cpu10ms_min = 0_f32;
        let dir_cpu1_hz_avg = 0_f32;
        let dir_cpu1_hz_min = 0_f32;
        let dir_cpu1k_hz_avg = 0_f32;
        let dir_cpu1k_hz_min = 0_f32;
        let dir_cpu20k_hz_avg = 0_f32;
        let dir_cpu20k_hz_min = 0_f32;
        let dir_cpu_id_word0 = u.int_in_range(0..=65535)?;
        let dir_cpu_id_word1 = u.int_in_range(0..=65535)?;
        let dir_cpu_id_word2 = u.int_in_range(0..=65535)?;
        let dir_cpu_id_word3 = u.int_in_range(0..=65535)?;
        let dir_crc = u.int_in_range(0..=4294970000)?;
        let dir_current_limit = 0_f32;
        let dir_dc_cable_current_est = -3276.8_f32;
        let dir_dc_cable_heat = 0_f32;
        let dir_dc_cap_temp = -40_f32;
        let dir_dc_link_cap_temp = -40_f32;
        let dir_decode_hardware_stack = 0_f32;
        let dir_drive_unit_odometer = 0_f32;
        let dir_eeprom_stack = 0_f32;
        let dir_flux_state = u.int_in_range(0..=10)?;
        let dir_gain_scale = 0_f32;
        let dir_gate_drive_state = u.int_in_range(0..=4)?;
        let dir_gate_drive_supply_state = u.int_in_range(0..=3)?;
        let dir_hv_dc_cable_temp = -40_f32;
        let dir_hw_fault_count = u.int_in_range(0..=15)?;
        let dir_idle_stack = 0_f32;
        let dir_immobilizer_stack = 0_f32;
        let dir_internal_angle_filt = 0_f32;
        let dir_llr_scale = 0_f32;
        let dir_lls_scale = 0_f32;
        let dir_lm_scale = 0_f32;
        let dir_load_angle = -4_f32;
        let dir_load_angle_margin = -4_f32;
        let dir_magnet_temp_est = -40_f32;
        let dir_module10_hz_stack = 0_f32;
        let dir_motor_ia = 0_f32;
        let dir_motor_i_aavg = -3276.8_f32;
        let dir_motor_ib = 0_f32;
        let dir_motor_i_bavg = -3276.8_f32;
        let dir_motor_ic = 0_f32;
        let dir_motor_type = u.int_in_range(0..=32)?;
        let dir_motor_v = 0_f32;
        let dir_neg_dc_busbar_temp = -40_f32;
        let dir_offset_a = -12.8_f32;
        let dir_offset_b = -12.8_f32;
        let dir_oil_pump_motor_speed = 0_f32;
        let dir_oil_pump_phase_voltage = 0_f32;
        let dir_oil_pump_pressure_estimate_max = 0_f32;
        let dir_oil_pump_pressure_expected_min = 0_f32;
        let dir_pcs_temp = -40_f32;
        let dir_peak_flux = 0_f32;
        let dir_peak_i_qref = 0_f32;
        let dir_phase_out_busbar_temp = -40_f32;
        let dir_phase_out_busbar_weld_temp = -40_f32;
        let dir_phase_out_lug_temp = -40_f32;
        let dir_pos_dc_busbar_temp = -40_f32;
        let dir_power_stage_safe_state = u.int_in_range(0..=3)?;
        let dir_pwm_state = u.int_in_range(0..=3)?;
        let dir_pwr_sat_charge_current = 0_f32;
        let dir_pwr_sat_discharge_current = 0_f32;
        let dir_pwr_sat_max_bus_voltage = 0_f32;
        let dir_pwr_sat_max_discharge_power = 0_f32;
        let dir_pwr_sat_max_regen_power = 0_f32;
        let dir_pwr_sat_min_bus_voltage = 0_f32;
        let dir_resolver_cla_mia = u.int_in_range(0..=1)? == 1;
        let dir_resolver_common_gain = 0_f32;
        let dir_resolver_cos_filtered = -1_f32;
        let dir_resolver_cos_rms_squared = 0_f32;
        let dir_resolver_error_rms_squared = 0_f32;
        let dir_resolver_no_carrier = u.int_in_range(0..=1)? == 1;
        let dir_resolver_no_phase_lock = u.int_in_range(0..=1)? == 1;
        let dir_resolver_offset_cos = 0_f32;
        let dir_resolver_offset_sin = 0_f32;
        let dir_resolver_phase_offset = 7.5_f32;
        let dir_resolver_ready = u.int_in_range(0..=1)? == 1;
        let dir_resolver_sin_filtered = -1_f32;
        let dir_resolver_sin_rms_squared = 0_f32;
        let dir_rotor_flux = 0_f32;
        let dir_rotor_max_magnet_temp = -40_f32;
        let dir_rotor_offset_est = -20_f32;
        let dir_rotor_offset_learning_state = u.int_in_range(0..=9)?;
        let dir_rotor_offset_mean = -20_f32;
        let dir_rs_scale = 0_f32;
        let dir_sopt_max_current_mag_sqrd = 0_f32;
        let dir_sopt_time_to_off = 0_f32;
        let dir_sopt_time_to_trip = 0_f32;
        let dir_sopt_trip_delay = 0_f32;
        let dir_ssm_state = u.int_in_range(0..=8)?;
        let dir_stator_end_winding_temp = -40_f32;
        let dir_stator_flux_fdb = 0_f32;
        let dir_stator_flux_ref = 0_f32;
        let dir_stator_i_dfdb = -3276.8_f32;
        let dir_stator_i_dref = -3276.8_f32;
        let dir_stator_i_qfdb = -3276.8_f32;
        let dir_stator_i_qref = -3276.8_f32;
        let dir_stator_temp1 = -40_f32;
        let dir_stator_temp2 = -40_f32;
        let dir_stator_vd = -1.31072_f32;
        let dir_stator_vd_filtered = -1.31072_f32;
        let dir_stator_vq = -1.31072_f32;
        let dir_stator_vq_filtered = -1.31072_f32;
        let dir_sys_heat_power_optimal = 0_f32;
        let dir_system_stack = 0_f32;
        let dir_system_torque_command = -1146.88_f32;
        let dir_tc_max_request = 0_f32;
        let dir_tc_min_request = 0_f32;
        let dir_torque_per_amp = 0_f32;
        let dir_tq_sat_motor_current = 0_f32;
        let dir_tq_sat_motor_voltage = 0_f32;
        let dir_tq_sat_thermal = 0_f32;
        let dir_tq_sat_ui_drive_torque = 0_f32;
        let dir_tq_sat_ui_regen_torque = 0_f32;
        let dir_tq_scale_differential = 0_f32;
        let dir_tq_scale_max_motor_speed = 0_f32;
        let dir_tq_scale_shift = 0_f32;
        let dir_uds_stack = 0_f32;
        let dir_usm_state = u.int_in_range(0..=7)?;
        let dir_ve_mass_inv_raw = 0.0001_f32;
        let dir_ve_res_force = -1.024_f32;
        let dir_waste_current_limit = 0_f32;
        let dir_xcp_stack = 0_f32;
        Id7d5dirDebug::new(dir_debug_selector,dir_brake_switch_nc,dir_brake_switch_no,dir_busbar_temp,dir_control_stack,dir_cpu100_hz_avg,dir_cpu100_hz_min,dir_cpu10_hz_avg,dir_cpu10_hz_min,dir_cpu10ms_min,dir_cpu1_hz_avg,dir_cpu1_hz_min,dir_cpu1k_hz_avg,dir_cpu1k_hz_min,dir_cpu20k_hz_avg,dir_cpu20k_hz_min,dir_cpu_id_word0,dir_cpu_id_word1,dir_cpu_id_word2,dir_cpu_id_word3,dir_crc,dir_current_limit,dir_dc_cable_current_est,dir_dc_cable_heat,dir_dc_cap_temp,dir_dc_link_cap_temp,dir_decode_hardware_stack,dir_drive_unit_odometer,dir_eeprom_stack,dir_flux_state,dir_gain_scale,dir_gate_drive_state,dir_gate_drive_supply_state,dir_hv_dc_cable_temp,dir_hw_fault_count,dir_idle_stack,dir_immobilizer_stack,dir_internal_angle_filt,dir_llr_scale,dir_lls_scale,dir_lm_scale,dir_load_angle,dir_load_angle_margin,dir_magnet_temp_est,dir_module10_hz_stack,dir_motor_ia,dir_motor_i_aavg,dir_motor_ib,dir_motor_i_bavg,dir_motor_ic,dir_motor_type,dir_motor_v,dir_neg_dc_busbar_temp,dir_offset_a,dir_offset_b,dir_oil_pump_motor_speed,dir_oil_pump_phase_voltage,dir_oil_pump_pressure_estimate_max,dir_oil_pump_pressure_expected_min,dir_pcs_temp,dir_peak_flux,dir_peak_i_qref,dir_phase_out_busbar_temp,dir_phase_out_busbar_weld_temp,dir_phase_out_lug_temp,dir_pos_dc_busbar_temp,dir_power_stage_safe_state,dir_pwm_state,dir_pwr_sat_charge_current,dir_pwr_sat_discharge_current,dir_pwr_sat_max_bus_voltage,dir_pwr_sat_max_discharge_power,dir_pwr_sat_max_regen_power,dir_pwr_sat_min_bus_voltage,dir_resolver_cla_mia,dir_resolver_common_gain,dir_resolver_cos_filtered,dir_resolver_cos_rms_squared,dir_resolver_error_rms_squared,dir_resolver_no_carrier,dir_resolver_no_phase_lock,dir_resolver_offset_cos,dir_resolver_offset_sin,dir_resolver_phase_offset,dir_resolver_ready,dir_resolver_sin_filtered,dir_resolver_sin_rms_squared,dir_rotor_flux,dir_rotor_max_magnet_temp,dir_rotor_offset_est,dir_rotor_offset_learning_state,dir_rotor_offset_mean,dir_rs_scale,dir_sopt_max_current_mag_sqrd,dir_sopt_time_to_off,dir_sopt_time_to_trip,dir_sopt_trip_delay,dir_ssm_state,dir_stator_end_winding_temp,dir_stator_flux_fdb,dir_stator_flux_ref,dir_stator_i_dfdb,dir_stator_i_dref,dir_stator_i_qfdb,dir_stator_i_qref,dir_stator_temp1,dir_stator_temp2,dir_stator_vd,dir_stator_vd_filtered,dir_stator_vq,dir_stator_vq_filtered,dir_sys_heat_power_optimal,dir_system_stack,dir_system_torque_command,dir_tc_max_request,dir_tc_min_request,dir_torque_per_amp,dir_tq_sat_motor_current,dir_tq_sat_motor_voltage,dir_tq_sat_thermal,dir_tq_sat_ui_drive_torque,dir_tq_sat_ui_regen_torque,dir_tq_scale_differential,dir_tq_scale_max_motor_speed,dir_tq_scale_shift,dir_uds_stack,dir_usm_state,dir_ve_mass_inv_raw,dir_ve_res_force,dir_waste_current_limit,dir_xcp_stack).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DIR_fluxState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirFluxState {
    DiFluxstateEnabled,
    DiFluxstateFault,
    DiFluxstateFluxDown,
    DiFluxstateFluxUp,
    DiFluxstateIcontrol,
    DiFluxstateStandby,
    DiFluxstateStart,
    DiFluxstateStationaryWaste,
    DiFluxstateTest,
    DiFluxstateVcontrol,
    Other(u8),
}
/// Defined values for DIR_gateDriveState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirGateDriveState {
    PstgGdStateConfigured,
    PstgGdStateConfiguring,
    PstgGdStateInit,
    PstgGdStateNotConfigured,
    PstgGdStateSelftest,
    Other(u8),
}
/// Defined values for DIR_gateDriveSupplyState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirGateDriveSupplyState {
    PstgGdSupplyDown,
    PstgGdSupplyFalling,
    PstgGdSupplyRising,
    PstgGdSupplyUp,
    Other(u8),
}
/// Defined values for DIR_magnetTempEst
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirMagnetTempEst {
    Sna,
    Other(f32),
}
/// Defined values for DIR_motorType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirMotorType {
    DiMotorF1a,
    DiMotorF1ac,
    DiMotorF2ab,
    DiMotorF2ac,
    DiMotorF2ad,
    DiMotorF2ae,
    DiMotorF2aeAl,
    DiMotorF2apmsrm,
    DiMotorIm100a,
    DiMotorIm100b,
    DiMotorIm130c,
    DiMotorIm130d,
    DiMotorIm130dAl,
    DiMotorIm130dAlPosco,
    DiMotorIm216a,
    DiMotorM7m3,
    DiMotorM7m4,
    DiMotorM7m5,
    DiMotorM7m6,
    DiMotorM8a,
    DiMotorPm216a,
    DiMotorPm216b,
    DiMotorPm216c,
    DiMotorPm216csr,
    DiMotorPm216csrN42,
    DiMotorPm216d,
    DiMotorPm228b,
    DiMotorPm275b,
    DiMotorPm350b,
    DiMotorRoadsterBase,
    DiMotorRoadsterSport,
    DiMotorSna,
    DiMotorSsr1a,
    Other(u8),
}
/// Defined values for DIR_oilPumpPhaseVoltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirOilPumpPhaseVoltage {
    Sna,
    Other(f32),
}
/// Defined values for DIR_oilPumpPressureEstimateMax
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirOilPumpPressureEstimateMax {
    Sna,
    Other(f32),
}
/// Defined values for DIR_oilPumpPressureExpectedMin
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirOilPumpPressureExpectedMin {
    Sna,
    Other(f32),
}
/// Defined values for DIR_powerStageSafeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirPowerStageSafeState {
    PstgSafestate3psHigh,
    PstgSafestate3psLow,
    PstgSafestateAllOff,
    PstgSafestateNone,
    Other(u8),
}
/// Defined values for DIR_pwmState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirPwmState {
    PwmstateDpwm2,
    PwmstateOpwm1,
    PwmstateOpwm2,
    PwmstateSvpwm,
    Other(u8),
}
/// Defined values for DIR_rotorOffsetLearningState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirRotorOffsetLearningState {
    RolNumStates,
    RolStateAccelerate,
    RolStateCorrect,
    RolStateDone,
    RolStateInit,
    RolStateMeasure,
    RolStateShift,
    RolStateVerify,
    RolStateWait,
    RolStateWrite,
    Other(u8),
}
/// Defined values for DIR_ssmState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirSsmState {
    SsmStateAbort,
    SsmStateEnable,
    SsmStateFault,
    SsmStateIdle,
    SsmStateRetry,
    SsmStateStandby,
    SsmStateStart,
    SsmStateUnavailable,
    SsmStateWaitForRetry,
    Other(u8),
}
/// Defined values for DIR_tcMaxRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirTcMaxRequest {
    Sna,
    Other(f32),
}
/// Defined values for DIR_tcMinRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirTcMinRequest {
    Sna,
    Other(f32),
}
/// Defined values for DIR_usmState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id7d5dirDebugDirUsmState {
    UsmStateAbort,
    UsmStateEnable,
    UsmStateFault,
    UsmStateRetry,
    UsmStateStandby,
    UsmStateStart,
    UsmStateUnavailable,
    UsmStateWaitForRetry,
    Other(u8),
}

/// ID757DIF_debug
///
/// - ID: 1879 (0x757)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
///
/// swapped with 7D5 in old firmware
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id757difDebug {
    raw: [u8; 8],
}

impl Id757difDebug {
    pub const MESSAGE_ID: u32 = 1879;
    
    /// Construct new ID757DIF_debug from values
    pub fn new(dif_debug_selector: u8, dif_brake_switch_nc: bool, dif_brake_switch_no: bool, dif_busbar_temp: f32, dif_control_stack: f32, dif_cpu100_hz_avg: f32, dif_cpu100_hz_min: f32, dif_cpu10_hz_avg: f32, dif_cpu10_hz_min: f32, dif_cpu10ms_min: f32, dif_cpu1_hz_avg: f32, dif_cpu1_hz_min: f32, dif_cpu1k_hz_avg: f32, dif_cpu1k_hz_min: f32, dif_cpu20k_hz_avg: f32, dif_cpu20k_hz_min: f32, dif_cpu_id_word0: u16, dif_cpu_id_word1: u16, dif_cpu_id_word2: u16, dif_cpu_id_word3: u16, dif_crc: u32, dif_current_limit: f32, dif_dc_cable_current_est: f32, dif_dc_cable_heat: f32, dif_dc_cap_temp: f32, dif_dc_link_cap_temp: f32, dif_decode_hardware_stack: f32, dif_drive_unit_odometer: f32, dif_eeprom_stack: f32, dif_flux_state: u8, dif_gain_scale: f32, dif_gate_drive_state: u8, dif_gate_drive_supply_state: u8, dif_hv_dc_cable_temp: f32, dif_hw_fault_count: u8, dif_idle_stack: f32, dif_immobilizer_stack: f32, dif_internal_angle_filt: f32, dif_llr_scale: f32, dif_lls_scale: f32, dif_lm_scale: f32, dif_load_angle: f32, dif_load_angle_margin: f32, dif_magnet_temp_est: f32, dif_module10_hz_stack: f32, dif_motor_ia: f32, dif_motor_i_aavg: f32, dif_motor_ib: f32, dif_motor_i_bavg: f32, dif_motor_ic: f32, dif_motor_type: u8, dif_motor_v: f32, dif_neg_dc_busbar_temp: f32, dif_offset_a: f32, dif_offset_b: f32, dif_oil_pump_motor_speed: f32, dif_oil_pump_phase_voltage: f32, dif_oil_pump_pressure_estimate_max: f32, dif_oil_pump_pressure_expected_min: f32, dif_pcs_temp: f32, dif_peak_flux: f32, dif_peak_i_qref: f32, dif_phase_out_busbar_temp: f32, dif_phase_out_busbar_weld_temp: f32, dif_phase_out_lug_temp: f32, dif_pos_dc_busbar_temp: f32, dif_power_stage_safe_state: u8, dif_pwm_state: u8, dif_pwr_sat_charge_current: f32, dif_pwr_sat_discharge_current: f32, dif_pwr_sat_max_bus_voltage: f32, dif_pwr_sat_max_discharge_power: f32, dif_pwr_sat_max_regen_power: f32, dif_pwr_sat_min_bus_voltage: f32, dif_resolver_cla_mia: bool, dif_resolver_common_gain: f32, dif_resolver_cos_filtered: f32, dif_resolver_cos_rms_squared: f32, dif_resolver_error_rms_squared: f32, dif_resolver_no_carrier: bool, dif_resolver_no_phase_lock: bool, dif_resolver_offset_cos: f32, dif_resolver_offset_sin: f32, dif_resolver_phase_offset: f32, dif_resolver_ready: bool, dif_resolver_sin_filtered: f32, dif_resolver_sin_rms_squared: f32, dif_rotor_flux: f32, dif_rotor_max_magnet_temp: f32, dif_rotor_offset_est: f32, dif_rotor_offset_learning_state: u8, dif_rotor_offset_mean: f32, dif_rs_scale: f32, dif_sopt_max_current_mag_sqrd: f32, dif_sopt_time_to_off: f32, dif_sopt_time_to_trip: f32, dif_sopt_trip_delay: f32, dif_ssm_state: u8, dif_stator_end_winding_temp: f32, dif_stator_flux_fdb: f32, dif_stator_flux_ref: f32, dif_stator_i_dfdb: f32, dif_stator_i_dref: f32, dif_stator_i_qfdb: f32, dif_stator_i_qref: f32, dif_stator_temp1: f32, dif_stator_temp2: f32, dif_stator_vd: f32, dif_stator_vd_filtered: f32, dif_stator_vq: f32, dif_stator_vq_filtered: f32, dif_sys_heat_power_optimal: f32, dif_system_stack: f32, dif_system_torque_command: f32, dif_tc_max_request: f32, dif_tc_min_request: f32, dif_torque_per_amp: f32, dif_tq_sat_motor_current: f32, dif_tq_sat_motor_voltage: f32, dif_tq_sat_thermal: f32, dif_tq_sat_ui_drive_torque: f32, dif_tq_sat_ui_regen_torque: f32, dif_tq_scale_differential: f32, dif_tq_scale_max_motor_speed: f32, dif_tq_scale_shift: f32, dif_uds_stack: f32, dif_usm_state: u8, dif_ve_mass_inv_raw: f32, dif_ve_res_force: f32, dif_waste_current_limit: f32, dif_xcp_stack: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_dif_debug_selector(dif_debug_selector)?;
        res.set_dif_brake_switch_nc(dif_brake_switch_nc)?;
        res.set_dif_brake_switch_no(dif_brake_switch_no)?;
        res.set_dif_busbar_temp(dif_busbar_temp)?;
        res.set_dif_control_stack(dif_control_stack)?;
        res.set_dif_cpu100_hz_avg(dif_cpu100_hz_avg)?;
        res.set_dif_cpu100_hz_min(dif_cpu100_hz_min)?;
        res.set_dif_cpu10_hz_avg(dif_cpu10_hz_avg)?;
        res.set_dif_cpu10_hz_min(dif_cpu10_hz_min)?;
        res.set_dif_cpu10ms_min(dif_cpu10ms_min)?;
        res.set_dif_cpu1_hz_avg(dif_cpu1_hz_avg)?;
        res.set_dif_cpu1_hz_min(dif_cpu1_hz_min)?;
        res.set_dif_cpu1k_hz_avg(dif_cpu1k_hz_avg)?;
        res.set_dif_cpu1k_hz_min(dif_cpu1k_hz_min)?;
        res.set_dif_cpu20k_hz_avg(dif_cpu20k_hz_avg)?;
        res.set_dif_cpu20k_hz_min(dif_cpu20k_hz_min)?;
        res.set_dif_cpu_id_word0(dif_cpu_id_word0)?;
        res.set_dif_cpu_id_word1(dif_cpu_id_word1)?;
        res.set_dif_cpu_id_word2(dif_cpu_id_word2)?;
        res.set_dif_cpu_id_word3(dif_cpu_id_word3)?;
        res.set_dif_crc(dif_crc)?;
        res.set_dif_current_limit(dif_current_limit)?;
        res.set_dif_dc_cable_current_est(dif_dc_cable_current_est)?;
        res.set_dif_dc_cable_heat(dif_dc_cable_heat)?;
        res.set_dif_dc_cap_temp(dif_dc_cap_temp)?;
        res.set_dif_dc_link_cap_temp(dif_dc_link_cap_temp)?;
        res.set_dif_decode_hardware_stack(dif_decode_hardware_stack)?;
        res.set_dif_drive_unit_odometer(dif_drive_unit_odometer)?;
        res.set_dif_eeprom_stack(dif_eeprom_stack)?;
        res.set_dif_flux_state(dif_flux_state)?;
        res.set_dif_gain_scale(dif_gain_scale)?;
        res.set_dif_gate_drive_state(dif_gate_drive_state)?;
        res.set_dif_gate_drive_supply_state(dif_gate_drive_supply_state)?;
        res.set_dif_hv_dc_cable_temp(dif_hv_dc_cable_temp)?;
        res.set_dif_hw_fault_count(dif_hw_fault_count)?;
        res.set_dif_idle_stack(dif_idle_stack)?;
        res.set_dif_immobilizer_stack(dif_immobilizer_stack)?;
        res.set_dif_internal_angle_filt(dif_internal_angle_filt)?;
        res.set_dif_llr_scale(dif_llr_scale)?;
        res.set_dif_lls_scale(dif_lls_scale)?;
        res.set_dif_lm_scale(dif_lm_scale)?;
        res.set_dif_load_angle(dif_load_angle)?;
        res.set_dif_load_angle_margin(dif_load_angle_margin)?;
        res.set_dif_magnet_temp_est(dif_magnet_temp_est)?;
        res.set_dif_module10_hz_stack(dif_module10_hz_stack)?;
        res.set_dif_motor_ia(dif_motor_ia)?;
        res.set_dif_motor_i_aavg(dif_motor_i_aavg)?;
        res.set_dif_motor_ib(dif_motor_ib)?;
        res.set_dif_motor_i_bavg(dif_motor_i_bavg)?;
        res.set_dif_motor_ic(dif_motor_ic)?;
        res.set_dif_motor_type(dif_motor_type)?;
        res.set_dif_motor_v(dif_motor_v)?;
        res.set_dif_neg_dc_busbar_temp(dif_neg_dc_busbar_temp)?;
        res.set_dif_offset_a(dif_offset_a)?;
        res.set_dif_offset_b(dif_offset_b)?;
        res.set_dif_oil_pump_motor_speed(dif_oil_pump_motor_speed)?;
        res.set_dif_oil_pump_phase_voltage(dif_oil_pump_phase_voltage)?;
        res.set_dif_oil_pump_pressure_estimate_max(dif_oil_pump_pressure_estimate_max)?;
        res.set_dif_oil_pump_pressure_expected_min(dif_oil_pump_pressure_expected_min)?;
        res.set_dif_pcs_temp(dif_pcs_temp)?;
        res.set_dif_peak_flux(dif_peak_flux)?;
        res.set_dif_peak_i_qref(dif_peak_i_qref)?;
        res.set_dif_phase_out_busbar_temp(dif_phase_out_busbar_temp)?;
        res.set_dif_phase_out_busbar_weld_temp(dif_phase_out_busbar_weld_temp)?;
        res.set_dif_phase_out_lug_temp(dif_phase_out_lug_temp)?;
        res.set_dif_pos_dc_busbar_temp(dif_pos_dc_busbar_temp)?;
        res.set_dif_power_stage_safe_state(dif_power_stage_safe_state)?;
        res.set_dif_pwm_state(dif_pwm_state)?;
        res.set_dif_pwr_sat_charge_current(dif_pwr_sat_charge_current)?;
        res.set_dif_pwr_sat_discharge_current(dif_pwr_sat_discharge_current)?;
        res.set_dif_pwr_sat_max_bus_voltage(dif_pwr_sat_max_bus_voltage)?;
        res.set_dif_pwr_sat_max_discharge_power(dif_pwr_sat_max_discharge_power)?;
        res.set_dif_pwr_sat_max_regen_power(dif_pwr_sat_max_regen_power)?;
        res.set_dif_pwr_sat_min_bus_voltage(dif_pwr_sat_min_bus_voltage)?;
        res.set_dif_resolver_cla_mia(dif_resolver_cla_mia)?;
        res.set_dif_resolver_common_gain(dif_resolver_common_gain)?;
        res.set_dif_resolver_cos_filtered(dif_resolver_cos_filtered)?;
        res.set_dif_resolver_cos_rms_squared(dif_resolver_cos_rms_squared)?;
        res.set_dif_resolver_error_rms_squared(dif_resolver_error_rms_squared)?;
        res.set_dif_resolver_no_carrier(dif_resolver_no_carrier)?;
        res.set_dif_resolver_no_phase_lock(dif_resolver_no_phase_lock)?;
        res.set_dif_resolver_offset_cos(dif_resolver_offset_cos)?;
        res.set_dif_resolver_offset_sin(dif_resolver_offset_sin)?;
        res.set_dif_resolver_phase_offset(dif_resolver_phase_offset)?;
        res.set_dif_resolver_ready(dif_resolver_ready)?;
        res.set_dif_resolver_sin_filtered(dif_resolver_sin_filtered)?;
        res.set_dif_resolver_sin_rms_squared(dif_resolver_sin_rms_squared)?;
        res.set_dif_rotor_flux(dif_rotor_flux)?;
        res.set_dif_rotor_max_magnet_temp(dif_rotor_max_magnet_temp)?;
        res.set_dif_rotor_offset_est(dif_rotor_offset_est)?;
        res.set_dif_rotor_offset_learning_state(dif_rotor_offset_learning_state)?;
        res.set_dif_rotor_offset_mean(dif_rotor_offset_mean)?;
        res.set_dif_rs_scale(dif_rs_scale)?;
        res.set_dif_sopt_max_current_mag_sqrd(dif_sopt_max_current_mag_sqrd)?;
        res.set_dif_sopt_time_to_off(dif_sopt_time_to_off)?;
        res.set_dif_sopt_time_to_trip(dif_sopt_time_to_trip)?;
        res.set_dif_sopt_trip_delay(dif_sopt_trip_delay)?;
        res.set_dif_ssm_state(dif_ssm_state)?;
        res.set_dif_stator_end_winding_temp(dif_stator_end_winding_temp)?;
        res.set_dif_stator_flux_fdb(dif_stator_flux_fdb)?;
        res.set_dif_stator_flux_ref(dif_stator_flux_ref)?;
        res.set_dif_stator_i_dfdb(dif_stator_i_dfdb)?;
        res.set_dif_stator_i_dref(dif_stator_i_dref)?;
        res.set_dif_stator_i_qfdb(dif_stator_i_qfdb)?;
        res.set_dif_stator_i_qref(dif_stator_i_qref)?;
        res.set_dif_stator_temp1(dif_stator_temp1)?;
        res.set_dif_stator_temp2(dif_stator_temp2)?;
        res.set_dif_stator_vd(dif_stator_vd)?;
        res.set_dif_stator_vd_filtered(dif_stator_vd_filtered)?;
        res.set_dif_stator_vq(dif_stator_vq)?;
        res.set_dif_stator_vq_filtered(dif_stator_vq_filtered)?;
        res.set_dif_sys_heat_power_optimal(dif_sys_heat_power_optimal)?;
        res.set_dif_system_stack(dif_system_stack)?;
        res.set_dif_system_torque_command(dif_system_torque_command)?;
        res.set_dif_tc_max_request(dif_tc_max_request)?;
        res.set_dif_tc_min_request(dif_tc_min_request)?;
        res.set_dif_torque_per_amp(dif_torque_per_amp)?;
        res.set_dif_tq_sat_motor_current(dif_tq_sat_motor_current)?;
        res.set_dif_tq_sat_motor_voltage(dif_tq_sat_motor_voltage)?;
        res.set_dif_tq_sat_thermal(dif_tq_sat_thermal)?;
        res.set_dif_tq_sat_ui_drive_torque(dif_tq_sat_ui_drive_torque)?;
        res.set_dif_tq_sat_ui_regen_torque(dif_tq_sat_ui_regen_torque)?;
        res.set_dif_tq_scale_differential(dif_tq_scale_differential)?;
        res.set_dif_tq_scale_max_motor_speed(dif_tq_scale_max_motor_speed)?;
        res.set_dif_tq_scale_shift(dif_tq_scale_shift)?;
        res.set_dif_uds_stack(dif_uds_stack)?;
        res.set_dif_usm_state(dif_usm_state)?;
        res.set_dif_ve_mass_inv_raw(dif_ve_mass_inv_raw)?;
        res.set_dif_ve_res_force(dif_ve_res_force)?;
        res.set_dif_waste_current_limit(dif_waste_current_limit)?;
        res.set_dif_xcp_stack(dif_xcp_stack)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DIF_debugSelector
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_debug_selector(&self) -> u8 {
        self.dif_debug_selector_raw()
    }
    
    /// Get raw value of DIF_debugSelector
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_debug_selector_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_debugSelector
    #[inline(always)]
    pub fn set_dif_debug_selector(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// DIF_brakeSwitchNC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_brake_switch_nc(&self) -> bool {
        self.dif_brake_switch_nc_raw()
    }
    
    /// Get raw value of DIF_brakeSwitchNC
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_brake_switch_nc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIF_brakeSwitchNC
    #[inline(always)]
    pub fn set_dif_brake_switch_nc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// DIF_brakeSwitchNO
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_brake_switch_no(&self) -> bool {
        self.dif_brake_switch_no_raw()
    }
    
    /// Get raw value of DIF_brakeSwitchNO
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_brake_switch_no_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIF_brakeSwitchNO
    #[inline(always)]
    pub fn set_dif_brake_switch_no(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// DIF_busbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_busbar_temp(&self) -> f32 {
        self.dif_busbar_temp_raw()
    }
    
    /// Get raw value of DIF_busbarTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_busbarTemp
    #[inline(always)]
    pub fn set_dif_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_controlStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_control_stack(&self) -> f32 {
        self.dif_control_stack_raw()
    }
    
    /// Get raw value of DIF_controlStack
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_control_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_controlStack
    #[inline(always)]
    pub fn set_dif_control_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu100HzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu100_hz_avg(&self) -> f32 {
        self.dif_cpu100_hz_avg_raw()
    }
    
    /// Get raw value of DIF_cpu100HzAvg
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu100_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu100HzAvg
    #[inline(always)]
    pub fn set_dif_cpu100_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu100HzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu100_hz_min(&self) -> f32 {
        self.dif_cpu100_hz_min_raw()
    }
    
    /// Get raw value of DIF_cpu100HzMin
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu100_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu100HzMin
    #[inline(always)]
    pub fn set_dif_cpu100_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu10HzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu10_hz_avg(&self) -> f32 {
        self.dif_cpu10_hz_avg_raw()
    }
    
    /// Get raw value of DIF_cpu10HzAvg
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu10_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu10HzAvg
    #[inline(always)]
    pub fn set_dif_cpu10_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu10HzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu10_hz_min(&self) -> f32 {
        self.dif_cpu10_hz_min_raw()
    }
    
    /// Get raw value of DIF_cpu10HzMin
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu10_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu10HzMin
    #[inline(always)]
    pub fn set_dif_cpu10_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu10msMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu10ms_min(&self) -> f32 {
        self.dif_cpu10ms_min_raw()
    }
    
    /// Get raw value of DIF_cpu10msMin
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu10ms_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu10msMin
    #[inline(always)]
    pub fn set_dif_cpu10ms_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu1HzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu1_hz_avg(&self) -> f32 {
        self.dif_cpu1_hz_avg_raw()
    }
    
    /// Get raw value of DIF_cpu1HzAvg
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu1_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu1HzAvg
    #[inline(always)]
    pub fn set_dif_cpu1_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu1HzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu1_hz_min(&self) -> f32 {
        self.dif_cpu1_hz_min_raw()
    }
    
    /// Get raw value of DIF_cpu1HzMin
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu1_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu1HzMin
    #[inline(always)]
    pub fn set_dif_cpu1_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu1kHzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu1k_hz_avg(&self) -> f32 {
        self.dif_cpu1k_hz_avg_raw()
    }
    
    /// Get raw value of DIF_cpu1kHzAvg
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu1k_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu1kHzAvg
    #[inline(always)]
    pub fn set_dif_cpu1k_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu1kHzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu1k_hz_min(&self) -> f32 {
        self.dif_cpu1k_hz_min_raw()
    }
    
    /// Get raw value of DIF_cpu1kHzMin
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu1k_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu1kHzMin
    #[inline(always)]
    pub fn set_dif_cpu1k_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu20kHzAvg
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu20k_hz_avg(&self) -> f32 {
        self.dif_cpu20k_hz_avg_raw()
    }
    
    /// Get raw value of DIF_cpu20kHzAvg
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu20k_hz_avg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu20kHzAvg
    #[inline(always)]
    pub fn set_dif_cpu20k_hz_avg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_cpu20kHzMin
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu20k_hz_min(&self) -> f32 {
        self.dif_cpu20k_hz_min_raw()
    }
    
    /// Get raw value of DIF_cpu20kHzMin
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu20k_hz_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_cpu20kHzMin
    #[inline(always)]
    pub fn set_dif_cpu20k_hz_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_cpuIDWord0
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu_id_word0(&self) -> u16 {
        self.dif_cpu_id_word0_raw()
    }
    
    /// Get raw value of DIF_cpuIDWord0
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu_id_word0_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_cpuIDWord0
    #[inline(always)]
    pub fn set_dif_cpu_id_word0(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_cpuIDWord1
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu_id_word1(&self) -> u16 {
        self.dif_cpu_id_word1_raw()
    }
    
    /// Get raw value of DIF_cpuIDWord1
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu_id_word1_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_cpuIDWord1
    #[inline(always)]
    pub fn set_dif_cpu_id_word1(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_cpuIDWord2
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu_id_word2(&self) -> u16 {
        self.dif_cpu_id_word2_raw()
    }
    
    /// Get raw value of DIF_cpuIDWord2
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu_id_word2_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_cpuIDWord2
    #[inline(always)]
    pub fn set_dif_cpu_id_word2(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_cpuIDWord3
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_cpu_id_word3(&self) -> u16 {
        self.dif_cpu_id_word3_raw()
    }
    
    /// Get raw value of DIF_cpuIDWord3
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_cpu_id_word3_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of DIF_cpuIDWord3
    #[inline(always)]
    pub fn set_dif_cpu_id_word3(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_crc
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_crc(&self) -> u32 {
        self.dif_crc_raw()
    }
    
    /// Get raw value of DIF_crc
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_crc_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        signal
    }
    
    /// Set value of DIF_crc
    #[inline(always)]
    pub fn set_dif_crc(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 4294970000_u32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIF_currentLimit
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_current_limit(&self) -> f32 {
        self.dif_current_limit_raw()
    }
    
    /// Get raw value of DIF_currentLimit
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_currentLimit
    #[inline(always)]
    pub fn set_dif_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_dcCableCurrentEst
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_dc_cable_current_est(&self) -> f32 {
        self.dif_dc_cable_current_est_raw()
    }
    
    /// Get raw value of DIF_dcCableCurrentEst
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_dc_cable_current_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_dcCableCurrentEst
    #[inline(always)]
    pub fn set_dif_dc_cable_current_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_dcCableHeat
    ///
    /// - Min: 0
    /// - Max: 65.535
    /// - Unit: "kA2s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_dc_cable_heat(&self) -> f32 {
        self.dif_dc_cable_heat_raw()
    }
    
    /// Get raw value of DIF_dcCableHeat
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_dc_cable_heat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_dcCableHeat
    #[inline(always)]
    pub fn set_dif_dc_cable_heat(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 65.535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_dcCapTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_dc_cap_temp(&self) -> f32 {
        self.dif_dc_cap_temp_raw()
    }
    
    /// Get raw value of DIF_dcCapTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_dc_cap_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_dcCapTemp
    #[inline(always)]
    pub fn set_dif_dc_cap_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_dcLinkCapTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_dc_link_cap_temp(&self) -> f32 {
        self.dif_dc_link_cap_temp_raw()
    }
    
    /// Get raw value of DIF_dcLinkCapTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_dc_link_cap_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_dcLinkCapTemp
    #[inline(always)]
    pub fn set_dif_dc_link_cap_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_decodeHardwareStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_decode_hardware_stack(&self) -> f32 {
        self.dif_decode_hardware_stack_raw()
    }
    
    /// Get raw value of DIF_decodeHardwareStack
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_decode_hardware_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_decodeHardwareStack
    #[inline(always)]
    pub fn set_dif_decode_hardware_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_driveUnitOdometer
    ///
    /// - Min: 0
    /// - Max: 42949700000
    /// - Unit: "rev"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_drive_unit_odometer(&self) -> f32 {
        self.dif_drive_unit_odometer_raw()
    }
    
    /// Get raw value of DIF_driveUnitOdometer
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_drive_unit_odometer_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..64].load_le::<u32>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_driveUnitOdometer
    #[inline(always)]
    pub fn set_dif_drive_unit_odometer(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 42949700000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<LocalBits>()[32..64].store_le(value);
        Ok(())
    }
    
    /// DIF_eepromStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_eeprom_stack(&self) -> f32 {
        self.dif_eeprom_stack_raw()
    }
    
    /// Get raw value of DIF_eepromStack
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_eeprom_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_eepromStack
    #[inline(always)]
    pub fn set_dif_eeprom_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_fluxState
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_flux_state(&self) -> Id757difDebugDifFluxState {
        match self.dif_flux_state_raw() {
            5 => Id757difDebugDifFluxState::DiFluxstateEnabled,
            9 => Id757difDebugDifFluxState::DiFluxstateFault,
            4 => Id757difDebugDifFluxState::DiFluxstateFluxDown,
            3 => Id757difDebugDifFluxState::DiFluxstateFluxUp,
            6 => Id757difDebugDifFluxState::DiFluxstateIcontrol,
            2 => Id757difDebugDifFluxState::DiFluxstateStandby,
            0 => Id757difDebugDifFluxState::DiFluxstateStart,
            10 => Id757difDebugDifFluxState::DiFluxstateStationaryWaste,
            1 => Id757difDebugDifFluxState::DiFluxstateTest,
            7 => Id757difDebugDifFluxState::DiFluxstateVcontrol,
            x => Id757difDebugDifFluxState::Other(x),
        }
    }
    
    /// Get raw value of DIF_fluxState
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_flux_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_fluxState
    #[inline(always)]
    pub fn set_dif_flux_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DIF_gainScale
    ///
    /// - Min: 0
    /// - Max: 2.55
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_gain_scale(&self) -> f32 {
        self.dif_gain_scale_raw()
    }
    
    /// Get raw value of DIF_gainScale
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_gain_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_gainScale
    #[inline(always)]
    pub fn set_dif_gain_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.55_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_gateDriveState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_gate_drive_state(&self) -> Id757difDebugDifGateDriveState {
        match self.dif_gate_drive_state_raw() {
            3 => Id757difDebugDifGateDriveState::PstgGdStateConfigured,
            2 => Id757difDebugDifGateDriveState::PstgGdStateConfiguring,
            0 => Id757difDebugDifGateDriveState::PstgGdStateInit,
            4 => Id757difDebugDifGateDriveState::PstgGdStateNotConfigured,
            1 => Id757difDebugDifGateDriveState::PstgGdStateSelftest,
            x => Id757difDebugDifGateDriveState::Other(x),
        }
    }
    
    /// Get raw value of DIF_gateDriveState
    ///
    /// - Start bit: 10
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_gate_drive_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_gateDriveState
    #[inline(always)]
    pub fn set_dif_gate_drive_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..13].store_le(value);
        Ok(())
    }
    
    /// DIF_gateDriveSupplyState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_gate_drive_supply_state(&self) -> Id757difDebugDifGateDriveSupplyState {
        match self.dif_gate_drive_supply_state_raw() {
            0 => Id757difDebugDifGateDriveSupplyState::PstgGdSupplyDown,
            3 => Id757difDebugDifGateDriveSupplyState::PstgGdSupplyFalling,
            1 => Id757difDebugDifGateDriveSupplyState::PstgGdSupplyRising,
            2 => Id757difDebugDifGateDriveSupplyState::PstgGdSupplyUp,
            x => Id757difDebugDifGateDriveSupplyState::Other(x),
        }
    }
    
    /// Get raw value of DIF_gateDriveSupplyState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_gate_drive_supply_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_gateDriveSupplyState
    #[inline(always)]
    pub fn set_dif_gate_drive_supply_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// DIF_hvDcCableTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_hv_dc_cable_temp(&self) -> f32 {
        self.dif_hv_dc_cable_temp_raw()
    }
    
    /// Get raw value of DIF_hvDcCableTemp
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_hv_dc_cable_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_hvDcCableTemp
    #[inline(always)]
    pub fn set_dif_hv_dc_cable_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_hwFaultCount
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_hw_fault_count(&self) -> u8 {
        self.dif_hw_fault_count_raw()
    }
    
    /// Get raw value of DIF_hwFaultCount
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_hw_fault_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_hwFaultCount
    #[inline(always)]
    pub fn set_dif_hw_fault_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// DIF_idleStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_idle_stack(&self) -> f32 {
        self.dif_idle_stack_raw()
    }
    
    /// Get raw value of DIF_idleStack
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_idle_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_idleStack
    #[inline(always)]
    pub fn set_dif_idle_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_immobilizerStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_immobilizer_stack(&self) -> f32 {
        self.dif_immobilizer_stack_raw()
    }
    
    /// Get raw value of DIF_immobilizerStack
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_immobilizer_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_immobilizerStack
    #[inline(always)]
    pub fn set_dif_immobilizer_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIF_internalAngleFilt
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_internal_angle_filt(&self) -> f32 {
        self.dif_internal_angle_filt_raw()
    }
    
    /// Get raw value of DIF_internalAngleFilt
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0003
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_internal_angle_filt_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.0003_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_internalAngleFilt
    #[inline(always)]
    pub fn set_dif_internal_angle_filt(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 8_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0003_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_llrScale
    ///
    /// - Min: 0
    /// - Max: 3.825
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_llr_scale(&self) -> f32 {
        self.dif_llr_scale_raw()
    }
    
    /// Get raw value of DIF_llrScale
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.015
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_llr_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.015_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_llrScale
    #[inline(always)]
    pub fn set_dif_llr_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3.825_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.015_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_llsScale
    ///
    /// - Min: 0
    /// - Max: 1.02
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_lls_scale(&self) -> f32 {
        self.dif_lls_scale_raw()
    }
    
    /// Get raw value of DIF_llsScale
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_lls_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_llsScale
    #[inline(always)]
    pub fn set_dif_lls_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.02_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_lmScale
    ///
    /// - Min: 0
    /// - Max: 1.02
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_lm_scale(&self) -> f32 {
        self.dif_lm_scale_raw()
    }
    
    /// Get raw value of DIF_lmScale
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_lm_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_lmScale
    #[inline(always)]
    pub fn set_dif_lm_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.02_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_loadAngle
    ///
    /// - Min: -4
    /// - Max: 4
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_load_angle(&self) -> f32 {
        self.dif_load_angle_raw()
    }
    
    /// Get raw value of DIF_loadAngle
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.0003
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_load_angle_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..56].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0003_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_loadAngle
    #[inline(always)]
    pub fn set_dif_load_angle(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4_f32 || 4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0003_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..56].store_le(value);
        Ok(())
    }
    
    /// DIF_loadAngleMargin
    ///
    /// - Min: -4
    /// - Max: 4
    /// - Unit: "rad"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_load_angle_margin(&self) -> f32 {
        self.dif_load_angle_margin_raw()
    }
    
    /// Get raw value of DIF_loadAngleMargin
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.0003
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_load_angle_margin_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0003_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_loadAngleMargin
    #[inline(always)]
    pub fn set_dif_load_angle_margin(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4_f32 || 4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0003_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_magnetTempEst
    ///
    /// - Min: -40
    /// - Max: 180
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_magnet_temp_est(&self) -> Id757difDebugDifMagnetTempEst {
        match self.dif_magnet_temp_est_raw() {
            0 => Id757difDebugDifMagnetTempEst::Sna,
            x => Id757difDebugDifMagnetTempEst::Other(x),
        }
    }
    
    /// Get raw value of DIF_magnetTempEst
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_magnet_temp_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_magnetTempEst
    #[inline(always)]
    pub fn set_dif_magnet_temp_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 180_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_module10HzStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_module10_hz_stack(&self) -> f32 {
        self.dif_module10_hz_stack_raw()
    }
    
    /// Get raw value of DIF_module10HzStack
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_module10_hz_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_module10HzStack
    #[inline(always)]
    pub fn set_dif_module10_hz_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_motorIA
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_ia(&self) -> f32 {
        self.dif_motor_ia_raw()
    }
    
    /// Get raw value of DIF_motorIA
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_motor_ia_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_motorIA
    #[inline(always)]
    pub fn set_dif_motor_ia(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_motorIAavg
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_i_aavg(&self) -> f32 {
        self.dif_motor_i_aavg_raw()
    }
    
    /// Get raw value of DIF_motorIAavg
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_motor_i_aavg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_motorIAavg
    #[inline(always)]
    pub fn set_dif_motor_i_aavg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_motorIB
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_ib(&self) -> f32 {
        self.dif_motor_ib_raw()
    }
    
    /// Get raw value of DIF_motorIB
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_motor_ib_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_motorIB
    #[inline(always)]
    pub fn set_dif_motor_ib(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_motorIBavg
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_i_bavg(&self) -> f32 {
        self.dif_motor_i_bavg_raw()
    }
    
    /// Get raw value of DIF_motorIBavg
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_motor_i_bavg_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_motorIBavg
    #[inline(always)]
    pub fn set_dif_motor_i_bavg(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_motorIC
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_ic(&self) -> f32 {
        self.dif_motor_ic_raw()
    }
    
    /// Get raw value of DIF_motorIC
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_motor_ic_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_motorIC
    #[inline(always)]
    pub fn set_dif_motor_ic(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_motorType
    ///
    /// - Min: 0
    /// - Max: 32
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_type(&self) -> Id757difDebugDifMotorType {
        match self.dif_motor_type_raw() {
            8 => Id757difDebugDifMotorType::DiMotorF1a,
            10 => Id757difDebugDifMotorType::DiMotorF1ac,
            11 => Id757difDebugDifMotorType::DiMotorF2ab,
            12 => Id757difDebugDifMotorType::DiMotorF2ac,
            13 => Id757difDebugDifMotorType::DiMotorF2ad,
            14 => Id757difDebugDifMotorType::DiMotorF2ae,
            26 => Id757difDebugDifMotorType::DiMotorF2aeAl,
            15 => Id757difDebugDifMotorType::DiMotorF2apmsrm,
            17 => Id757difDebugDifMotorType::DiMotorIm100a,
            19 => Id757difDebugDifMotorType::DiMotorIm100b,
            22 => Id757difDebugDifMotorType::DiMotorIm130c,
            24 => Id757difDebugDifMotorType::DiMotorIm130d,
            25 => Id757difDebugDifMotorType::DiMotorIm130dAl,
            27 => Id757difDebugDifMotorType::DiMotorIm130dAlPosco,
            20 => Id757difDebugDifMotorType::DiMotorIm216a,
            3 => Id757difDebugDifMotorType::DiMotorM7m3,
            4 => Id757difDebugDifMotorType::DiMotorM7m4,
            5 => Id757difDebugDifMotorType::DiMotorM7m5,
            7 => Id757difDebugDifMotorType::DiMotorM7m6,
            6 => Id757difDebugDifMotorType::DiMotorM8a,
            16 => Id757difDebugDifMotorType::DiMotorPm216a,
            18 => Id757difDebugDifMotorType::DiMotorPm216b,
            21 => Id757difDebugDifMotorType::DiMotorPm216c,
            30 => Id757difDebugDifMotorType::DiMotorPm216csr,
            31 => Id757difDebugDifMotorType::DiMotorPm216csrN42,
            23 => Id757difDebugDifMotorType::DiMotorPm216d,
            32 => Id757difDebugDifMotorType::DiMotorPm228b,
            28 => Id757difDebugDifMotorType::DiMotorPm275b,
            29 => Id757difDebugDifMotorType::DiMotorPm350b,
            1 => Id757difDebugDifMotorType::DiMotorRoadsterBase,
            2 => Id757difDebugDifMotorType::DiMotorRoadsterSport,
            0 => Id757difDebugDifMotorType::DiMotorSna,
            9 => Id757difDebugDifMotorType::DiMotorSsr1a,
            x => Id757difDebugDifMotorType::Other(x),
        }
    }
    
    /// Get raw value of DIF_motorType
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_motor_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_motorType
    #[inline(always)]
    pub fn set_dif_motor_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 32_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..14].store_le(value);
        Ok(())
    }
    
    /// DIF_motorV
    ///
    /// - Min: 0
    /// - Max: 1.3107
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_motor_v(&self) -> f32 {
        self.dif_motor_v_raw()
    }
    
    /// Get raw value of DIF_motorV
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.00002
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_motor_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.00002_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_motorV
    #[inline(always)]
    pub fn set_dif_motor_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.3107_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.00002_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_negDcBusbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_neg_dc_busbar_temp(&self) -> f32 {
        self.dif_neg_dc_busbar_temp_raw()
    }
    
    /// Get raw value of DIF_negDcBusbarTemp
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_neg_dc_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_negDcBusbarTemp
    #[inline(always)]
    pub fn set_dif_neg_dc_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_offsetA
    ///
    /// - Min: -12.8
    /// - Max: 12.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_offset_a(&self) -> f32 {
        self.dif_offset_a_raw()
    }
    
    /// Get raw value of DIF_offsetA
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_offset_a_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_offsetA
    #[inline(always)]
    pub fn set_dif_offset_a(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -12.8_f32 || 12.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_offsetB
    ///
    /// - Min: -12.8
    /// - Max: 12.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_offset_b(&self) -> f32 {
        self.dif_offset_b_raw()
    }
    
    /// Get raw value of DIF_offsetB
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_offset_b_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_offsetB
    #[inline(always)]
    pub fn set_dif_offset_b(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -12.8_f32 || 12.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_oilPumpMotorSpeed
    ///
    /// - Min: 0
    /// - Max: 10200
    /// - Unit: "RPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_oil_pump_motor_speed(&self) -> f32 {
        self.dif_oil_pump_motor_speed_raw()
    }
    
    /// Get raw value of DIF_oilPumpMotorSpeed
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 40
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_oil_pump_motor_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 40_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_oilPumpMotorSpeed
    #[inline(always)]
    pub fn set_dif_oil_pump_motor_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 40_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_oilPumpPhaseVoltage
    ///
    /// - Min: 0
    /// - Max: 25.4
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_oil_pump_phase_voltage(&self) -> Id757difDebugDifOilPumpPhaseVoltage {
        match self.dif_oil_pump_phase_voltage_raw() {
            255 => Id757difDebugDifOilPumpPhaseVoltage::Sna,
            x => Id757difDebugDifOilPumpPhaseVoltage::Other(x),
        }
    }
    
    /// Get raw value of DIF_oilPumpPhaseVoltage
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_oil_pump_phase_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_oilPumpPhaseVoltage
    #[inline(always)]
    pub fn set_dif_oil_pump_phase_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_oilPumpPressureEstimateMax
    ///
    /// - Min: 0
    /// - Max: 500
    /// - Unit: "kPa"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_oil_pump_pressure_estimate_max(&self) -> Id757difDebugDifOilPumpPressureEstimateMax {
        match self.dif_oil_pump_pressure_estimate_max_raw() {
            255 => Id757difDebugDifOilPumpPressureEstimateMax::Sna,
            x => Id757difDebugDifOilPumpPressureEstimateMax::Other(x),
        }
    }
    
    /// Get raw value of DIF_oilPumpPressureEstimateMax
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_oil_pump_pressure_estimate_max_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_oilPumpPressureEstimateMax
    #[inline(always)]
    pub fn set_dif_oil_pump_pressure_estimate_max(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_oilPumpPressureExpectedMin
    ///
    /// - Min: 0
    /// - Max: 500
    /// - Unit: "kPa"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_oil_pump_pressure_expected_min(&self) -> Id757difDebugDifOilPumpPressureExpectedMin {
        match self.dif_oil_pump_pressure_expected_min_raw() {
            255 => Id757difDebugDifOilPumpPressureExpectedMin::Sna,
            x => Id757difDebugDifOilPumpPressureExpectedMin::Other(x),
        }
    }
    
    /// Get raw value of DIF_oilPumpPressureExpectedMin
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_oil_pump_pressure_expected_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_oilPumpPressureExpectedMin
    #[inline(always)]
    pub fn set_dif_oil_pump_pressure_expected_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_pcsTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pcs_temp(&self) -> f32 {
        self.dif_pcs_temp_raw()
    }
    
    /// Get raw value of DIF_pcsTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pcs_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pcsTemp
    #[inline(always)]
    pub fn set_dif_pcs_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_peakFlux
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_peak_flux(&self) -> f32 {
        self.dif_peak_flux_raw()
    }
    
    /// Get raw value of DIF_peakFlux
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_peak_flux_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_peakFlux
    #[inline(always)]
    pub fn set_dif_peak_flux(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_peakIQref
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_peak_i_qref(&self) -> f32 {
        self.dif_peak_i_qref_raw()
    }
    
    /// Get raw value of DIF_peakIQref
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_peak_i_qref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_peakIQref
    #[inline(always)]
    pub fn set_dif_peak_i_qref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_phaseOutBusbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_phase_out_busbar_temp(&self) -> f32 {
        self.dif_phase_out_busbar_temp_raw()
    }
    
    /// Get raw value of DIF_phaseOutBusbarTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_phase_out_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_phaseOutBusbarTemp
    #[inline(always)]
    pub fn set_dif_phase_out_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_phaseOutBusbarWeldTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_phase_out_busbar_weld_temp(&self) -> f32 {
        self.dif_phase_out_busbar_weld_temp_raw()
    }
    
    /// Get raw value of DIF_phaseOutBusbarWeldTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_phase_out_busbar_weld_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_phaseOutBusbarWeldTemp
    #[inline(always)]
    pub fn set_dif_phase_out_busbar_weld_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_phaseOutLugTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_phase_out_lug_temp(&self) -> f32 {
        self.dif_phase_out_lug_temp_raw()
    }
    
    /// Get raw value of DIF_phaseOutLugTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_phase_out_lug_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_phaseOutLugTemp
    #[inline(always)]
    pub fn set_dif_phase_out_lug_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_posDcBusbarTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pos_dc_busbar_temp(&self) -> f32 {
        self.dif_pos_dc_busbar_temp_raw()
    }
    
    /// Get raw value of DIF_posDcBusbarTemp
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pos_dc_busbar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_posDcBusbarTemp
    #[inline(always)]
    pub fn set_dif_pos_dc_busbar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIF_powerStageSafeState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_power_stage_safe_state(&self) -> Id757difDebugDifPowerStageSafeState {
        match self.dif_power_stage_safe_state_raw() {
            2 => Id757difDebugDifPowerStageSafeState::PstgSafestate3psHigh,
            3 => Id757difDebugDifPowerStageSafeState::PstgSafestate3psLow,
            1 => Id757difDebugDifPowerStageSafeState::PstgSafestateAllOff,
            0 => Id757difDebugDifPowerStageSafeState::PstgSafestateNone,
            x => Id757difDebugDifPowerStageSafeState::Other(x),
        }
    }
    
    /// Get raw value of DIF_powerStageSafeState
    ///
    /// - Start bit: 13
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_power_stage_safe_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[13..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_powerStageSafeState
    #[inline(always)]
    pub fn set_dif_power_stage_safe_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[13..15].store_le(value);
        Ok(())
    }
    
    /// DIF_pwmState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwm_state(&self) -> Id757difDebugDifPwmState {
        match self.dif_pwm_state_raw() {
            1 => Id757difDebugDifPwmState::PwmstateDpwm2,
            2 => Id757difDebugDifPwmState::PwmstateOpwm1,
            3 => Id757difDebugDifPwmState::PwmstateOpwm2,
            0 => Id757difDebugDifPwmState::PwmstateSvpwm,
            x => Id757difDebugDifPwmState::Other(x),
        }
    }
    
    /// Get raw value of DIF_pwmState
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_pwmState
    #[inline(always)]
    pub fn set_dif_pwm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// DIF_pwrSatChargeCurrent
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwr_sat_charge_current(&self) -> f32 {
        self.dif_pwr_sat_charge_current_raw()
    }
    
    /// Get raw value of DIF_pwrSatChargeCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwr_sat_charge_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pwrSatChargeCurrent
    #[inline(always)]
    pub fn set_dif_pwr_sat_charge_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_pwrSatDischargeCurrent
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwr_sat_discharge_current(&self) -> f32 {
        self.dif_pwr_sat_discharge_current_raw()
    }
    
    /// Get raw value of DIF_pwrSatDischargeCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwr_sat_discharge_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pwrSatDischargeCurrent
    #[inline(always)]
    pub fn set_dif_pwr_sat_discharge_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_pwrSatMaxBusVoltage
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwr_sat_max_bus_voltage(&self) -> f32 {
        self.dif_pwr_sat_max_bus_voltage_raw()
    }
    
    /// Get raw value of DIF_pwrSatMaxBusVoltage
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwr_sat_max_bus_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pwrSatMaxBusVoltage
    #[inline(always)]
    pub fn set_dif_pwr_sat_max_bus_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_pwrSatMaxDischargePower
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwr_sat_max_discharge_power(&self) -> f32 {
        self.dif_pwr_sat_max_discharge_power_raw()
    }
    
    /// Get raw value of DIF_pwrSatMaxDischargePower
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwr_sat_max_discharge_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pwrSatMaxDischargePower
    #[inline(always)]
    pub fn set_dif_pwr_sat_max_discharge_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_pwrSatMaxRegenPower
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwr_sat_max_regen_power(&self) -> f32 {
        self.dif_pwr_sat_max_regen_power_raw()
    }
    
    /// Get raw value of DIF_pwrSatMaxRegenPower
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwr_sat_max_regen_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pwrSatMaxRegenPower
    #[inline(always)]
    pub fn set_dif_pwr_sat_max_regen_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_pwrSatMinBusVoltage
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_pwr_sat_min_bus_voltage(&self) -> f32 {
        self.dif_pwr_sat_min_bus_voltage_raw()
    }
    
    /// Get raw value of DIF_pwrSatMinBusVoltage
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_pwr_sat_min_bus_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_pwrSatMinBusVoltage
    #[inline(always)]
    pub fn set_dif_pwr_sat_min_bus_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverClaMIA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_cla_mia(&self) -> bool {
        self.dif_resolver_cla_mia_raw()
    }
    
    /// Get raw value of DIF_resolverClaMIA
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_cla_mia_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIF_resolverClaMIA
    #[inline(always)]
    pub fn set_dif_resolver_cla_mia(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverCommonGain
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_common_gain(&self) -> f32 {
        self.dif_resolver_common_gain_raw()
    }
    
    /// Get raw value of DIF_resolverCommonGain
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.025
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_common_gain_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.025_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverCommonGain
    #[inline(always)]
    pub fn set_dif_resolver_common_gain(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.025_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverCosFiltered
    ///
    /// - Min: -1
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_cos_filtered(&self) -> f32 {
        self.dif_resolver_cos_filtered_raw()
    }
    
    /// Get raw value of DIF_resolverCosFiltered
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_resolver_cos_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverCosFiltered
    #[inline(always)]
    pub fn set_dif_resolver_cos_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverCosRmsSquared
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_cos_rms_squared(&self) -> f32 {
        self.dif_resolver_cos_rms_squared_raw()
    }
    
    /// Get raw value of DIF_resolverCosRmsSquared
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_cos_rms_squared_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverCosRmsSquared
    #[inline(always)]
    pub fn set_dif_resolver_cos_rms_squared(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverErrorRmsSquared
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_error_rms_squared(&self) -> f32 {
        self.dif_resolver_error_rms_squared_raw()
    }
    
    /// Get raw value of DIF_resolverErrorRmsSquared
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_error_rms_squared_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverErrorRmsSquared
    #[inline(always)]
    pub fn set_dif_resolver_error_rms_squared(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverNoCarrier
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_no_carrier(&self) -> bool {
        self.dif_resolver_no_carrier_raw()
    }
    
    /// Get raw value of DIF_resolverNoCarrier
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_no_carrier_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIF_resolverNoCarrier
    #[inline(always)]
    pub fn set_dif_resolver_no_carrier(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[41..42].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverNoPhaseLock
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_no_phase_lock(&self) -> bool {
        self.dif_resolver_no_phase_lock_raw()
    }
    
    /// Get raw value of DIF_resolverNoPhaseLock
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_no_phase_lock_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIF_resolverNoPhaseLock
    #[inline(always)]
    pub fn set_dif_resolver_no_phase_lock(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverOffsetCos
    ///
    /// - Min: 0
    /// - Max: 3.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_offset_cos(&self) -> f32 {
        self.dif_resolver_offset_cos_raw()
    }
    
    /// Get raw value of DIF_resolverOffsetCos
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.015
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_offset_cos_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.015_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverOffsetCos
    #[inline(always)]
    pub fn set_dif_resolver_offset_cos(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.015_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverOffsetSin
    ///
    /// - Min: 0
    /// - Max: 3.3
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_offset_sin(&self) -> f32 {
        self.dif_resolver_offset_sin_raw()
    }
    
    /// Get raw value of DIF_resolverOffsetSin
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.015
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_offset_sin_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.015_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverOffsetSin
    #[inline(always)]
    pub fn set_dif_resolver_offset_sin(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.015_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverPhaseOffset
    ///
    /// - Min: 7.5
    /// - Max: 32.5
    /// - Unit: "us"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_phase_offset(&self) -> f32 {
        self.dif_resolver_phase_offset_raw()
    }
    
    /// Get raw value of DIF_resolverPhaseOffset
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 7.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_phase_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 7.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverPhaseOffset
    #[inline(always)]
    pub fn set_dif_resolver_phase_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 7.5_f32 || 32.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 7.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverReady
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_ready(&self) -> bool {
        self.dif_resolver_ready_raw()
    }
    
    /// Get raw value of DIF_resolverReady
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_ready_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DIF_resolverReady
    #[inline(always)]
    pub fn set_dif_resolver_ready(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[40..41].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverSinFiltered
    ///
    /// - Min: -1
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_sin_filtered(&self) -> f32 {
        self.dif_resolver_sin_filtered_raw()
    }
    
    /// Get raw value of DIF_resolverSinFiltered
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_resolver_sin_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverSinFiltered
    #[inline(always)]
    pub fn set_dif_resolver_sin_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_resolverSinRmsSquared
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "1"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_resolver_sin_rms_squared(&self) -> f32 {
        self.dif_resolver_sin_rms_squared_raw()
    }
    
    /// Get raw value of DIF_resolverSinRmsSquared
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_resolver_sin_rms_squared_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_resolverSinRmsSquared
    #[inline(always)]
    pub fn set_dif_resolver_sin_rms_squared(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_rotorFlux
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_rotor_flux(&self) -> f32 {
        self.dif_rotor_flux_raw()
    }
    
    /// Get raw value of DIF_rotorFlux
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_rotor_flux_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_rotorFlux
    #[inline(always)]
    pub fn set_dif_rotor_flux(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_rotorMaxMagnetTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_rotor_max_magnet_temp(&self) -> f32 {
        self.dif_rotor_max_magnet_temp_raw()
    }
    
    /// Get raw value of DIF_rotorMaxMagnetTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_rotor_max_magnet_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_rotorMaxMagnetTemp
    #[inline(always)]
    pub fn set_dif_rotor_max_magnet_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_rotorOffsetEst
    ///
    /// - Min: -20
    /// - Max: 20
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_rotor_offset_est(&self) -> f32 {
        self.dif_rotor_offset_est_raw()
    }
    
    /// Get raw value of DIF_rotorOffsetEst
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_rotor_offset_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..20].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_rotorOffsetEst
    #[inline(always)]
    pub fn set_dif_rotor_offset_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..20].store_le(value);
        Ok(())
    }
    
    /// DIF_rotorOffsetLearningState
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_rotor_offset_learning_state(&self) -> Id757difDebugDifRotorOffsetLearningState {
        match self.dif_rotor_offset_learning_state_raw() {
            9 => Id757difDebugDifRotorOffsetLearningState::RolNumStates,
            2 => Id757difDebugDifRotorOffsetLearningState::RolStateAccelerate,
            5 => Id757difDebugDifRotorOffsetLearningState::RolStateCorrect,
            8 => Id757difDebugDifRotorOffsetLearningState::RolStateDone,
            0 => Id757difDebugDifRotorOffsetLearningState::RolStateInit,
            4 => Id757difDebugDifRotorOffsetLearningState::RolStateMeasure,
            3 => Id757difDebugDifRotorOffsetLearningState::RolStateShift,
            6 => Id757difDebugDifRotorOffsetLearningState::RolStateVerify,
            1 => Id757difDebugDifRotorOffsetLearningState::RolStateWait,
            7 => Id757difDebugDifRotorOffsetLearningState::RolStateWrite,
            x => Id757difDebugDifRotorOffsetLearningState::Other(x),
        }
    }
    
    /// Get raw value of DIF_rotorOffsetLearningState
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_rotor_offset_learning_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_rotorOffsetLearningState
    #[inline(always)]
    pub fn set_dif_rotor_offset_learning_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// DIF_rotorOffsetMean
    ///
    /// - Min: -20
    /// - Max: 20
    /// - Unit: "deg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_rotor_offset_mean(&self) -> f32 {
        self.dif_rotor_offset_mean_raw()
    }
    
    /// Get raw value of DIF_rotorOffsetMean
    ///
    /// - Start bit: 20
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_rotor_offset_mean_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_rotorOffsetMean
    #[inline(always)]
    pub fn set_dif_rotor_offset_mean(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[20..32].store_le(value);
        Ok(())
    }
    
    /// DIF_rsScale
    ///
    /// - Min: 0
    /// - Max: 2.55
    /// - Unit: "scale"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_rs_scale(&self) -> f32 {
        self.dif_rs_scale_raw()
    }
    
    /// Get raw value of DIF_rsScale
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_rs_scale_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_rsScale
    #[inline(always)]
    pub fn set_dif_rs_scale(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.55_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_soptMaxCurrentMagSqrd
    ///
    /// - Min: 0
    /// - Max: 6553500
    /// - Unit: "A2"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_sopt_max_current_mag_sqrd(&self) -> f32 {
        self.dif_sopt_max_current_mag_sqrd_raw()
    }
    
    /// Get raw value of DIF_soptMaxCurrentMagSqrd
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 100
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_sopt_max_current_mag_sqrd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..56].load_le::<u16>();
        
        let factor = 100_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_soptMaxCurrentMagSqrd
    #[inline(always)]
    pub fn set_dif_sopt_max_current_mag_sqrd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 100_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..56].store_le(value);
        Ok(())
    }
    
    /// DIF_soptTimeToOff
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "ms"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_sopt_time_to_off(&self) -> f32 {
        self.dif_sopt_time_to_off_raw()
    }
    
    /// Get raw value of DIF_soptTimeToOff
    ///
    /// - Start bit: 24
    /// - Signal size: 11 bits
    /// - Factor: 0.05
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_sopt_time_to_off_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..35].load_le::<u16>();
        
        let factor = 0.05_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_soptTimeToOff
    #[inline(always)]
    pub fn set_dif_sopt_time_to_off(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.05_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..35].store_le(value);
        Ok(())
    }
    
    /// DIF_soptTimeToTrip
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: "ms"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_sopt_time_to_trip(&self) -> f32 {
        self.dif_sopt_time_to_trip_raw()
    }
    
    /// Get raw value of DIF_soptTimeToTrip
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.05
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_sopt_time_to_trip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.05_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_soptTimeToTrip
    #[inline(always)]
    pub fn set_dif_sopt_time_to_trip(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.05_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_soptTripDelay
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: "ms"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_sopt_trip_delay(&self) -> f32 {
        self.dif_sopt_trip_delay_raw()
    }
    
    /// Get raw value of DIF_soptTripDelay
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.05
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_sopt_trip_delay_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.05_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_soptTripDelay
    #[inline(always)]
    pub fn set_dif_sopt_trip_delay(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.05_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_ssmState
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_ssm_state(&self) -> Id757difDebugDifSsmState {
        match self.dif_ssm_state_raw() {
            5 => Id757difDebugDifSsmState::SsmStateAbort,
            4 => Id757difDebugDifSsmState::SsmStateEnable,
            8 => Id757difDebugDifSsmState::SsmStateFault,
            2 => Id757difDebugDifSsmState::SsmStateIdle,
            7 => Id757difDebugDifSsmState::SsmStateRetry,
            3 => Id757difDebugDifSsmState::SsmStateStandby,
            0 => Id757difDebugDifSsmState::SsmStateStart,
            1 => Id757difDebugDifSsmState::SsmStateUnavailable,
            6 => Id757difDebugDifSsmState::SsmStateWaitForRetry,
            x => Id757difDebugDifSsmState::Other(x),
        }
    }
    
    /// Get raw value of DIF_ssmState
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_ssm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_ssmState
    #[inline(always)]
    pub fn set_dif_ssm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// DIF_statorEndWindingTemp
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_end_winding_temp(&self) -> f32 {
        self.dif_stator_end_winding_temp_raw()
    }
    
    /// Get raw value of DIF_statorEndWindingTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_stator_end_winding_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorEndWindingTemp
    #[inline(always)]
    pub fn set_dif_stator_end_winding_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_statorFluxFdb
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_flux_fdb(&self) -> f32 {
        self.dif_stator_flux_fdb_raw()
    }
    
    /// Get raw value of DIF_statorFluxFdb
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_stator_flux_fdb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorFluxFdb
    #[inline(always)]
    pub fn set_dif_stator_flux_fdb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_statorFluxRef
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Wb"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_flux_ref(&self) -> f32 {
        self.dif_stator_flux_ref_raw()
    }
    
    /// Get raw value of DIF_statorFluxRef
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_stator_flux_ref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorFluxRef
    #[inline(always)]
    pub fn set_dif_stator_flux_ref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_statorIDfdb
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_i_dfdb(&self) -> f32 {
        self.dif_stator_i_dfdb_raw()
    }
    
    /// Get raw value of DIF_statorIDfdb
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_i_dfdb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorIDfdb
    #[inline(always)]
    pub fn set_dif_stator_i_dfdb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_statorIDref
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_i_dref(&self) -> f32 {
        self.dif_stator_i_dref_raw()
    }
    
    /// Get raw value of DIF_statorIDref
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_i_dref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorIDref
    #[inline(always)]
    pub fn set_dif_stator_i_dref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_statorIQfdb
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_i_qfdb(&self) -> f32 {
        self.dif_stator_i_qfdb_raw()
    }
    
    /// Get raw value of DIF_statorIQfdb
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_i_qfdb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorIQfdb
    #[inline(always)]
    pub fn set_dif_stator_i_qfdb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_statorIQref
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_i_qref(&self) -> f32 {
        self.dif_stator_i_qref_raw()
    }
    
    /// Get raw value of DIF_statorIQref
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_i_qref_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorIQref
    #[inline(always)]
    pub fn set_dif_stator_i_qref(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_statorTemp1
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_temp1(&self) -> f32 {
        self.dif_stator_temp1_raw()
    }
    
    /// Get raw value of DIF_statorTemp1
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_stator_temp1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorTemp1
    #[inline(always)]
    pub fn set_dif_stator_temp1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_statorTemp2
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_temp2(&self) -> f32 {
        self.dif_stator_temp2_raw()
    }
    
    /// Get raw value of DIF_statorTemp2
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_stator_temp2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorTemp2
    #[inline(always)]
    pub fn set_dif_stator_temp2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_statorVD
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_vd(&self) -> f32 {
        self.dif_stator_vd_raw()
    }
    
    /// Get raw value of DIF_statorVD
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_vd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorVD
    #[inline(always)]
    pub fn set_dif_stator_vd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_statorVDFiltered
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_vd_filtered(&self) -> f32 {
        self.dif_stator_vd_filtered_raw()
    }
    
    /// Get raw value of DIF_statorVDFiltered
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_vd_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorVDFiltered
    #[inline(always)]
    pub fn set_dif_stator_vd_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_statorVQ
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_vq(&self) -> f32 {
        self.dif_stator_vq_raw()
    }
    
    /// Get raw value of DIF_statorVQ
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_vq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorVQ
    #[inline(always)]
    pub fn set_dif_stator_vq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..32].store_le(value);
        Ok(())
    }
    
    /// DIF_statorVQFiltered
    ///
    /// - Min: -1.31072
    /// - Max: 1.31068
    /// - Unit: "mindex"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_stator_vq_filtered(&self) -> f32 {
        self.dif_stator_vq_filtered_raw()
    }
    
    /// Get raw value of DIF_statorVQFiltered
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.00004
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_stator_vq_filtered_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.00004_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_statorVQFiltered
    #[inline(always)]
    pub fn set_dif_stator_vq_filtered(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.31072_f32 || 1.31068_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.00004_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// DIF_sysHeatPowerOptimal
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: "kW"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_sys_heat_power_optimal(&self) -> f32 {
        self.dif_sys_heat_power_optimal_raw()
    }
    
    /// Get raw value of DIF_sysHeatPowerOptimal
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.08
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_sys_heat_power_optimal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.08_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_sysHeatPowerOptimal
    #[inline(always)]
    pub fn set_dif_sys_heat_power_optimal(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.08_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_systemStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_system_stack(&self) -> f32 {
        self.dif_system_stack_raw()
    }
    
    /// Get raw value of DIF_systemStack
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_system_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_systemStack
    #[inline(always)]
    pub fn set_dif_system_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_systemTorqueCommand
    ///
    /// - Min: -1146.88
    /// - Max: 1146.85
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_system_torque_command(&self) -> f32 {
        self.dif_system_torque_command_raw()
    }
    
    /// Get raw value of DIF_systemTorqueCommand
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.035
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_system_torque_command_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.035_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_systemTorqueCommand
    #[inline(always)]
    pub fn set_dif_system_torque_command(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1146.88_f32 || 1146.85_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.035_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_tcMaxRequest
    ///
    /// - Min: 0
    /// - Max: 1275
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tc_max_request(&self) -> Id757difDebugDifTcMaxRequest {
        match self.dif_tc_max_request_raw() {
            255 => Id757difDebugDifTcMaxRequest::Sna,
            x => Id757difDebugDifTcMaxRequest::Other(x),
        }
    }
    
    /// Get raw value of DIF_tcMaxRequest
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tc_max_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tcMaxRequest
    #[inline(always)]
    pub fn set_dif_tc_max_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1275_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// DIF_tcMinRequest
    ///
    /// - Min: 0
    /// - Max: 1275
    /// - Unit: "Nm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tc_min_request(&self) -> Id757difDebugDifTcMinRequest {
        match self.dif_tc_min_request_raw() {
            255 => Id757difDebugDifTcMinRequest::Sna,
            x => Id757difDebugDifTcMinRequest::Other(x),
        }
    }
    
    /// Get raw value of DIF_tcMinRequest
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tc_min_request_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tcMinRequest
    #[inline(always)]
    pub fn set_dif_tc_min_request(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1275_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// DIF_torquePerAmp
    ///
    /// - Min: 0
    /// - Max: 6.5535
    /// - Unit: "Nm/A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_torque_per_amp(&self) -> f32 {
        self.dif_torque_per_amp_raw()
    }
    
    /// Get raw value of DIF_torquePerAmp
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_torque_per_amp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_torquePerAmp
    #[inline(always)]
    pub fn set_dif_torque_per_amp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6.5535_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_tqSatMotorCurrent
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_sat_motor_current(&self) -> f32 {
        self.dif_tq_sat_motor_current_raw()
    }
    
    /// Get raw value of DIF_tqSatMotorCurrent
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_sat_motor_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqSatMotorCurrent
    #[inline(always)]
    pub fn set_dif_tq_sat_motor_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_tqSatMotorVoltage
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_sat_motor_voltage(&self) -> f32 {
        self.dif_tq_sat_motor_voltage_raw()
    }
    
    /// Get raw value of DIF_tqSatMotorVoltage
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_sat_motor_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqSatMotorVoltage
    #[inline(always)]
    pub fn set_dif_tq_sat_motor_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_tqSatThermal
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_sat_thermal(&self) -> f32 {
        self.dif_tq_sat_thermal_raw()
    }
    
    /// Get raw value of DIF_tqSatThermal
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_sat_thermal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqSatThermal
    #[inline(always)]
    pub fn set_dif_tq_sat_thermal(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_tqSatUiDriveTorque
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_sat_ui_drive_torque(&self) -> f32 {
        self.dif_tq_sat_ui_drive_torque_raw()
    }
    
    /// Get raw value of DIF_tqSatUiDriveTorque
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_sat_ui_drive_torque_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqSatUiDriveTorque
    #[inline(always)]
    pub fn set_dif_tq_sat_ui_drive_torque(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DIF_tqSatUiRegenTorque
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_sat_ui_regen_torque(&self) -> f32 {
        self.dif_tq_sat_ui_regen_torque_raw()
    }
    
    /// Get raw value of DIF_tqSatUiRegenTorque
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_sat_ui_regen_torque_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqSatUiRegenTorque
    #[inline(always)]
    pub fn set_dif_tq_sat_ui_regen_torque(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_tqScaleDifferential
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_scale_differential(&self) -> f32 {
        self.dif_tq_scale_differential_raw()
    }
    
    /// Get raw value of DIF_tqScaleDifferential
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_scale_differential_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqScaleDifferential
    #[inline(always)]
    pub fn set_dif_tq_scale_differential(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DIF_tqScaleMaxMotorSpeed
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_scale_max_motor_speed(&self) -> f32 {
        self.dif_tq_scale_max_motor_speed_raw()
    }
    
    /// Get raw value of DIF_tqScaleMaxMotorSpeed
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_scale_max_motor_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqScaleMaxMotorSpeed
    #[inline(always)]
    pub fn set_dif_tq_scale_max_motor_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// DIF_tqScaleShift
    ///
    /// - Min: 0
    /// - Max: 102
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_tq_scale_shift(&self) -> f32 {
        self.dif_tq_scale_shift_raw()
    }
    
    /// Get raw value of DIF_tqScaleShift
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_tq_scale_shift_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_tqScaleShift
    #[inline(always)]
    pub fn set_dif_tq_scale_shift(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// DIF_udsStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_uds_stack(&self) -> f32 {
        self.dif_uds_stack_raw()
    }
    
    /// Get raw value of DIF_udsStack
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_uds_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_udsStack
    #[inline(always)]
    pub fn set_dif_uds_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// DIF_usmState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_usm_state(&self) -> Id757difDebugDifUsmState {
        match self.dif_usm_state_raw() {
            3 => Id757difDebugDifUsmState::UsmStateAbort,
            4 => Id757difDebugDifUsmState::UsmStateEnable,
            5 => Id757difDebugDifUsmState::UsmStateFault,
            2 => Id757difDebugDifUsmState::UsmStateRetry,
            1 => Id757difDebugDifUsmState::UsmStateStandby,
            0 => Id757difDebugDifUsmState::UsmStateStart,
            6 => Id757difDebugDifUsmState::UsmStateUnavailable,
            7 => Id757difDebugDifUsmState::UsmStateWaitForRetry,
            x => Id757difDebugDifUsmState::Other(x),
        }
    }
    
    /// Get raw value of DIF_usmState
    ///
    /// - Start bit: 12
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_usm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DIF_usmState
    #[inline(always)]
    pub fn set_dif_usm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..15].store_le(value);
        Ok(())
    }
    
    /// DIF_veMassInvRaw
    ///
    /// - Min: 0.0001
    /// - Max: 0.0005
    /// - Unit: "1/kg"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_ve_mass_inv_raw(&self) -> f32 {
        self.dif_ve_mass_inv_raw_raw()
    }
    
    /// Get raw value of DIF_veMassInvRaw
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.0000001
    /// - Offset: 0.0001
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_ve_mass_inv_raw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..20].load_le::<u16>();
        
        let factor = 0.0000001_f32;
        let offset = 0.0001_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_veMassInvRaw
    #[inline(always)]
    pub fn set_dif_ve_mass_inv_raw(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0.0001_f32 || 0.0005_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0000001_f32;
        let offset = 0.0001_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..20].store_le(value);
        Ok(())
    }
    
    /// DIF_veResForce
    ///
    /// - Min: -1.024
    /// - Max: 1.0235
    /// - Unit: "G"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_ve_res_force(&self) -> f32 {
        self.dif_ve_res_force_raw()
    }
    
    /// Get raw value of DIF_veResForce
    ///
    /// - Start bit: 20
    /// - Signal size: 12 bits
    /// - Factor: 0.0005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn dif_ve_res_force_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..32].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.0005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_veResForce
    #[inline(always)]
    pub fn set_dif_ve_res_force(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1.024_f32 || 1.0235_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.0005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[20..32].store_le(value);
        Ok(())
    }
    
    /// DIF_wasteCurrentLimit
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_waste_current_limit(&self) -> f32 {
        self.dif_waste_current_limit_raw()
    }
    
    /// Get raw value of DIF_wasteCurrentLimit
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_waste_current_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_wasteCurrentLimit
    #[inline(always)]
    pub fn set_dif_waste_current_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
    /// DIF_xcpStack
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn dif_xcp_stack(&self) -> f32 {
        self.dif_xcp_stack_raw()
    }
    
    /// Get raw value of DIF_xcpStack
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dif_xcp_stack_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of DIF_xcpStack
    #[inline(always)]
    pub fn set_dif_xcp_stack(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 1879 }); }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id757difDebug {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id757difDebug
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let dif_debug_selector = u.int_in_range(0..=255)?;
        let dif_brake_switch_nc = u.int_in_range(0..=1)? == 1;
        let dif_brake_switch_no = u.int_in_range(0..=1)? == 1;
        let dif_busbar_temp = -40_f32;
        let dif_control_stack = 0_f32;
        let dif_cpu100_hz_avg = 0_f32;
        let dif_cpu100_hz_min = 0_f32;
        let dif_cpu10_hz_avg = 0_f32;
        let dif_cpu10_hz_min = 0_f32;
        let dif_cpu10ms_min = 0_f32;
        let dif_cpu1_hz_avg = 0_f32;
        let dif_cpu1_hz_min = 0_f32;
        let dif_cpu1k_hz_avg = 0_f32;
        let dif_cpu1k_hz_min = 0_f32;
        let dif_cpu20k_hz_avg = 0_f32;
        let dif_cpu20k_hz_min = 0_f32;
        let dif_cpu_id_word0 = u.int_in_range(0..=65535)?;
        let dif_cpu_id_word1 = u.int_in_range(0..=65535)?;
        let dif_cpu_id_word2 = u.int_in_range(0..=65535)?;
        let dif_cpu_id_word3 = u.int_in_range(0..=65535)?;
        let dif_crc = u.int_in_range(0..=4294970000)?;
        let dif_current_limit = 0_f32;
        let dif_dc_cable_current_est = -3276.8_f32;
        let dif_dc_cable_heat = 0_f32;
        let dif_dc_cap_temp = -40_f32;
        let dif_dc_link_cap_temp = -40_f32;
        let dif_decode_hardware_stack = 0_f32;
        let dif_drive_unit_odometer = 0_f32;
        let dif_eeprom_stack = 0_f32;
        let dif_flux_state = u.int_in_range(0..=10)?;
        let dif_gain_scale = 0_f32;
        let dif_gate_drive_state = u.int_in_range(0..=4)?;
        let dif_gate_drive_supply_state = u.int_in_range(0..=3)?;
        let dif_hv_dc_cable_temp = -40_f32;
        let dif_hw_fault_count = u.int_in_range(0..=15)?;
        let dif_idle_stack = 0_f32;
        let dif_immobilizer_stack = 0_f32;
        let dif_internal_angle_filt = 0_f32;
        let dif_llr_scale = 0_f32;
        let dif_lls_scale = 0_f32;
        let dif_lm_scale = 0_f32;
        let dif_load_angle = -4_f32;
        let dif_load_angle_margin = -4_f32;
        let dif_magnet_temp_est = -40_f32;
        let dif_module10_hz_stack = 0_f32;
        let dif_motor_ia = 0_f32;
        let dif_motor_i_aavg = -3276.8_f32;
        let dif_motor_ib = 0_f32;
        let dif_motor_i_bavg = -3276.8_f32;
        let dif_motor_ic = 0_f32;
        let dif_motor_type = u.int_in_range(0..=32)?;
        let dif_motor_v = 0_f32;
        let dif_neg_dc_busbar_temp = -40_f32;
        let dif_offset_a = -12.8_f32;
        let dif_offset_b = -12.8_f32;
        let dif_oil_pump_motor_speed = 0_f32;
        let dif_oil_pump_phase_voltage = 0_f32;
        let dif_oil_pump_pressure_estimate_max = 0_f32;
        let dif_oil_pump_pressure_expected_min = 0_f32;
        let dif_pcs_temp = -40_f32;
        let dif_peak_flux = 0_f32;
        let dif_peak_i_qref = 0_f32;
        let dif_phase_out_busbar_temp = -40_f32;
        let dif_phase_out_busbar_weld_temp = -40_f32;
        let dif_phase_out_lug_temp = -40_f32;
        let dif_pos_dc_busbar_temp = -40_f32;
        let dif_power_stage_safe_state = u.int_in_range(0..=3)?;
        let dif_pwm_state = u.int_in_range(0..=3)?;
        let dif_pwr_sat_charge_current = 0_f32;
        let dif_pwr_sat_discharge_current = 0_f32;
        let dif_pwr_sat_max_bus_voltage = 0_f32;
        let dif_pwr_sat_max_discharge_power = 0_f32;
        let dif_pwr_sat_max_regen_power = 0_f32;
        let dif_pwr_sat_min_bus_voltage = 0_f32;
        let dif_resolver_cla_mia = u.int_in_range(0..=1)? == 1;
        let dif_resolver_common_gain = 0_f32;
        let dif_resolver_cos_filtered = -1_f32;
        let dif_resolver_cos_rms_squared = 0_f32;
        let dif_resolver_error_rms_squared = 0_f32;
        let dif_resolver_no_carrier = u.int_in_range(0..=1)? == 1;
        let dif_resolver_no_phase_lock = u.int_in_range(0..=1)? == 1;
        let dif_resolver_offset_cos = 0_f32;
        let dif_resolver_offset_sin = 0_f32;
        let dif_resolver_phase_offset = 7.5_f32;
        let dif_resolver_ready = u.int_in_range(0..=1)? == 1;
        let dif_resolver_sin_filtered = -1_f32;
        let dif_resolver_sin_rms_squared = 0_f32;
        let dif_rotor_flux = 0_f32;
        let dif_rotor_max_magnet_temp = -40_f32;
        let dif_rotor_offset_est = -20_f32;
        let dif_rotor_offset_learning_state = u.int_in_range(0..=9)?;
        let dif_rotor_offset_mean = -20_f32;
        let dif_rs_scale = 0_f32;
        let dif_sopt_max_current_mag_sqrd = 0_f32;
        let dif_sopt_time_to_off = 0_f32;
        let dif_sopt_time_to_trip = 0_f32;
        let dif_sopt_trip_delay = 0_f32;
        let dif_ssm_state = u.int_in_range(0..=8)?;
        let dif_stator_end_winding_temp = -40_f32;
        let dif_stator_flux_fdb = 0_f32;
        let dif_stator_flux_ref = 0_f32;
        let dif_stator_i_dfdb = -3276.8_f32;
        let dif_stator_i_dref = -3276.8_f32;
        let dif_stator_i_qfdb = -3276.8_f32;
        let dif_stator_i_qref = -3276.8_f32;
        let dif_stator_temp1 = -40_f32;
        let dif_stator_temp2 = -40_f32;
        let dif_stator_vd = -1.31072_f32;
        let dif_stator_vd_filtered = -1.31072_f32;
        let dif_stator_vq = -1.31072_f32;
        let dif_stator_vq_filtered = -1.31072_f32;
        let dif_sys_heat_power_optimal = 0_f32;
        let dif_system_stack = 0_f32;
        let dif_system_torque_command = -1146.88_f32;
        let dif_tc_max_request = 0_f32;
        let dif_tc_min_request = 0_f32;
        let dif_torque_per_amp = 0_f32;
        let dif_tq_sat_motor_current = 0_f32;
        let dif_tq_sat_motor_voltage = 0_f32;
        let dif_tq_sat_thermal = 0_f32;
        let dif_tq_sat_ui_drive_torque = 0_f32;
        let dif_tq_sat_ui_regen_torque = 0_f32;
        let dif_tq_scale_differential = 0_f32;
        let dif_tq_scale_max_motor_speed = 0_f32;
        let dif_tq_scale_shift = 0_f32;
        let dif_uds_stack = 0_f32;
        let dif_usm_state = u.int_in_range(0..=7)?;
        let dif_ve_mass_inv_raw = 0.0001_f32;
        let dif_ve_res_force = -1.024_f32;
        let dif_waste_current_limit = 0_f32;
        let dif_xcp_stack = 0_f32;
        Id757difDebug::new(dif_debug_selector,dif_brake_switch_nc,dif_brake_switch_no,dif_busbar_temp,dif_control_stack,dif_cpu100_hz_avg,dif_cpu100_hz_min,dif_cpu10_hz_avg,dif_cpu10_hz_min,dif_cpu10ms_min,dif_cpu1_hz_avg,dif_cpu1_hz_min,dif_cpu1k_hz_avg,dif_cpu1k_hz_min,dif_cpu20k_hz_avg,dif_cpu20k_hz_min,dif_cpu_id_word0,dif_cpu_id_word1,dif_cpu_id_word2,dif_cpu_id_word3,dif_crc,dif_current_limit,dif_dc_cable_current_est,dif_dc_cable_heat,dif_dc_cap_temp,dif_dc_link_cap_temp,dif_decode_hardware_stack,dif_drive_unit_odometer,dif_eeprom_stack,dif_flux_state,dif_gain_scale,dif_gate_drive_state,dif_gate_drive_supply_state,dif_hv_dc_cable_temp,dif_hw_fault_count,dif_idle_stack,dif_immobilizer_stack,dif_internal_angle_filt,dif_llr_scale,dif_lls_scale,dif_lm_scale,dif_load_angle,dif_load_angle_margin,dif_magnet_temp_est,dif_module10_hz_stack,dif_motor_ia,dif_motor_i_aavg,dif_motor_ib,dif_motor_i_bavg,dif_motor_ic,dif_motor_type,dif_motor_v,dif_neg_dc_busbar_temp,dif_offset_a,dif_offset_b,dif_oil_pump_motor_speed,dif_oil_pump_phase_voltage,dif_oil_pump_pressure_estimate_max,dif_oil_pump_pressure_expected_min,dif_pcs_temp,dif_peak_flux,dif_peak_i_qref,dif_phase_out_busbar_temp,dif_phase_out_busbar_weld_temp,dif_phase_out_lug_temp,dif_pos_dc_busbar_temp,dif_power_stage_safe_state,dif_pwm_state,dif_pwr_sat_charge_current,dif_pwr_sat_discharge_current,dif_pwr_sat_max_bus_voltage,dif_pwr_sat_max_discharge_power,dif_pwr_sat_max_regen_power,dif_pwr_sat_min_bus_voltage,dif_resolver_cla_mia,dif_resolver_common_gain,dif_resolver_cos_filtered,dif_resolver_cos_rms_squared,dif_resolver_error_rms_squared,dif_resolver_no_carrier,dif_resolver_no_phase_lock,dif_resolver_offset_cos,dif_resolver_offset_sin,dif_resolver_phase_offset,dif_resolver_ready,dif_resolver_sin_filtered,dif_resolver_sin_rms_squared,dif_rotor_flux,dif_rotor_max_magnet_temp,dif_rotor_offset_est,dif_rotor_offset_learning_state,dif_rotor_offset_mean,dif_rs_scale,dif_sopt_max_current_mag_sqrd,dif_sopt_time_to_off,dif_sopt_time_to_trip,dif_sopt_trip_delay,dif_ssm_state,dif_stator_end_winding_temp,dif_stator_flux_fdb,dif_stator_flux_ref,dif_stator_i_dfdb,dif_stator_i_dref,dif_stator_i_qfdb,dif_stator_i_qref,dif_stator_temp1,dif_stator_temp2,dif_stator_vd,dif_stator_vd_filtered,dif_stator_vq,dif_stator_vq_filtered,dif_sys_heat_power_optimal,dif_system_stack,dif_system_torque_command,dif_tc_max_request,dif_tc_min_request,dif_torque_per_amp,dif_tq_sat_motor_current,dif_tq_sat_motor_voltage,dif_tq_sat_thermal,dif_tq_sat_ui_drive_torque,dif_tq_sat_ui_regen_torque,dif_tq_scale_differential,dif_tq_scale_max_motor_speed,dif_tq_scale_shift,dif_uds_stack,dif_usm_state,dif_ve_mass_inv_raw,dif_ve_res_force,dif_waste_current_limit,dif_xcp_stack).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DIF_fluxState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifFluxState {
    DiFluxstateEnabled,
    DiFluxstateFault,
    DiFluxstateFluxDown,
    DiFluxstateFluxUp,
    DiFluxstateIcontrol,
    DiFluxstateStandby,
    DiFluxstateStart,
    DiFluxstateStationaryWaste,
    DiFluxstateTest,
    DiFluxstateVcontrol,
    Other(u8),
}
/// Defined values for DIF_gateDriveState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifGateDriveState {
    PstgGdStateConfigured,
    PstgGdStateConfiguring,
    PstgGdStateInit,
    PstgGdStateNotConfigured,
    PstgGdStateSelftest,
    Other(u8),
}
/// Defined values for DIF_gateDriveSupplyState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifGateDriveSupplyState {
    PstgGdSupplyDown,
    PstgGdSupplyFalling,
    PstgGdSupplyRising,
    PstgGdSupplyUp,
    Other(u8),
}
/// Defined values for DIF_magnetTempEst
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifMagnetTempEst {
    Sna,
    Other(f32),
}
/// Defined values for DIF_motorType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifMotorType {
    DiMotorF1a,
    DiMotorF1ac,
    DiMotorF2ab,
    DiMotorF2ac,
    DiMotorF2ad,
    DiMotorF2ae,
    DiMotorF2aeAl,
    DiMotorF2apmsrm,
    DiMotorIm100a,
    DiMotorIm100b,
    DiMotorIm130c,
    DiMotorIm130d,
    DiMotorIm130dAl,
    DiMotorIm130dAlPosco,
    DiMotorIm216a,
    DiMotorM7m3,
    DiMotorM7m4,
    DiMotorM7m5,
    DiMotorM7m6,
    DiMotorM8a,
    DiMotorPm216a,
    DiMotorPm216b,
    DiMotorPm216c,
    DiMotorPm216csr,
    DiMotorPm216csrN42,
    DiMotorPm216d,
    DiMotorPm228b,
    DiMotorPm275b,
    DiMotorPm350b,
    DiMotorRoadsterBase,
    DiMotorRoadsterSport,
    DiMotorSna,
    DiMotorSsr1a,
    Other(u8),
}
/// Defined values for DIF_oilPumpPhaseVoltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifOilPumpPhaseVoltage {
    Sna,
    Other(f32),
}
/// Defined values for DIF_oilPumpPressureEstimateMax
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifOilPumpPressureEstimateMax {
    Sna,
    Other(f32),
}
/// Defined values for DIF_oilPumpPressureExpectedMin
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifOilPumpPressureExpectedMin {
    Sna,
    Other(f32),
}
/// Defined values for DIF_powerStageSafeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifPowerStageSafeState {
    PstgSafestate3psHigh,
    PstgSafestate3psLow,
    PstgSafestateAllOff,
    PstgSafestateNone,
    Other(u8),
}
/// Defined values for DIF_pwmState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifPwmState {
    PwmstateDpwm2,
    PwmstateOpwm1,
    PwmstateOpwm2,
    PwmstateSvpwm,
    Other(u8),
}
/// Defined values for DIF_rotorOffsetLearningState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifRotorOffsetLearningState {
    RolNumStates,
    RolStateAccelerate,
    RolStateCorrect,
    RolStateDone,
    RolStateInit,
    RolStateMeasure,
    RolStateShift,
    RolStateVerify,
    RolStateWait,
    RolStateWrite,
    Other(u8),
}
/// Defined values for DIF_ssmState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifSsmState {
    SsmStateAbort,
    SsmStateEnable,
    SsmStateFault,
    SsmStateIdle,
    SsmStateRetry,
    SsmStateStandby,
    SsmStateStart,
    SsmStateUnavailable,
    SsmStateWaitForRetry,
    Other(u8),
}
/// Defined values for DIF_tcMaxRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifTcMaxRequest {
    Sna,
    Other(f32),
}
/// Defined values for DIF_tcMinRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifTcMinRequest {
    Sna,
    Other(f32),
}
/// Defined values for DIF_usmState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id757difDebugDifUsmState {
    UsmStateAbort,
    UsmStateEnable,
    UsmStateFault,
    UsmStateRetry,
    UsmStateStandby,
    UsmStateStart,
    UsmStateUnavailable,
    UsmStateWaitForRetry,
    Other(u8),
}

/// ID2B6DI_chassisControlStatus
///
/// - ID: 694 (0x2b6)
/// - Size: 2 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2b6diChassisControlStatus {
    raw: [u8; 2],
}

impl Id2b6diChassisControlStatus {
    pub const MESSAGE_ID: u32 = 694;
    
    /// Construct new ID2B6DI_chassisControlStatus from values
    pub fn new(di_btc_state_ui: bool, di_ptc_state_ui: u8, di_tc_telltale_flash: bool, di_tc_telltale_on: bool, di_traction_control_mode_ui: u8, di_vdc_telltale_flash: bool, di_vdc_telltale_on: bool, di_vehicle_hold_telltale_on: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_di_btc_state_ui(di_btc_state_ui)?;
        res.set_di_ptc_state_ui(di_ptc_state_ui)?;
        res.set_di_tc_telltale_flash(di_tc_telltale_flash)?;
        res.set_di_tc_telltale_on(di_tc_telltale_on)?;
        res.set_di_traction_control_mode_ui(di_traction_control_mode_ui)?;
        res.set_di_vdc_telltale_flash(di_vdc_telltale_flash)?;
        res.set_di_vdc_telltale_on(di_vdc_telltale_on)?;
        res.set_di_vehicle_hold_telltale_on(di_vehicle_hold_telltale_on)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// DI_btcStateUI
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_btc_state_ui(&self) -> bool {
        self.di_btc_state_ui_raw()
    }
    
    /// Get raw value of DI_btcStateUI
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_btc_state_ui_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_btcStateUI
    #[inline(always)]
    pub fn set_di_btc_state_ui(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// DI_ptcStateUI
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_ptc_state_ui(&self) -> Id2b6diChassisControlStatusDiPtcStateUi {
        match self.di_ptc_state_ui_raw() {
            0 => Id2b6diChassisControlStatusDiPtcStateUi::Faulted,
            1 => Id2b6diChassisControlStatusDiPtcStateUi::Backup,
            2 => Id2b6diChassisControlStatusDiPtcStateUi::On,
            3 => Id2b6diChassisControlStatusDiPtcStateUi::Sna,
            x => Id2b6diChassisControlStatusDiPtcStateUi::Other(x),
        }
    }
    
    /// Get raw value of DI_ptcStateUI
    ///
    /// - Start bit: 7
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_ptc_state_ui_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[7..9].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DI_ptcStateUI
    #[inline(always)]
    pub fn set_di_ptc_state_ui(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 694 }); }
        self.raw.view_bits_mut::<LocalBits>()[7..9].store_le(value);
        Ok(())
    }
    
    /// DI_tcTelltaleFlash
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_tc_telltale_flash(&self) -> bool {
        self.di_tc_telltale_flash_raw()
    }
    
    /// Get raw value of DI_tcTelltaleFlash
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_tc_telltale_flash_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_tcTelltaleFlash
    #[inline(always)]
    pub fn set_di_tc_telltale_flash(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// DI_tcTelltaleOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_tc_telltale_on(&self) -> bool {
        self.di_tc_telltale_on_raw()
    }
    
    /// Get raw value of DI_tcTelltaleOn
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_tc_telltale_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_tcTelltaleOn
    #[inline(always)]
    pub fn set_di_tc_telltale_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// DI_tractionControlModeUI
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_traction_control_mode_ui(&self) -> Id2b6diChassisControlStatusDiTractionControlModeUi {
        match self.di_traction_control_mode_ui_raw() {
            0 => Id2b6diChassisControlStatusDiTractionControlModeUi::Normal,
            1 => Id2b6diChassisControlStatusDiTractionControlModeUi::SlipStart,
            2 => Id2b6diChassisControlStatusDiTractionControlModeUi::DevMode1,
            3 => Id2b6diChassisControlStatusDiTractionControlModeUi::DevMode2,
            4 => Id2b6diChassisControlStatusDiTractionControlModeUi::RollsMode,
            5 => Id2b6diChassisControlStatusDiTractionControlModeUi::DynoMode,
            6 => Id2b6diChassisControlStatusDiTractionControlModeUi::OffroadAssist,
            x => Id2b6diChassisControlStatusDiTractionControlModeUi::Other(x),
        }
    }
    
    /// Get raw value of DI_tractionControlModeUI
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_traction_control_mode_ui_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DI_tractionControlModeUI
    #[inline(always)]
    pub fn set_di_traction_control_mode_ui(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 694 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..7].store_le(value);
        Ok(())
    }
    
    /// DI_vdcTelltaleFlash
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_vdc_telltale_flash(&self) -> bool {
        self.di_vdc_telltale_flash_raw()
    }
    
    /// Get raw value of DI_vdcTelltaleFlash
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_vdc_telltale_flash_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_vdcTelltaleFlash
    #[inline(always)]
    pub fn set_di_vdc_telltale_flash(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// DI_vdcTelltaleOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_vdc_telltale_on(&self) -> bool {
        self.di_vdc_telltale_on_raw()
    }
    
    /// Get raw value of DI_vdcTelltaleOn
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_vdc_telltale_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_vdcTelltaleOn
    #[inline(always)]
    pub fn set_di_vdc_telltale_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// DI_vehicleHoldTelltaleOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn di_vehicle_hold_telltale_on(&self) -> bool {
        self.di_vehicle_hold_telltale_on_raw()
    }
    
    /// Get raw value of DI_vehicleHoldTelltaleOn
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn di_vehicle_hold_telltale_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DI_vehicleHoldTelltaleOn
    #[inline(always)]
    pub fn set_di_vehicle_hold_telltale_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2b6diChassisControlStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2b6diChassisControlStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let di_btc_state_ui = u.int_in_range(0..=1)? == 1;
        let di_ptc_state_ui = u.int_in_range(0..=3)?;
        let di_tc_telltale_flash = u.int_in_range(0..=1)? == 1;
        let di_tc_telltale_on = u.int_in_range(0..=1)? == 1;
        let di_traction_control_mode_ui = u.int_in_range(0..=6)?;
        let di_vdc_telltale_flash = u.int_in_range(0..=1)? == 1;
        let di_vdc_telltale_on = u.int_in_range(0..=1)? == 1;
        let di_vehicle_hold_telltale_on = u.int_in_range(0..=1)? == 1;
        Id2b6diChassisControlStatus::new(di_btc_state_ui,di_ptc_state_ui,di_tc_telltale_flash,di_tc_telltale_on,di_traction_control_mode_ui,di_vdc_telltale_flash,di_vdc_telltale_on,di_vehicle_hold_telltale_on).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for DI_ptcStateUI
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b6diChassisControlStatusDiPtcStateUi {
    Faulted,
    Backup,
    On,
    Sna,
    Other(u8),
}
/// Defined values for DI_tractionControlModeUI
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2b6diChassisControlStatusDiTractionControlModeUi {
    Normal,
    SlipStart,
    DevMode1,
    DevMode2,
    RollsMode,
    DynoMode,
    OffroadAssist,
    Other(u8),
}

/// ID284UIvehicleModes
///
/// - ID: 644 (0x284)
/// - Size: 5 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id284uIvehicleModes {
    raw: [u8; 5],
}

impl Id284uIvehicleModes {
    pub const MESSAGE_ID: u32 = 644;
    
    /// Construct new ID284UIvehicleModes from values
    pub fn new(u_ifactory_mode284: bool, u_ihomelink_v2_command0284: u8, u_ihomelink_v2_command1284: u8, u_ihomelink_v2_command2284: u8, u_iservice_mode284: bool, u_ishowroom_mode284: bool, u_itransport_mode284: bool, u_igame_mode284: bool, u_iis_delivered284: bool, u_icar_wash_mode_request284: bool, u_ivalet_mode284: bool, u_isentry_mode284: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_u_ifactory_mode284(u_ifactory_mode284)?;
        res.set_u_ihomelink_v2_command0284(u_ihomelink_v2_command0284)?;
        res.set_u_ihomelink_v2_command1284(u_ihomelink_v2_command1284)?;
        res.set_u_ihomelink_v2_command2284(u_ihomelink_v2_command2284)?;
        res.set_u_iservice_mode284(u_iservice_mode284)?;
        res.set_u_ishowroom_mode284(u_ishowroom_mode284)?;
        res.set_u_itransport_mode284(u_itransport_mode284)?;
        res.set_u_igame_mode284(u_igame_mode284)?;
        res.set_u_iis_delivered284(u_iis_delivered284)?;
        res.set_u_icar_wash_mode_request284(u_icar_wash_mode_request284)?;
        res.set_u_ivalet_mode284(u_ivalet_mode284)?;
        res.set_u_isentry_mode284(u_isentry_mode284)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UIfactoryMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_ifactory_mode284(&self) -> bool {
        self.u_ifactory_mode284_raw()
    }
    
    /// Get raw value of UIfactoryMode284
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_ifactory_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIfactoryMode284
    #[inline(always)]
    pub fn set_u_ifactory_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[0..1].store_le(value);
        Ok(())
    }
    
    /// UIhomelinkV2Command0284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_ihomelink_v2_command0284(&self) -> u8 {
        self.u_ihomelink_v2_command0284_raw()
    }
    
    /// Get raw value of UIhomelinkV2Command0284
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_ihomelink_v2_command0284_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UIhomelinkV2Command0284
    #[inline(always)]
    pub fn set_u_ihomelink_v2_command0284(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 644 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// UIhomelinkV2Command1284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_ihomelink_v2_command1284(&self) -> u8 {
        self.u_ihomelink_v2_command1284_raw()
    }
    
    /// Get raw value of UIhomelinkV2Command1284
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_ihomelink_v2_command1284_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UIhomelinkV2Command1284
    #[inline(always)]
    pub fn set_u_ihomelink_v2_command1284(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 644 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// UIhomelinkV2Command2284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_ihomelink_v2_command2284(&self) -> u8 {
        self.u_ihomelink_v2_command2284_raw()
    }
    
    /// Get raw value of UIhomelinkV2Command2284
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_ihomelink_v2_command2284_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UIhomelinkV2Command2284
    #[inline(always)]
    pub fn set_u_ihomelink_v2_command2284(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 644 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// UIserviceMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_iservice_mode284(&self) -> bool {
        self.u_iservice_mode284_raw()
    }
    
    /// Get raw value of UIserviceMode284
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_iservice_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIserviceMode284
    #[inline(always)]
    pub fn set_u_iservice_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// UIshowroomMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_ishowroom_mode284(&self) -> bool {
        self.u_ishowroom_mode284_raw()
    }
    
    /// Get raw value of UIshowroomMode284
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_ishowroom_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIshowroomMode284
    #[inline(always)]
    pub fn set_u_ishowroom_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[2..3].store_le(value);
        Ok(())
    }
    
    /// UItransportMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_itransport_mode284(&self) -> bool {
        self.u_itransport_mode284_raw()
    }
    
    /// Get raw value of UItransportMode284
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_itransport_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UItransportMode284
    #[inline(always)]
    pub fn set_u_itransport_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[1..2].store_le(value);
        Ok(())
    }
    
    /// UIgameMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_igame_mode284(&self) -> bool {
        self.u_igame_mode284_raw()
    }
    
    /// Get raw value of UIgameMode284
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_igame_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIgameMode284
    #[inline(always)]
    pub fn set_u_igame_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[34..35].store_le(value);
        Ok(())
    }
    
    /// UIisDelivered284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_iis_delivered284(&self) -> bool {
        self.u_iis_delivered284_raw()
    }
    
    /// Get raw value of UIisDelivered284
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_iis_delivered284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIisDelivered284
    #[inline(always)]
    pub fn set_u_iis_delivered284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// UIcarWashModeRequest284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_icar_wash_mode_request284(&self) -> bool {
        self.u_icar_wash_mode_request284_raw()
    }
    
    /// Get raw value of UIcarWashModeRequest284
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_icar_wash_mode_request284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIcarWashModeRequest284
    #[inline(always)]
    pub fn set_u_icar_wash_mode_request284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[32..33].store_le(value);
        Ok(())
    }
    
    /// UIvaletMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_ivalet_mode284(&self) -> bool {
        self.u_ivalet_mode284_raw()
    }
    
    /// Get raw value of UIvaletMode284
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_ivalet_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIvaletMode284
    #[inline(always)]
    pub fn set_u_ivalet_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[33..34].store_le(value);
        Ok(())
    }
    
    /// UIsentryMode284
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn u_isentry_mode284(&self) -> bool {
        self.u_isentry_mode284_raw()
    }
    
    /// Get raw value of UIsentryMode284
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn u_isentry_mode284_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of UIsentryMode284
    #[inline(always)]
    pub fn set_u_isentry_mode284(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id284uIvehicleModes {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id284uIvehicleModes
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let u_ifactory_mode284 = u.int_in_range(0..=1)? == 1;
        let u_ihomelink_v2_command0284 = u.int_in_range(0..=0)?;
        let u_ihomelink_v2_command1284 = u.int_in_range(0..=0)?;
        let u_ihomelink_v2_command2284 = u.int_in_range(0..=0)?;
        let u_iservice_mode284 = u.int_in_range(0..=1)? == 1;
        let u_ishowroom_mode284 = u.int_in_range(0..=1)? == 1;
        let u_itransport_mode284 = u.int_in_range(0..=1)? == 1;
        let u_igame_mode284 = u.int_in_range(0..=1)? == 1;
        let u_iis_delivered284 = u.int_in_range(0..=1)? == 1;
        let u_icar_wash_mode_request284 = u.int_in_range(0..=1)? == 1;
        let u_ivalet_mode284 = u.int_in_range(0..=1)? == 1;
        let u_isentry_mode284 = u.int_in_range(0..=1)? == 1;
        Id284uIvehicleModes::new(u_ifactory_mode284,u_ihomelink_v2_command0284,u_ihomelink_v2_command1284,u_ihomelink_v2_command2284,u_iservice_mode284,u_ishowroom_mode284,u_itransport_mode284,u_igame_mode284,u_iis_delivered284,u_icar_wash_mode_request284,u_ivalet_mode284,u_isentry_mode284).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID221VCFRONT_LVPowerState
///
/// - ID: 545 (0x221)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id221vcfrontLvPowerState {
    raw: [u8; 8],
}

impl Id221vcfrontLvPowerState {
    pub const MESSAGE_ID: u32 = 545;
    
    /// Construct new ID221VCFRONT_LVPowerState from values
    pub fn new(vcfront_lv_power_state_index: u8, vcfront_cmpdlv_state: u8, vcfront_amplifier_lv_request: u8, vcfront_cp_lv_request: u8, vcfront_das1_high_current_lv_state: u8, vcfront_das2_high_current_lv_state: u8, vcfront_dif_lv_state: u8, vcfront_dir_lv_request: u8, vcfront_epas_lv_state: u8, vcfront_esp_lv_state: u8, vcfront_hvac_comp_lv_state: u8, vcfront_hvc_lv_request: u8, vcfront_i_booster_lv_state: u8, vcfront_ocs_lv_request: u8, vcfront_oil_pump_front_lv_state: u8, vcfront_oil_pump_rear_lv_request: u8, vcfront_park_lv_state: u8, vcfront_pcs_lv_state: u8, vcfront_ptc_lv_request: u8, vcfront_radc_lv_state: u8, vcfront_rcm_lv_request: u8, vcfront_sccm_lv_request: u8, vcfront_tas_lv_state: u8, vcfront_tpms_lv_request: u8, vcfront_tuner_lv_request: u8, vcfront_ui_hi_current_lv_state: u8, vcfront_vcleft_hi_current_lv_state: u8, vcfront_vcright_hi_current_lv_state: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcfront_lv_power_state_index(vcfront_lv_power_state_index)?;
        res.set_vcfront_cmpdlv_state(vcfront_cmpdlv_state)?;
        res.set_vcfront_amplifier_lv_request(vcfront_amplifier_lv_request)?;
        res.set_vcfront_cp_lv_request(vcfront_cp_lv_request)?;
        res.set_vcfront_das1_high_current_lv_state(vcfront_das1_high_current_lv_state)?;
        res.set_vcfront_das2_high_current_lv_state(vcfront_das2_high_current_lv_state)?;
        res.set_vcfront_dif_lv_state(vcfront_dif_lv_state)?;
        res.set_vcfront_dir_lv_request(vcfront_dir_lv_request)?;
        res.set_vcfront_epas_lv_state(vcfront_epas_lv_state)?;
        res.set_vcfront_esp_lv_state(vcfront_esp_lv_state)?;
        res.set_vcfront_hvac_comp_lv_state(vcfront_hvac_comp_lv_state)?;
        res.set_vcfront_hvc_lv_request(vcfront_hvc_lv_request)?;
        res.set_vcfront_i_booster_lv_state(vcfront_i_booster_lv_state)?;
        res.set_vcfront_ocs_lv_request(vcfront_ocs_lv_request)?;
        res.set_vcfront_oil_pump_front_lv_state(vcfront_oil_pump_front_lv_state)?;
        res.set_vcfront_oil_pump_rear_lv_request(vcfront_oil_pump_rear_lv_request)?;
        res.set_vcfront_park_lv_state(vcfront_park_lv_state)?;
        res.set_vcfront_pcs_lv_state(vcfront_pcs_lv_state)?;
        res.set_vcfront_ptc_lv_request(vcfront_ptc_lv_request)?;
        res.set_vcfront_radc_lv_state(vcfront_radc_lv_state)?;
        res.set_vcfront_rcm_lv_request(vcfront_rcm_lv_request)?;
        res.set_vcfront_sccm_lv_request(vcfront_sccm_lv_request)?;
        res.set_vcfront_tas_lv_state(vcfront_tas_lv_state)?;
        res.set_vcfront_tpms_lv_request(vcfront_tpms_lv_request)?;
        res.set_vcfront_tuner_lv_request(vcfront_tuner_lv_request)?;
        res.set_vcfront_ui_hi_current_lv_state(vcfront_ui_hi_current_lv_state)?;
        res.set_vcfront_vcleft_hi_current_lv_state(vcfront_vcleft_hi_current_lv_state)?;
        res.set_vcfront_vcright_hi_current_lv_state(vcfront_vcright_hi_current_lv_state)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_LVPowerStateIndex
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lv_power_state_index(&self) -> Id221vcfrontLvPowerStateVcfrontLvPowerStateIndex {
        match self.vcfront_lv_power_state_index_raw() {
            0 => Id221vcfrontLvPowerStateVcfrontLvPowerStateIndex::Mux0,
            1 => Id221vcfrontLvPowerStateVcfrontLvPowerStateIndex::Mux1,
            x => Id221vcfrontLvPowerStateVcfrontLvPowerStateIndex::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_LVPowerStateIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_lv_power_state_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_LVPowerStateIndex
    #[inline(always)]
    pub fn set_vcfront_lv_power_state_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..5].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_CMPDLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cmpdlv_state(&self) -> Id221vcfrontLvPowerStateVcfrontCmpdlvState {
        match self.vcfront_cmpdlv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontCmpdlvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontCmpdlvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontCmpdlvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontCmpdlvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontCmpdlvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_CMPDLVState
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cmpdlv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_CMPDLVState
    #[inline(always)]
    pub fn set_vcfront_cmpdlv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_amplifierLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_amplifier_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest {
        match self.vcfront_amplifier_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_amplifierLVRequest
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_amplifier_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_amplifierLVRequest
    #[inline(always)]
    pub fn set_vcfront_amplifier_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..30].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_cpLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cp_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontCpLvRequest {
        match self.vcfront_cp_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontCpLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontCpLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontCpLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontCpLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontCpLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_cpLVRequest
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cp_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_cpLVRequest
    #[inline(always)]
    pub fn set_vcfront_cp_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_das1HighCurrentLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_das1_high_current_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState {
        match self.vcfront_das1_high_current_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_das1HighCurrentLVState
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_das1_high_current_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_das1HighCurrentLVState
    #[inline(always)]
    pub fn set_vcfront_das1_high_current_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[30..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_das2HighCurrentLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_das2_high_current_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState {
        match self.vcfront_das2_high_current_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_das2HighCurrentLVState
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_das2_high_current_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_das2HighCurrentLVState
    #[inline(always)]
    pub fn set_vcfront_das2_high_current_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..34].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_difLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_dif_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontDifLvState {
        match self.vcfront_dif_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontDifLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontDifLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontDifLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontDifLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontDifLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_difLVState
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_dif_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_difLVState
    #[inline(always)]
    pub fn set_vcfront_dif_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..38].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_dirLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_dir_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontDirLvRequest {
        match self.vcfront_dir_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontDirLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontDirLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontDirLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontDirLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontDirLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_dirLVRequest
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_dir_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_dirLVRequest
    #[inline(always)]
    pub fn set_vcfront_dir_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[34..36].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_epasLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontEpasLvState {
        match self.vcfront_epas_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontEpasLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontEpasLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontEpasLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontEpasLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontEpasLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_epasLVState
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_epasLVState
    #[inline(always)]
    pub fn set_vcfront_epas_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_espLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontEspLvState {
        match self.vcfront_esp_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontEspLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontEspLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontEspLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontEspLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontEspLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_espLVState
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_espLVState
    #[inline(always)]
    pub fn set_vcfront_esp_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hvacCompLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hvac_comp_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontHvacCompLvState {
        match self.vcfront_hvac_comp_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontHvacCompLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontHvacCompLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontHvacCompLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontHvacCompLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontHvacCompLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_hvacCompLVState
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hvac_comp_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hvacCompLVState
    #[inline(always)]
    pub fn set_vcfront_hvac_comp_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hvcLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hvc_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontHvcLvRequest {
        match self.vcfront_hvc_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontHvcLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontHvcLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontHvcLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontHvcLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontHvcLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_hvcLVRequest
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hvc_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hvcLVRequest
    #[inline(always)]
    pub fn set_vcfront_hvc_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontIBoosterLvState {
        match self.vcfront_i_booster_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontIBoosterLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontIBoosterLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontIBoosterLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontIBoosterLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontIBoosterLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_iBoosterLVState
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_iBoosterLVState
    #[inline(always)]
    pub fn set_vcfront_i_booster_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ocsLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ocs_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontOcsLvRequest {
        match self.vcfront_ocs_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontOcsLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontOcsLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontOcsLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontOcsLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontOcsLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_ocsLVRequest
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ocs_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_ocsLVRequest
    #[inline(always)]
    pub fn set_vcfront_ocs_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_oilPumpFrontLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_oil_pump_front_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState {
        match self.vcfront_oil_pump_front_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_oilPumpFrontLVState
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_oil_pump_front_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_oilPumpFrontLVState
    #[inline(always)]
    pub fn set_vcfront_oil_pump_front_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_oilPumpRearLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_oil_pump_rear_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest {
        match self.vcfront_oil_pump_rear_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_oilPumpRearLVRequest
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_oil_pump_rear_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_oilPumpRearLVRequest
    #[inline(always)]
    pub fn set_vcfront_oil_pump_rear_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_parkLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_park_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontParkLvState {
        match self.vcfront_park_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontParkLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontParkLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontParkLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontParkLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontParkLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_parkLVState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_park_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_parkLVState
    #[inline(always)]
    pub fn set_vcfront_park_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pcsLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontPcsLvState {
        match self.vcfront_pcs_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontPcsLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontPcsLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontPcsLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontPcsLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontPcsLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pcsLVState
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_pcsLVState
    #[inline(always)]
    pub fn set_vcfront_pcs_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ptcLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ptc_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontPtcLvRequest {
        match self.vcfront_ptc_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontPtcLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontPtcLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontPtcLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontPtcLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontPtcLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_ptcLVRequest
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ptc_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_ptcLVRequest
    #[inline(always)]
    pub fn set_vcfront_ptc_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..18].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radcLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_radc_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontRadcLvState {
        match self.vcfront_radc_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontRadcLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontRadcLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontRadcLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontRadcLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontRadcLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_radcLVState
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_radc_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_radcLVState
    #[inline(always)]
    pub fn set_vcfront_radc_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_rcmLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rcm_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontRcmLvRequest {
        match self.vcfront_rcm_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontRcmLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontRcmLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontRcmLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontRcmLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontRcmLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_rcmLVRequest
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rcm_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_rcmLVRequest
    #[inline(always)]
    pub fn set_vcfront_rcm_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sccmLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sccm_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontSccmLvRequest {
        match self.vcfront_sccm_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontSccmLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontSccmLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontSccmLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontSccmLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontSccmLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_sccmLVRequest
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_sccm_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_sccmLVRequest
    #[inline(always)]
    pub fn set_vcfront_sccm_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tasLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_tas_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontTasLvState {
        match self.vcfront_tas_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontTasLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontTasLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontTasLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontTasLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontTasLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_tasLVState
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_tas_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_tasLVState
    #[inline(always)]
    pub fn set_vcfront_tas_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tpmsLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_tpms_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontTpmsLvRequest {
        match self.vcfront_tpms_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontTpmsLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontTpmsLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontTpmsLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontTpmsLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontTpmsLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_tpmsLVRequest
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_tpms_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_tpmsLVRequest
    #[inline(always)]
    pub fn set_vcfront_tpms_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tunerLVRequest
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_tuner_lv_request(&self) -> Id221vcfrontLvPowerStateVcfrontTunerLvRequest {
        match self.vcfront_tuner_lv_request_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontTunerLvRequest::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontTunerLvRequest::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontTunerLvRequest::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontTunerLvRequest::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontTunerLvRequest::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_tunerLVRequest
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_tuner_lv_request_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_tunerLVRequest
    #[inline(always)]
    pub fn set_vcfront_tuner_lv_request(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiHiCurrentLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_hi_current_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState {
        match self.vcfront_ui_hi_current_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_uiHiCurrentLVState
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_hi_current_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_uiHiCurrentLVState
    #[inline(always)]
    pub fn set_vcfront_ui_hi_current_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vcleftHiCurrentLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vcleft_hi_current_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState {
        match self.vcfront_vcleft_hi_current_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vcleftHiCurrentLVState
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vcleft_hi_current_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vcleftHiCurrentLVState
    #[inline(always)]
    pub fn set_vcfront_vcleft_hi_current_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..46].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vcrightHiCurrentLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vcright_hi_current_lv_state(&self) -> Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState {
        match self.vcfront_vcright_hi_current_lv_state_raw() {
            3 => Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState::LvFault,
            2 => Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState::LvGoingDown,
            0 => Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState::LvOff,
            1 => Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState::LvOn,
            x => Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vcrightHiCurrentLVState
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vcright_hi_current_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vcrightHiCurrentLVState
    #[inline(always)]
    pub fn set_vcfront_vcright_hi_current_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 545 }); }
        self.raw.view_bits_mut::<LocalBits>()[46..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id221vcfrontLvPowerState {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id221vcfrontLvPowerState
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_lv_power_state_index = u.int_in_range(0..=1)?;
        let vcfront_cmpdlv_state = u.int_in_range(0..=3)?;
        let vcfront_amplifier_lv_request = u.int_in_range(0..=3)?;
        let vcfront_cp_lv_request = u.int_in_range(0..=3)?;
        let vcfront_das1_high_current_lv_state = u.int_in_range(0..=3)?;
        let vcfront_das2_high_current_lv_state = u.int_in_range(0..=3)?;
        let vcfront_dif_lv_state = u.int_in_range(0..=3)?;
        let vcfront_dir_lv_request = u.int_in_range(0..=3)?;
        let vcfront_epas_lv_state = u.int_in_range(0..=3)?;
        let vcfront_esp_lv_state = u.int_in_range(0..=3)?;
        let vcfront_hvac_comp_lv_state = u.int_in_range(0..=3)?;
        let vcfront_hvc_lv_request = u.int_in_range(0..=3)?;
        let vcfront_i_booster_lv_state = u.int_in_range(0..=3)?;
        let vcfront_ocs_lv_request = u.int_in_range(0..=3)?;
        let vcfront_oil_pump_front_lv_state = u.int_in_range(0..=3)?;
        let vcfront_oil_pump_rear_lv_request = u.int_in_range(0..=3)?;
        let vcfront_park_lv_state = u.int_in_range(0..=3)?;
        let vcfront_pcs_lv_state = u.int_in_range(0..=3)?;
        let vcfront_ptc_lv_request = u.int_in_range(0..=3)?;
        let vcfront_radc_lv_state = u.int_in_range(0..=3)?;
        let vcfront_rcm_lv_request = u.int_in_range(0..=3)?;
        let vcfront_sccm_lv_request = u.int_in_range(0..=3)?;
        let vcfront_tas_lv_state = u.int_in_range(0..=3)?;
        let vcfront_tpms_lv_request = u.int_in_range(0..=3)?;
        let vcfront_tuner_lv_request = u.int_in_range(0..=3)?;
        let vcfront_ui_hi_current_lv_state = u.int_in_range(0..=3)?;
        let vcfront_vcleft_hi_current_lv_state = u.int_in_range(0..=3)?;
        let vcfront_vcright_hi_current_lv_state = u.int_in_range(0..=3)?;
        Id221vcfrontLvPowerState::new(vcfront_lv_power_state_index,vcfront_cmpdlv_state,vcfront_amplifier_lv_request,vcfront_cp_lv_request,vcfront_das1_high_current_lv_state,vcfront_das2_high_current_lv_state,vcfront_dif_lv_state,vcfront_dir_lv_request,vcfront_epas_lv_state,vcfront_esp_lv_state,vcfront_hvac_comp_lv_state,vcfront_hvc_lv_request,vcfront_i_booster_lv_state,vcfront_ocs_lv_request,vcfront_oil_pump_front_lv_state,vcfront_oil_pump_rear_lv_request,vcfront_park_lv_state,vcfront_pcs_lv_state,vcfront_ptc_lv_request,vcfront_radc_lv_state,vcfront_rcm_lv_request,vcfront_sccm_lv_request,vcfront_tas_lv_state,vcfront_tpms_lv_request,vcfront_tuner_lv_request,vcfront_ui_hi_current_lv_state,vcfront_vcleft_hi_current_lv_state,vcfront_vcright_hi_current_lv_state).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_LVPowerStateIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontLvPowerStateIndex {
    Mux0,
    Mux1,
    Other(u8),
}
/// Defined values for VCFRONT_CMPDLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontCmpdlvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_amplifierLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontAmplifierLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_cpLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontCpLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_das1HighCurrentLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontDas1HighCurrentLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_das2HighCurrentLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontDas2HighCurrentLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_difLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontDifLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_dirLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontDirLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_epasLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontEpasLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_espLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontEspLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_hvacCompLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontHvacCompLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_hvcLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontHvcLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_iBoosterLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontIBoosterLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_ocsLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontOcsLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_oilPumpFrontLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontOilPumpFrontLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_oilPumpRearLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontOilPumpRearLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_parkLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontParkLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_pcsLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontPcsLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_ptcLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontPtcLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_radcLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontRadcLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_rcmLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontRcmLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_sccmLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontSccmLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_tasLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontTasLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_tpmsLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontTpmsLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_tunerLVRequest
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontTunerLvRequest {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_uiHiCurrentLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontUiHiCurrentLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_vcleftHiCurrentLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontVcleftHiCurrentLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCFRONT_vcrightHiCurrentLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id221vcfrontLvPowerStateVcfrontVcrightHiCurrentLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}

/// ID225VCRIGHT_LVPowerState
///
/// - ID: 549 (0x225)
/// - Size: 3 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id225vcrightLvPowerState {
    raw: [u8; 3],
}

impl Id225vcrightLvPowerState {
    pub const MESSAGE_ID: u32 = 549;
    
    /// Construct new ID225VCRIGHT_LVPowerState from values
    pub fn new(vcright_amplifier_lv_state: u8, vcright_cntctr_pwr_state: bool, vcright_e_fuse_lockout_status: u8, vcright_hvc_lv_state: u8, vcright_lumbar_lv_state: u8, vcright_ocs_lv_state: u8, vcright_ptc_lv_state: u8, vcright_rcm_lv_state: u8, vcright_rear_oil_pump_lv_state: u8, vcright_sw_en_status: bool, vcright_tuner_lv_state: u8, vcright_vehicle_power_state_dbg: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_vcright_amplifier_lv_state(vcright_amplifier_lv_state)?;
        res.set_vcright_cntctr_pwr_state(vcright_cntctr_pwr_state)?;
        res.set_vcright_e_fuse_lockout_status(vcright_e_fuse_lockout_status)?;
        res.set_vcright_hvc_lv_state(vcright_hvc_lv_state)?;
        res.set_vcright_lumbar_lv_state(vcright_lumbar_lv_state)?;
        res.set_vcright_ocs_lv_state(vcright_ocs_lv_state)?;
        res.set_vcright_ptc_lv_state(vcright_ptc_lv_state)?;
        res.set_vcright_rcm_lv_state(vcright_rcm_lv_state)?;
        res.set_vcright_rear_oil_pump_lv_state(vcright_rear_oil_pump_lv_state)?;
        res.set_vcright_sw_en_status(vcright_sw_en_status)?;
        res.set_vcright_tuner_lv_state(vcright_tuner_lv_state)?;
        res.set_vcright_vehicle_power_state_dbg(vcright_vehicle_power_state_dbg)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_amplifierLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_amplifier_lv_state(&self) -> Id225vcrightLvPowerStateVcrightAmplifierLvState {
        match self.vcright_amplifier_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightAmplifierLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightAmplifierLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightAmplifierLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightAmplifierLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightAmplifierLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_amplifierLVState
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_amplifier_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_amplifierLVState
    #[inline(always)]
    pub fn set_vcright_amplifier_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_cntctrPwrState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_cntctr_pwr_state(&self) -> bool {
        self.vcright_cntctr_pwr_state_raw()
    }
    
    /// Get raw value of VCRIGHT_cntctrPwrState
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_cntctr_pwr_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_cntctrPwrState
    #[inline(always)]
    pub fn set_vcright_cntctr_pwr_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_eFuseLockoutStatus
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_e_fuse_lockout_status(&self) -> Id225vcrightLvPowerStateVcrightEFuseLockoutStatus {
        match self.vcright_e_fuse_lockout_status_raw() {
            2 => Id225vcrightLvPowerStateVcrightEFuseLockoutStatus::EfuseLockoutStatusActive,
            0 => Id225vcrightLvPowerStateVcrightEFuseLockoutStatus::EfuseLockoutStatusIdle,
            1 => Id225vcrightLvPowerStateVcrightEFuseLockoutStatus::EfuseLockoutStatusPending,
            x => Id225vcrightLvPowerStateVcrightEFuseLockoutStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_eFuseLockoutStatus
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_e_fuse_lockout_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_eFuseLockoutStatus
    #[inline(always)]
    pub fn set_vcright_e_fuse_lockout_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[18..20].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvcLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvc_lv_state(&self) -> Id225vcrightLvPowerStateVcrightHvcLvState {
        match self.vcright_hvc_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightHvcLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightHvcLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightHvcLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightHvcLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightHvcLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvcLVState
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvc_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvcLVState
    #[inline(always)]
    pub fn set_vcright_hvc_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_lumbarLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_lumbar_lv_state(&self) -> Id225vcrightLvPowerStateVcrightLumbarLvState {
        match self.vcright_lumbar_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightLumbarLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightLumbarLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightLumbarLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightLumbarLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightLumbarLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_lumbarLVState
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_lumbar_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_lumbarLVState
    #[inline(always)]
    pub fn set_vcright_lumbar_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_ocsLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ocs_lv_state(&self) -> Id225vcrightLvPowerStateVcrightOcsLvState {
        match self.vcright_ocs_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightOcsLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightOcsLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightOcsLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightOcsLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightOcsLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_ocsLVState
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_ocs_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_ocsLVState
    #[inline(always)]
    pub fn set_vcright_ocs_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_ptcLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_ptc_lv_state(&self) -> Id225vcrightLvPowerStateVcrightPtcLvState {
        match self.vcright_ptc_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightPtcLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightPtcLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightPtcLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightPtcLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightPtcLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_ptcLVState
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_ptc_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_ptcLVState
    #[inline(always)]
    pub fn set_vcright_ptc_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rcmLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rcm_lv_state(&self) -> Id225vcrightLvPowerStateVcrightRcmLvState {
        match self.vcright_rcm_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightRcmLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightRcmLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightRcmLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightRcmLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightRcmLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_rcmLVState
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rcm_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rcmLVState
    #[inline(always)]
    pub fn set_vcright_rcm_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_rearOilPumpLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_rear_oil_pump_lv_state(&self) -> Id225vcrightLvPowerStateVcrightRearOilPumpLvState {
        match self.vcright_rear_oil_pump_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightRearOilPumpLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightRearOilPumpLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightRearOilPumpLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightRearOilPumpLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightRearOilPumpLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_rearOilPumpLVState
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_rear_oil_pump_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_rearOilPumpLVState
    #[inline(always)]
    pub fn set_vcright_rear_oil_pump_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_swEnStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_sw_en_status(&self) -> bool {
        self.vcright_sw_en_status_raw()
    }
    
    /// Get raw value of VCRIGHT_swEnStatus
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_sw_en_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_swEnStatus
    #[inline(always)]
    pub fn set_vcright_sw_en_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tunerLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_tuner_lv_state(&self) -> Id225vcrightLvPowerStateVcrightTunerLvState {
        match self.vcright_tuner_lv_state_raw() {
            3 => Id225vcrightLvPowerStateVcrightTunerLvState::LvFault,
            2 => Id225vcrightLvPowerStateVcrightTunerLvState::LvGoingDown,
            0 => Id225vcrightLvPowerStateVcrightTunerLvState::LvOff,
            1 => Id225vcrightLvPowerStateVcrightTunerLvState::LvOn,
            x => Id225vcrightLvPowerStateVcrightTunerLvState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tunerLVState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_tuner_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_tunerLVState
    #[inline(always)]
    pub fn set_vcright_tuner_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_vehiclePowerStateDBG
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_vehicle_power_state_dbg(&self) -> Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg {
        match self.vcright_vehicle_power_state_dbg_raw() {
            2 => Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg::VehiclePowerStateAccessory,
            1 => Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg::VehiclePowerStateConditioning,
            3 => Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg::VehiclePowerStateDrive,
            0 => Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg::VehiclePowerStateOff,
            x => Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_vehiclePowerStateDBG
    ///
    /// - Start bit: 21
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_vehicle_power_state_dbg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_vehiclePowerStateDBG
    #[inline(always)]
    pub fn set_vcright_vehicle_power_state_dbg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 549 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..23].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id225vcrightLvPowerState {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id225vcrightLvPowerState
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_amplifier_lv_state = u.int_in_range(0..=3)?;
        let vcright_cntctr_pwr_state = u.int_in_range(0..=1)? == 1;
        let vcright_e_fuse_lockout_status = u.int_in_range(0..=2)?;
        let vcright_hvc_lv_state = u.int_in_range(0..=3)?;
        let vcright_lumbar_lv_state = u.int_in_range(0..=3)?;
        let vcright_ocs_lv_state = u.int_in_range(0..=3)?;
        let vcright_ptc_lv_state = u.int_in_range(0..=3)?;
        let vcright_rcm_lv_state = u.int_in_range(0..=3)?;
        let vcright_rear_oil_pump_lv_state = u.int_in_range(0..=3)?;
        let vcright_sw_en_status = u.int_in_range(0..=1)? == 1;
        let vcright_tuner_lv_state = u.int_in_range(0..=3)?;
        let vcright_vehicle_power_state_dbg = u.int_in_range(0..=3)?;
        Id225vcrightLvPowerState::new(vcright_amplifier_lv_state,vcright_cntctr_pwr_state,vcright_e_fuse_lockout_status,vcright_hvc_lv_state,vcright_lumbar_lv_state,vcright_ocs_lv_state,vcright_ptc_lv_state,vcright_rcm_lv_state,vcright_rear_oil_pump_lv_state,vcright_sw_en_status,vcright_tuner_lv_state,vcright_vehicle_power_state_dbg).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_amplifierLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightAmplifierLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_eFuseLockoutStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightEFuseLockoutStatus {
    EfuseLockoutStatusActive,
    EfuseLockoutStatusIdle,
    EfuseLockoutStatusPending,
    Other(u8),
}
/// Defined values for VCRIGHT_hvcLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightHvcLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_lumbarLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightLumbarLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_ocsLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightOcsLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_ptcLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightPtcLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_rcmLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightRcmLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_rearOilPumpLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightRearOilPumpLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_tunerLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightTunerLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCRIGHT_vehiclePowerStateDBG
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id225vcrightLvPowerStateVcrightVehiclePowerStateDbg {
    VehiclePowerStateAccessory,
    VehiclePowerStateConditioning,
    VehiclePowerStateDrive,
    VehiclePowerStateOff,
    Other(u8),
}

/// ID2F1VCFRONT_eFuseDebugStatus
///
/// - ID: 753 (0x2f1)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2f1vcfrontEFuseDebugStatus {
    raw: [u8; 8],
}

impl Id2f1vcfrontEFuseDebugStatus {
    pub const MESSAGE_ID: u32 = 753;
    
    /// Construct new ID2F1VCFRONT_eFuseDebugStatus from values
    pub fn new(vcfront_e_fuse_debug_status_index: u8, vcfront_charge_pump_voltage: f32, vcfront_epas3p_current: f32, vcfront_epas3p_fault: bool, vcfront_epas3p_self_test_result: u8, vcfront_epas3p_state: u8, vcfront_epas3p_temp: f32, vcfront_epas3p_voltage: f32, vcfront_epas3s_current: f32, vcfront_epas3s_fault: bool, vcfront_epas3s_self_test_result: u8, vcfront_epas3s_state: u8, vcfront_epas3s_temp: f32, vcfront_epas3s_voltage: f32, vcfront_esp_motor_current: f32, vcfront_esp_motor_fault: bool, vcfront_esp_motor_self_test_result: u8, vcfront_esp_motor_state: u8, vcfront_esp_motor_temp: f32, vcfront_esp_motor_voltage: f32, vcfront_esp_valve_current: f32, vcfront_esp_valve_fault: bool, vcfront_esp_valve_state: u8, vcfront_esp_valve_temp: f32, vcfront_esp_valve_voltage: f32, vcfront_ibs_unfiltered_temperature: f32, vcfront_pcs_current: f32, vcfront_pcs_fault: bool, vcfront_pcs_state: u8, vcfront_pcs_temp: f32, vcfront_pcs_voltage: f32, vcfront_autopilot1_current: f32, vcfront_autopilot1_fault: bool, vcfront_autopilot1_state: u8, vcfront_autopilot1_temp: f32, vcfront_autopilot1_voltage: f32, vcfront_autopilot2_current: f32, vcfront_autopilot2_fault: bool, vcfront_autopilot2_state: u8, vcfront_autopilot2_temp: f32, vcfront_autopilot2_voltage: f32, vcfront_charged_ibs_amp_hours: u16, vcfront_discharged_ibs_amp_hours: u16, vcfront_e_fuse_lockout_voltage: f32, vcfront_headlamp_left_current: f32, vcfront_headlamp_left_fault: bool, vcfront_headlamp_left_state: bool, vcfront_headlamp_left_temperature: f32, vcfront_headlamp_left_voltage: f32, vcfront_headlamp_right_current: f32, vcfront_headlamp_right_fault: bool, vcfront_headlamp_right_state: bool, vcfront_headlamp_right_temperature: f32, vcfront_headlamp_right_voltage: f32, vcfront_i_booster_current: f32, vcfront_i_booster_fault: bool, vcfront_i_booster_self_test_result: u8, vcfront_i_booster_state: u8, vcfront_i_booster_temp: f32, vcfront_i_booster_voltage: f32, vcfront_left_controller_current: f32, vcfront_left_controller_fault: bool, vcfront_left_controller_state: u8, vcfront_left_controller_temp: f32, vcfront_left_controller_voltage: f32, vcfront_pcs_self_test_result: u8, vcfront_pump1_and_fan_current: f32, vcfront_pump1_and_fan_state: bool, vcfront_pump1_and_fan_voltage: f32, vcfront_pump2_and_air_comp_current: f32, vcfront_pump2_and_air_comp_state: bool, vcfront_pump2_and_air_comp_voltage: f32, vcfront_rail_a_12v: f32, vcfront_rail_a_5v: f32, vcfront_rail_b_12v: f32, vcfront_rail_b_5v: f32, vcfront_right_controller_current: f32, vcfront_right_controller_fault: bool, vcfront_right_controller_state: u8, vcfront_right_controller_temp: f32, vcfront_right_controller_voltage: f32, vcfront_sleep_bypass_current: f32, vcfront_sleep_bypass_fault: bool, vcfront_sleep_bypass_state: bool, vcfront_sleep_bypass_voltage: f32, vcfront_ui_audio_current: f32, vcfront_ui_audio_fault: bool, vcfront_ui_audio_state: bool, vcfront_ui_current: f32, vcfront_ui_fault: bool, vcfront_ui_state: bool, vcfront_vbat_fused_high_current: f32, vcfront_vbat_fused_high_fault: bool, vcfront_vbat_fused_high_state: bool, vcfront_vbat_fused_high_temp: f32, vcfront_vbat_fused_high_voltage: f32, vcfront_vbat_fused_self_test_result: u8, vcfront_vcleft_self_test_result: u8, vcfront_vcright_self_test_result: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcfront_e_fuse_debug_status_index(vcfront_e_fuse_debug_status_index)?;
        res.set_vcfront_charge_pump_voltage(vcfront_charge_pump_voltage)?;
        res.set_vcfront_epas3p_current(vcfront_epas3p_current)?;
        res.set_vcfront_epas3p_fault(vcfront_epas3p_fault)?;
        res.set_vcfront_epas3p_self_test_result(vcfront_epas3p_self_test_result)?;
        res.set_vcfront_epas3p_state(vcfront_epas3p_state)?;
        res.set_vcfront_epas3p_temp(vcfront_epas3p_temp)?;
        res.set_vcfront_epas3p_voltage(vcfront_epas3p_voltage)?;
        res.set_vcfront_epas3s_current(vcfront_epas3s_current)?;
        res.set_vcfront_epas3s_fault(vcfront_epas3s_fault)?;
        res.set_vcfront_epas3s_self_test_result(vcfront_epas3s_self_test_result)?;
        res.set_vcfront_epas3s_state(vcfront_epas3s_state)?;
        res.set_vcfront_epas3s_temp(vcfront_epas3s_temp)?;
        res.set_vcfront_epas3s_voltage(vcfront_epas3s_voltage)?;
        res.set_vcfront_esp_motor_current(vcfront_esp_motor_current)?;
        res.set_vcfront_esp_motor_fault(vcfront_esp_motor_fault)?;
        res.set_vcfront_esp_motor_self_test_result(vcfront_esp_motor_self_test_result)?;
        res.set_vcfront_esp_motor_state(vcfront_esp_motor_state)?;
        res.set_vcfront_esp_motor_temp(vcfront_esp_motor_temp)?;
        res.set_vcfront_esp_motor_voltage(vcfront_esp_motor_voltage)?;
        res.set_vcfront_esp_valve_current(vcfront_esp_valve_current)?;
        res.set_vcfront_esp_valve_fault(vcfront_esp_valve_fault)?;
        res.set_vcfront_esp_valve_state(vcfront_esp_valve_state)?;
        res.set_vcfront_esp_valve_temp(vcfront_esp_valve_temp)?;
        res.set_vcfront_esp_valve_voltage(vcfront_esp_valve_voltage)?;
        res.set_vcfront_ibs_unfiltered_temperature(vcfront_ibs_unfiltered_temperature)?;
        res.set_vcfront_pcs_current(vcfront_pcs_current)?;
        res.set_vcfront_pcs_fault(vcfront_pcs_fault)?;
        res.set_vcfront_pcs_state(vcfront_pcs_state)?;
        res.set_vcfront_pcs_temp(vcfront_pcs_temp)?;
        res.set_vcfront_pcs_voltage(vcfront_pcs_voltage)?;
        res.set_vcfront_autopilot1_current(vcfront_autopilot1_current)?;
        res.set_vcfront_autopilot1_fault(vcfront_autopilot1_fault)?;
        res.set_vcfront_autopilot1_state(vcfront_autopilot1_state)?;
        res.set_vcfront_autopilot1_temp(vcfront_autopilot1_temp)?;
        res.set_vcfront_autopilot1_voltage(vcfront_autopilot1_voltage)?;
        res.set_vcfront_autopilot2_current(vcfront_autopilot2_current)?;
        res.set_vcfront_autopilot2_fault(vcfront_autopilot2_fault)?;
        res.set_vcfront_autopilot2_state(vcfront_autopilot2_state)?;
        res.set_vcfront_autopilot2_temp(vcfront_autopilot2_temp)?;
        res.set_vcfront_autopilot2_voltage(vcfront_autopilot2_voltage)?;
        res.set_vcfront_charged_ibs_amp_hours(vcfront_charged_ibs_amp_hours)?;
        res.set_vcfront_discharged_ibs_amp_hours(vcfront_discharged_ibs_amp_hours)?;
        res.set_vcfront_e_fuse_lockout_voltage(vcfront_e_fuse_lockout_voltage)?;
        res.set_vcfront_headlamp_left_current(vcfront_headlamp_left_current)?;
        res.set_vcfront_headlamp_left_fault(vcfront_headlamp_left_fault)?;
        res.set_vcfront_headlamp_left_state(vcfront_headlamp_left_state)?;
        res.set_vcfront_headlamp_left_temperature(vcfront_headlamp_left_temperature)?;
        res.set_vcfront_headlamp_left_voltage(vcfront_headlamp_left_voltage)?;
        res.set_vcfront_headlamp_right_current(vcfront_headlamp_right_current)?;
        res.set_vcfront_headlamp_right_fault(vcfront_headlamp_right_fault)?;
        res.set_vcfront_headlamp_right_state(vcfront_headlamp_right_state)?;
        res.set_vcfront_headlamp_right_temperature(vcfront_headlamp_right_temperature)?;
        res.set_vcfront_headlamp_right_voltage(vcfront_headlamp_right_voltage)?;
        res.set_vcfront_i_booster_current(vcfront_i_booster_current)?;
        res.set_vcfront_i_booster_fault(vcfront_i_booster_fault)?;
        res.set_vcfront_i_booster_self_test_result(vcfront_i_booster_self_test_result)?;
        res.set_vcfront_i_booster_state(vcfront_i_booster_state)?;
        res.set_vcfront_i_booster_temp(vcfront_i_booster_temp)?;
        res.set_vcfront_i_booster_voltage(vcfront_i_booster_voltage)?;
        res.set_vcfront_left_controller_current(vcfront_left_controller_current)?;
        res.set_vcfront_left_controller_fault(vcfront_left_controller_fault)?;
        res.set_vcfront_left_controller_state(vcfront_left_controller_state)?;
        res.set_vcfront_left_controller_temp(vcfront_left_controller_temp)?;
        res.set_vcfront_left_controller_voltage(vcfront_left_controller_voltage)?;
        res.set_vcfront_pcs_self_test_result(vcfront_pcs_self_test_result)?;
        res.set_vcfront_pump1_and_fan_current(vcfront_pump1_and_fan_current)?;
        res.set_vcfront_pump1_and_fan_state(vcfront_pump1_and_fan_state)?;
        res.set_vcfront_pump1_and_fan_voltage(vcfront_pump1_and_fan_voltage)?;
        res.set_vcfront_pump2_and_air_comp_current(vcfront_pump2_and_air_comp_current)?;
        res.set_vcfront_pump2_and_air_comp_state(vcfront_pump2_and_air_comp_state)?;
        res.set_vcfront_pump2_and_air_comp_voltage(vcfront_pump2_and_air_comp_voltage)?;
        res.set_vcfront_rail_a_12v(vcfront_rail_a_12v)?;
        res.set_vcfront_rail_a_5v(vcfront_rail_a_5v)?;
        res.set_vcfront_rail_b_12v(vcfront_rail_b_12v)?;
        res.set_vcfront_rail_b_5v(vcfront_rail_b_5v)?;
        res.set_vcfront_right_controller_current(vcfront_right_controller_current)?;
        res.set_vcfront_right_controller_fault(vcfront_right_controller_fault)?;
        res.set_vcfront_right_controller_state(vcfront_right_controller_state)?;
        res.set_vcfront_right_controller_temp(vcfront_right_controller_temp)?;
        res.set_vcfront_right_controller_voltage(vcfront_right_controller_voltage)?;
        res.set_vcfront_sleep_bypass_current(vcfront_sleep_bypass_current)?;
        res.set_vcfront_sleep_bypass_fault(vcfront_sleep_bypass_fault)?;
        res.set_vcfront_sleep_bypass_state(vcfront_sleep_bypass_state)?;
        res.set_vcfront_sleep_bypass_voltage(vcfront_sleep_bypass_voltage)?;
        res.set_vcfront_ui_audio_current(vcfront_ui_audio_current)?;
        res.set_vcfront_ui_audio_fault(vcfront_ui_audio_fault)?;
        res.set_vcfront_ui_audio_state(vcfront_ui_audio_state)?;
        res.set_vcfront_ui_current(vcfront_ui_current)?;
        res.set_vcfront_ui_fault(vcfront_ui_fault)?;
        res.set_vcfront_ui_state(vcfront_ui_state)?;
        res.set_vcfront_vbat_fused_high_current(vcfront_vbat_fused_high_current)?;
        res.set_vcfront_vbat_fused_high_fault(vcfront_vbat_fused_high_fault)?;
        res.set_vcfront_vbat_fused_high_state(vcfront_vbat_fused_high_state)?;
        res.set_vcfront_vbat_fused_high_temp(vcfront_vbat_fused_high_temp)?;
        res.set_vcfront_vbat_fused_high_voltage(vcfront_vbat_fused_high_voltage)?;
        res.set_vcfront_vbat_fused_self_test_result(vcfront_vbat_fused_self_test_result)?;
        res.set_vcfront_vcleft_self_test_result(vcfront_vcleft_self_test_result)?;
        res.set_vcfront_vcright_self_test_result(vcfront_vcright_self_test_result)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_eFuseDebugStatusIndex
    ///
    /// - Min: 0
    /// - Max: 18
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_e_fuse_debug_status_index(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex {
        match self.vcfront_e_fuse_debug_status_index_raw() {
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsAutopilot1,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsAutopilot2,
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsEpas3p,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsEpas3s,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsEspMotor,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsEspValve,
            12 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsHeadlamps,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsIbooster,
            18 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsInvalid,
            17 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsLvBatteryDebug,
            16 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsMiscRails,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsPcs,
            14 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsPumps,
            15 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsRailsAB,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsSleepBypass,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsUi,
            13 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsVbatFusedHighCurrent,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsVcleft,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::VcfDbgStsVcright,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_eFuseDebugStatusIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_e_fuse_debug_status_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_eFuseDebugStatusIndex
    #[inline(always)]
    pub fn set_vcfront_e_fuse_debug_status_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 18_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..5].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ChargePumpVoltage
    ///
    /// - Min: 0
    /// - Max: 356.751
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_charge_pump_voltage(&self) -> f32 {
        self.vcfront_charge_pump_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_ChargePumpVoltage
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_charge_pump_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..40].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ChargePumpVoltage
    #[inline(always)]
    pub fn set_vcfront_charge_pump_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 356.751_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3PCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3p_current(&self) -> f32 {
        self.vcfront_epas3p_current_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3PCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3p_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_EPAS3PCurrent
    #[inline(always)]
    pub fn set_vcfront_epas3p_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3PFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3p_fault(&self) -> bool {
        self.vcfront_epas3p_fault_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3PFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3p_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_EPAS3PFault
    #[inline(always)]
    pub fn set_vcfront_epas3p_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3PSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3p_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult {
        match self.vcfront_epas3p_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_EPAS3PSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3p_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_EPAS3PSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_epas3p_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3PState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3p_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pState {
        match self.vcfront_epas3p_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_EPAS3PState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3p_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_EPAS3PState
    #[inline(always)]
    pub fn set_vcfront_epas3p_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3PTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3p_temp(&self) -> f32 {
        self.vcfront_epas3p_temp_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3PTemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3p_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_EPAS3PTemp
    #[inline(always)]
    pub fn set_vcfront_epas3p_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3PVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3p_voltage(&self) -> f32 {
        self.vcfront_epas3p_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3PVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3p_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_EPAS3PVoltage
    #[inline(always)]
    pub fn set_vcfront_epas3p_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3SCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3s_current(&self) -> f32 {
        self.vcfront_epas3s_current_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3SCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3s_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_EPAS3SCurrent
    #[inline(always)]
    pub fn set_vcfront_epas3s_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3SFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3s_fault(&self) -> bool {
        self.vcfront_epas3s_fault_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3SFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3s_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_EPAS3SFault
    #[inline(always)]
    pub fn set_vcfront_epas3s_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3SSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3s_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult {
        match self.vcfront_epas3s_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_EPAS3SSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3s_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_EPAS3SSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_epas3s_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3SState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3s_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sState {
        match self.vcfront_epas3s_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_EPAS3SState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3s_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_EPAS3SState
    #[inline(always)]
    pub fn set_vcfront_epas3s_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3STemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3s_temp(&self) -> f32 {
        self.vcfront_epas3s_temp_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3STemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3s_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_EPAS3STemp
    #[inline(always)]
    pub fn set_vcfront_epas3s_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_EPAS3SVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas3s_voltage(&self) -> f32 {
        self.vcfront_epas3s_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_EPAS3SVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas3s_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_EPAS3SVoltage
    #[inline(always)]
    pub fn set_vcfront_epas3s_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPMotorCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_motor_current(&self) -> f32 {
        self.vcfront_esp_motor_current_raw()
    }
    
    /// Get raw value of VCFRONT_ESPMotorCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_motor_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ESPMotorCurrent
    #[inline(always)]
    pub fn set_vcfront_esp_motor_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPMotorFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_motor_fault(&self) -> bool {
        self.vcfront_esp_motor_fault_raw()
    }
    
    /// Get raw value of VCFRONT_ESPMotorFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_motor_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ESPMotorFault
    #[inline(always)]
    pub fn set_vcfront_esp_motor_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPMotorSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_motor_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult {
        match self.vcfront_esp_motor_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_ESPMotorSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_motor_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_ESPMotorSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_esp_motor_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPMotorState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_motor_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorState {
        match self.vcfront_esp_motor_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_ESPMotorState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_motor_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_ESPMotorState
    #[inline(always)]
    pub fn set_vcfront_esp_motor_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPMotorTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_motor_temp(&self) -> f32 {
        self.vcfront_esp_motor_temp_raw()
    }
    
    /// Get raw value of VCFRONT_ESPMotorTemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_motor_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ESPMotorTemp
    #[inline(always)]
    pub fn set_vcfront_esp_motor_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPMotorVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_motor_voltage(&self) -> f32 {
        self.vcfront_esp_motor_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_ESPMotorVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_motor_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ESPMotorVoltage
    #[inline(always)]
    pub fn set_vcfront_esp_motor_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPValveCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_valve_current(&self) -> f32 {
        self.vcfront_esp_valve_current_raw()
    }
    
    /// Get raw value of VCFRONT_ESPValveCurrent
    ///
    /// - Start bit: 44
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_valve_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..60].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ESPValveCurrent
    #[inline(always)]
    pub fn set_vcfront_esp_valve_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[44..60].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPValveFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_valve_fault(&self) -> bool {
        self.vcfront_esp_valve_fault_raw()
    }
    
    /// Get raw value of VCFRONT_ESPValveFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_valve_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ESPValveFault
    #[inline(always)]
    pub fn set_vcfront_esp_valve_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPValveState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_valve_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontEspValveState {
        match self.vcfront_esp_valve_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontEspValveState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontEspValveState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontEspValveState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontEspValveState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_ESPValveState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_valve_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_ESPValveState
    #[inline(always)]
    pub fn set_vcfront_esp_valve_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPValveTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_valve_temp(&self) -> f32 {
        self.vcfront_esp_valve_temp_raw()
    }
    
    /// Get raw value of VCFRONT_ESPValveTemp
    ///
    /// - Start bit: 12
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_valve_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[12..23].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ESPValveTemp
    #[inline(always)]
    pub fn set_vcfront_esp_valve_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[12..23].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ESPValveVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_esp_valve_voltage(&self) -> f32 {
        self.vcfront_esp_valve_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_ESPValveVoltage
    ///
    /// - Start bit: 28
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_esp_valve_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..44].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ESPValveVoltage
    #[inline(always)]
    pub fn set_vcfront_esp_valve_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[28..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_IBSUnfilteredTemperature
    ///
    /// - Min: -327.68
    /// - Max: 327.67
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ibs_unfiltered_temperature(&self) -> f32 {
        self.vcfront_ibs_unfiltered_temperature_raw()
    }
    
    /// Get raw value of VCFRONT_IBSUnfilteredTemperature
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_ibs_unfiltered_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..56].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_IBSUnfilteredTemperature
    #[inline(always)]
    pub fn set_vcfront_ibs_unfiltered_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -327.68_f32 || 327.67_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PCSCurrent
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_current(&self) -> f32 {
        self.vcfront_pcs_current_raw()
    }
    
    /// Get raw value of VCFRONT_PCSCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_pcs_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_PCSCurrent
    #[inline(always)]
    pub fn set_vcfront_pcs_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PCSFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_fault(&self) -> bool {
        self.vcfront_pcs_fault_raw()
    }
    
    /// Get raw value of VCFRONT_PCSFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_PCSFault
    #[inline(always)]
    pub fn set_vcfront_pcs_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PCSState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontPcsState {
        match self.vcfront_pcs_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontPcsState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_PCSState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_PCSState
    #[inline(always)]
    pub fn set_vcfront_pcs_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PCSTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_temp(&self) -> f32 {
        self.vcfront_pcs_temp_raw()
    }
    
    /// Get raw value of VCFRONT_PCSTemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_PCSTemp
    #[inline(always)]
    pub fn set_vcfront_pcs_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PCSVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_voltage(&self) -> f32 {
        self.vcfront_pcs_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_PCSVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_PCSVoltage
    #[inline(always)]
    pub fn set_vcfront_pcs_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot1Current
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot1_current(&self) -> f32 {
        self.vcfront_autopilot1_current_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot1Current
    ///
    /// - Start bit: 43
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot1_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[43..59].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_autopilot1Current
    #[inline(always)]
    pub fn set_vcfront_autopilot1_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[43..59].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot1Fault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot1_fault(&self) -> bool {
        self.vcfront_autopilot1_fault_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot1Fault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot1_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_autopilot1Fault
    #[inline(always)]
    pub fn set_vcfront_autopilot1_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot1State
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot1_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot1State {
        match self.vcfront_autopilot1_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot1State::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot1State::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot1State::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot1State::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_autopilot1State
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot1_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_autopilot1State
    #[inline(always)]
    pub fn set_vcfront_autopilot1_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot1Temp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot1_temp(&self) -> f32 {
        self.vcfront_autopilot1_temp_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot1Temp
    ///
    /// - Start bit: 11
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot1_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[11..22].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_autopilot1Temp
    #[inline(always)]
    pub fn set_vcfront_autopilot1_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[11..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot1Voltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot1_voltage(&self) -> f32 {
        self.vcfront_autopilot1_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot1Voltage
    ///
    /// - Start bit: 27
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot1_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[27..43].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_autopilot1Voltage
    #[inline(always)]
    pub fn set_vcfront_autopilot1_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[27..43].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot2Current
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot2_current(&self) -> f32 {
        self.vcfront_autopilot2_current_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot2Current
    ///
    /// - Start bit: 43
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot2_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[43..59].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_autopilot2Current
    #[inline(always)]
    pub fn set_vcfront_autopilot2_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[43..59].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot2Fault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot2_fault(&self) -> bool {
        self.vcfront_autopilot2_fault_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot2Fault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot2_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_autopilot2Fault
    #[inline(always)]
    pub fn set_vcfront_autopilot2_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot2State
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot2_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot2State {
        match self.vcfront_autopilot2_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot2State::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot2State::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot2State::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot2State::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_autopilot2State
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot2_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_autopilot2State
    #[inline(always)]
    pub fn set_vcfront_autopilot2_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot2Temp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot2_temp(&self) -> f32 {
        self.vcfront_autopilot2_temp_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot2Temp
    ///
    /// - Start bit: 11
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot2_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[11..22].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_autopilot2Temp
    #[inline(always)]
    pub fn set_vcfront_autopilot2_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[11..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_autopilot2Voltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_autopilot2_voltage(&self) -> f32 {
        self.vcfront_autopilot2_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_autopilot2Voltage
    ///
    /// - Start bit: 27
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_autopilot2_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[27..43].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_autopilot2Voltage
    #[inline(always)]
    pub fn set_vcfront_autopilot2_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[27..43].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chargedIBSAmpHours
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "Ah"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_charged_ibs_amp_hours(&self) -> u16 {
        self.vcfront_charged_ibs_amp_hours_raw()
    }
    
    /// Get raw value of VCFRONT_chargedIBSAmpHours
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_charged_ibs_amp_hours_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[8..24].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_chargedIBSAmpHours
    #[inline(always)]
    pub fn set_vcfront_charged_ibs_amp_hours(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_dischargedIBSAmpHours
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "Ah"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_discharged_ibs_amp_hours(&self) -> u16 {
        self.vcfront_discharged_ibs_amp_hours_raw()
    }
    
    /// Get raw value of VCFRONT_dischargedIBSAmpHours
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_discharged_ibs_amp_hours_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[24..40].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_dischargedIBSAmpHours
    #[inline(always)]
    pub fn set_vcfront_discharged_ibs_amp_hours(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_eFuseLockoutVoltage
    ///
    /// - Min: 0
    /// - Max: 22.2919
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_e_fuse_lockout_voltage(&self) -> f32 {
        self.vcfront_e_fuse_lockout_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_eFuseLockoutVoltage
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_e_fuse_lockout_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..20].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_eFuseLockoutVoltage
    #[inline(always)]
    pub fn set_vcfront_e_fuse_lockout_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2919_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampLeftCurrent
    ///
    /// - Min: 0
    /// - Max: 102.3
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_left_current(&self) -> f32 {
        self.vcfront_headlamp_left_current_raw()
    }
    
    /// Get raw value of VCFRONT_headlampLeftCurrent
    ///
    /// - Start bit: 10
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_left_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..20].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_headlampLeftCurrent
    #[inline(always)]
    pub fn set_vcfront_headlamp_left_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[10..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampLeftFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_left_fault(&self) -> bool {
        self.vcfront_headlamp_left_fault_raw()
    }
    
    /// Get raw value of VCFRONT_headlampLeftFault
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_left_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_headlampLeftFault
    #[inline(always)]
    pub fn set_vcfront_headlamp_left_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampLeftState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_left_state(&self) -> bool {
        self.vcfront_headlamp_left_state_raw()
    }
    
    /// Get raw value of VCFRONT_headlampLeftState
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_left_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_headlampLeftState
    #[inline(always)]
    pub fn set_vcfront_headlamp_left_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampLeftTemperature
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_left_temperature(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftTemperature {
        match self.vcfront_headlamp_left_temperature_raw() {
            128 => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftTemperature::Sna,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftTemperature::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_headlampLeftTemperature
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_headlamp_left_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_headlampLeftTemperature
    #[inline(always)]
    pub fn set_vcfront_headlamp_left_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampLeftVoltage
    ///
    /// - Min: 0
    /// - Max: 25.4
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_left_voltage(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftVoltage {
        match self.vcfront_headlamp_left_voltage_raw() {
            255 => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftVoltage::Sna,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftVoltage::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_headlampLeftVoltage
    ///
    /// - Start bit: 20
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_left_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..28].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_headlampLeftVoltage
    #[inline(always)]
    pub fn set_vcfront_headlamp_left_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[20..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampRightCurrent
    ///
    /// - Min: 0
    /// - Max: 102.3
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_right_current(&self) -> f32 {
        self.vcfront_headlamp_right_current_raw()
    }
    
    /// Get raw value of VCFRONT_headlampRightCurrent
    ///
    /// - Start bit: 30
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_right_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[30..40].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_headlampRightCurrent
    #[inline(always)]
    pub fn set_vcfront_headlamp_right_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102.3_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[30..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampRightFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_right_fault(&self) -> bool {
        self.vcfront_headlamp_right_fault_raw()
    }
    
    /// Get raw value of VCFRONT_headlampRightFault
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_right_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_headlampRightFault
    #[inline(always)]
    pub fn set_vcfront_headlamp_right_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampRightState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_right_state(&self) -> bool {
        self.vcfront_headlamp_right_state_raw()
    }
    
    /// Get raw value of VCFRONT_headlampRightState
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_right_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_headlampRightState
    #[inline(always)]
    pub fn set_vcfront_headlamp_right_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampRightTemperature
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_right_temperature(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightTemperature {
        match self.vcfront_headlamp_right_temperature_raw() {
            128 => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightTemperature::Sna,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightTemperature::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_headlampRightTemperature
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_headlamp_right_temperature_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_headlampRightTemperature
    #[inline(always)]
    pub fn set_vcfront_headlamp_right_temperature(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampRightVoltage
    ///
    /// - Min: 0
    /// - Max: 25.4
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_right_voltage(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightVoltage {
        match self.vcfront_headlamp_right_voltage_raw() {
            255 => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightVoltage::Sna,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightVoltage::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_headlampRightVoltage
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_right_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_headlampRightVoltage
    #[inline(always)]
    pub fn set_vcfront_headlamp_right_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.4_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_current(&self) -> f32 {
        self.vcfront_i_booster_current_raw()
    }
    
    /// Get raw value of VCFRONT_iBoosterCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_iBoosterCurrent
    #[inline(always)]
    pub fn set_vcfront_i_booster_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_fault(&self) -> bool {
        self.vcfront_i_booster_fault_raw()
    }
    
    /// Get raw value of VCFRONT_iBoosterFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_iBoosterFault
    #[inline(always)]
    pub fn set_vcfront_i_booster_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult {
        match self.vcfront_i_booster_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_iBoosterSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_iBoosterSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_i_booster_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterState {
        match self.vcfront_i_booster_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_iBoosterState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_iBoosterState
    #[inline(always)]
    pub fn set_vcfront_i_booster_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_temp(&self) -> f32 {
        self.vcfront_i_booster_temp_raw()
    }
    
    /// Get raw value of VCFRONT_iBoosterTemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_iBoosterTemp
    #[inline(always)]
    pub fn set_vcfront_i_booster_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_voltage(&self) -> f32 {
        self.vcfront_i_booster_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_iBoosterVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_iBoosterVoltage
    #[inline(always)]
    pub fn set_vcfront_i_booster_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_leftControllerCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_left_controller_current(&self) -> f32 {
        self.vcfront_left_controller_current_raw()
    }
    
    /// Get raw value of VCFRONT_leftControllerCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_left_controller_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_leftControllerCurrent
    #[inline(always)]
    pub fn set_vcfront_left_controller_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_leftControllerFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_left_controller_fault(&self) -> bool {
        self.vcfront_left_controller_fault_raw()
    }
    
    /// Get raw value of VCFRONT_leftControllerFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_left_controller_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_leftControllerFault
    #[inline(always)]
    pub fn set_vcfront_left_controller_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_leftControllerState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_left_controller_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontLeftControllerState {
        match self.vcfront_left_controller_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontLeftControllerState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontLeftControllerState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontLeftControllerState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontLeftControllerState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_leftControllerState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_left_controller_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_leftControllerState
    #[inline(always)]
    pub fn set_vcfront_left_controller_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_leftControllerTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_left_controller_temp(&self) -> f32 {
        self.vcfront_left_controller_temp_raw()
    }
    
    /// Get raw value of VCFRONT_leftControllerTemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_left_controller_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_leftControllerTemp
    #[inline(always)]
    pub fn set_vcfront_left_controller_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_leftControllerVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_left_controller_voltage(&self) -> f32 {
        self.vcfront_left_controller_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_leftControllerVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_left_controller_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_leftControllerVoltage
    #[inline(always)]
    pub fn set_vcfront_left_controller_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pcsSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult {
        match self.vcfront_pcs_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pcsSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_pcsSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_pcs_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pump1AndFanCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump1_and_fan_current(&self) -> f32 {
        self.vcfront_pump1_and_fan_current_raw()
    }
    
    /// Get raw value of VCFRONT_pump1AndFanCurrent
    ///
    /// - Start bit: 6
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump1_and_fan_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[6..22].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pump1AndFanCurrent
    #[inline(always)]
    pub fn set_vcfront_pump1_and_fan_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[6..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pump1AndFanState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump1_and_fan_state(&self) -> bool {
        self.vcfront_pump1_and_fan_state_raw()
    }
    
    /// Get raw value of VCFRONT_pump1AndFanState
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump1_and_fan_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_pump1AndFanState
    #[inline(always)]
    pub fn set_vcfront_pump1_and_fan_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pump1AndFanVoltage
    ///
    /// - Min: 0
    /// - Max: 409.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump1_and_fan_voltage(&self) -> f32 {
        self.vcfront_pump1_and_fan_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_pump1AndFanVoltage
    ///
    /// - Start bit: 22
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump1_and_fan_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[22..34].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pump1AndFanVoltage
    #[inline(always)]
    pub fn set_vcfront_pump1_and_fan_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 409.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[22..34].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pump2AndAirCompCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump2_and_air_comp_current(&self) -> f32 {
        self.vcfront_pump2_and_air_comp_current_raw()
    }
    
    /// Get raw value of VCFRONT_pump2AndAirCompCurrent
    ///
    /// - Start bit: 35
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump2_and_air_comp_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[35..51].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pump2AndAirCompCurrent
    #[inline(always)]
    pub fn set_vcfront_pump2_and_air_comp_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[35..51].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pump2AndAirCompState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump2_and_air_comp_state(&self) -> bool {
        self.vcfront_pump2_and_air_comp_state_raw()
    }
    
    /// Get raw value of VCFRONT_pump2AndAirCompState
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump2_and_air_comp_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_pump2AndAirCompState
    #[inline(always)]
    pub fn set_vcfront_pump2_and_air_comp_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[34..35].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pump2AndAirCompVoltage
    ///
    /// - Min: 0
    /// - Max: 409.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump2_and_air_comp_voltage(&self) -> f32 {
        self.vcfront_pump2_and_air_comp_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_pump2AndAirCompVoltage
    ///
    /// - Start bit: 51
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump2_and_air_comp_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pump2AndAirCompVoltage
    #[inline(always)]
    pub fn set_vcfront_pump2_and_air_comp_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 409.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[51..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_railA_12v
    ///
    /// - Min: 0
    /// - Max: 22.2919
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rail_a_12v(&self) -> f32 {
        self.vcfront_rail_a_12v_raw()
    }
    
    /// Get raw value of VCFRONT_railA_12v
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rail_a_12v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..20].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_railA_12v
    #[inline(always)]
    pub fn set_vcfront_rail_a_12v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2919_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_railA_5v
    ///
    /// - Min: 0
    /// - Max: 22.2919
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rail_a_5v(&self) -> f32 {
        self.vcfront_rail_a_5v_raw()
    }
    
    /// Get raw value of VCFRONT_railA_5v
    ///
    /// - Start bit: 32
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rail_a_5v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..44].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_railA_5v
    #[inline(always)]
    pub fn set_vcfront_rail_a_5v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2919_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_railB_12v
    ///
    /// - Min: 0
    /// - Max: 22.2919
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rail_b_12v(&self) -> f32 {
        self.vcfront_rail_b_12v_raw()
    }
    
    /// Get raw value of VCFRONT_railB_12v
    ///
    /// - Start bit: 20
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rail_b_12v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[20..32].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_railB_12v
    #[inline(always)]
    pub fn set_vcfront_rail_b_12v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2919_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[20..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_railB_5v
    ///
    /// - Min: 0
    /// - Max: 22.2919
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rail_b_5v(&self) -> f32 {
        self.vcfront_rail_b_5v_raw()
    }
    
    /// Get raw value of VCFRONT_railB_5v
    ///
    /// - Start bit: 44
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rail_b_5v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..56].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_railB_5v
    #[inline(always)]
    pub fn set_vcfront_rail_b_5v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2919_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[44..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_rightControllerCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_right_controller_current(&self) -> f32 {
        self.vcfront_right_controller_current_raw()
    }
    
    /// Get raw value of VCFRONT_rightControllerCurrent
    ///
    /// - Start bit: 47
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_right_controller_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[47..63].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_rightControllerCurrent
    #[inline(always)]
    pub fn set_vcfront_right_controller_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[47..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_rightControllerFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_right_controller_fault(&self) -> bool {
        self.vcfront_right_controller_fault_raw()
    }
    
    /// Get raw value of VCFRONT_rightControllerFault
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_right_controller_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_rightControllerFault
    #[inline(always)]
    pub fn set_vcfront_right_controller_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_rightControllerState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_right_controller_state(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontRightControllerState {
        match self.vcfront_right_controller_state_raw() {
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontRightControllerState::EfuseStateLockedOut,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontRightControllerState::EfuseStateOff,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontRightControllerState::EfuseStateOn,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontRightControllerState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_rightControllerState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_right_controller_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_rightControllerState
    #[inline(always)]
    pub fn set_vcfront_right_controller_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_rightControllerTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_right_controller_temp(&self) -> f32 {
        self.vcfront_right_controller_temp_raw()
    }
    
    /// Get raw value of VCFRONT_rightControllerTemp
    ///
    /// - Start bit: 15
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_right_controller_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[15..26].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_rightControllerTemp
    #[inline(always)]
    pub fn set_vcfront_right_controller_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[15..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_rightControllerVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_right_controller_voltage(&self) -> f32 {
        self.vcfront_right_controller_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_rightControllerVoltage
    ///
    /// - Start bit: 31
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_right_controller_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[31..47].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_rightControllerVoltage
    #[inline(always)]
    pub fn set_vcfront_right_controller_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[31..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sleepBypassCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sleep_bypass_current(&self) -> f32 {
        self.vcfront_sleep_bypass_current_raw()
    }
    
    /// Get raw value of VCFRONT_sleepBypassCurrent
    ///
    /// - Start bit: 26
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_sleep_bypass_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[26..42].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_sleepBypassCurrent
    #[inline(always)]
    pub fn set_vcfront_sleep_bypass_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[26..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sleepBypassFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sleep_bypass_fault(&self) -> bool {
        self.vcfront_sleep_bypass_fault_raw()
    }
    
    /// Get raw value of VCFRONT_sleepBypassFault
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_sleep_bypass_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_sleepBypassFault
    #[inline(always)]
    pub fn set_vcfront_sleep_bypass_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sleepBypassState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sleep_bypass_state(&self) -> bool {
        self.vcfront_sleep_bypass_state_raw()
    }
    
    /// Get raw value of VCFRONT_sleepBypassState
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_sleep_bypass_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_sleepBypassState
    #[inline(always)]
    pub fn set_vcfront_sleep_bypass_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sleepBypassVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sleep_bypass_voltage(&self) -> f32 {
        self.vcfront_sleep_bypass_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_sleepBypassVoltage
    ///
    /// - Start bit: 10
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_sleep_bypass_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..26].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_sleepBypassVoltage
    #[inline(always)]
    pub fn set_vcfront_sleep_bypass_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[10..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiAudioCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_audio_current(&self) -> f32 {
        self.vcfront_ui_audio_current_raw()
    }
    
    /// Get raw value of VCFRONT_uiAudioCurrent
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_audio_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..24].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_uiAudioCurrent
    #[inline(always)]
    pub fn set_vcfront_ui_audio_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiAudioFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_audio_fault(&self) -> bool {
        self.vcfront_ui_audio_fault_raw()
    }
    
    /// Get raw value of VCFRONT_uiAudioFault
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_audio_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_uiAudioFault
    #[inline(always)]
    pub fn set_vcfront_ui_audio_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiAudioState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_audio_state(&self) -> bool {
        self.vcfront_ui_audio_state_raw()
    }
    
    /// Get raw value of VCFRONT_uiAudioState
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_audio_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_uiAudioState
    #[inline(always)]
    pub fn set_vcfront_ui_audio_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_current(&self) -> f32 {
        self.vcfront_ui_current_raw()
    }
    
    /// Get raw value of VCFRONT_uiCurrent
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..48].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_uiCurrent
    #[inline(always)]
    pub fn set_vcfront_ui_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_fault(&self) -> bool {
        self.vcfront_ui_fault_raw()
    }
    
    /// Get raw value of VCFRONT_uiFault
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_uiFault
    #[inline(always)]
    pub fn set_vcfront_ui_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_uiState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ui_state(&self) -> bool {
        self.vcfront_ui_state_raw()
    }
    
    /// Get raw value of VCFRONT_uiState
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ui_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_uiState
    #[inline(always)]
    pub fn set_vcfront_ui_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatFusedHighCurrent
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "A"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_current(&self) -> f32 {
        self.vcfront_vbat_fused_high_current_raw()
    }
    
    /// Get raw value of VCFRONT_vbatFusedHighCurrent
    ///
    /// - Start bit: 46
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[46..62].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_vbatFusedHighCurrent
    #[inline(always)]
    pub fn set_vcfront_vbat_fused_high_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[46..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatFusedHighFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_fault(&self) -> bool {
        self.vcfront_vbat_fused_high_fault_raw()
    }
    
    /// Get raw value of VCFRONT_vbatFusedHighFault
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_vbatFusedHighFault
    #[inline(always)]
    pub fn set_vcfront_vbat_fused_high_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatFusedHighState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_state(&self) -> bool {
        self.vcfront_vbat_fused_high_state_raw()
    }
    
    /// Get raw value of VCFRONT_vbatFusedHighState
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_vbatFusedHighState
    #[inline(always)]
    pub fn set_vcfront_vbat_fused_high_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatFusedHighTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_temp(&self) -> f32 {
        self.vcfront_vbat_fused_high_temp_raw()
    }
    
    /// Get raw value of VCFRONT_vbatFusedHighTemp
    ///
    /// - Start bit: 14
    /// - Signal size: 11 bits
    /// - Factor: 0.125
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[14..25].load_le::<u16>();
        
        let factor = 0.125_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_vbatFusedHighTemp
    #[inline(always)]
    pub fn set_vcfront_vbat_fused_high_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.125_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[14..25].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatFusedHighVoltage
    ///
    /// - Min: 0
    /// - Max: 6553.5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_voltage(&self) -> f32 {
        self.vcfront_vbat_fused_high_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_vbatFusedHighVoltage
    ///
    /// - Start bit: 30
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_fused_high_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[30..46].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_vbatFusedHighVoltage
    #[inline(always)]
    pub fn set_vcfront_vbat_fused_high_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[30..46].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatFusedSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_fused_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult {
        match self.vcfront_vbat_fused_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vbatFusedSelfTestResult
    ///
    /// - Start bit: 10
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_fused_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vbatFusedSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_vbat_fused_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vcleftSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vcleft_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult {
        match self.vcfront_vcleft_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vcleftSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vcleft_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vcleftSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_vcleft_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vcrightSelfTestResult
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vcright_self_test_result(&self) -> Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult {
        match self.vcfront_vcright_self_test_result_raw() {
            4 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedEfuseOutputShort,
            8 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
            6 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
            10 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedNotLatched,
            7 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
            5 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
            3 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedRailsUnstable,
            9 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
            0 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultNotRun,
            2 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultPassed,
            1 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultRunning,
            11 => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::EfuseSelfTestEfuseResultSkipped,
            x => Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vcrightSelfTestResult
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vcright_self_test_result_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vcrightSelfTestResult
    #[inline(always)]
    pub fn set_vcfront_vcright_self_test_result(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 753 }); }
        self.raw.view_bits_mut::<LocalBits>()[11..15].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2f1vcfrontEFuseDebugStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2f1vcfrontEFuseDebugStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_e_fuse_debug_status_index = u.int_in_range(0..=18)?;
        let vcfront_charge_pump_voltage = 0_f32;
        let vcfront_epas3p_current = 0_f32;
        let vcfront_epas3p_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_epas3p_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_epas3p_state = u.int_in_range(0..=2)?;
        let vcfront_epas3p_temp = -40_f32;
        let vcfront_epas3p_voltage = 0_f32;
        let vcfront_epas3s_current = 0_f32;
        let vcfront_epas3s_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_epas3s_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_epas3s_state = u.int_in_range(0..=2)?;
        let vcfront_epas3s_temp = -40_f32;
        let vcfront_epas3s_voltage = 0_f32;
        let vcfront_esp_motor_current = 0_f32;
        let vcfront_esp_motor_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_esp_motor_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_esp_motor_state = u.int_in_range(0..=2)?;
        let vcfront_esp_motor_temp = -40_f32;
        let vcfront_esp_motor_voltage = 0_f32;
        let vcfront_esp_valve_current = 0_f32;
        let vcfront_esp_valve_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_esp_valve_state = u.int_in_range(0..=2)?;
        let vcfront_esp_valve_temp = -40_f32;
        let vcfront_esp_valve_voltage = 0_f32;
        let vcfront_ibs_unfiltered_temperature = -327.68_f32;
        let vcfront_pcs_current = -3276.8_f32;
        let vcfront_pcs_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_pcs_state = u.int_in_range(0..=2)?;
        let vcfront_pcs_temp = -40_f32;
        let vcfront_pcs_voltage = 0_f32;
        let vcfront_autopilot1_current = 0_f32;
        let vcfront_autopilot1_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_autopilot1_state = u.int_in_range(0..=2)?;
        let vcfront_autopilot1_temp = -40_f32;
        let vcfront_autopilot1_voltage = 0_f32;
        let vcfront_autopilot2_current = 0_f32;
        let vcfront_autopilot2_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_autopilot2_state = u.int_in_range(0..=2)?;
        let vcfront_autopilot2_temp = -40_f32;
        let vcfront_autopilot2_voltage = 0_f32;
        let vcfront_charged_ibs_amp_hours = u.int_in_range(0..=65535)?;
        let vcfront_discharged_ibs_amp_hours = u.int_in_range(0..=65535)?;
        let vcfront_e_fuse_lockout_voltage = 0_f32;
        let vcfront_headlamp_left_current = 0_f32;
        let vcfront_headlamp_left_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_headlamp_left_state = u.int_in_range(0..=1)? == 1;
        let vcfront_headlamp_left_temperature = -40_f32;
        let vcfront_headlamp_left_voltage = 0_f32;
        let vcfront_headlamp_right_current = 0_f32;
        let vcfront_headlamp_right_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_headlamp_right_state = u.int_in_range(0..=1)? == 1;
        let vcfront_headlamp_right_temperature = -40_f32;
        let vcfront_headlamp_right_voltage = 0_f32;
        let vcfront_i_booster_current = 0_f32;
        let vcfront_i_booster_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_i_booster_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_i_booster_state = u.int_in_range(0..=2)?;
        let vcfront_i_booster_temp = -40_f32;
        let vcfront_i_booster_voltage = 0_f32;
        let vcfront_left_controller_current = 0_f32;
        let vcfront_left_controller_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_left_controller_state = u.int_in_range(0..=2)?;
        let vcfront_left_controller_temp = -40_f32;
        let vcfront_left_controller_voltage = 0_f32;
        let vcfront_pcs_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_pump1_and_fan_current = 0_f32;
        let vcfront_pump1_and_fan_state = u.int_in_range(0..=1)? == 1;
        let vcfront_pump1_and_fan_voltage = 0_f32;
        let vcfront_pump2_and_air_comp_current = 0_f32;
        let vcfront_pump2_and_air_comp_state = u.int_in_range(0..=1)? == 1;
        let vcfront_pump2_and_air_comp_voltage = 0_f32;
        let vcfront_rail_a_12v = 0_f32;
        let vcfront_rail_a_5v = 0_f32;
        let vcfront_rail_b_12v = 0_f32;
        let vcfront_rail_b_5v = 0_f32;
        let vcfront_right_controller_current = 0_f32;
        let vcfront_right_controller_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_right_controller_state = u.int_in_range(0..=2)?;
        let vcfront_right_controller_temp = -40_f32;
        let vcfront_right_controller_voltage = 0_f32;
        let vcfront_sleep_bypass_current = 0_f32;
        let vcfront_sleep_bypass_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_sleep_bypass_state = u.int_in_range(0..=1)? == 1;
        let vcfront_sleep_bypass_voltage = 0_f32;
        let vcfront_ui_audio_current = 0_f32;
        let vcfront_ui_audio_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_ui_audio_state = u.int_in_range(0..=1)? == 1;
        let vcfront_ui_current = 0_f32;
        let vcfront_ui_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_ui_state = u.int_in_range(0..=1)? == 1;
        let vcfront_vbat_fused_high_current = 0_f32;
        let vcfront_vbat_fused_high_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_vbat_fused_high_state = u.int_in_range(0..=1)? == 1;
        let vcfront_vbat_fused_high_temp = -40_f32;
        let vcfront_vbat_fused_high_voltage = 0_f32;
        let vcfront_vbat_fused_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_vcleft_self_test_result = u.int_in_range(0..=11)?;
        let vcfront_vcright_self_test_result = u.int_in_range(0..=11)?;
        Id2f1vcfrontEFuseDebugStatus::new(vcfront_e_fuse_debug_status_index,vcfront_charge_pump_voltage,vcfront_epas3p_current,vcfront_epas3p_fault,vcfront_epas3p_self_test_result,vcfront_epas3p_state,vcfront_epas3p_temp,vcfront_epas3p_voltage,vcfront_epas3s_current,vcfront_epas3s_fault,vcfront_epas3s_self_test_result,vcfront_epas3s_state,vcfront_epas3s_temp,vcfront_epas3s_voltage,vcfront_esp_motor_current,vcfront_esp_motor_fault,vcfront_esp_motor_self_test_result,vcfront_esp_motor_state,vcfront_esp_motor_temp,vcfront_esp_motor_voltage,vcfront_esp_valve_current,vcfront_esp_valve_fault,vcfront_esp_valve_state,vcfront_esp_valve_temp,vcfront_esp_valve_voltage,vcfront_ibs_unfiltered_temperature,vcfront_pcs_current,vcfront_pcs_fault,vcfront_pcs_state,vcfront_pcs_temp,vcfront_pcs_voltage,vcfront_autopilot1_current,vcfront_autopilot1_fault,vcfront_autopilot1_state,vcfront_autopilot1_temp,vcfront_autopilot1_voltage,vcfront_autopilot2_current,vcfront_autopilot2_fault,vcfront_autopilot2_state,vcfront_autopilot2_temp,vcfront_autopilot2_voltage,vcfront_charged_ibs_amp_hours,vcfront_discharged_ibs_amp_hours,vcfront_e_fuse_lockout_voltage,vcfront_headlamp_left_current,vcfront_headlamp_left_fault,vcfront_headlamp_left_state,vcfront_headlamp_left_temperature,vcfront_headlamp_left_voltage,vcfront_headlamp_right_current,vcfront_headlamp_right_fault,vcfront_headlamp_right_state,vcfront_headlamp_right_temperature,vcfront_headlamp_right_voltage,vcfront_i_booster_current,vcfront_i_booster_fault,vcfront_i_booster_self_test_result,vcfront_i_booster_state,vcfront_i_booster_temp,vcfront_i_booster_voltage,vcfront_left_controller_current,vcfront_left_controller_fault,vcfront_left_controller_state,vcfront_left_controller_temp,vcfront_left_controller_voltage,vcfront_pcs_self_test_result,vcfront_pump1_and_fan_current,vcfront_pump1_and_fan_state,vcfront_pump1_and_fan_voltage,vcfront_pump2_and_air_comp_current,vcfront_pump2_and_air_comp_state,vcfront_pump2_and_air_comp_voltage,vcfront_rail_a_12v,vcfront_rail_a_5v,vcfront_rail_b_12v,vcfront_rail_b_5v,vcfront_right_controller_current,vcfront_right_controller_fault,vcfront_right_controller_state,vcfront_right_controller_temp,vcfront_right_controller_voltage,vcfront_sleep_bypass_current,vcfront_sleep_bypass_fault,vcfront_sleep_bypass_state,vcfront_sleep_bypass_voltage,vcfront_ui_audio_current,vcfront_ui_audio_fault,vcfront_ui_audio_state,vcfront_ui_current,vcfront_ui_fault,vcfront_ui_state,vcfront_vbat_fused_high_current,vcfront_vbat_fused_high_fault,vcfront_vbat_fused_high_state,vcfront_vbat_fused_high_temp,vcfront_vbat_fused_high_voltage,vcfront_vbat_fused_self_test_result,vcfront_vcleft_self_test_result,vcfront_vcright_self_test_result).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_eFuseDebugStatusIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEFuseDebugStatusIndex {
    VcfDbgStsAutopilot1,
    VcfDbgStsAutopilot2,
    VcfDbgStsEpas3p,
    VcfDbgStsEpas3s,
    VcfDbgStsEspMotor,
    VcfDbgStsEspValve,
    VcfDbgStsHeadlamps,
    VcfDbgStsIbooster,
    VcfDbgStsInvalid,
    VcfDbgStsLvBatteryDebug,
    VcfDbgStsMiscRails,
    VcfDbgStsPcs,
    VcfDbgStsPumps,
    VcfDbgStsRailsAB,
    VcfDbgStsSleepBypass,
    VcfDbgStsUi,
    VcfDbgStsVbatFusedHighCurrent,
    VcfDbgStsVcleft,
    VcfDbgStsVcright,
    Other(u8),
}
/// Defined values for VCFRONT_EPAS3PSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_EPAS3PState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEpas3pState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_EPAS3SSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_EPAS3SState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEpas3sState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_ESPMotorSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_ESPMotorState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEspMotorState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_ESPValveState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontEspValveState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_PCSState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontPcsState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_autopilot1State
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot1State {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_autopilot2State
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontAutopilot2State {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_headlampLeftTemperature
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftTemperature {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_headlampLeftVoltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampLeftVoltage {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_headlampRightTemperature
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightTemperature {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_headlampRightVoltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontHeadlampRightVoltage {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_iBoosterSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_iBoosterState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontIBoosterState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_leftControllerState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontLeftControllerState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_pcsSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontPcsSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_rightControllerState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontRightControllerState {
    EfuseStateLockedOut,
    EfuseStateOff,
    EfuseStateOn,
    Other(u8),
}
/// Defined values for VCFRONT_vbatFusedSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontVbatFusedSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_vcleftSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontVcleftSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}
/// Defined values for VCFRONT_vcrightSelfTestResult
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2f1vcfrontEFuseDebugStatusVcfrontVcrightSelfTestResult {
    EfuseSelfTestEfuseResultFailedEfuseOutputShort,
    EfuseSelfTestEfuseResultFailedEnableHighMalfunction,
    EfuseSelfTestEfuseResultFailedEnableLowMalfunction,
    EfuseSelfTestEfuseResultFailedNotLatched,
    EfuseSelfTestEfuseResultFailedPowerFetChannelOpen,
    EfuseSelfTestEfuseResultFailedPowerFetStuckOn,
    EfuseSelfTestEfuseResultFailedRailsUnstable,
    EfuseSelfTestEfuseResultFailedTurnOffPathTooSlow,
    EfuseSelfTestEfuseResultNotRun,
    EfuseSelfTestEfuseResultPassed,
    EfuseSelfTestEfuseResultRunning,
    EfuseSelfTestEfuseResultSkipped,
    Other(u8),
}

/// ID242VCLEFT_LVPowerState
///
/// - ID: 578 (0x242)
/// - Size: 2 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id242vcleftLvPowerState {
    raw: [u8; 2],
}

impl Id242vcleftLvPowerState {
    pub const MESSAGE_ID: u32 = 578;
    
    /// Construct new ID242VCLEFT_LVPowerState from values
    pub fn new(vcleft_cp_lv_state: u8, vcleft_di_lv_state: u8, vcleft_lumbar_lv_state: u8, vcleft_rcm_lv_state: u8, vcleft_sccm_lv_state: u8, vcleft_swc_lv_state: u8, vcleft_tpms_lv_state: u8, vcleft_vehicle_power_state_dbg: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_vcleft_cp_lv_state(vcleft_cp_lv_state)?;
        res.set_vcleft_di_lv_state(vcleft_di_lv_state)?;
        res.set_vcleft_lumbar_lv_state(vcleft_lumbar_lv_state)?;
        res.set_vcleft_rcm_lv_state(vcleft_rcm_lv_state)?;
        res.set_vcleft_sccm_lv_state(vcleft_sccm_lv_state)?;
        res.set_vcleft_swc_lv_state(vcleft_swc_lv_state)?;
        res.set_vcleft_tpms_lv_state(vcleft_tpms_lv_state)?;
        res.set_vcleft_vehicle_power_state_dbg(vcleft_vehicle_power_state_dbg)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCLEFT_cpLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_cp_lv_state(&self) -> Id242vcleftLvPowerStateVcleftCpLvState {
        match self.vcleft_cp_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftCpLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftCpLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftCpLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftCpLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftCpLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_cpLVState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_cp_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_cpLVState
    #[inline(always)]
    pub fn set_vcleft_cp_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..10].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_diLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_di_lv_state(&self) -> Id242vcleftLvPowerStateVcleftDiLvState {
        match self.vcleft_di_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftDiLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftDiLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftDiLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftDiLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftDiLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_diLVState
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_di_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_diLVState
    #[inline(always)]
    pub fn set_vcleft_di_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[6..8].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_lumbarLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_lumbar_lv_state(&self) -> Id242vcleftLvPowerStateVcleftLumbarLvState {
        match self.vcleft_lumbar_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftLumbarLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftLumbarLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftLumbarLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftLumbarLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftLumbarLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_lumbarLVState
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_lumbar_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_lumbarLVState
    #[inline(always)]
    pub fn set_vcleft_lumbar_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..14].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_rcmLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_rcm_lv_state(&self) -> Id242vcleftLvPowerStateVcleftRcmLvState {
        match self.vcleft_rcm_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftRcmLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftRcmLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftRcmLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftRcmLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftRcmLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_rcmLVState
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_rcm_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_rcmLVState
    #[inline(always)]
    pub fn set_vcleft_rcm_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_sccmLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_sccm_lv_state(&self) -> Id242vcleftLvPowerStateVcleftSccmLvState {
        match self.vcleft_sccm_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftSccmLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftSccmLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftSccmLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftSccmLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftSccmLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_sccmLVState
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_sccm_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_sccmLVState
    #[inline(always)]
    pub fn set_vcleft_sccm_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[4..6].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_swcLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_swc_lv_state(&self) -> Id242vcleftLvPowerStateVcleftSwcLvState {
        match self.vcleft_swc_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftSwcLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftSwcLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftSwcLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftSwcLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftSwcLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_swcLVState
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_swc_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_swcLVState
    #[inline(always)]
    pub fn set_vcleft_swc_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..12].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_tpmsLVState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_tpms_lv_state(&self) -> Id242vcleftLvPowerStateVcleftTpmsLvState {
        match self.vcleft_tpms_lv_state_raw() {
            3 => Id242vcleftLvPowerStateVcleftTpmsLvState::LvFault,
            2 => Id242vcleftLvPowerStateVcleftTpmsLvState::LvGoingDown,
            0 => Id242vcleftLvPowerStateVcleftTpmsLvState::LvOff,
            1 => Id242vcleftLvPowerStateVcleftTpmsLvState::LvOn,
            x => Id242vcleftLvPowerStateVcleftTpmsLvState::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_tpmsLVState
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_tpms_lv_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_tpmsLVState
    #[inline(always)]
    pub fn set_vcleft_tpms_lv_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..4].store_le(value);
        Ok(())
    }
    
    /// VCLEFT_vehiclePowerStateDBG
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcleft_vehicle_power_state_dbg(&self) -> Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg {
        match self.vcleft_vehicle_power_state_dbg_raw() {
            2 => Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg::VehiclePowerStateAccessory,
            1 => Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg::VehiclePowerStateConditioning,
            3 => Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg::VehiclePowerStateDrive,
            0 => Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg::VehiclePowerStateOff,
            x => Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg::Other(x),
        }
    }
    
    /// Get raw value of VCLEFT_vehiclePowerStateDBG
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcleft_vehicle_power_state_dbg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCLEFT_vehiclePowerStateDBG
    #[inline(always)]
    pub fn set_vcleft_vehicle_power_state_dbg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 578 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id242vcleftLvPowerState {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id242vcleftLvPowerState
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcleft_cp_lv_state = u.int_in_range(0..=3)?;
        let vcleft_di_lv_state = u.int_in_range(0..=3)?;
        let vcleft_lumbar_lv_state = u.int_in_range(0..=3)?;
        let vcleft_rcm_lv_state = u.int_in_range(0..=3)?;
        let vcleft_sccm_lv_state = u.int_in_range(0..=3)?;
        let vcleft_swc_lv_state = u.int_in_range(0..=3)?;
        let vcleft_tpms_lv_state = u.int_in_range(0..=3)?;
        let vcleft_vehicle_power_state_dbg = u.int_in_range(0..=3)?;
        Id242vcleftLvPowerState::new(vcleft_cp_lv_state,vcleft_di_lv_state,vcleft_lumbar_lv_state,vcleft_rcm_lv_state,vcleft_sccm_lv_state,vcleft_swc_lv_state,vcleft_tpms_lv_state,vcleft_vehicle_power_state_dbg).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCLEFT_cpLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftCpLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_diLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftDiLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_lumbarLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftLumbarLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_rcmLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftRcmLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_sccmLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftSccmLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_swcLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftSwcLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_tpmsLVState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftTpmsLvState {
    LvFault,
    LvGoingDown,
    LvOff,
    LvOn,
    Other(u8),
}
/// Defined values for VCLEFT_vehiclePowerStateDBG
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id242vcleftLvPowerStateVcleftVehiclePowerStateDbg {
    VehiclePowerStateAccessory,
    VehiclePowerStateConditioning,
    VehiclePowerStateDrive,
    VehiclePowerStateOff,
    Other(u8),
}

/// ID243VCRIGHT_hvacStatus
///
/// - ID: 579 (0x243)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id243vcrightHvacStatus {
    raw: [u8; 8],
}

impl Id243vcrightHvacStatus {
    pub const MESSAGE_ID: u32 = 579;
    
    /// Construct new ID243VCRIGHT_hvacStatus from values
    pub fn new(vcright_hvac_status_index: u8, vcright_hvac_ac_running: bool, vcright_hvac_air_distribution_mode: u8, vcright_hvac_blower_segment: u8, vcright_hvac_cabin_temp_est: f32, vcright_hvac_duct_target_left: f32, vcright_hvac_duct_target_right: f32, vcright_hvac_evap_inlet_temp_estimat: f32, vcright_hvac_massflow_refrig_system: u8, vcright_hvac_model_init_status: u8, vcright_hvac_overheat_prot_active: bool, vcright_hvac_power_state: u8, vcright_hvac_qdot_left: f32, vcright_hvac_qdot_right: f32, vcright_hvac_recirc: u8, vcright_hvac_recirc_door_percent: f32, vcright_hvac_second_row_state: u8, vcright_hvac_system_nominal: bool, vcright_hvac_vent_status: u8, vcright_temp_duct_left: f32, vcright_temp_duct_left_lower: f32, vcright_temp_duct_left_upper: f32, vcright_temp_duct_right: f32, vcright_temp_duct_right_lower: f32, vcright_temp_duct_right_upper: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcright_hvac_status_index(vcright_hvac_status_index)?;
        res.set_vcright_hvac_ac_running(vcright_hvac_ac_running)?;
        res.set_vcright_hvac_air_distribution_mode(vcright_hvac_air_distribution_mode)?;
        res.set_vcright_hvac_blower_segment(vcright_hvac_blower_segment)?;
        res.set_vcright_hvac_cabin_temp_est(vcright_hvac_cabin_temp_est)?;
        res.set_vcright_hvac_duct_target_left(vcright_hvac_duct_target_left)?;
        res.set_vcright_hvac_duct_target_right(vcright_hvac_duct_target_right)?;
        res.set_vcright_hvac_evap_inlet_temp_estimat(vcright_hvac_evap_inlet_temp_estimat)?;
        res.set_vcright_hvac_massflow_refrig_system(vcright_hvac_massflow_refrig_system)?;
        res.set_vcright_hvac_model_init_status(vcright_hvac_model_init_status)?;
        res.set_vcright_hvac_overheat_prot_active(vcright_hvac_overheat_prot_active)?;
        res.set_vcright_hvac_power_state(vcright_hvac_power_state)?;
        res.set_vcright_hvac_qdot_left(vcright_hvac_qdot_left)?;
        res.set_vcright_hvac_qdot_right(vcright_hvac_qdot_right)?;
        res.set_vcright_hvac_recirc(vcright_hvac_recirc)?;
        res.set_vcright_hvac_recirc_door_percent(vcright_hvac_recirc_door_percent)?;
        res.set_vcright_hvac_second_row_state(vcright_hvac_second_row_state)?;
        res.set_vcright_hvac_system_nominal(vcright_hvac_system_nominal)?;
        res.set_vcright_hvac_vent_status(vcright_hvac_vent_status)?;
        res.set_vcright_temp_duct_left(vcright_temp_duct_left)?;
        res.set_vcright_temp_duct_left_lower(vcright_temp_duct_left_lower)?;
        res.set_vcright_temp_duct_left_upper(vcright_temp_duct_left_upper)?;
        res.set_vcright_temp_duct_right(vcright_temp_duct_right)?;
        res.set_vcright_temp_duct_right_lower(vcright_temp_duct_right_lower)?;
        res.set_vcright_temp_duct_right_upper(vcright_temp_duct_right_upper)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_hvacStatusIndex
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_status_index(&self) -> Id243vcrightHvacStatusVcrightHvacStatusIndex {
        match self.vcright_hvac_status_index_raw() {
            3 => Id243vcrightHvacStatusVcrightHvacStatusIndex::End,
            0 => Id243vcrightHvacStatusVcrightHvacStatusIndex::StatusUi,
            1 => Id243vcrightHvacStatusVcrightHvacStatusIndex::StatusVcfront,
            2 => Id243vcrightHvacStatusVcrightHvacStatusIndex::StatusVcfront2,
            x => Id243vcrightHvacStatusVcrightHvacStatusIndex::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacStatusIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_status_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacStatusIndex
    #[inline(always)]
    pub fn set_vcright_hvac_status_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..2].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacACRunning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_ac_running(&self) -> Id243vcrightHvacStatusVcrightHvacAcRunning {
        match self.vcright_hvac_ac_running_raw() {
            false => Id243vcrightHvacStatusVcrightHvacAcRunning::Off,
            true => Id243vcrightHvacStatusVcrightHvacAcRunning::On,
            x => Id243vcrightHvacStatusVcrightHvacAcRunning::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacACRunning
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_ac_running_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacACRunning
    #[inline(always)]
    pub fn set_vcright_hvac_ac_running(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacAirDistributionMode
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_air_distribution_mode(&self) -> Id243vcrightHvacStatusVcrightHvacAirDistributionMode {
        match self.vcright_hvac_air_distribution_mode_raw() {
            4 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::Defrost,
            5 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::DefrostFloor,
            6 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::DefrostPanel,
            7 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::DefrostPanelFloor,
            1 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::Floor,
            0 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::None,
            2 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::Panel,
            3 => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::PanelFloor,
            x => Id243vcrightHvacStatusVcrightHvacAirDistributionMode::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacAirDistributionMode
    ///
    /// - Start bit: 41
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_air_distribution_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[41..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacAirDistributionMode
    #[inline(always)]
    pub fn set_vcright_hvac_air_distribution_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[41..44].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacBlowerSegment
    ///
    /// - Min: 0
    /// - Max: 11
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_blower_segment(&self) -> Id243vcrightHvacStatusVcrightHvacBlowerSegment {
        match self.vcright_hvac_blower_segment_raw() {
            1 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X1,
            10 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X10,
            11 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X11,
            2 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X2,
            3 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X3,
            4 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X4,
            5 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X5,
            6 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X6,
            7 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X7,
            8 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X8,
            9 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::X9,
            0 => Id243vcrightHvacStatusVcrightHvacBlowerSegment::Off,
            x => Id243vcrightHvacStatusVcrightHvacBlowerSegment::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacBlowerSegment
    ///
    /// - Start bit: 44
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_blower_segment_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacBlowerSegment
    #[inline(always)]
    pub fn set_vcright_hvac_blower_segment(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 11_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..48].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacCabinTempEst
    ///
    /// Cabin Temperature
    ///
    /// - Min: -40
    /// - Max: 164
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_cabin_temp_est(&self) -> f32 {
        self.vcright_hvac_cabin_temp_est_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacCabinTempEst
    ///
    /// - Start bit: 30
    /// - Signal size: 11 bits
    /// - Factor: 0.1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_cabin_temp_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[30..41].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacCabinTempEst
    #[inline(always)]
    pub fn set_vcright_hvac_cabin_temp_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 164_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[30..41].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacDuctTargetLeft
    ///
    /// - Min: -40
    /// - Max: 80
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_duct_target_left(&self) -> Id243vcrightHvacStatusVcrightHvacDuctTargetLeft {
        match self.vcright_hvac_duct_target_left_raw() {
            255 => Id243vcrightHvacStatusVcrightHvacDuctTargetLeft::Sna,
            x => Id243vcrightHvacStatusVcrightHvacDuctTargetLeft::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacDuctTargetLeft
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_duct_target_left_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacDuctTargetLeft
    #[inline(always)]
    pub fn set_vcright_hvac_duct_target_left(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 80_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacDuctTargetRight
    ///
    /// - Min: -40
    /// - Max: 80
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_duct_target_right(&self) -> Id243vcrightHvacStatusVcrightHvacDuctTargetRight {
        match self.vcright_hvac_duct_target_right_raw() {
            255 => Id243vcrightHvacStatusVcrightHvacDuctTargetRight::Sna,
            x => Id243vcrightHvacStatusVcrightHvacDuctTargetRight::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacDuctTargetRight
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_duct_target_right_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..64].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacDuctTargetRight
    #[inline(always)]
    pub fn set_vcright_hvac_duct_target_right(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 80_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..64].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacEvapInletTempEstimat
    ///
    /// - Min: -40
    /// - Max: 90
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_evap_inlet_temp_estimat(&self) -> Id243vcrightHvacStatusVcrightHvacEvapInletTempEstimat {
        match self.vcright_hvac_evap_inlet_temp_estimat_raw() {
            1023 => Id243vcrightHvacStatusVcrightHvacEvapInletTempEstimat::Sna,
            x => Id243vcrightHvacStatusVcrightHvacEvapInletTempEstimat::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacEvapInletTempEstimat
    ///
    /// - Start bit: 19
    /// - Signal size: 10 bits
    /// - Factor: 0.13
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_evap_inlet_temp_estimat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[19..29].load_le::<u16>();
        
        let factor = 0.13_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacEvapInletTempEstimat
    #[inline(always)]
    pub fn set_vcright_hvac_evap_inlet_temp_estimat(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 90_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.13_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[19..29].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacMassflowRefrigSystem
    ///
    /// - Min: 0
    /// - Max: 250
    /// - Unit: "g/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_massflow_refrig_system(&self) -> u8 {
        self.vcright_hvac_massflow_refrig_system_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacMassflowRefrigSystem
    ///
    /// - Start bit: 2
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_massflow_refrig_system_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[2..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacMassflowRefrigSystem
    #[inline(always)]
    pub fn set_vcright_hvac_massflow_refrig_system(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 250_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[2..10].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacModelInitStatus
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_model_init_status(&self) -> Id243vcrightHvacStatusVcrightHvacModelInitStatus {
        match self.vcright_hvac_model_init_status_raw() {
            4 => Id243vcrightHvacStatusVcrightHvacModelInitStatus::InitForwardCalc,
            2 => Id243vcrightHvacStatusVcrightHvacModelInitStatus::InitFromSensors,
            3 => Id243vcrightHvacStatusVcrightHvacModelInitStatus::InitFromSensorsPredictionError,
            5 => Id243vcrightHvacStatusVcrightHvacModelInitStatus::InitWaitingForSensors,
            1 => Id243vcrightHvacStatusVcrightHvacModelInitStatus::NotInitWaitForGtw,
            0 => Id243vcrightHvacStatusVcrightHvacModelInitStatus::NotInitWaitForSensors,
            x => Id243vcrightHvacStatusVcrightHvacModelInitStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacModelInitStatus
    ///
    /// - Start bit: 60
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_model_init_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[60..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacModelInitStatus
    #[inline(always)]
    pub fn set_vcright_hvac_model_init_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 5_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[60..63].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacOverheatProtActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_overheat_prot_active(&self) -> bool {
        self.vcright_hvac_overheat_prot_active_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacOverheatProtActive
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_overheat_prot_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacOverheatProtActive
    #[inline(always)]
    pub fn set_vcright_hvac_overheat_prot_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacPowerState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_power_state(&self) -> Id243vcrightHvacStatusVcrightHvacPowerState {
        match self.vcright_hvac_power_state_raw() {
            0 => Id243vcrightHvacStatusVcrightHvacPowerState::Off,
            1 => Id243vcrightHvacStatusVcrightHvacPowerState::On,
            4 => Id243vcrightHvacStatusVcrightHvacPowerState::OverheatProtect,
            3 => Id243vcrightHvacStatusVcrightHvacPowerState::OverheatProtectFanonly,
            2 => Id243vcrightHvacStatusVcrightHvacPowerState::Precondition,
            x => Id243vcrightHvacStatusVcrightHvacPowerState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacPowerState
    ///
    /// - Start bit: 51
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_power_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[51..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacPowerState
    #[inline(always)]
    pub fn set_vcright_hvac_power_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[51..54].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacQdotLeft
    ///
    /// - Min: -8191
    /// - Max: 8191
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_qdot_left(&self) -> f32 {
        self.vcright_hvac_qdot_left_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacQdotLeft
    ///
    /// - Start bit: 2
    /// - Signal size: 14 bits
    /// - Factor: 1
    /// - Offset: -8191
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_qdot_left_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[2..16].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -8191_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacQdotLeft
    #[inline(always)]
    pub fn set_vcright_hvac_qdot_left(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -8191_f32 || 8191_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 1_f32;
        let offset = -8191_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[2..16].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacQdotRight
    ///
    /// - Min: -8191
    /// - Max: 8191
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_qdot_right(&self) -> f32 {
        self.vcright_hvac_qdot_right_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacQdotRight
    ///
    /// - Start bit: 16
    /// - Signal size: 14 bits
    /// - Factor: 1
    /// - Offset: -8191
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_qdot_right_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..30].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -8191_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacQdotRight
    #[inline(always)]
    pub fn set_vcright_hvac_qdot_right(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -8191_f32 || 8191_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 1_f32;
        let offset = -8191_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..30].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacRecirc
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_recirc(&self) -> Id243vcrightHvacStatusVcrightHvacRecirc {
        match self.vcright_hvac_recirc_raw() {
            0 => Id243vcrightHvacStatusVcrightHvacRecirc::Auto,
            2 => Id243vcrightHvacStatusVcrightHvacRecirc::Fresh,
            1 => Id243vcrightHvacStatusVcrightHvacRecirc::Recirc,
            x => Id243vcrightHvacStatusVcrightHvacRecirc::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacRecirc
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_recirc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacRecirc
    #[inline(always)]
    pub fn set_vcright_hvac_recirc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacRecircDoorPercent
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_recirc_door_percent(&self) -> f32 {
        self.vcright_hvac_recirc_door_percent_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacRecircDoorPercent
    ///
    /// - Start bit: 10
    /// - Signal size: 6 bits
    /// - Factor: 1.6
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_recirc_door_percent_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..16].load_le::<u8>();
        
        let factor = 1.6_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacRecircDoorPercent
    #[inline(always)]
    pub fn set_vcright_hvac_recirc_door_percent(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 1.6_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[10..16].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacSecondRowState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_second_row_state(&self) -> Id243vcrightHvacStatusVcrightHvacSecondRowState {
        match self.vcright_hvac_second_row_state_raw() {
            0 => Id243vcrightHvacStatusVcrightHvacSecondRowState::Auto,
            4 => Id243vcrightHvacStatusVcrightHvacSecondRowState::High,
            2 => Id243vcrightHvacStatusVcrightHvacSecondRowState::Low,
            3 => Id243vcrightHvacStatusVcrightHvacSecondRowState::Med,
            1 => Id243vcrightHvacStatusVcrightHvacSecondRowState::Off,
            x => Id243vcrightHvacStatusVcrightHvacSecondRowState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacSecondRowState
    ///
    /// - Start bit: 56
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_second_row_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacSecondRowState
    #[inline(always)]
    pub fn set_vcright_hvac_second_row_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..59].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacSystemNominal
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_system_nominal(&self) -> bool {
        self.vcright_hvac_system_nominal_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacSystemNominal
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_system_nominal_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacSystemNominal
    #[inline(always)]
    pub fn set_vcright_hvac_system_nominal(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[59..60].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacVentStatus
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_vent_status(&self) -> Id243vcrightHvacStatusVcrightHvacVentStatus {
        match self.vcright_hvac_vent_status_raw() {
            0 => Id243vcrightHvacStatusVcrightHvacVentStatus::Both,
            1 => Id243vcrightHvacStatusVcrightHvacVentStatus::Left,
            2 => Id243vcrightHvacStatusVcrightHvacVentStatus::Right,
            x => Id243vcrightHvacStatusVcrightHvacVentStatus::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacVentStatus
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_vent_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacVentStatus
    #[inline(always)]
    pub fn set_vcright_hvac_vent_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempDuctLeft
    ///
    /// - Min: -22
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_duct_left(&self) -> Id243vcrightHvacStatusVcrightTempDuctLeft {
        match self.vcright_temp_duct_left_raw() {
            255 => Id243vcrightHvacStatusVcrightTempDuctLeft::Sna,
            x => Id243vcrightHvacStatusVcrightTempDuctLeft::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempDuctLeft
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -22
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_duct_left_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -22_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempDuctLeft
    #[inline(always)]
    pub fn set_vcright_temp_duct_left(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -22_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempDuctLeftLower
    ///
    /// - Min: -22
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_duct_left_lower(&self) -> Id243vcrightHvacStatusVcrightTempDuctLeftLower {
        match self.vcright_temp_duct_left_lower_raw() {
            255 => Id243vcrightHvacStatusVcrightTempDuctLeftLower::Sna,
            x => Id243vcrightHvacStatusVcrightTempDuctLeftLower::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempDuctLeftLower
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -22
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_duct_left_lower_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -22_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempDuctLeftLower
    #[inline(always)]
    pub fn set_vcright_temp_duct_left_lower(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -22_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempDuctLeftUpper
    ///
    /// - Min: -22
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_duct_left_upper(&self) -> Id243vcrightHvacStatusVcrightTempDuctLeftUpper {
        match self.vcright_temp_duct_left_upper_raw() {
            255 => Id243vcrightHvacStatusVcrightTempDuctLeftUpper::Sna,
            x => Id243vcrightHvacStatusVcrightTempDuctLeftUpper::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempDuctLeftUpper
    ///
    /// - Start bit: 2
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -22
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_duct_left_upper_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[2..10].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -22_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempDuctLeftUpper
    #[inline(always)]
    pub fn set_vcright_temp_duct_left_upper(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -22_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[2..10].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempDuctRight
    ///
    /// - Min: -22
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_duct_right(&self) -> Id243vcrightHvacStatusVcrightTempDuctRight {
        match self.vcright_temp_duct_right_raw() {
            255 => Id243vcrightHvacStatusVcrightTempDuctRight::Sna,
            x => Id243vcrightHvacStatusVcrightTempDuctRight::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempDuctRight
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -22
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_duct_right_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -22_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempDuctRight
    #[inline(always)]
    pub fn set_vcright_temp_duct_right(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -22_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempDuctRightLower
    ///
    /// - Min: -22
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_duct_right_lower(&self) -> Id243vcrightHvacStatusVcrightTempDuctRightLower {
        match self.vcright_temp_duct_right_lower_raw() {
            255 => Id243vcrightHvacStatusVcrightTempDuctRightLower::Sna,
            x => Id243vcrightHvacStatusVcrightTempDuctRightLower::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempDuctRightLower
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -22
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_duct_right_lower_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -22_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempDuctRightLower
    #[inline(always)]
    pub fn set_vcright_temp_duct_right_lower(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -22_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempDuctRightUpper
    ///
    /// - Min: -22
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_duct_right_upper(&self) -> Id243vcrightHvacStatusVcrightTempDuctRightUpper {
        match self.vcright_temp_duct_right_upper_raw() {
            255 => Id243vcrightHvacStatusVcrightTempDuctRightUpper::Sna,
            x => Id243vcrightHvacStatusVcrightTempDuctRightUpper::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempDuctRightUpper
    ///
    /// - Start bit: 10
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -22
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_duct_right_upper_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[10..18].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -22_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempDuctRightUpper
    #[inline(always)]
    pub fn set_vcright_temp_duct_right_upper(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -22_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 579 }); }
        let factor = 0.5_f32;
        let offset = -22_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[10..18].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id243vcrightHvacStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id243vcrightHvacStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_hvac_status_index = u.int_in_range(0..=3)?;
        let vcright_hvac_ac_running = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_air_distribution_mode = u.int_in_range(0..=7)?;
        let vcright_hvac_blower_segment = u.int_in_range(0..=11)?;
        let vcright_hvac_cabin_temp_est = -40_f32;
        let vcright_hvac_duct_target_left = -40_f32;
        let vcright_hvac_duct_target_right = -40_f32;
        let vcright_hvac_evap_inlet_temp_estimat = -40_f32;
        let vcright_hvac_massflow_refrig_system = u.int_in_range(0..=250)?;
        let vcright_hvac_model_init_status = u.int_in_range(0..=5)?;
        let vcright_hvac_overheat_prot_active = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_power_state = u.int_in_range(0..=4)?;
        let vcright_hvac_qdot_left = -8191_f32;
        let vcright_hvac_qdot_right = -8191_f32;
        let vcright_hvac_recirc = u.int_in_range(0..=2)?;
        let vcright_hvac_recirc_door_percent = 0_f32;
        let vcright_hvac_second_row_state = u.int_in_range(0..=4)?;
        let vcright_hvac_system_nominal = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_vent_status = u.int_in_range(0..=2)?;
        let vcright_temp_duct_left = -22_f32;
        let vcright_temp_duct_left_lower = -22_f32;
        let vcright_temp_duct_left_upper = -22_f32;
        let vcright_temp_duct_right = -22_f32;
        let vcright_temp_duct_right_lower = -22_f32;
        let vcright_temp_duct_right_upper = -22_f32;
        Id243vcrightHvacStatus::new(vcright_hvac_status_index,vcright_hvac_ac_running,vcright_hvac_air_distribution_mode,vcright_hvac_blower_segment,vcright_hvac_cabin_temp_est,vcright_hvac_duct_target_left,vcright_hvac_duct_target_right,vcright_hvac_evap_inlet_temp_estimat,vcright_hvac_massflow_refrig_system,vcright_hvac_model_init_status,vcright_hvac_overheat_prot_active,vcright_hvac_power_state,vcright_hvac_qdot_left,vcright_hvac_qdot_right,vcright_hvac_recirc,vcright_hvac_recirc_door_percent,vcright_hvac_second_row_state,vcright_hvac_system_nominal,vcright_hvac_vent_status,vcright_temp_duct_left,vcright_temp_duct_left_lower,vcright_temp_duct_left_upper,vcright_temp_duct_right,vcright_temp_duct_right_lower,vcright_temp_duct_right_upper).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_hvacStatusIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacStatusIndex {
    End,
    StatusUi,
    StatusVcfront,
    StatusVcfront2,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacACRunning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacAcRunning {
    Off,
    On,
    Other(bool),
}
/// Defined values for VCRIGHT_hvacAirDistributionMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacAirDistributionMode {
    Defrost,
    DefrostFloor,
    DefrostPanel,
    DefrostPanelFloor,
    Floor,
    None,
    Panel,
    PanelFloor,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacBlowerSegment
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacBlowerSegment {
    X1,
    X10,
    X11,
    X2,
    X3,
    X4,
    X5,
    X6,
    X7,
    X8,
    X9,
    Off,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacDuctTargetLeft
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacDuctTargetLeft {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_hvacDuctTargetRight
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacDuctTargetRight {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_hvacEvapInletTempEstimat
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacEvapInletTempEstimat {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_hvacModelInitStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacModelInitStatus {
    InitForwardCalc,
    InitFromSensors,
    InitFromSensorsPredictionError,
    InitWaitingForSensors,
    NotInitWaitForGtw,
    NotInitWaitForSensors,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacPowerState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacPowerState {
    Off,
    On,
    OverheatProtect,
    OverheatProtectFanonly,
    Precondition,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacRecirc
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacRecirc {
    Auto,
    Fresh,
    Recirc,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacSecondRowState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacSecondRowState {
    Auto,
    High,
    Low,
    Med,
    Off,
    Other(u8),
}
/// Defined values for VCRIGHT_hvacVentStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightHvacVentStatus {
    Both,
    Left,
    Right,
    Other(u8),
}
/// Defined values for VCRIGHT_tempDuctLeft
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightTempDuctLeft {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempDuctLeftLower
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightTempDuctLeftLower {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempDuctLeftUpper
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightTempDuctLeftUpper {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempDuctRight
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightTempDuctRight {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempDuctRightLower
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightTempDuctRightLower {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempDuctRightUpper
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id243vcrightHvacStatusVcrightTempDuctRightUpper {
    Sna,
    Other(f32),
}

/// ID20CVCRIGHT_hvacRequest
///
/// - ID: 524 (0x20c)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id20cvcrightHvacRequest {
    raw: [u8; 8],
}

impl Id20cvcrightHvacRequest {
    pub const MESSAGE_ID: u32 = 524;
    
    /// Construct new ID20CVCRIGHT_hvacRequest from values
    pub fn new(vcright_conditioning_request: bool, vcright_evap_performance_low: bool, vcright_hvac_blower_speed_rpm_req: f32, vcright_hvac_evap_enabled: bool, vcright_hvac_heating_enabled_left: bool, vcright_hvac_heating_enabled_right: bool, vcright_hvac_perf_test_running: bool, vcright_hvac_perf_test_state: u8, vcright_hvac_unavailable: bool, vcright_temp_ambient_raw: f32, vcright_temp_evaporator: f32, vcright_temp_evaporator_target: f32, vcright_watts_demand_evap: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcright_conditioning_request(vcright_conditioning_request)?;
        res.set_vcright_evap_performance_low(vcright_evap_performance_low)?;
        res.set_vcright_hvac_blower_speed_rpm_req(vcright_hvac_blower_speed_rpm_req)?;
        res.set_vcright_hvac_evap_enabled(vcright_hvac_evap_enabled)?;
        res.set_vcright_hvac_heating_enabled_left(vcright_hvac_heating_enabled_left)?;
        res.set_vcright_hvac_heating_enabled_right(vcright_hvac_heating_enabled_right)?;
        res.set_vcright_hvac_perf_test_running(vcright_hvac_perf_test_running)?;
        res.set_vcright_hvac_perf_test_state(vcright_hvac_perf_test_state)?;
        res.set_vcright_hvac_unavailable(vcright_hvac_unavailable)?;
        res.set_vcright_temp_ambient_raw(vcright_temp_ambient_raw)?;
        res.set_vcright_temp_evaporator(vcright_temp_evaporator)?;
        res.set_vcright_temp_evaporator_target(vcright_temp_evaporator_target)?;
        res.set_vcright_watts_demand_evap(vcright_watts_demand_evap)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCRIGHT_conditioningRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_conditioning_request(&self) -> bool {
        self.vcright_conditioning_request_raw()
    }
    
    /// Get raw value of VCRIGHT_conditioningRequest
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_conditioning_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_conditioningRequest
    #[inline(always)]
    pub fn set_vcright_conditioning_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_evapPerformanceLow
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_evap_performance_low(&self) -> bool {
        self.vcright_evap_performance_low_raw()
    }
    
    /// Get raw value of VCRIGHT_evapPerformanceLow
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_evap_performance_low_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_evapPerformanceLow
    #[inline(always)]
    pub fn set_vcright_evap_performance_low(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[43..44].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacBlowerSpeedRPMReq
    ///
    /// - Min: 0
    /// - Max: 5115
    /// - Unit: "RPM"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_blower_speed_rpm_req(&self) -> f32 {
        self.vcright_hvac_blower_speed_rpm_req_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacBlowerSpeedRPMReq
    ///
    /// - Start bit: 32
    /// - Signal size: 10 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_blower_speed_rpm_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..42].load_le::<u16>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_hvacBlowerSpeedRPMReq
    #[inline(always)]
    pub fn set_vcright_hvac_blower_speed_rpm_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5115_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 524 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..42].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacEvapEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_evap_enabled(&self) -> bool {
        self.vcright_hvac_evap_enabled_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacEvapEnabled
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_evap_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacEvapEnabled
    #[inline(always)]
    pub fn set_vcright_hvac_evap_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacHeatingEnabledLeft
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_heating_enabled_left(&self) -> bool {
        self.vcright_hvac_heating_enabled_left_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacHeatingEnabledLeft
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_heating_enabled_left_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacHeatingEnabledLeft
    #[inline(always)]
    pub fn set_vcright_hvac_heating_enabled_left(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[52..53].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacHeatingEnabledRight
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_heating_enabled_right(&self) -> bool {
        self.vcright_hvac_heating_enabled_right_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacHeatingEnabledRight
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_heating_enabled_right_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacHeatingEnabledRight
    #[inline(always)]
    pub fn set_vcright_hvac_heating_enabled_right(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[53..54].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacPerfTestRunning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_perf_test_running(&self) -> bool {
        self.vcright_hvac_perf_test_running_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacPerfTestRunning
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_perf_test_running_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacPerfTestRunning
    #[inline(always)]
    pub fn set_vcright_hvac_perf_test_running(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[42..43].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacPerfTestState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_perf_test_state(&self) -> Id20cvcrightHvacRequestVcrightHvacPerfTestState {
        match self.vcright_hvac_perf_test_state_raw() {
            2 => Id20cvcrightHvacRequestVcrightHvacPerfTestState::Blowing,
            0 => Id20cvcrightHvacRequestVcrightHvacPerfTestState::Stopped,
            1 => Id20cvcrightHvacRequestVcrightHvacPerfTestState::Waiting,
            x => Id20cvcrightHvacRequestVcrightHvacPerfTestState::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_hvacPerfTestState
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_perf_test_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCRIGHT_hvacPerfTestState
    #[inline(always)]
    pub fn set_vcright_hvac_perf_test_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 524 }); }
        self.raw.view_bits_mut::<LocalBits>()[54..56].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_hvacUnavailable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_hvac_unavailable(&self) -> bool {
        self.vcright_hvac_unavailable_raw()
    }
    
    /// Get raw value of VCRIGHT_hvacUnavailable
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_hvac_unavailable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCRIGHT_hvacUnavailable
    #[inline(always)]
    pub fn set_vcright_hvac_unavailable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[56..57].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempAmbientRaw
    ///
    /// - Min: -40
    /// - Max: 80
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_ambient_raw(&self) -> Id20cvcrightHvacRequestVcrightTempAmbientRaw {
        match self.vcright_temp_ambient_raw_raw() {
            0 => Id20cvcrightHvacRequestVcrightTempAmbientRaw::Sna,
            x => Id20cvcrightHvacRequestVcrightTempAmbientRaw::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempAmbientRaw
    ///
    /// - Start bit: 44
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_ambient_raw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..52].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempAmbientRaw
    #[inline(always)]
    pub fn set_vcright_temp_ambient_raw(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 80_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 524 }); }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[44..52].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempEvaporator
    ///
    /// - Min: -40
    /// - Max: 105
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_evaporator(&self) -> Id20cvcrightHvacRequestVcrightTempEvaporator {
        match self.vcright_temp_evaporator_raw() {
            2047 => Id20cvcrightHvacRequestVcrightTempEvaporator::Sna,
            x => Id20cvcrightHvacRequestVcrightTempEvaporator::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempEvaporator
    ///
    /// - Start bit: 13
    /// - Signal size: 11 bits
    /// - Factor: 0.1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_evaporator_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[13..24].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempEvaporator
    #[inline(always)]
    pub fn set_vcright_temp_evaporator(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 105_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 524 }); }
        let factor = 0.1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[13..24].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_tempEvaporatorTarget
    ///
    /// - Min: 0
    /// - Max: 50
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_temp_evaporator_target(&self) -> Id20cvcrightHvacRequestVcrightTempEvaporatorTarget {
        match self.vcright_temp_evaporator_target_raw() {
            255 => Id20cvcrightHvacRequestVcrightTempEvaporatorTarget::Sna,
            x => Id20cvcrightHvacRequestVcrightTempEvaporatorTarget::Other(x),
        }
    }
    
    /// Get raw value of VCRIGHT_tempEvaporatorTarget
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_temp_evaporator_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_tempEvaporatorTarget
    #[inline(always)]
    pub fn set_vcright_temp_evaporator_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 524 }); }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCRIGHT_wattsDemandEvap
    ///
    /// Evaporator Power
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcright_watts_demand_evap(&self) -> f32 {
        self.vcright_watts_demand_evap_raw()
    }
    
    /// Get raw value of VCRIGHT_wattsDemandEvap
    ///
    /// - Start bit: 0
    /// - Signal size: 11 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcright_watts_demand_evap_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[0..11].load_le::<u16>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCRIGHT_wattsDemandEvap
    #[inline(always)]
    pub fn set_vcright_watts_demand_evap(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 524 }); }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[0..11].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id20cvcrightHvacRequest {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id20cvcrightHvacRequest
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcright_conditioning_request = u.int_in_range(0..=1)? == 1;
        let vcright_evap_performance_low = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_blower_speed_rpm_req = 0_f32;
        let vcright_hvac_evap_enabled = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_heating_enabled_left = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_heating_enabled_right = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_perf_test_running = u.int_in_range(0..=1)? == 1;
        let vcright_hvac_perf_test_state = u.int_in_range(0..=2)?;
        let vcright_hvac_unavailable = u.int_in_range(0..=1)? == 1;
        let vcright_temp_ambient_raw = -40_f32;
        let vcright_temp_evaporator = -40_f32;
        let vcright_temp_evaporator_target = 0_f32;
        let vcright_watts_demand_evap = 0_f32;
        Id20cvcrightHvacRequest::new(vcright_conditioning_request,vcright_evap_performance_low,vcright_hvac_blower_speed_rpm_req,vcright_hvac_evap_enabled,vcright_hvac_heating_enabled_left,vcright_hvac_heating_enabled_right,vcright_hvac_perf_test_running,vcright_hvac_perf_test_state,vcright_hvac_unavailable,vcright_temp_ambient_raw,vcright_temp_evaporator,vcright_temp_evaporator_target,vcright_watts_demand_evap).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCRIGHT_hvacPerfTestState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20cvcrightHvacRequestVcrightHvacPerfTestState {
    Blowing,
    Stopped,
    Waiting,
    Other(u8),
}
/// Defined values for VCRIGHT_tempAmbientRaw
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20cvcrightHvacRequestVcrightTempAmbientRaw {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempEvaporator
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20cvcrightHvacRequestVcrightTempEvaporator {
    Sna,
    Other(f32),
}
/// Defined values for VCRIGHT_tempEvaporatorTarget
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id20cvcrightHvacRequestVcrightTempEvaporatorTarget {
    Sna,
    Other(f32),
}

/// ID2E1VCFRONT_status
///
/// - ID: 737 (0x2e1)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id2e1vcfrontStatus {
    raw: [u8; 8],
}

impl Id2e1vcfrontStatus {
    pub const MESSAGE_ID: u32 = 737;
    
    /// Construct new ID2E1VCFRONT_status from values
    pub fn new(vcfront_status_index: u8, vcfront_12va_rail_stable: bool, vcfront_12vb_rail_stable: bool, vcfront_12v_overcharge_counter: u8, vcfront_5va_rail_stable: bool, vcfront_5vb_rail_stable: bool, vcfront_as8510_voltage: f32, vcfront_charge_pump_voltage_stable: bool, vcfront_hsd_init_complete_u13: bool, vcfront_hsd_init_complete_u16: bool, vcfront_ibs_fault: bool, vcfront_pcs_mia: bool, vcfront_pe_reset_line_state: bool, vcfront_air_compressor_status: u8, vcfront_any_closure_open: bool, vcfront_any_door_open: bool, vcfront_battery_sm_state: u8, vcfront_charge_needed: bool, vcfront_chiller_demand_active: bool, vcfront_comp_perf_recovery_limited: bool, vcfront_coolant_fill_routine_status: u8, vcfront_crash_detected_type: u8, vcfront_crash_state: u8, vcfront_crash_unlock_override_set: bool, vcfront_epas_wake_line: bool, vcfront_freeze_evap_i_term: bool, vcfront_frunk_access_post: bool, vcfront_frunk_interior_rel_switch: bool, vcfront_frunk_latch_status: u8, vcfront_frunk_latch_type: u8, vcfront_has_low_refrigerant: bool, vcfront_headlamp_left_fan_status: bool, vcfront_headlamp_right_fan_status: bool, vcfront_headlight_left_v_position: u16, vcfront_headlight_right_v_position: u16, vcfront_homelink_comm_status: u8, vcfront_homelink_v2_response0: u8, vcfront_homelink_v2_response1: u8, vcfront_homelink_v2_response2: u8, vcfront_homelink_v2_response3: u8, vcfront_homelink_v2_response4: u8, vcfront_horn_on: bool, vcfront_hvac_mode_not_attainable: bool, vcfront_hvac_perf_test_command: u8, vcfront_i_booster_state_dbg: u8, vcfront_i_booster_wake_line: bool, vcfront_is_active_heating_battery: bool, vcfront_is_cold_start_running: bool, vcfront_is_evap_operation_allowed: bool, vcfront_is_heat_pump_oil_purge_active: bool, vcfront_max_evap_heat_rejection: f32, vcfront_min_evap_heat_rejection: f32, vcfront_passenger_buckle_status: bool, vcfront_pressure_refrig_discharge: f32, vcfront_pressure_refrig_suction: f32, vcfront_radar_heater_state: u8, vcfront_rail_a_state: bool, vcfront_rail_b_state: bool, vcfront_refrig_fill_routine_status: u8, vcfront_reverse_battery_fault: bool, vcfront_shorted_cell_fault_counter: u8, vcfront_silent_wake_ibs_current: f32, vcfront_sleep_current: f32, vcfront_temp_comp_target_voltage: f32, vcfront_time_spent_sleeping: u8, vcfront_vbat_monitor_voltage: f32, vcfront_vbat_prot: f32, vcfront_vehicle_status_dbg: u8, vcfront_voltage_drop_counter: u8, vcfront_voltage_floor_reached_count: u8, vcfront_voltage_profile: u8, vcfront_wiper_position: u8, vcfront_wiper_speed: u8, vcfront_wiper_state: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcfront_status_index(vcfront_status_index)?;
        res.set_vcfront_12va_rail_stable(vcfront_12va_rail_stable)?;
        res.set_vcfront_12vb_rail_stable(vcfront_12vb_rail_stable)?;
        res.set_vcfront_12v_overcharge_counter(vcfront_12v_overcharge_counter)?;
        res.set_vcfront_5va_rail_stable(vcfront_5va_rail_stable)?;
        res.set_vcfront_5vb_rail_stable(vcfront_5vb_rail_stable)?;
        res.set_vcfront_as8510_voltage(vcfront_as8510_voltage)?;
        res.set_vcfront_charge_pump_voltage_stable(vcfront_charge_pump_voltage_stable)?;
        res.set_vcfront_hsd_init_complete_u13(vcfront_hsd_init_complete_u13)?;
        res.set_vcfront_hsd_init_complete_u16(vcfront_hsd_init_complete_u16)?;
        res.set_vcfront_ibs_fault(vcfront_ibs_fault)?;
        res.set_vcfront_pcs_mia(vcfront_pcs_mia)?;
        res.set_vcfront_pe_reset_line_state(vcfront_pe_reset_line_state)?;
        res.set_vcfront_air_compressor_status(vcfront_air_compressor_status)?;
        res.set_vcfront_any_closure_open(vcfront_any_closure_open)?;
        res.set_vcfront_any_door_open(vcfront_any_door_open)?;
        res.set_vcfront_battery_sm_state(vcfront_battery_sm_state)?;
        res.set_vcfront_charge_needed(vcfront_charge_needed)?;
        res.set_vcfront_chiller_demand_active(vcfront_chiller_demand_active)?;
        res.set_vcfront_comp_perf_recovery_limited(vcfront_comp_perf_recovery_limited)?;
        res.set_vcfront_coolant_fill_routine_status(vcfront_coolant_fill_routine_status)?;
        res.set_vcfront_crash_detected_type(vcfront_crash_detected_type)?;
        res.set_vcfront_crash_state(vcfront_crash_state)?;
        res.set_vcfront_crash_unlock_override_set(vcfront_crash_unlock_override_set)?;
        res.set_vcfront_epas_wake_line(vcfront_epas_wake_line)?;
        res.set_vcfront_freeze_evap_i_term(vcfront_freeze_evap_i_term)?;
        res.set_vcfront_frunk_access_post(vcfront_frunk_access_post)?;
        res.set_vcfront_frunk_interior_rel_switch(vcfront_frunk_interior_rel_switch)?;
        res.set_vcfront_frunk_latch_status(vcfront_frunk_latch_status)?;
        res.set_vcfront_frunk_latch_type(vcfront_frunk_latch_type)?;
        res.set_vcfront_has_low_refrigerant(vcfront_has_low_refrigerant)?;
        res.set_vcfront_headlamp_left_fan_status(vcfront_headlamp_left_fan_status)?;
        res.set_vcfront_headlamp_right_fan_status(vcfront_headlamp_right_fan_status)?;
        res.set_vcfront_headlight_left_v_position(vcfront_headlight_left_v_position)?;
        res.set_vcfront_headlight_right_v_position(vcfront_headlight_right_v_position)?;
        res.set_vcfront_homelink_comm_status(vcfront_homelink_comm_status)?;
        res.set_vcfront_homelink_v2_response0(vcfront_homelink_v2_response0)?;
        res.set_vcfront_homelink_v2_response1(vcfront_homelink_v2_response1)?;
        res.set_vcfront_homelink_v2_response2(vcfront_homelink_v2_response2)?;
        res.set_vcfront_homelink_v2_response3(vcfront_homelink_v2_response3)?;
        res.set_vcfront_homelink_v2_response4(vcfront_homelink_v2_response4)?;
        res.set_vcfront_horn_on(vcfront_horn_on)?;
        res.set_vcfront_hvac_mode_not_attainable(vcfront_hvac_mode_not_attainable)?;
        res.set_vcfront_hvac_perf_test_command(vcfront_hvac_perf_test_command)?;
        res.set_vcfront_i_booster_state_dbg(vcfront_i_booster_state_dbg)?;
        res.set_vcfront_i_booster_wake_line(vcfront_i_booster_wake_line)?;
        res.set_vcfront_is_active_heating_battery(vcfront_is_active_heating_battery)?;
        res.set_vcfront_is_cold_start_running(vcfront_is_cold_start_running)?;
        res.set_vcfront_is_evap_operation_allowed(vcfront_is_evap_operation_allowed)?;
        res.set_vcfront_is_heat_pump_oil_purge_active(vcfront_is_heat_pump_oil_purge_active)?;
        res.set_vcfront_max_evap_heat_rejection(vcfront_max_evap_heat_rejection)?;
        res.set_vcfront_min_evap_heat_rejection(vcfront_min_evap_heat_rejection)?;
        res.set_vcfront_passenger_buckle_status(vcfront_passenger_buckle_status)?;
        res.set_vcfront_pressure_refrig_discharge(vcfront_pressure_refrig_discharge)?;
        res.set_vcfront_pressure_refrig_suction(vcfront_pressure_refrig_suction)?;
        res.set_vcfront_radar_heater_state(vcfront_radar_heater_state)?;
        res.set_vcfront_rail_a_state(vcfront_rail_a_state)?;
        res.set_vcfront_rail_b_state(vcfront_rail_b_state)?;
        res.set_vcfront_refrig_fill_routine_status(vcfront_refrig_fill_routine_status)?;
        res.set_vcfront_reverse_battery_fault(vcfront_reverse_battery_fault)?;
        res.set_vcfront_shorted_cell_fault_counter(vcfront_shorted_cell_fault_counter)?;
        res.set_vcfront_silent_wake_ibs_current(vcfront_silent_wake_ibs_current)?;
        res.set_vcfront_sleep_current(vcfront_sleep_current)?;
        res.set_vcfront_temp_comp_target_voltage(vcfront_temp_comp_target_voltage)?;
        res.set_vcfront_time_spent_sleeping(vcfront_time_spent_sleeping)?;
        res.set_vcfront_vbat_monitor_voltage(vcfront_vbat_monitor_voltage)?;
        res.set_vcfront_vbat_prot(vcfront_vbat_prot)?;
        res.set_vcfront_vehicle_status_dbg(vcfront_vehicle_status_dbg)?;
        res.set_vcfront_voltage_drop_counter(vcfront_voltage_drop_counter)?;
        res.set_vcfront_voltage_floor_reached_count(vcfront_voltage_floor_reached_count)?;
        res.set_vcfront_voltage_profile(vcfront_voltage_profile)?;
        res.set_vcfront_wiper_position(vcfront_wiper_position)?;
        res.set_vcfront_wiper_speed(vcfront_wiper_speed)?;
        res.set_vcfront_wiper_state(vcfront_wiper_state)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_statusIndex
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_status_index(&self) -> Id2e1vcfrontStatusVcfrontStatusIndex {
        match self.vcfront_status_index_raw() {
            0 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxBodyControls,
            2 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxHomelink,
            6 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxInvalid,
            4 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxLvBattery,
            3 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxRefrigerantSystem,
            5 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxSystemHealth,
            1 => Id2e1vcfrontStatusVcfrontStatusIndex::VcfStsIdxVehicleState,
            x => Id2e1vcfrontStatusVcfrontStatusIndex::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_statusIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_status_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_statusIndex
    #[inline(always)]
    pub fn set_vcfront_status_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..3].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_12VARailStable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_12va_rail_stable(&self) -> bool {
        self.vcfront_12va_rail_stable_raw()
    }
    
    /// Get raw value of VCFRONT_12VARailStable
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_12va_rail_stable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_12VARailStable
    #[inline(always)]
    pub fn set_vcfront_12va_rail_stable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_12VBRailStable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_12vb_rail_stable(&self) -> bool {
        self.vcfront_12vb_rail_stable_raw()
    }
    
    /// Get raw value of VCFRONT_12VBRailStable
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_12vb_rail_stable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_12VBRailStable
    #[inline(always)]
    pub fn set_vcfront_12vb_rail_stable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_12VOverchargeCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_12v_overcharge_counter(&self) -> u8 {
        self.vcfront_12v_overcharge_counter_raw()
    }
    
    /// Get raw value of VCFRONT_12VOverchargeCounter
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_12v_overcharge_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_12VOverchargeCounter
    #[inline(always)]
    pub fn set_vcfront_12v_overcharge_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_5VARailStable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_5va_rail_stable(&self) -> bool {
        self.vcfront_5va_rail_stable_raw()
    }
    
    /// Get raw value of VCFRONT_5VARailStable
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_5va_rail_stable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_5VARailStable
    #[inline(always)]
    pub fn set_vcfront_5va_rail_stable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_5VBRailStable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_5vb_rail_stable(&self) -> bool {
        self.vcfront_5vb_rail_stable_raw()
    }
    
    /// Get raw value of VCFRONT_5VBRailStable
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_5vb_rail_stable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_5VBRailStable
    #[inline(always)]
    pub fn set_vcfront_5vb_rail_stable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_AS8510Voltage
    ///
    /// - Min: 0
    /// - Max: 22.2864
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_as8510_voltage(&self) -> Id2e1vcfrontStatusVcfrontAs8510Voltage {
        match self.vcfront_as8510_voltage_raw() {
            4095 => Id2e1vcfrontStatusVcfrontAs8510Voltage::Sna,
            x => Id2e1vcfrontStatusVcfrontAs8510Voltage::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_AS8510Voltage
    ///
    /// - Start bit: 28
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_as8510_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..40].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_AS8510Voltage
    #[inline(always)]
    pub fn set_vcfront_as8510_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2864_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[28..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ChargePumpVoltageStable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_charge_pump_voltage_stable(&self) -> bool {
        self.vcfront_charge_pump_voltage_stable_raw()
    }
    
    /// Get raw value of VCFRONT_ChargePumpVoltageStable
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_charge_pump_voltage_stable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ChargePumpVoltageStable
    #[inline(always)]
    pub fn set_vcfront_charge_pump_voltage_stable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HSDInitCompleteU13
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hsd_init_complete_u13(&self) -> bool {
        self.vcfront_hsd_init_complete_u13_raw()
    }
    
    /// Get raw value of VCFRONT_HSDInitCompleteU13
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hsd_init_complete_u13_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_HSDInitCompleteU13
    #[inline(always)]
    pub fn set_vcfront_hsd_init_complete_u13(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HSDInitCompleteU16
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hsd_init_complete_u16(&self) -> bool {
        self.vcfront_hsd_init_complete_u16_raw()
    }
    
    /// Get raw value of VCFRONT_HSDInitCompleteU16
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hsd_init_complete_u16_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_HSDInitCompleteU16
    #[inline(always)]
    pub fn set_vcfront_hsd_init_complete_u16(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_IBSFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ibs_fault(&self) -> bool {
        self.vcfront_ibs_fault_raw()
    }
    
    /// Get raw value of VCFRONT_IBSFault
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ibs_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_IBSFault
    #[inline(always)]
    pub fn set_vcfront_ibs_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PCSMia
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pcs_mia(&self) -> bool {
        self.vcfront_pcs_mia_raw()
    }
    
    /// Get raw value of VCFRONT_PCSMia
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pcs_mia_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_PCSMia
    #[inline(always)]
    pub fn set_vcfront_pcs_mia(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PEResetLineState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pe_reset_line_state(&self) -> bool {
        self.vcfront_pe_reset_line_state_raw()
    }
    
    /// Get raw value of VCFRONT_PEResetLineState
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pe_reset_line_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_PEResetLineState
    #[inline(always)]
    pub fn set_vcfront_pe_reset_line_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_airCompressorStatus
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_air_compressor_status(&self) -> Id2e1vcfrontStatusVcfrontAirCompressorStatus {
        match self.vcfront_air_compressor_status_raw() {
            4 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusFault,
            0 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusOff,
            1 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusOn,
            5 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusRetryAvailable,
            7 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusSna,
            2 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusTurningOff,
            3 => Id2e1vcfrontStatusVcfrontAirCompressorStatus::VcfrontAirCompressorStatusTurningOn,
            x => Id2e1vcfrontStatusVcfrontAirCompressorStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_airCompressorStatus
    ///
    /// - Start bit: 25
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_air_compressor_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[25..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_airCompressorStatus
    #[inline(always)]
    pub fn set_vcfront_air_compressor_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[25..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_anyClosureOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_any_closure_open(&self) -> bool {
        self.vcfront_any_closure_open_raw()
    }
    
    /// Get raw value of VCFRONT_anyClosureOpen
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_any_closure_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_anyClosureOpen
    #[inline(always)]
    pub fn set_vcfront_any_closure_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_anyDoorOpen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_any_door_open(&self) -> bool {
        self.vcfront_any_door_open_raw()
    }
    
    /// Get raw value of VCFRONT_anyDoorOpen
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_any_door_open_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_anyDoorOpen
    #[inline(always)]
    pub fn set_vcfront_any_door_open(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_batterySMState
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_battery_sm_state(&self) -> Id2e1vcfrontStatusVcfrontBatterySmState {
        match self.vcfront_battery_sm_state_raw() {
            1 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateCharge,
            2 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateDischarge,
            6 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateDisconnectedBatteryTest,
            8 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateFault,
            0 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateInit,
            5 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateOtaStandby,
            4 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateResistanceEstimation,
            7 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateShortedCellTest,
            3 => Id2e1vcfrontStatusVcfrontBatterySmState::BatterySmStateStandby,
            x => Id2e1vcfrontStatusVcfrontBatterySmState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_batterySMState
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_battery_sm_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_batterySMState
    #[inline(always)]
    pub fn set_vcfront_battery_sm_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chargeNeeded
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_charge_needed(&self) -> bool {
        self.vcfront_charge_needed_raw()
    }
    
    /// Get raw value of VCFRONT_chargeNeeded
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_charge_needed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_chargeNeeded
    #[inline(always)]
    pub fn set_vcfront_charge_needed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerDemandActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_demand_active(&self) -> bool {
        self.vcfront_chiller_demand_active_raw()
    }
    
    /// Get raw value of VCFRONT_chillerDemandActive
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_chiller_demand_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_chillerDemandActive
    #[inline(always)]
    pub fn set_vcfront_chiller_demand_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[26..27].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_compPerfRecoveryLimited
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_comp_perf_recovery_limited(&self) -> bool {
        self.vcfront_comp_perf_recovery_limited_raw()
    }
    
    /// Get raw value of VCFRONT_compPerfRecoveryLimited
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_comp_perf_recovery_limited_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_compPerfRecoveryLimited
    #[inline(always)]
    pub fn set_vcfront_comp_perf_recovery_limited(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[27..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantFillRoutineStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_fill_routine_status(&self) -> Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus {
        match self.vcfront_coolant_fill_routine_status_raw() {
            3 => Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus::Faulted,
            1 => Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus::MovingToFillPosition,
            0 => Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus::NotReady,
            2 => Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus::ReadyToFill,
            x => Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantFillRoutineStatus
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_fill_routine_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantFillRoutineStatus
    #[inline(always)]
    pub fn set_vcfront_coolant_fill_routine_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[50..52].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_crashDetectedType
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_crash_detected_type(&self) -> Id2e1vcfrontStatusVcfrontCrashDetectedType {
        match self.vcfront_crash_detected_type_raw() {
            1 => Id2e1vcfrontStatusVcfrontCrashDetectedType::CrashDetectedTypeMinor1,
            2 => Id2e1vcfrontStatusVcfrontCrashDetectedType::CrashDetectedTypeMinor2,
            0 => Id2e1vcfrontStatusVcfrontCrashDetectedType::CrashDetectedTypeNone,
            3 => Id2e1vcfrontStatusVcfrontCrashDetectedType::CrashDetectedTypeSevere,
            x => Id2e1vcfrontStatusVcfrontCrashDetectedType::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_crashDetectedType
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_crash_detected_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_crashDetectedType
    #[inline(always)]
    pub fn set_vcfront_crash_detected_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_crashState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_crash_state(&self) -> Id2e1vcfrontStatusVcfrontCrashState {
        match self.vcfront_crash_state_raw() {
            0 => Id2e1vcfrontStatusVcfrontCrashState::CrashStateIdle,
            1 => Id2e1vcfrontStatusVcfrontCrashState::CrashStateMinor1,
            2 => Id2e1vcfrontStatusVcfrontCrashState::CrashStateMinor2,
            3 => Id2e1vcfrontStatusVcfrontCrashState::CrashStateSevere,
            x => Id2e1vcfrontStatusVcfrontCrashState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_crashState
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_crash_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_crashState
    #[inline(always)]
    pub fn set_vcfront_crash_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[22..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_crashUnlockOverrideSet
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_crash_unlock_override_set(&self) -> bool {
        self.vcfront_crash_unlock_override_set_raw()
    }
    
    /// Get raw value of VCFRONT_crashUnlockOverrideSet
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_crash_unlock_override_set_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_crashUnlockOverrideSet
    #[inline(always)]
    pub fn set_vcfront_crash_unlock_override_set(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_epasWakeLine
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_epas_wake_line(&self) -> bool {
        self.vcfront_epas_wake_line_raw()
    }
    
    /// Get raw value of VCFRONT_epasWakeLine
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_epas_wake_line_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_epasWakeLine
    #[inline(always)]
    pub fn set_vcfront_epas_wake_line(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[4..5].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_freezeEvapITerm
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_freeze_evap_i_term(&self) -> bool {
        self.vcfront_freeze_evap_i_term_raw()
    }
    
    /// Get raw value of VCFRONT_freezeEvapITerm
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_freeze_evap_i_term_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_freezeEvapITerm
    #[inline(always)]
    pub fn set_vcfront_freeze_evap_i_term(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[24..25].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_frunkAccessPost
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_frunk_access_post(&self) -> bool {
        self.vcfront_frunk_access_post_raw()
    }
    
    /// Get raw value of VCFRONT_frunkAccessPost
    ///
    /// - Start bit: 62
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_frunk_access_post_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[62..63].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_frunkAccessPost
    #[inline(always)]
    pub fn set_vcfront_frunk_access_post(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[62..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_frunkInteriorRelSwitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_frunk_interior_rel_switch(&self) -> bool {
        self.vcfront_frunk_interior_rel_switch_raw()
    }
    
    /// Get raw value of VCFRONT_frunkInteriorRelSwitch
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_frunk_interior_rel_switch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_frunkInteriorRelSwitch
    #[inline(always)]
    pub fn set_vcfront_frunk_interior_rel_switch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_frunkLatchStatus
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_frunk_latch_status(&self) -> Id2e1vcfrontStatusVcfrontFrunkLatchStatus {
        match self.vcfront_frunk_latch_status_raw() {
            5 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchAjar,
            2 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchClosed,
            3 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchClosing,
            7 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchDefault,
            8 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchFault,
            1 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchOpened,
            4 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchOpening,
            0 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchSna,
            6 => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::LatchTimeout,
            x => Id2e1vcfrontStatusVcfrontFrunkLatchStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_frunkLatchStatus
    ///
    /// - Start bit: 3
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_frunk_latch_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[3..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_frunkLatchStatus
    #[inline(always)]
    pub fn set_vcfront_frunk_latch_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[3..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_frunkLatchType
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_frunk_latch_type(&self) -> Id2e1vcfrontStatusVcfrontFrunkLatchType {
        match self.vcfront_frunk_latch_type_raw() {
            1 => Id2e1vcfrontStatusVcfrontFrunkLatchType::FrunkLatchTypeDoubleActuator,
            2 => Id2e1vcfrontStatusVcfrontFrunkLatchType::FrunkLatchTypeDoublePull,
            0 => Id2e1vcfrontStatusVcfrontFrunkLatchType::FrunkLatchTypeUnknown,
            x => Id2e1vcfrontStatusVcfrontFrunkLatchType::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_frunkLatchType
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_frunk_latch_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_frunkLatchType
    #[inline(always)]
    pub fn set_vcfront_frunk_latch_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[58..60].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hasLowRefrigerant
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_has_low_refrigerant(&self) -> bool {
        self.vcfront_has_low_refrigerant_raw()
    }
    
    /// Get raw value of VCFRONT_hasLowRefrigerant
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_has_low_refrigerant_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hasLowRefrigerant
    #[inline(always)]
    pub fn set_vcfront_has_low_refrigerant(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[29..30].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampLeftFanStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_left_fan_status(&self) -> bool {
        self.vcfront_headlamp_left_fan_status_raw()
    }
    
    /// Get raw value of VCFRONT_headlampLeftFanStatus
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_left_fan_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_headlampLeftFanStatus
    #[inline(always)]
    pub fn set_vcfront_headlamp_left_fan_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlampRightFanStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlamp_right_fan_status(&self) -> bool {
        self.vcfront_headlamp_right_fan_status_raw()
    }
    
    /// Get raw value of VCFRONT_headlampRightFanStatus
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlamp_right_fan_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_headlampRightFanStatus
    #[inline(always)]
    pub fn set_vcfront_headlamp_right_fan_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlightLeftVPosition
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlight_left_v_position(&self) -> u16 {
        self.vcfront_headlight_left_v_position_raw()
    }
    
    /// Get raw value of VCFRONT_headlightLeftVPosition
    ///
    /// - Start bit: 28
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlight_left_v_position_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[28..38].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_headlightLeftVPosition
    #[inline(always)]
    pub fn set_vcfront_headlight_left_v_position(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..38].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_headlightRightVPosition
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_headlight_right_v_position(&self) -> u16 {
        self.vcfront_headlight_right_v_position_raw()
    }
    
    /// Get raw value of VCFRONT_headlightRightVPosition
    ///
    /// - Start bit: 38
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_headlight_right_v_position_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[38..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_headlightRightVPosition
    #[inline(always)]
    pub fn set_vcfront_headlight_right_v_position(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[38..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkCommStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_comm_status(&self) -> Id2e1vcfrontStatusVcfrontHomelinkCommStatus {
        match self.vcfront_homelink_comm_status_raw() {
            3 => Id2e1vcfrontStatusVcfrontHomelinkCommStatus::HomelinkCommStatusFault,
            1 => Id2e1vcfrontStatusVcfrontHomelinkCommStatus::HomelinkCommStatusOff,
            2 => Id2e1vcfrontStatusVcfrontHomelinkCommStatus::HomelinkCommStatusOn,
            0 => Id2e1vcfrontStatusVcfrontHomelinkCommStatus::HomelinkCommStatusSna,
            x => Id2e1vcfrontStatusVcfrontHomelinkCommStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_homelinkCommStatus
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_comm_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkCommStatus
    #[inline(always)]
    pub fn set_vcfront_homelink_comm_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkV2Response0
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_v2_response0(&self) -> u8 {
        self.vcfront_homelink_v2_response0_raw()
    }
    
    /// Get raw value of VCFRONT_homelinkV2Response0
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_v2_response0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkV2Response0
    #[inline(always)]
    pub fn set_vcfront_homelink_v2_response0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkV2Response1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_v2_response1(&self) -> u8 {
        self.vcfront_homelink_v2_response1_raw()
    }
    
    /// Get raw value of VCFRONT_homelinkV2Response1
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_v2_response1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkV2Response1
    #[inline(always)]
    pub fn set_vcfront_homelink_v2_response1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkV2Response2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_v2_response2(&self) -> u8 {
        self.vcfront_homelink_v2_response2_raw()
    }
    
    /// Get raw value of VCFRONT_homelinkV2Response2
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_v2_response2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkV2Response2
    #[inline(always)]
    pub fn set_vcfront_homelink_v2_response2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkV2Response3
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_v2_response3(&self) -> u8 {
        self.vcfront_homelink_v2_response3_raw()
    }
    
    /// Get raw value of VCFRONT_homelinkV2Response3
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_v2_response3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkV2Response3
    #[inline(always)]
    pub fn set_vcfront_homelink_v2_response3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkV2Response4
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_v2_response4(&self) -> u8 {
        self.vcfront_homelink_v2_response4_raw()
    }
    
    /// Get raw value of VCFRONT_homelinkV2Response4
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_v2_response4_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkV2Response4
    #[inline(always)]
    pub fn set_vcfront_homelink_v2_response4(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hornOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_horn_on(&self) -> bool {
        self.vcfront_horn_on_raw()
    }
    
    /// Get raw value of VCFRONT_hornOn
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_horn_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hornOn
    #[inline(always)]
    pub fn set_vcfront_horn_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[51..52].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hvacModeNotAttainable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hvac_mode_not_attainable(&self) -> bool {
        self.vcfront_hvac_mode_not_attainable_raw()
    }
    
    /// Get raw value of VCFRONT_hvacModeNotAttainable
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hvac_mode_not_attainable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hvacModeNotAttainable
    #[inline(always)]
    pub fn set_vcfront_hvac_mode_not_attainable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[28..29].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hvacPerfTestCommand
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hvac_perf_test_command(&self) -> Id2e1vcfrontStatusVcfrontHvacPerfTestCommand {
        match self.vcfront_hvac_perf_test_command_raw() {
            2 => Id2e1vcfrontStatusVcfrontHvacPerfTestCommand::Blow,
            1 => Id2e1vcfrontStatusVcfrontHvacPerfTestCommand::Init,
            0 => Id2e1vcfrontStatusVcfrontHvacPerfTestCommand::NotStarted,
            3 => Id2e1vcfrontStatusVcfrontHvacPerfTestCommand::Stop,
            x => Id2e1vcfrontStatusVcfrontHvacPerfTestCommand::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_hvacPerfTestCommand
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hvac_perf_test_command_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hvacPerfTestCommand
    #[inline(always)]
    pub fn set_vcfront_hvac_perf_test_command(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[48..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterStateDBG
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_state_dbg(&self) -> Id2e1vcfrontStatusVcfrontIBoosterStateDbg {
        match self.vcfront_i_booster_state_dbg_raw() {
            4 => Id2e1vcfrontStatusVcfrontIBoosterStateDbg::IboosterForceOff,
            2 => Id2e1vcfrontStatusVcfrontIBoosterStateDbg::IboosterGoingDown,
            0 => Id2e1vcfrontStatusVcfrontIBoosterStateDbg::IboosterOff,
            1 => Id2e1vcfrontStatusVcfrontIBoosterStateDbg::IboosterOn,
            3 => Id2e1vcfrontStatusVcfrontIBoosterStateDbg::IboosterWritingDataShutdown,
            x => Id2e1vcfrontStatusVcfrontIBoosterStateDbg::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_iBoosterStateDBG
    ///
    /// - Start bit: 5
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_state_dbg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[5..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_iBoosterStateDBG
    #[inline(always)]
    pub fn set_vcfront_i_booster_state_dbg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_iBoosterWakeLine
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_i_booster_wake_line(&self) -> bool {
        self.vcfront_i_booster_wake_line_raw()
    }
    
    /// Get raw value of VCFRONT_iBoosterWakeLine
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_i_booster_wake_line_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_iBoosterWakeLine
    #[inline(always)]
    pub fn set_vcfront_i_booster_wake_line(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[3..4].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_isActiveHeatingBattery
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_is_active_heating_battery(&self) -> bool {
        self.vcfront_is_active_heating_battery_raw()
    }
    
    /// Get raw value of VCFRONT_isActiveHeatingBattery
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_is_active_heating_battery_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_isActiveHeatingBattery
    #[inline(always)]
    pub fn set_vcfront_is_active_heating_battery(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[63..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_isColdStartRunning
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_is_cold_start_running(&self) -> bool {
        self.vcfront_is_cold_start_running_raw()
    }
    
    /// Get raw value of VCFRONT_isColdStartRunning
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_is_cold_start_running_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_isColdStartRunning
    #[inline(always)]
    pub fn set_vcfront_is_cold_start_running(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_isEvapOperationAllowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_is_evap_operation_allowed(&self) -> bool {
        self.vcfront_is_evap_operation_allowed_raw()
    }
    
    /// Get raw value of VCFRONT_isEvapOperationAllowed
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_is_evap_operation_allowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_isEvapOperationAllowed
    #[inline(always)]
    pub fn set_vcfront_is_evap_operation_allowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[25..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_isHeatPumpOilPurgeActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_is_heat_pump_oil_purge_active(&self) -> bool {
        self.vcfront_is_heat_pump_oil_purge_active_raw()
    }
    
    /// Get raw value of VCFRONT_isHeatPumpOilPurgeActive
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_is_heat_pump_oil_purge_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_isHeatPumpOilPurgeActive
    #[inline(always)]
    pub fn set_vcfront_is_heat_pump_oil_purge_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[31..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_maxEvapHeatRejection
    ///
    /// - Min: 0
    /// - Max: 16575
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_max_evap_heat_rejection(&self) -> f32 {
        self.vcfront_max_evap_heat_rejection_raw()
    }
    
    /// Get raw value of VCFRONT_maxEvapHeatRejection
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 65
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_max_evap_heat_rejection_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 65_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_maxEvapHeatRejection
    #[inline(always)]
    pub fn set_vcfront_max_evap_heat_rejection(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16575_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 65_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_minEvapHeatRejection
    ///
    /// - Min: 0
    /// - Max: 2500
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_min_evap_heat_rejection(&self) -> f32 {
        self.vcfront_min_evap_heat_rejection_raw()
    }
    
    /// Get raw value of VCFRONT_minEvapHeatRejection
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_min_evap_heat_rejection_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_minEvapHeatRejection
    #[inline(always)]
    pub fn set_vcfront_min_evap_heat_rejection(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_passengerBuckleStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_passenger_buckle_status(&self) -> Id2e1vcfrontStatusVcfrontPassengerBuckleStatus {
        match self.vcfront_passenger_buckle_status_raw() {
            true => Id2e1vcfrontStatusVcfrontPassengerBuckleStatus::Buckled,
            false => Id2e1vcfrontStatusVcfrontPassengerBuckleStatus::Unbuckled,
            x => Id2e1vcfrontStatusVcfrontPassengerBuckleStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_passengerBuckleStatus
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_passenger_buckle_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_passengerBuckleStatus
    #[inline(always)]
    pub fn set_vcfront_passenger_buckle_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[57..58].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pressureRefrigDischarge
    ///
    /// - Min: 0
    /// - Max: 31.75
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pressure_refrig_discharge(&self) -> Id2e1vcfrontStatusVcfrontPressureRefrigDischarge {
        match self.vcfront_pressure_refrig_discharge_raw() {
            255 => Id2e1vcfrontStatusVcfrontPressureRefrigDischarge::Sna,
            x => Id2e1vcfrontStatusVcfrontPressureRefrigDischarge::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pressureRefrigDischarge
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pressure_refrig_discharge_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pressureRefrigDischarge
    #[inline(always)]
    pub fn set_vcfront_pressure_refrig_discharge(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 31.75_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pressureRefrigSuction
    ///
    /// - Min: 0
    /// - Max: 11.5
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pressure_refrig_suction(&self) -> Id2e1vcfrontStatusVcfrontPressureRefrigSuction {
        match self.vcfront_pressure_refrig_suction_raw() {
            127 => Id2e1vcfrontStatusVcfrontPressureRefrigSuction::Sna,
            x => Id2e1vcfrontStatusVcfrontPressureRefrigSuction::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pressureRefrigSuction
    ///
    /// - Start bit: 32
    /// - Signal size: 7 bits
    /// - Factor: 0.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pressure_refrig_suction_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..39].load_le::<u8>();
        
        let factor = 0.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pressureRefrigSuction
    #[inline(always)]
    pub fn set_vcfront_pressure_refrig_suction(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 11.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..39].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radarHeaterState
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_radar_heater_state(&self) -> Id2e1vcfrontStatusVcfrontRadarHeaterState {
        match self.vcfront_radar_heater_state_raw() {
            4 => Id2e1vcfrontStatusVcfrontRadarHeaterState::HeaterStateFault,
            2 => Id2e1vcfrontStatusVcfrontRadarHeaterState::HeaterStateOff,
            3 => Id2e1vcfrontStatusVcfrontRadarHeaterState::HeaterStateOffUnavailable,
            1 => Id2e1vcfrontStatusVcfrontRadarHeaterState::HeaterStateOn,
            0 => Id2e1vcfrontStatusVcfrontRadarHeaterState::HeaterStateSna,
            x => Id2e1vcfrontStatusVcfrontRadarHeaterState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_radarHeaterState
    ///
    /// - Start bit: 52
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_radar_heater_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..55].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_radarHeaterState
    #[inline(always)]
    pub fn set_vcfront_radar_heater_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..55].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_railAState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rail_a_state(&self) -> bool {
        self.vcfront_rail_a_state_raw()
    }
    
    /// Get raw value of VCFRONT_railAState
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rail_a_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_railAState
    #[inline(always)]
    pub fn set_vcfront_rail_a_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_railBState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rail_b_state(&self) -> bool {
        self.vcfront_rail_b_state_raw()
    }
    
    /// Get raw value of VCFRONT_railBState
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rail_b_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_railBState
    #[inline(always)]
    pub fn set_vcfront_rail_b_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_refrigFillRoutineStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_refrig_fill_routine_status(&self) -> Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus {
        match self.vcfront_refrig_fill_routine_status_raw() {
            3 => Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus::Faulted,
            1 => Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus::MovingToFillPosition,
            0 => Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus::NotReady,
            2 => Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus::ReadyToFill,
            x => Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_refrigFillRoutineStatus
    ///
    /// - Start bit: 52
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_refrig_fill_routine_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[52..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_refrigFillRoutineStatus
    #[inline(always)]
    pub fn set_vcfront_refrig_fill_routine_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[52..54].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_reverseBatteryFault
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_reverse_battery_fault(&self) -> bool {
        self.vcfront_reverse_battery_fault_raw()
    }
    
    /// Get raw value of VCFRONT_reverseBatteryFault
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_reverse_battery_fault_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_reverseBatteryFault
    #[inline(always)]
    pub fn set_vcfront_reverse_battery_fault(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[30..31].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_shortedCellFaultCounter
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_shorted_cell_fault_counter(&self) -> u8 {
        self.vcfront_shorted_cell_fault_counter_raw()
    }
    
    /// Get raw value of VCFRONT_shortedCellFaultCounter
    ///
    /// - Start bit: 44
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_shorted_cell_fault_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[44..47].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_shortedCellFaultCounter
    #[inline(always)]
    pub fn set_vcfront_shorted_cell_fault_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[44..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_silentWakeIBSCurrent
    ///
    /// - Min: -409.5
    /// - Max: 0
    /// - Unit: "mA"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_silent_wake_ibs_current(&self) -> f32 {
        self.vcfront_silent_wake_ibs_current_raw()
    }
    
    /// Get raw value of VCFRONT_silentWakeIBSCurrent
    ///
    /// - Start bit: 32
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: -204.7
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_silent_wake_ibs_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..44].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = -204.7_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_silentWakeIBSCurrent
    #[inline(always)]
    pub fn set_vcfront_silent_wake_ibs_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -409.5_f32 || 0_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.1_f32;
        let offset = -204.7_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_sleepCurrent
    ///
    /// - Min: -409.5
    /// - Max: 0
    /// - Unit: "mA"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_sleep_current(&self) -> f32 {
        self.vcfront_sleep_current_raw()
    }
    
    /// Get raw value of VCFRONT_sleepCurrent
    ///
    /// - Start bit: 32
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: -204.7
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_sleep_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..44].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = -204.7_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_sleepCurrent
    #[inline(always)]
    pub fn set_vcfront_sleep_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -409.5_f32 || 0_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.1_f32;
        let offset = -204.7_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tempCompTargetVoltage
    ///
    /// - Min: 9
    /// - Max: 16
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_temp_comp_target_voltage(&self) -> f32 {
        self.vcfront_temp_comp_target_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_tempCompTargetVoltage
    ///
    /// - Start bit: 3
    /// - Signal size: 10 bits
    /// - Factor: 0.01
    /// - Offset: 9
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_temp_comp_target_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[3..13].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = 9_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_tempCompTargetVoltage
    #[inline(always)]
    pub fn set_vcfront_temp_comp_target_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 9_f32 || 16_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.01_f32;
        let offset = 9_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[3..13].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_timeSpentSleeping
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_time_spent_sleeping(&self) -> u8 {
        self.vcfront_time_spent_sleeping_raw()
    }
    
    /// Get raw value of VCFRONT_timeSpentSleeping
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_time_spent_sleeping_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_timeSpentSleeping
    #[inline(always)]
    pub fn set_vcfront_time_spent_sleeping(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatMonitorVoltage
    ///
    /// - Min: 0
    /// - Max: 22.2864
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_monitor_voltage(&self) -> Id2e1vcfrontStatusVcfrontVbatMonitorVoltage {
        match self.vcfront_vbat_monitor_voltage_raw() {
            4095 => Id2e1vcfrontStatusVcfrontVbatMonitorVoltage::Sna,
            x => Id2e1vcfrontStatusVcfrontVbatMonitorVoltage::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vbatMonitorVoltage
    ///
    /// - Start bit: 16
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_monitor_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..28].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_vbatMonitorVoltage
    #[inline(always)]
    pub fn set_vcfront_vbat_monitor_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2864_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[16..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vbatProt
    ///
    /// - Min: 0
    /// - Max: 22.2919
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vbat_prot(&self) -> f32 {
        self.vcfront_vbat_prot_raw()
    }
    
    /// Get raw value of VCFRONT_vbatProt
    ///
    /// - Start bit: 40
    /// - Signal size: 12 bits
    /// - Factor: 0.00544368
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vbat_prot_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..52].load_le::<u16>();
        
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_vbatProt
    #[inline(always)]
    pub fn set_vcfront_vbat_prot(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 22.2919_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        let factor = 0.00544368_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[40..52].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_vehicleStatusDBG
    ///
    /// - Min: 0
    /// - Max: 17
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_vehicle_status_dbg(&self) -> Id2e1vcfrontStatusVcfrontVehicleStatusDbg {
        match self.vcfront_vehicle_status_dbg_raw() {
            10 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusAccessory,
            11 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusAccessoryPlus,
            3 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusBatteryPostWake,
            12 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusConditioning,
            14 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusCrash,
            13 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusDrive,
            9 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusHvUpStandby,
            0 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusInit,
            1 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusLowPowerStandby,
            8 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusLvAwake,
            7 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusLvShutdown,
            15 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusOta,
            17 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusReset,
            2 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusSilentWake,
            5 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusSleepShutdown,
            6 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusSleepStandby,
            4 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusSystemChecks,
            16 => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::VehicleStatusTurnOnRails,
            x => Id2e1vcfrontStatusVcfrontVehicleStatusDbg::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_vehicleStatusDBG
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_vehicle_status_dbg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_vehicleStatusDBG
    #[inline(always)]
    pub fn set_vcfront_vehicle_status_dbg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 17_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..13].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_voltageDropCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_voltage_drop_counter(&self) -> u8 {
        self.vcfront_voltage_drop_counter_raw()
    }
    
    /// Get raw value of VCFRONT_voltageDropCounter
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_voltage_drop_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_voltageDropCounter
    #[inline(always)]
    pub fn set_vcfront_voltage_drop_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[20..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_voltageFloorReachedCount
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_voltage_floor_reached_count(&self) -> u8 {
        self.vcfront_voltage_floor_reached_count_raw()
    }
    
    /// Get raw value of VCFRONT_voltageFloorReachedCount
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_voltage_floor_reached_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_voltageFloorReachedCount
    #[inline(always)]
    pub fn set_vcfront_voltage_floor_reached_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_voltageProfile
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_voltage_profile(&self) -> Id2e1vcfrontStatusVcfrontVoltageProfile {
        match self.vcfront_voltage_profile_raw() {
            3 => Id2e1vcfrontStatusVcfrontVoltageProfile::VoltageProfileAlwaysClosedContactors,
            0 => Id2e1vcfrontStatusVcfrontVoltageProfile::VoltageProfileCharge,
            1 => Id2e1vcfrontStatusVcfrontVoltageProfile::VoltageProfileFloat,
            2 => Id2e1vcfrontStatusVcfrontVoltageProfile::VoltageProfileReducedFloat,
            x => Id2e1vcfrontStatusVcfrontVoltageProfile::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_voltageProfile
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_voltage_profile_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_voltageProfile
    #[inline(always)]
    pub fn set_vcfront_voltage_profile(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..30].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_wiperPosition
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_wiper_position(&self) -> Id2e1vcfrontStatusVcfrontWiperPosition {
        match self.vcfront_wiper_position_raw() {
            3 => Id2e1vcfrontStatusVcfrontWiperPosition::WiperPositionDelayedRest,
            2 => Id2e1vcfrontStatusVcfrontWiperPosition::WiperPositionDepressedPark,
            1 => Id2e1vcfrontStatusVcfrontWiperPosition::WiperPositionService,
            0 => Id2e1vcfrontStatusVcfrontWiperPosition::WiperPositionSna,
            4 => Id2e1vcfrontStatusVcfrontWiperPosition::WiperPositionWiping,
            x => Id2e1vcfrontStatusVcfrontWiperPosition::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_wiperPosition
    ///
    /// - Start bit: 12
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_wiper_position_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_wiperPosition
    #[inline(always)]
    pub fn set_vcfront_wiper_position(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_wiperSpeed
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_wiper_speed(&self) -> Id2e1vcfrontStatusVcfrontWiperSpeed {
        match self.vcfront_wiper_speed_raw() {
            2 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeed1,
            3 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeed2,
            4 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeed3,
            5 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeed4,
            6 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeed5,
            8 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeedHigh,
            7 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeedLow,
            1 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeedOff,
            0 => Id2e1vcfrontStatusVcfrontWiperSpeed::WiperSpeedSna,
            x => Id2e1vcfrontStatusVcfrontWiperSpeed::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_wiperSpeed
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_wiper_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_wiperSpeed
    #[inline(always)]
    pub fn set_vcfront_wiper_speed(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_wiperState
    ///
    /// - Min: 0
    /// - Max: 12
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_wiper_state(&self) -> Id2e1vcfrontStatusVcfrontWiperState {
        match self.vcfront_wiper_state_raw() {
            9 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateContFast,
            10 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateContSlow,
            3 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateDelayedRest,
            2 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateFault,
            7 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateIntermittentHigh,
            8 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateIntermittentLow,
            12 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateIntAutoHigh,
            11 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateIntAutoLow,
            6 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateMomentaryWipe,
            4 => Id2e1vcfrontStatusVcfrontWiperState::WiperStatePark,
            1 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateService,
            0 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateSna,
            5 => Id2e1vcfrontStatusVcfrontWiperState::WiperStateWash,
            x => Id2e1vcfrontStatusVcfrontWiperState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_wiperState
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_wiper_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_wiperState
    #[inline(always)]
    pub fn set_vcfront_wiper_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 12_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 737 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..20].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id2e1vcfrontStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id2e1vcfrontStatus
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_status_index = u.int_in_range(0..=6)?;
        let vcfront_12va_rail_stable = u.int_in_range(0..=1)? == 1;
        let vcfront_12vb_rail_stable = u.int_in_range(0..=1)? == 1;
        let vcfront_12v_overcharge_counter = u.int_in_range(0..=15)?;
        let vcfront_5va_rail_stable = u.int_in_range(0..=1)? == 1;
        let vcfront_5vb_rail_stable = u.int_in_range(0..=1)? == 1;
        let vcfront_as8510_voltage = 0_f32;
        let vcfront_charge_pump_voltage_stable = u.int_in_range(0..=1)? == 1;
        let vcfront_hsd_init_complete_u13 = u.int_in_range(0..=1)? == 1;
        let vcfront_hsd_init_complete_u16 = u.int_in_range(0..=1)? == 1;
        let vcfront_ibs_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_pcs_mia = u.int_in_range(0..=1)? == 1;
        let vcfront_pe_reset_line_state = u.int_in_range(0..=1)? == 1;
        let vcfront_air_compressor_status = u.int_in_range(0..=7)?;
        let vcfront_any_closure_open = u.int_in_range(0..=1)? == 1;
        let vcfront_any_door_open = u.int_in_range(0..=1)? == 1;
        let vcfront_battery_sm_state = u.int_in_range(0..=8)?;
        let vcfront_charge_needed = u.int_in_range(0..=1)? == 1;
        let vcfront_chiller_demand_active = u.int_in_range(0..=1)? == 1;
        let vcfront_comp_perf_recovery_limited = u.int_in_range(0..=1)? == 1;
        let vcfront_coolant_fill_routine_status = u.int_in_range(0..=3)?;
        let vcfront_crash_detected_type = u.int_in_range(0..=3)?;
        let vcfront_crash_state = u.int_in_range(0..=3)?;
        let vcfront_crash_unlock_override_set = u.int_in_range(0..=1)? == 1;
        let vcfront_epas_wake_line = u.int_in_range(0..=1)? == 1;
        let vcfront_freeze_evap_i_term = u.int_in_range(0..=1)? == 1;
        let vcfront_frunk_access_post = u.int_in_range(0..=1)? == 1;
        let vcfront_frunk_interior_rel_switch = u.int_in_range(0..=1)? == 1;
        let vcfront_frunk_latch_status = u.int_in_range(0..=8)?;
        let vcfront_frunk_latch_type = u.int_in_range(0..=2)?;
        let vcfront_has_low_refrigerant = u.int_in_range(0..=1)? == 1;
        let vcfront_headlamp_left_fan_status = u.int_in_range(0..=1)? == 1;
        let vcfront_headlamp_right_fan_status = u.int_in_range(0..=1)? == 1;
        let vcfront_headlight_left_v_position = u.int_in_range(0..=1023)?;
        let vcfront_headlight_right_v_position = u.int_in_range(0..=1023)?;
        let vcfront_homelink_comm_status = u.int_in_range(0..=3)?;
        let vcfront_homelink_v2_response0 = u.int_in_range(0..=255)?;
        let vcfront_homelink_v2_response1 = u.int_in_range(0..=255)?;
        let vcfront_homelink_v2_response2 = u.int_in_range(0..=255)?;
        let vcfront_homelink_v2_response3 = u.int_in_range(0..=255)?;
        let vcfront_homelink_v2_response4 = u.int_in_range(0..=255)?;
        let vcfront_horn_on = u.int_in_range(0..=1)? == 1;
        let vcfront_hvac_mode_not_attainable = u.int_in_range(0..=1)? == 1;
        let vcfront_hvac_perf_test_command = u.int_in_range(0..=3)?;
        let vcfront_i_booster_state_dbg = u.int_in_range(0..=4)?;
        let vcfront_i_booster_wake_line = u.int_in_range(0..=1)? == 1;
        let vcfront_is_active_heating_battery = u.int_in_range(0..=1)? == 1;
        let vcfront_is_cold_start_running = u.int_in_range(0..=1)? == 1;
        let vcfront_is_evap_operation_allowed = u.int_in_range(0..=1)? == 1;
        let vcfront_is_heat_pump_oil_purge_active = u.int_in_range(0..=1)? == 1;
        let vcfront_max_evap_heat_rejection = 0_f32;
        let vcfront_min_evap_heat_rejection = 0_f32;
        let vcfront_passenger_buckle_status = u.int_in_range(0..=1)? == 1;
        let vcfront_pressure_refrig_discharge = 0_f32;
        let vcfront_pressure_refrig_suction = 0_f32;
        let vcfront_radar_heater_state = u.int_in_range(0..=4)?;
        let vcfront_rail_a_state = u.int_in_range(0..=1)? == 1;
        let vcfront_rail_b_state = u.int_in_range(0..=1)? == 1;
        let vcfront_refrig_fill_routine_status = u.int_in_range(0..=3)?;
        let vcfront_reverse_battery_fault = u.int_in_range(0..=1)? == 1;
        let vcfront_shorted_cell_fault_counter = u.int_in_range(0..=7)?;
        let vcfront_silent_wake_ibs_current = -409.5_f32;
        let vcfront_sleep_current = -409.5_f32;
        let vcfront_temp_comp_target_voltage = 9_f32;
        let vcfront_time_spent_sleeping = u.int_in_range(0..=255)?;
        let vcfront_vbat_monitor_voltage = 0_f32;
        let vcfront_vbat_prot = 0_f32;
        let vcfront_vehicle_status_dbg = u.int_in_range(0..=17)?;
        let vcfront_voltage_drop_counter = u.int_in_range(0..=15)?;
        let vcfront_voltage_floor_reached_count = u.int_in_range(0..=15)?;
        let vcfront_voltage_profile = u.int_in_range(0..=3)?;
        let vcfront_wiper_position = u.int_in_range(0..=4)?;
        let vcfront_wiper_speed = u.int_in_range(0..=8)?;
        let vcfront_wiper_state = u.int_in_range(0..=12)?;
        Id2e1vcfrontStatus::new(vcfront_status_index,vcfront_12va_rail_stable,vcfront_12vb_rail_stable,vcfront_12v_overcharge_counter,vcfront_5va_rail_stable,vcfront_5vb_rail_stable,vcfront_as8510_voltage,vcfront_charge_pump_voltage_stable,vcfront_hsd_init_complete_u13,vcfront_hsd_init_complete_u16,vcfront_ibs_fault,vcfront_pcs_mia,vcfront_pe_reset_line_state,vcfront_air_compressor_status,vcfront_any_closure_open,vcfront_any_door_open,vcfront_battery_sm_state,vcfront_charge_needed,vcfront_chiller_demand_active,vcfront_comp_perf_recovery_limited,vcfront_coolant_fill_routine_status,vcfront_crash_detected_type,vcfront_crash_state,vcfront_crash_unlock_override_set,vcfront_epas_wake_line,vcfront_freeze_evap_i_term,vcfront_frunk_access_post,vcfront_frunk_interior_rel_switch,vcfront_frunk_latch_status,vcfront_frunk_latch_type,vcfront_has_low_refrigerant,vcfront_headlamp_left_fan_status,vcfront_headlamp_right_fan_status,vcfront_headlight_left_v_position,vcfront_headlight_right_v_position,vcfront_homelink_comm_status,vcfront_homelink_v2_response0,vcfront_homelink_v2_response1,vcfront_homelink_v2_response2,vcfront_homelink_v2_response3,vcfront_homelink_v2_response4,vcfront_horn_on,vcfront_hvac_mode_not_attainable,vcfront_hvac_perf_test_command,vcfront_i_booster_state_dbg,vcfront_i_booster_wake_line,vcfront_is_active_heating_battery,vcfront_is_cold_start_running,vcfront_is_evap_operation_allowed,vcfront_is_heat_pump_oil_purge_active,vcfront_max_evap_heat_rejection,vcfront_min_evap_heat_rejection,vcfront_passenger_buckle_status,vcfront_pressure_refrig_discharge,vcfront_pressure_refrig_suction,vcfront_radar_heater_state,vcfront_rail_a_state,vcfront_rail_b_state,vcfront_refrig_fill_routine_status,vcfront_reverse_battery_fault,vcfront_shorted_cell_fault_counter,vcfront_silent_wake_ibs_current,vcfront_sleep_current,vcfront_temp_comp_target_voltage,vcfront_time_spent_sleeping,vcfront_vbat_monitor_voltage,vcfront_vbat_prot,vcfront_vehicle_status_dbg,vcfront_voltage_drop_counter,vcfront_voltage_floor_reached_count,vcfront_voltage_profile,vcfront_wiper_position,vcfront_wiper_speed,vcfront_wiper_state).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_statusIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontStatusIndex {
    VcfStsIdxBodyControls,
    VcfStsIdxHomelink,
    VcfStsIdxInvalid,
    VcfStsIdxLvBattery,
    VcfStsIdxRefrigerantSystem,
    VcfStsIdxSystemHealth,
    VcfStsIdxVehicleState,
    Other(u8),
}
/// Defined values for VCFRONT_AS8510Voltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontAs8510Voltage {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_airCompressorStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontAirCompressorStatus {
    VcfrontAirCompressorStatusFault,
    VcfrontAirCompressorStatusOff,
    VcfrontAirCompressorStatusOn,
    VcfrontAirCompressorStatusRetryAvailable,
    VcfrontAirCompressorStatusSna,
    VcfrontAirCompressorStatusTurningOff,
    VcfrontAirCompressorStatusTurningOn,
    Other(u8),
}
/// Defined values for VCFRONT_batterySMState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontBatterySmState {
    BatterySmStateCharge,
    BatterySmStateDischarge,
    BatterySmStateDisconnectedBatteryTest,
    BatterySmStateFault,
    BatterySmStateInit,
    BatterySmStateOtaStandby,
    BatterySmStateResistanceEstimation,
    BatterySmStateShortedCellTest,
    BatterySmStateStandby,
    Other(u8),
}
/// Defined values for VCFRONT_coolantFillRoutineStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontCoolantFillRoutineStatus {
    Faulted,
    MovingToFillPosition,
    NotReady,
    ReadyToFill,
    Other(u8),
}
/// Defined values for VCFRONT_crashDetectedType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontCrashDetectedType {
    CrashDetectedTypeMinor1,
    CrashDetectedTypeMinor2,
    CrashDetectedTypeNone,
    CrashDetectedTypeSevere,
    Other(u8),
}
/// Defined values for VCFRONT_crashState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontCrashState {
    CrashStateIdle,
    CrashStateMinor1,
    CrashStateMinor2,
    CrashStateSevere,
    Other(u8),
}
/// Defined values for VCFRONT_frunkLatchStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontFrunkLatchStatus {
    LatchAjar,
    LatchClosed,
    LatchClosing,
    LatchDefault,
    LatchFault,
    LatchOpened,
    LatchOpening,
    LatchSna,
    LatchTimeout,
    Other(u8),
}
/// Defined values for VCFRONT_frunkLatchType
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontFrunkLatchType {
    FrunkLatchTypeDoubleActuator,
    FrunkLatchTypeDoublePull,
    FrunkLatchTypeUnknown,
    Other(u8),
}
/// Defined values for VCFRONT_homelinkCommStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontHomelinkCommStatus {
    HomelinkCommStatusFault,
    HomelinkCommStatusOff,
    HomelinkCommStatusOn,
    HomelinkCommStatusSna,
    Other(u8),
}
/// Defined values for VCFRONT_hvacPerfTestCommand
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontHvacPerfTestCommand {
    Blow,
    Init,
    NotStarted,
    Stop,
    Other(u8),
}
/// Defined values for VCFRONT_iBoosterStateDBG
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontIBoosterStateDbg {
    IboosterForceOff,
    IboosterGoingDown,
    IboosterOff,
    IboosterOn,
    IboosterWritingDataShutdown,
    Other(u8),
}
/// Defined values for VCFRONT_passengerBuckleStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontPassengerBuckleStatus {
    Buckled,
    Unbuckled,
    Other(bool),
}
/// Defined values for VCFRONT_pressureRefrigDischarge
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontPressureRefrigDischarge {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_pressureRefrigSuction
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontPressureRefrigSuction {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_radarHeaterState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontRadarHeaterState {
    HeaterStateFault,
    HeaterStateOff,
    HeaterStateOffUnavailable,
    HeaterStateOn,
    HeaterStateSna,
    Other(u8),
}
/// Defined values for VCFRONT_refrigFillRoutineStatus
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontRefrigFillRoutineStatus {
    Faulted,
    MovingToFillPosition,
    NotReady,
    ReadyToFill,
    Other(u8),
}
/// Defined values for VCFRONT_vbatMonitorVoltage
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontVbatMonitorVoltage {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_vehicleStatusDBG
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontVehicleStatusDbg {
    VehicleStatusAccessory,
    VehicleStatusAccessoryPlus,
    VehicleStatusBatteryPostWake,
    VehicleStatusConditioning,
    VehicleStatusCrash,
    VehicleStatusDrive,
    VehicleStatusHvUpStandby,
    VehicleStatusInit,
    VehicleStatusLowPowerStandby,
    VehicleStatusLvAwake,
    VehicleStatusLvShutdown,
    VehicleStatusOta,
    VehicleStatusReset,
    VehicleStatusSilentWake,
    VehicleStatusSleepShutdown,
    VehicleStatusSleepStandby,
    VehicleStatusSystemChecks,
    VehicleStatusTurnOnRails,
    Other(u8),
}
/// Defined values for VCFRONT_voltageProfile
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontVoltageProfile {
    VoltageProfileAlwaysClosedContactors,
    VoltageProfileCharge,
    VoltageProfileFloat,
    VoltageProfileReducedFloat,
    Other(u8),
}
/// Defined values for VCFRONT_wiperPosition
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontWiperPosition {
    WiperPositionDelayedRest,
    WiperPositionDepressedPark,
    WiperPositionService,
    WiperPositionSna,
    WiperPositionWiping,
    Other(u8),
}
/// Defined values for VCFRONT_wiperSpeed
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontWiperSpeed {
    WiperSpeed1,
    WiperSpeed2,
    WiperSpeed3,
    WiperSpeed4,
    WiperSpeed5,
    WiperSpeedHigh,
    WiperSpeedLow,
    WiperSpeedOff,
    WiperSpeedSna,
    Other(u8),
}
/// Defined values for VCFRONT_wiperState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id2e1vcfrontStatusVcfrontWiperState {
    WiperStateContFast,
    WiperStateContSlow,
    WiperStateDelayedRest,
    WiperStateFault,
    WiperStateIntermittentHigh,
    WiperStateIntermittentLow,
    WiperStateIntAutoHigh,
    WiperStateIntAutoLow,
    WiperStateMomentaryWipe,
    WiperStatePark,
    WiperStateService,
    WiperStateSna,
    WiperStateWash,
    Other(u8),
}

/// ID381VCFRONT_logging1Hz
///
/// - ID: 897 (0x381)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id381vcfrontLogging1Hz {
    raw: [u8; 8],
}

impl Id381vcfrontLogging1Hz {
    pub const MESSAGE_ID: u32 = 897;
    
    /// Construct new ID381VCFRONT_logging1Hz from values
    pub fn new(vcfront_logging1_hz_index: u8, vcfront_cc_qdot_actual: f32, vcfront_cc_qdot_fd_frwrd_target: f32, vcfront_cc_qdot_fdbk: f32, vcfront_cmp_discharge_superheat: f32, vcfront_di_qdot_a: f32, vcfront_hcml_blade_temp: f32, vcfront_hcml_diffuse_temp: f32, vcfront_hcml_high_beam_temp: f32, vcfront_hcml_low_beam_spot_temp: f32, vcfront_hcml_turn_temp: f32, vcfront_hcmr_blade_temp: f32, vcfront_hcmr_diffuse_temp: f32, vcfront_hcmr_high_beam_temp: f32, vcfront_hcmr_low_beam_spot_temp: f32, vcfront_hcmr_turn_temp: f32, vcfront_p_discharge_controller_outp: f32, vcfront_p_suction_controller_output: f32, vcfront_ambient_colder_than_batt: bool, vcfront_ambient_sourcing_available: bool, vcfront_ambient_sourcing_disabled: bool, vcfront_batt_dissipation: f32, vcfront_batt_loop_worth_cooling: bool, vcfront_batt_over_stag_upper_limit: bool, vcfront_batt_under_stag_upper_limit: bool, vcfront_cabin_heat_energy_during_dri: f32, vcfront_calibrated_position_hcml: u16, vcfront_calibrated_position_hcmr: u16, vcfront_cc_left_exv_calib_failed: bool, vcfront_cc_left_exv_calib_offset: f32, vcfront_cc_left_exv_range: f32, vcfront_cc_right_exv_calib_failed: bool, vcfront_cc_right_exv_calib_offset: f32, vcfront_cc_right_exv_range: f32, vcfront_chiller_exv_calib_failed: bool, vcfront_chiller_exv_calib_offset: f32, vcfront_chiller_exv_range: f32, vcfront_chiller_inlet_temp_estimate: i8, vcfront_chiller_lift_disabled_low_ps: bool, vcfront_chiller_passive_cool_power: f32, vcfront_comp_energy_during_drive: f32, vcfront_condenser_pressure_limit: f32, vcfront_coolant_level_voltage: f32, vcfront_coolant_valve_angle_drift: f32, vcfront_coolant_valve_count_range: f32, vcfront_coolant_valve_daily_angle_tr: f32, vcfront_coolant_valve_odometer: f32, vcfront_coolant_valve_rad_bypass: u8, vcfront_coolant_valve_recal_count: u16, vcfront_coolant_valve_recal_reason: u8, vcfront_coolant_valve_windup_est_l: f32, vcfront_coolant_valve_windup_est_r: f32, vcfront_current_position_hcml: u16, vcfront_current_position_hcmr: u16, vcfront_cycle_model_converged: bool, vcfront_di_dissipation: f32, vcfront_discharge_pressure_limit: f32, vcfront_discharge_pressure_target: f32, vcfront_drl_mode: u8, vcfront_est_comp_power: f32, vcfront_est_comp_refrig_massflow: f32, vcfront_est_compressor_rpm: f32, vcfront_est_pressure_disch: f32, vcfront_est_pressure_liq: f32, vcfront_est_pressure_suct: f32, vcfront_est_q_lift: f32, vcfront_est_temp_disch: f32, vcfront_est_temp_liq: f32, vcfront_est_temp_suct: f32, vcfront_evap_disabled_low_ps_cutout: bool, vcfront_evap_exv_calib_failed: bool, vcfront_evap_exv_calib_offset: f32, vcfront_evap_exv_range: f32, vcfront_evap_fd_frwrd_target: f32, vcfront_evap_fd_frwrd_target_minimum: f32, vcfront_evap_fdbk: f32, vcfront_exterior_quiet_mode_allowed: bool, vcfront_exterior_quiet_mode_enabled: bool, vcfront_fan_control_feedfwd_active: bool, vcfront_fan_control_rad_can_cool: bool, vcfront_fan_control_radiator_inlet_t: f32, vcfront_fan_control_radiator_ua: f32, vcfront_fan_demand_condenser: u8, vcfront_fan_demand_radiator: u8, vcfront_feed_back_duct_temp_controll: f32, vcfront_feed_back_evap_temp_controll: f32, vcfront_feed_fwd_fan_demand: u8, vcfront_feed_fwd_m_dot_cabin_condense: f32, vcfront_feed_fwd_m_dot_evaporator: f32, vcfront_feed_fwd_pump_demand: u8, vcfront_feedfwd_load_cooling_domina: bool, vcfront_homelink_region_code: u8, vcfront_hp_ambient_source: bool, vcfront_hp_at_steady_state: bool, vcfront_hp_batt_over_temp_hvac_disabl: bool, vcfront_hp_batt_stag_target: f32, vcfront_hp_battery_cool: bool, vcfront_hp_battery_cool_cabin_conden: bool, vcfront_hp_battery_cool_cabin_reheat: bool, vcfront_hp_battery_cool_evaporator: bool, vcfront_hp_battery_heat_ambient_sour: bool, vcfront_hp_battery_heat_cop1: bool, vcfront_hp_cop: f32, vcfront_hp_cabin_cool_evaporator: bool, vcfront_hp_cabin_cool_evaporator_reh: bool, vcfront_hp_cabin_heat_ambient_source: bool, vcfront_hp_cabin_heat_battery_cool_re: bool, vcfront_hp_cabin_heat_battery_heat_re: bool, vcfront_hp_cabin_heat_blend: bool, vcfront_hp_cabin_heat_cop1: bool, vcfront_hp_cabin_heat_reheat_ambient: bool, vcfront_hp_cabin_heat_reheat_scaveng: bool, vcfront_hp_cabin_heat_scavenge_only: bool, vcfront_hp_comp_power_index: u8, vcfront_hp_comp_power_index_filtered: u8, vcfront_hp_diag_louver_calib: bool, vcfront_hp_force_scavenge: bool, vcfront_hp_general: bool, vcfront_hp_mode: u8, vcfront_hp_potential_low_refrig: bool, vcfront_hp_refrigerant_purge_state: u8, vcfront_hp_subcool_target: u8, vcfront_lcc_active_cool_target: u8, vcfront_lcc_exv_calib_failed: bool, vcfront_lcc_exv_calib_offset: f32, vcfront_lcc_exv_range: f32, vcfront_lcc_inlet_temp_estimate: i8, vcfront_lcc_passive_heat_power: f32, vcfront_low_side_lift_energy_drive: f32, vcfront_low_side_watts_lift: f32, vcfront_max_allowed_evap_power_in_ser: f32, vcfront_max_chiller_cooling_power: f32, vcfront_max_compressor_rpm_allowed: f32, vcfront_min_allowed_chiller_power_in: f32, vcfront_min_allowed_suction_pressur: f32, vcfront_min_flow_pd_cont: f32, vcfront_mode_desired: u8, vcfront_mode_transition_id: u8, vcfront_model_load_cooling_dominant: bool, vcfront_passive_cooling_state: u8, vcfront_passive_demand_rad_bypass: u8, vcfront_passive_series_reg_on: bool, vcfront_pressure_refrig_disch_est: u8, vcfront_pressure_refrig_suction_est: f32, vcfront_pt_loop_worth_cooling: bool, vcfront_pump_battery_fet_temp: f32, vcfront_pump_powertrain_fet_temp: f32, vcfront_rad_active_reject_estimate: u16, vcfront_rad_passive_reject_estimate: u16, vcfront_radiator_fan_fet_temp: f32, vcfront_radiator_fan_run_reason: u8, vcfront_recirc_exv_calib_failed: bool, vcfront_recirc_exv_calib_offset: f32, vcfront_recirc_exv_range: f32, vcfront_subcool_actual: f32, vcfront_suction_pressure_target: f32, vcfront_suction_superheat_est_ps_sna: f32, vcfront_suction_superheat_est_ts_sna: f32, vcfront_target_bat_active_cool: u8, vcfront_target_bat_active_heat: f32, vcfront_target_bat_passive: f32, vcfront_target_pt_active_cool: f32, vcfront_target_pt_passive: f32, vcfront_temp_refrig_discharge_est: f32, vcfront_temp_refrig_suction: f32, vcfront_temp_refrig_suction_est: u8, vcfront_total_load_cooling_dominant: bool, vcfront_wiper_cycles: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vcfront_logging1_hz_index(vcfront_logging1_hz_index)?;
        res.set_vcfront_cc_qdot_actual(vcfront_cc_qdot_actual)?;
        res.set_vcfront_cc_qdot_fd_frwrd_target(vcfront_cc_qdot_fd_frwrd_target)?;
        res.set_vcfront_cc_qdot_fdbk(vcfront_cc_qdot_fdbk)?;
        res.set_vcfront_cmp_discharge_superheat(vcfront_cmp_discharge_superheat)?;
        res.set_vcfront_di_qdot_a(vcfront_di_qdot_a)?;
        res.set_vcfront_hcml_blade_temp(vcfront_hcml_blade_temp)?;
        res.set_vcfront_hcml_diffuse_temp(vcfront_hcml_diffuse_temp)?;
        res.set_vcfront_hcml_high_beam_temp(vcfront_hcml_high_beam_temp)?;
        res.set_vcfront_hcml_low_beam_spot_temp(vcfront_hcml_low_beam_spot_temp)?;
        res.set_vcfront_hcml_turn_temp(vcfront_hcml_turn_temp)?;
        res.set_vcfront_hcmr_blade_temp(vcfront_hcmr_blade_temp)?;
        res.set_vcfront_hcmr_diffuse_temp(vcfront_hcmr_diffuse_temp)?;
        res.set_vcfront_hcmr_high_beam_temp(vcfront_hcmr_high_beam_temp)?;
        res.set_vcfront_hcmr_low_beam_spot_temp(vcfront_hcmr_low_beam_spot_temp)?;
        res.set_vcfront_hcmr_turn_temp(vcfront_hcmr_turn_temp)?;
        res.set_vcfront_p_discharge_controller_outp(vcfront_p_discharge_controller_outp)?;
        res.set_vcfront_p_suction_controller_output(vcfront_p_suction_controller_output)?;
        res.set_vcfront_ambient_colder_than_batt(vcfront_ambient_colder_than_batt)?;
        res.set_vcfront_ambient_sourcing_available(vcfront_ambient_sourcing_available)?;
        res.set_vcfront_ambient_sourcing_disabled(vcfront_ambient_sourcing_disabled)?;
        res.set_vcfront_batt_dissipation(vcfront_batt_dissipation)?;
        res.set_vcfront_batt_loop_worth_cooling(vcfront_batt_loop_worth_cooling)?;
        res.set_vcfront_batt_over_stag_upper_limit(vcfront_batt_over_stag_upper_limit)?;
        res.set_vcfront_batt_under_stag_upper_limit(vcfront_batt_under_stag_upper_limit)?;
        res.set_vcfront_cabin_heat_energy_during_dri(vcfront_cabin_heat_energy_during_dri)?;
        res.set_vcfront_calibrated_position_hcml(vcfront_calibrated_position_hcml)?;
        res.set_vcfront_calibrated_position_hcmr(vcfront_calibrated_position_hcmr)?;
        res.set_vcfront_cc_left_exv_calib_failed(vcfront_cc_left_exv_calib_failed)?;
        res.set_vcfront_cc_left_exv_calib_offset(vcfront_cc_left_exv_calib_offset)?;
        res.set_vcfront_cc_left_exv_range(vcfront_cc_left_exv_range)?;
        res.set_vcfront_cc_right_exv_calib_failed(vcfront_cc_right_exv_calib_failed)?;
        res.set_vcfront_cc_right_exv_calib_offset(vcfront_cc_right_exv_calib_offset)?;
        res.set_vcfront_cc_right_exv_range(vcfront_cc_right_exv_range)?;
        res.set_vcfront_chiller_exv_calib_failed(vcfront_chiller_exv_calib_failed)?;
        res.set_vcfront_chiller_exv_calib_offset(vcfront_chiller_exv_calib_offset)?;
        res.set_vcfront_chiller_exv_range(vcfront_chiller_exv_range)?;
        res.set_vcfront_chiller_inlet_temp_estimate(vcfront_chiller_inlet_temp_estimate)?;
        res.set_vcfront_chiller_lift_disabled_low_ps(vcfront_chiller_lift_disabled_low_ps)?;
        res.set_vcfront_chiller_passive_cool_power(vcfront_chiller_passive_cool_power)?;
        res.set_vcfront_comp_energy_during_drive(vcfront_comp_energy_during_drive)?;
        res.set_vcfront_condenser_pressure_limit(vcfront_condenser_pressure_limit)?;
        res.set_vcfront_coolant_level_voltage(vcfront_coolant_level_voltage)?;
        res.set_vcfront_coolant_valve_angle_drift(vcfront_coolant_valve_angle_drift)?;
        res.set_vcfront_coolant_valve_count_range(vcfront_coolant_valve_count_range)?;
        res.set_vcfront_coolant_valve_daily_angle_tr(vcfront_coolant_valve_daily_angle_tr)?;
        res.set_vcfront_coolant_valve_odometer(vcfront_coolant_valve_odometer)?;
        res.set_vcfront_coolant_valve_rad_bypass(vcfront_coolant_valve_rad_bypass)?;
        res.set_vcfront_coolant_valve_recal_count(vcfront_coolant_valve_recal_count)?;
        res.set_vcfront_coolant_valve_recal_reason(vcfront_coolant_valve_recal_reason)?;
        res.set_vcfront_coolant_valve_windup_est_l(vcfront_coolant_valve_windup_est_l)?;
        res.set_vcfront_coolant_valve_windup_est_r(vcfront_coolant_valve_windup_est_r)?;
        res.set_vcfront_current_position_hcml(vcfront_current_position_hcml)?;
        res.set_vcfront_current_position_hcmr(vcfront_current_position_hcmr)?;
        res.set_vcfront_cycle_model_converged(vcfront_cycle_model_converged)?;
        res.set_vcfront_di_dissipation(vcfront_di_dissipation)?;
        res.set_vcfront_discharge_pressure_limit(vcfront_discharge_pressure_limit)?;
        res.set_vcfront_discharge_pressure_target(vcfront_discharge_pressure_target)?;
        res.set_vcfront_drl_mode(vcfront_drl_mode)?;
        res.set_vcfront_est_comp_power(vcfront_est_comp_power)?;
        res.set_vcfront_est_comp_refrig_massflow(vcfront_est_comp_refrig_massflow)?;
        res.set_vcfront_est_compressor_rpm(vcfront_est_compressor_rpm)?;
        res.set_vcfront_est_pressure_disch(vcfront_est_pressure_disch)?;
        res.set_vcfront_est_pressure_liq(vcfront_est_pressure_liq)?;
        res.set_vcfront_est_pressure_suct(vcfront_est_pressure_suct)?;
        res.set_vcfront_est_q_lift(vcfront_est_q_lift)?;
        res.set_vcfront_est_temp_disch(vcfront_est_temp_disch)?;
        res.set_vcfront_est_temp_liq(vcfront_est_temp_liq)?;
        res.set_vcfront_est_temp_suct(vcfront_est_temp_suct)?;
        res.set_vcfront_evap_disabled_low_ps_cutout(vcfront_evap_disabled_low_ps_cutout)?;
        res.set_vcfront_evap_exv_calib_failed(vcfront_evap_exv_calib_failed)?;
        res.set_vcfront_evap_exv_calib_offset(vcfront_evap_exv_calib_offset)?;
        res.set_vcfront_evap_exv_range(vcfront_evap_exv_range)?;
        res.set_vcfront_evap_fd_frwrd_target(vcfront_evap_fd_frwrd_target)?;
        res.set_vcfront_evap_fd_frwrd_target_minimum(vcfront_evap_fd_frwrd_target_minimum)?;
        res.set_vcfront_evap_fdbk(vcfront_evap_fdbk)?;
        res.set_vcfront_exterior_quiet_mode_allowed(vcfront_exterior_quiet_mode_allowed)?;
        res.set_vcfront_exterior_quiet_mode_enabled(vcfront_exterior_quiet_mode_enabled)?;
        res.set_vcfront_fan_control_feedfwd_active(vcfront_fan_control_feedfwd_active)?;
        res.set_vcfront_fan_control_rad_can_cool(vcfront_fan_control_rad_can_cool)?;
        res.set_vcfront_fan_control_radiator_inlet_t(vcfront_fan_control_radiator_inlet_t)?;
        res.set_vcfront_fan_control_radiator_ua(vcfront_fan_control_radiator_ua)?;
        res.set_vcfront_fan_demand_condenser(vcfront_fan_demand_condenser)?;
        res.set_vcfront_fan_demand_radiator(vcfront_fan_demand_radiator)?;
        res.set_vcfront_feed_back_duct_temp_controll(vcfront_feed_back_duct_temp_controll)?;
        res.set_vcfront_feed_back_evap_temp_controll(vcfront_feed_back_evap_temp_controll)?;
        res.set_vcfront_feed_fwd_fan_demand(vcfront_feed_fwd_fan_demand)?;
        res.set_vcfront_feed_fwd_m_dot_cabin_condense(vcfront_feed_fwd_m_dot_cabin_condense)?;
        res.set_vcfront_feed_fwd_m_dot_evaporator(vcfront_feed_fwd_m_dot_evaporator)?;
        res.set_vcfront_feed_fwd_pump_demand(vcfront_feed_fwd_pump_demand)?;
        res.set_vcfront_feedfwd_load_cooling_domina(vcfront_feedfwd_load_cooling_domina)?;
        res.set_vcfront_homelink_region_code(vcfront_homelink_region_code)?;
        res.set_vcfront_hp_ambient_source(vcfront_hp_ambient_source)?;
        res.set_vcfront_hp_at_steady_state(vcfront_hp_at_steady_state)?;
        res.set_vcfront_hp_batt_over_temp_hvac_disabl(vcfront_hp_batt_over_temp_hvac_disabl)?;
        res.set_vcfront_hp_batt_stag_target(vcfront_hp_batt_stag_target)?;
        res.set_vcfront_hp_battery_cool(vcfront_hp_battery_cool)?;
        res.set_vcfront_hp_battery_cool_cabin_conden(vcfront_hp_battery_cool_cabin_conden)?;
        res.set_vcfront_hp_battery_cool_cabin_reheat(vcfront_hp_battery_cool_cabin_reheat)?;
        res.set_vcfront_hp_battery_cool_evaporator(vcfront_hp_battery_cool_evaporator)?;
        res.set_vcfront_hp_battery_heat_ambient_sour(vcfront_hp_battery_heat_ambient_sour)?;
        res.set_vcfront_hp_battery_heat_cop1(vcfront_hp_battery_heat_cop1)?;
        res.set_vcfront_hp_cop(vcfront_hp_cop)?;
        res.set_vcfront_hp_cabin_cool_evaporator(vcfront_hp_cabin_cool_evaporator)?;
        res.set_vcfront_hp_cabin_cool_evaporator_reh(vcfront_hp_cabin_cool_evaporator_reh)?;
        res.set_vcfront_hp_cabin_heat_ambient_source(vcfront_hp_cabin_heat_ambient_source)?;
        res.set_vcfront_hp_cabin_heat_battery_cool_re(vcfront_hp_cabin_heat_battery_cool_re)?;
        res.set_vcfront_hp_cabin_heat_battery_heat_re(vcfront_hp_cabin_heat_battery_heat_re)?;
        res.set_vcfront_hp_cabin_heat_blend(vcfront_hp_cabin_heat_blend)?;
        res.set_vcfront_hp_cabin_heat_cop1(vcfront_hp_cabin_heat_cop1)?;
        res.set_vcfront_hp_cabin_heat_reheat_ambient(vcfront_hp_cabin_heat_reheat_ambient)?;
        res.set_vcfront_hp_cabin_heat_reheat_scaveng(vcfront_hp_cabin_heat_reheat_scaveng)?;
        res.set_vcfront_hp_cabin_heat_scavenge_only(vcfront_hp_cabin_heat_scavenge_only)?;
        res.set_vcfront_hp_comp_power_index(vcfront_hp_comp_power_index)?;
        res.set_vcfront_hp_comp_power_index_filtered(vcfront_hp_comp_power_index_filtered)?;
        res.set_vcfront_hp_diag_louver_calib(vcfront_hp_diag_louver_calib)?;
        res.set_vcfront_hp_force_scavenge(vcfront_hp_force_scavenge)?;
        res.set_vcfront_hp_general(vcfront_hp_general)?;
        res.set_vcfront_hp_mode(vcfront_hp_mode)?;
        res.set_vcfront_hp_potential_low_refrig(vcfront_hp_potential_low_refrig)?;
        res.set_vcfront_hp_refrigerant_purge_state(vcfront_hp_refrigerant_purge_state)?;
        res.set_vcfront_hp_subcool_target(vcfront_hp_subcool_target)?;
        res.set_vcfront_lcc_active_cool_target(vcfront_lcc_active_cool_target)?;
        res.set_vcfront_lcc_exv_calib_failed(vcfront_lcc_exv_calib_failed)?;
        res.set_vcfront_lcc_exv_calib_offset(vcfront_lcc_exv_calib_offset)?;
        res.set_vcfront_lcc_exv_range(vcfront_lcc_exv_range)?;
        res.set_vcfront_lcc_inlet_temp_estimate(vcfront_lcc_inlet_temp_estimate)?;
        res.set_vcfront_lcc_passive_heat_power(vcfront_lcc_passive_heat_power)?;
        res.set_vcfront_low_side_lift_energy_drive(vcfront_low_side_lift_energy_drive)?;
        res.set_vcfront_low_side_watts_lift(vcfront_low_side_watts_lift)?;
        res.set_vcfront_max_allowed_evap_power_in_ser(vcfront_max_allowed_evap_power_in_ser)?;
        res.set_vcfront_max_chiller_cooling_power(vcfront_max_chiller_cooling_power)?;
        res.set_vcfront_max_compressor_rpm_allowed(vcfront_max_compressor_rpm_allowed)?;
        res.set_vcfront_min_allowed_chiller_power_in(vcfront_min_allowed_chiller_power_in)?;
        res.set_vcfront_min_allowed_suction_pressur(vcfront_min_allowed_suction_pressur)?;
        res.set_vcfront_min_flow_pd_cont(vcfront_min_flow_pd_cont)?;
        res.set_vcfront_mode_desired(vcfront_mode_desired)?;
        res.set_vcfront_mode_transition_id(vcfront_mode_transition_id)?;
        res.set_vcfront_model_load_cooling_dominant(vcfront_model_load_cooling_dominant)?;
        res.set_vcfront_passive_cooling_state(vcfront_passive_cooling_state)?;
        res.set_vcfront_passive_demand_rad_bypass(vcfront_passive_demand_rad_bypass)?;
        res.set_vcfront_passive_series_reg_on(vcfront_passive_series_reg_on)?;
        res.set_vcfront_pressure_refrig_disch_est(vcfront_pressure_refrig_disch_est)?;
        res.set_vcfront_pressure_refrig_suction_est(vcfront_pressure_refrig_suction_est)?;
        res.set_vcfront_pt_loop_worth_cooling(vcfront_pt_loop_worth_cooling)?;
        res.set_vcfront_pump_battery_fet_temp(vcfront_pump_battery_fet_temp)?;
        res.set_vcfront_pump_powertrain_fet_temp(vcfront_pump_powertrain_fet_temp)?;
        res.set_vcfront_rad_active_reject_estimate(vcfront_rad_active_reject_estimate)?;
        res.set_vcfront_rad_passive_reject_estimate(vcfront_rad_passive_reject_estimate)?;
        res.set_vcfront_radiator_fan_fet_temp(vcfront_radiator_fan_fet_temp)?;
        res.set_vcfront_radiator_fan_run_reason(vcfront_radiator_fan_run_reason)?;
        res.set_vcfront_recirc_exv_calib_failed(vcfront_recirc_exv_calib_failed)?;
        res.set_vcfront_recirc_exv_calib_offset(vcfront_recirc_exv_calib_offset)?;
        res.set_vcfront_recirc_exv_range(vcfront_recirc_exv_range)?;
        res.set_vcfront_subcool_actual(vcfront_subcool_actual)?;
        res.set_vcfront_suction_pressure_target(vcfront_suction_pressure_target)?;
        res.set_vcfront_suction_superheat_est_ps_sna(vcfront_suction_superheat_est_ps_sna)?;
        res.set_vcfront_suction_superheat_est_ts_sna(vcfront_suction_superheat_est_ts_sna)?;
        res.set_vcfront_target_bat_active_cool(vcfront_target_bat_active_cool)?;
        res.set_vcfront_target_bat_active_heat(vcfront_target_bat_active_heat)?;
        res.set_vcfront_target_bat_passive(vcfront_target_bat_passive)?;
        res.set_vcfront_target_pt_active_cool(vcfront_target_pt_active_cool)?;
        res.set_vcfront_target_pt_passive(vcfront_target_pt_passive)?;
        res.set_vcfront_temp_refrig_discharge_est(vcfront_temp_refrig_discharge_est)?;
        res.set_vcfront_temp_refrig_suction(vcfront_temp_refrig_suction)?;
        res.set_vcfront_temp_refrig_suction_est(vcfront_temp_refrig_suction_est)?;
        res.set_vcfront_total_load_cooling_dominant(vcfront_total_load_cooling_dominant)?;
        res.set_vcfront_wiper_cycles(vcfront_wiper_cycles)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// VCFRONT_logging1HzIndex
    ///
    /// - Min: 0
    /// - Max: 19
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_logging1_hz_index(&self) -> Id381vcfrontLogging1HzVcfrontLogging1HzIndex {
        match self.vcfront_logging1_hz_index_raw() {
            18 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::BodyControl,
            0 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::Coolant,
            19 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::Coolant2,
            2 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::CoolantValve,
            20 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::End,
            1 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::FanDemandCondenserAndFetTemps,
            3 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HcmlLedTemps,
            4 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HcmrLedTemps,
            6 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HeadlampAim,
            5 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::Homelink,
            15 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpArbitration,
            9 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpControlLoopAndState,
            10 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpCycleModel,
            8 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpDataAndAccumulators,
            12 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpDissipationAndPower,
            11 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpExvCalibration,
            7 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpExvRange,
            17 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpModeOptionsAndEstimates,
            16 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpModeSelectAndEstimates,
            14 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpPressureControl,
            13 => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::HpTempsAndDemands,
            x => Id381vcfrontLogging1HzVcfrontLogging1HzIndex::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_logging1HzIndex
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_logging1_hz_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_logging1HzIndex
    #[inline(always)]
    pub fn set_vcfront_logging1_hz_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 19_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..5].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_CCQdotActual
    ///
    /// - Min: 0
    /// - Max: 10100
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_qdot_actual(&self) -> f32 {
        self.vcfront_cc_qdot_actual_raw()
    }
    
    /// Get raw value of VCFRONT_CCQdotActual
    ///
    /// - Start bit: 21
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cc_qdot_actual_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[21..28].load_le::<u8>();
        
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_CCQdotActual
    #[inline(always)]
    pub fn set_vcfront_cc_qdot_actual(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[21..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_CCQdotFdFrwrdTarget
    ///
    /// - Min: 0
    /// - Max: 10100
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_qdot_fd_frwrd_target(&self) -> f32 {
        self.vcfront_cc_qdot_fd_frwrd_target_raw()
    }
    
    /// Get raw value of VCFRONT_CCQdotFdFrwrdTarget
    ///
    /// - Start bit: 7
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cc_qdot_fd_frwrd_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[7..14].load_le::<u8>();
        
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_CCQdotFdFrwrdTarget
    #[inline(always)]
    pub fn set_vcfront_cc_qdot_fd_frwrd_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[7..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_CCQdotFdbk
    ///
    /// - Min: -5000
    /// - Max: 5000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_qdot_fdbk(&self) -> f32 {
        self.vcfront_cc_qdot_fdbk_raw()
    }
    
    /// Get raw value of VCFRONT_CCQdotFdbk
    ///
    /// - Start bit: 14
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_cc_qdot_fdbk_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[14..21].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_CCQdotFdbk
    #[inline(always)]
    pub fn set_vcfront_cc_qdot_fdbk(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -5000_f32 || 5000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[14..21].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_CMPDischargeSuperheat
    ///
    /// - Min: -10
    /// - Max: 21
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cmp_discharge_superheat(&self) -> f32 {
        self.vcfront_cmp_discharge_superheat_raw()
    }
    
    /// Get raw value of VCFRONT_CMPDischargeSuperheat
    ///
    /// - Start bit: 17
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 6
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_cmp_discharge_superheat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[17..22].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 6_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_CMPDischargeSuperheat
    #[inline(always)]
    pub fn set_vcfront_cmp_discharge_superheat(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10_f32 || 21_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 6_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[17..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_DIQdotA
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_di_qdot_a(&self) -> f32 {
        self.vcfront_di_qdot_a_raw()
    }
    
    /// Get raw value of VCFRONT_DIQdotA
    ///
    /// - Start bit: 42
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_di_qdot_a_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[42..49].load_le::<u8>();
        
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_DIQdotA
    #[inline(always)]
    pub fn set_vcfront_di_qdot_a(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[42..49].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCML_bladeTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcml_blade_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmlBladeTemp {
        match self.vcfront_hcml_blade_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmlBladeTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmlBladeTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCML_bladeTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcml_blade_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCML_bladeTemp
    #[inline(always)]
    pub fn set_vcfront_hcml_blade_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCML_diffuseTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcml_diffuse_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmlDiffuseTemp {
        match self.vcfront_hcml_diffuse_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmlDiffuseTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmlDiffuseTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCML_diffuseTemp
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcml_diffuse_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCML_diffuseTemp
    #[inline(always)]
    pub fn set_vcfront_hcml_diffuse_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCML_highBeamTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcml_high_beam_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmlHighBeamTemp {
        match self.vcfront_hcml_high_beam_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmlHighBeamTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmlHighBeamTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCML_highBeamTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcml_high_beam_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCML_highBeamTemp
    #[inline(always)]
    pub fn set_vcfront_hcml_high_beam_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCML_lowBeamSpotTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcml_low_beam_spot_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmlLowBeamSpotTemp {
        match self.vcfront_hcml_low_beam_spot_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmlLowBeamSpotTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmlLowBeamSpotTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCML_lowBeamSpotTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcml_low_beam_spot_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCML_lowBeamSpotTemp
    #[inline(always)]
    pub fn set_vcfront_hcml_low_beam_spot_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCML_turnTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcml_turn_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmlTurnTemp {
        match self.vcfront_hcml_turn_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmlTurnTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmlTurnTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCML_turnTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcml_turn_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCML_turnTemp
    #[inline(always)]
    pub fn set_vcfront_hcml_turn_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCMR_bladeTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcmr_blade_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmrBladeTemp {
        match self.vcfront_hcmr_blade_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmrBladeTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmrBladeTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCMR_bladeTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcmr_blade_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCMR_bladeTemp
    #[inline(always)]
    pub fn set_vcfront_hcmr_blade_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCMR_diffuseTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcmr_diffuse_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmrDiffuseTemp {
        match self.vcfront_hcmr_diffuse_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmrDiffuseTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmrDiffuseTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCMR_diffuseTemp
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcmr_diffuse_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCMR_diffuseTemp
    #[inline(always)]
    pub fn set_vcfront_hcmr_diffuse_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCMR_highBeamTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcmr_high_beam_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmrHighBeamTemp {
        match self.vcfront_hcmr_high_beam_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmrHighBeamTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmrHighBeamTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCMR_highBeamTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcmr_high_beam_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCMR_highBeamTemp
    #[inline(always)]
    pub fn set_vcfront_hcmr_high_beam_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCMR_lowBeamSpotTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcmr_low_beam_spot_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmrLowBeamSpotTemp {
        match self.vcfront_hcmr_low_beam_spot_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmrLowBeamSpotTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmrLowBeamSpotTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCMR_lowBeamSpotTemp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcmr_low_beam_spot_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCMR_lowBeamSpotTemp
    #[inline(always)]
    pub fn set_vcfront_hcmr_low_beam_spot_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_HCMR_turnTemp
    ///
    /// - Min: -60
    /// - Max: 194
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hcmr_turn_temp(&self) -> Id381vcfrontLogging1HzVcfrontHcmrTurnTemp {
        match self.vcfront_hcmr_turn_temp_raw() {
            128 => Id381vcfrontLogging1HzVcfrontHcmrTurnTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontHcmrTurnTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_HCMR_turnTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 67
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_hcmr_turn_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 67_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_HCMR_turnTemp
    #[inline(always)]
    pub fn set_vcfront_hcmr_turn_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -60_f32 || 194_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 67_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PDischargeControllerOutp
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_p_discharge_controller_outp(&self) -> f32 {
        self.vcfront_p_discharge_controller_outp_raw()
    }
    
    /// Get raw value of VCFRONT_PDischargeControllerOutp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_p_discharge_controller_outp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_PDischargeControllerOutp
    #[inline(always)]
    pub fn set_vcfront_p_discharge_controller_outp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_PSuctionControllerOutput
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_p_suction_controller_output(&self) -> f32 {
        self.vcfront_p_suction_controller_output_raw()
    }
    
    /// Get raw value of VCFRONT_PSuctionControllerOutput
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_p_suction_controller_output_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_PSuctionControllerOutput
    #[inline(always)]
    pub fn set_vcfront_p_suction_controller_output(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ambientColderThanBatt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ambient_colder_than_batt(&self) -> bool {
        self.vcfront_ambient_colder_than_batt_raw()
    }
    
    /// Get raw value of VCFRONT_ambientColderThanBatt
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ambient_colder_than_batt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ambientColderThanBatt
    #[inline(always)]
    pub fn set_vcfront_ambient_colder_than_batt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ambientSourcingAvailable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ambient_sourcing_available(&self) -> bool {
        self.vcfront_ambient_sourcing_available_raw()
    }
    
    /// Get raw value of VCFRONT_ambientSourcingAvailable
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ambient_sourcing_available_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ambientSourcingAvailable
    #[inline(always)]
    pub fn set_vcfront_ambient_sourcing_available(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ambientSourcingDisabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_ambient_sourcing_disabled(&self) -> bool {
        self.vcfront_ambient_sourcing_disabled_raw()
    }
    
    /// Get raw value of VCFRONT_ambientSourcingDisabled
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_ambient_sourcing_disabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ambientSourcingDisabled
    #[inline(always)]
    pub fn set_vcfront_ambient_sourcing_disabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_battDissipation
    ///
    /// - Min: 0
    /// - Max: 35000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_batt_dissipation(&self) -> f32 {
        self.vcfront_batt_dissipation_raw()
    }
    
    /// Get raw value of VCFRONT_battDissipation
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 140
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_batt_dissipation_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 140_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_battDissipation
    #[inline(always)]
    pub fn set_vcfront_batt_dissipation(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 35000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 140_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_battLoopWorthCooling
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_batt_loop_worth_cooling(&self) -> bool {
        self.vcfront_batt_loop_worth_cooling_raw()
    }
    
    /// Get raw value of VCFRONT_battLoopWorthCooling
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_batt_loop_worth_cooling_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_battLoopWorthCooling
    #[inline(always)]
    pub fn set_vcfront_batt_loop_worth_cooling(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_battOverStagUpperLimit
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_batt_over_stag_upper_limit(&self) -> bool {
        self.vcfront_batt_over_stag_upper_limit_raw()
    }
    
    /// Get raw value of VCFRONT_battOverStagUpperLimit
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_batt_over_stag_upper_limit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_battOverStagUpperLimit
    #[inline(always)]
    pub fn set_vcfront_batt_over_stag_upper_limit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_battUnderStagUpperLimit
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_batt_under_stag_upper_limit(&self) -> bool {
        self.vcfront_batt_under_stag_upper_limit_raw()
    }
    
    /// Get raw value of VCFRONT_battUnderStagUpperLimit
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_batt_under_stag_upper_limit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_battUnderStagUpperLimit
    #[inline(always)]
    pub fn set_vcfront_batt_under_stag_upper_limit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_cabinHeatEnergyDuringDri
    ///
    /// - Min: 0
    /// - Max: 19000
    /// - Unit: "Wh"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cabin_heat_energy_during_dri(&self) -> f32 {
        self.vcfront_cabin_heat_energy_during_dri_raw()
    }
    
    /// Get raw value of VCFRONT_cabinHeatEnergyDuringDri
    ///
    /// - Start bit: 42
    /// - Signal size: 7 bits
    /// - Factor: 150
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cabin_heat_energy_during_dri_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[42..49].load_le::<u8>();
        
        let factor = 150_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_cabinHeatEnergyDuringDri
    #[inline(always)]
    pub fn set_vcfront_cabin_heat_energy_during_dri(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 19000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 150_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[42..49].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_calibratedPositionHCML
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "Steps"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_calibrated_position_hcml(&self) -> u16 {
        self.vcfront_calibrated_position_hcml_raw()
    }
    
    /// Get raw value of VCFRONT_calibratedPositionHCML
    ///
    /// - Start bit: 5
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_calibrated_position_hcml_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[5..15].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_calibratedPositionHCML
    #[inline(always)]
    pub fn set_vcfront_calibrated_position_hcml(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_calibratedPositionHCMR
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "Steps"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_calibrated_position_hcmr(&self) -> u16 {
        self.vcfront_calibrated_position_hcmr_raw()
    }
    
    /// Get raw value of VCFRONT_calibratedPositionHCMR
    ///
    /// - Start bit: 16
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_calibrated_position_hcmr_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[16..26].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_calibratedPositionHCMR
    #[inline(always)]
    pub fn set_vcfront_calibrated_position_hcmr(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ccLeftExvCalibFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_left_exv_calib_failed(&self) -> bool {
        self.vcfront_cc_left_exv_calib_failed_raw()
    }
    
    /// Get raw value of VCFRONT_ccLeftExvCalibFailed
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cc_left_exv_calib_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ccLeftExvCalibFailed
    #[inline(always)]
    pub fn set_vcfront_cc_left_exv_calib_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ccLeftExvCalibOffset
    ///
    /// - Min: -510
    /// - Max: 510
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_left_exv_calib_offset(&self) -> f32 {
        self.vcfront_cc_left_exv_calib_offset_raw()
    }
    
    /// Get raw value of VCFRONT_ccLeftExvCalibOffset
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_cc_left_exv_calib_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ccLeftExvCalibOffset
    #[inline(always)]
    pub fn set_vcfront_cc_left_exv_calib_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -510_f32 || 510_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ccLeftExvRange
    ///
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_left_exv_range(&self) -> f32 {
        self.vcfront_cc_left_exv_range_raw()
    }
    
    /// Get raw value of VCFRONT_ccLeftExvRange
    ///
    /// - Start bit: 41
    /// - Signal size: 9 bits
    /// - Factor: 3
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cc_left_exv_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[41..50].load_le::<u16>();
        
        let factor = 3_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ccLeftExvRange
    #[inline(always)]
    pub fn set_vcfront_cc_left_exv_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 3_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[41..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ccRightExvCalibFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_right_exv_calib_failed(&self) -> bool {
        self.vcfront_cc_right_exv_calib_failed_raw()
    }
    
    /// Get raw value of VCFRONT_ccRightExvCalibFailed
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cc_right_exv_calib_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ccRightExvCalibFailed
    #[inline(always)]
    pub fn set_vcfront_cc_right_exv_calib_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ccRightExvCalibOffset
    ///
    /// - Min: -510
    /// - Max: 510
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_right_exv_calib_offset(&self) -> f32 {
        self.vcfront_cc_right_exv_calib_offset_raw()
    }
    
    /// Get raw value of VCFRONT_ccRightExvCalibOffset
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_cc_right_exv_calib_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ccRightExvCalibOffset
    #[inline(always)]
    pub fn set_vcfront_cc_right_exv_calib_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -510_f32 || 510_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ccRightExvRange
    ///
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cc_right_exv_range(&self) -> f32 {
        self.vcfront_cc_right_exv_range_raw()
    }
    
    /// Get raw value of VCFRONT_ccRightExvRange
    ///
    /// - Start bit: 50
    /// - Signal size: 9 bits
    /// - Factor: 3
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cc_right_exv_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[50..59].load_le::<u16>();
        
        let factor = 3_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_ccRightExvRange
    #[inline(always)]
    pub fn set_vcfront_cc_right_exv_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 3_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[50..59].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerExvCalibFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_exv_calib_failed(&self) -> bool {
        self.vcfront_chiller_exv_calib_failed_raw()
    }
    
    /// Get raw value of VCFRONT_chillerExvCalibFailed
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_chiller_exv_calib_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_chillerExvCalibFailed
    #[inline(always)]
    pub fn set_vcfront_chiller_exv_calib_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[56..57].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerExvCalibOffset
    ///
    /// - Min: -510
    /// - Max: 510
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_exv_calib_offset(&self) -> f32 {
        self.vcfront_chiller_exv_calib_offset_raw()
    }
    
    /// Get raw value of VCFRONT_chillerExvCalibOffset
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_chiller_exv_calib_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_chillerExvCalibOffset
    #[inline(always)]
    pub fn set_vcfront_chiller_exv_calib_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -510_f32 || 510_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerExvRange
    ///
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_exv_range(&self) -> f32 {
        self.vcfront_chiller_exv_range_raw()
    }
    
    /// Get raw value of VCFRONT_chillerExvRange
    ///
    /// - Start bit: 5
    /// - Signal size: 9 bits
    /// - Factor: 3
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_chiller_exv_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[5..14].load_le::<u16>();
        
        let factor = 3_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_chillerExvRange
    #[inline(always)]
    pub fn set_vcfront_chiller_exv_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 3_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[5..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerInletTempEstimate
    ///
    /// - Min: -40
    /// - Max: 85
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_inlet_temp_estimate(&self) -> i8 {
        self.vcfront_chiller_inlet_temp_estimate_raw()
    }
    
    /// Get raw value of VCFRONT_chillerInletTempEstimate
    ///
    /// - Start bit: 27
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_chiller_inlet_temp_estimate_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[27..35].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCFRONT_chillerInletTempEstimate
    #[inline(always)]
    pub fn set_vcfront_chiller_inlet_temp_estimate(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_i8 || 85_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[27..35].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerLiftDisabledLowPs
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_lift_disabled_low_ps(&self) -> bool {
        self.vcfront_chiller_lift_disabled_low_ps_raw()
    }
    
    /// Get raw value of VCFRONT_chillerLiftDisabledLowPs
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_chiller_lift_disabled_low_ps_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_chillerLiftDisabledLowPs
    #[inline(always)]
    pub fn set_vcfront_chiller_lift_disabled_low_ps(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_chillerPassiveCoolPower
    ///
    /// - Min: 0
    /// - Max: 15000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_chiller_passive_cool_power(&self) -> f32 {
        self.vcfront_chiller_passive_cool_power_raw()
    }
    
    /// Get raw value of VCFRONT_chillerPassiveCoolPower
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 60
    /// - Offset: 7560
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_chiller_passive_cool_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 60_f32;
        let offset = 7560_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_chillerPassiveCoolPower
    #[inline(always)]
    pub fn set_vcfront_chiller_passive_cool_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 15000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 60_f32;
        let offset = 7560_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_compEnergyDuringDrive
    ///
    /// - Min: 0
    /// - Max: 19000
    /// - Unit: "Wh"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_comp_energy_during_drive(&self) -> f32 {
        self.vcfront_comp_energy_during_drive_raw()
    }
    
    /// Get raw value of VCFRONT_compEnergyDuringDrive
    ///
    /// - Start bit: 35
    /// - Signal size: 7 bits
    /// - Factor: 150
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_comp_energy_during_drive_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[35..42].load_le::<u8>();
        
        let factor = 150_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_compEnergyDuringDrive
    #[inline(always)]
    pub fn set_vcfront_comp_energy_during_drive(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 19000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 150_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[35..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_condenserPressureLimit
    ///
    /// - Min: 10
    /// - Max: 20
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_condenser_pressure_limit(&self) -> f32 {
        self.vcfront_condenser_pressure_limit_raw()
    }
    
    /// Get raw value of VCFRONT_condenserPressureLimit
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 0.16
    /// - Offset: 10
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_condenser_pressure_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..14].load_le::<u8>();
        
        let factor = 0.16_f32;
        let offset = 10_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_condenserPressureLimit
    #[inline(always)]
    pub fn set_vcfront_condenser_pressure_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 10_f32 || 20_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.16_f32;
        let offset = 10_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantLevelVoltage
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "V"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_level_voltage(&self) -> f32 {
        self.vcfront_coolant_level_voltage_raw()
    }
    
    /// Get raw value of VCFRONT_coolantLevelVoltage
    ///
    /// - Start bit: 55
    /// - Signal size: 9 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_level_voltage_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[55..64].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantLevelVoltage
    #[inline(always)]
    pub fn set_vcfront_coolant_level_voltage(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[55..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveAngleDrift
    ///
    /// - Min: -127
    /// - Max: 127
    /// - Unit: "degrees"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_angle_drift(&self) -> f32 {
        self.vcfront_coolant_valve_angle_drift_raw()
    }
    
    /// Get raw value of VCFRONT_coolantValveAngleDrift
    ///
    /// - Start bit: 18
    /// - Signal size: 10 bits
    /// - Factor: 0.25
    /// - Offset: -127
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_angle_drift_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[18..28].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = -127_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantValveAngleDrift
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_angle_drift(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -127_f32 || 127_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.25_f32;
        let offset = -127_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[18..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveCountRange
    ///
    /// - Min: 375
    /// - Max: 1375
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_count_range(&self) -> Id381vcfrontLogging1HzVcfrontCoolantValveCountRange {
        match self.vcfront_coolant_valve_count_range_raw() {
            1023 => Id381vcfrontLogging1HzVcfrontCoolantValveCountRange::Sna,
            x => Id381vcfrontLogging1HzVcfrontCoolantValveCountRange::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantValveCountRange
    ///
    /// - Start bit: 8
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 375
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_count_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..18].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = 375_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantValveCountRange
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_count_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 375_f32 || 1375_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 375_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[8..18].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveDailyAngleTr
    ///
    /// - Min: 0
    /// - Max: 20000
    /// - Unit: "degrees"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_daily_angle_tr(&self) -> f32 {
        self.vcfront_coolant_valve_daily_angle_tr_raw()
    }
    
    /// Get raw value of VCFRONT_coolantValveDailyAngleTr
    ///
    /// - Start bit: 34
    /// - Signal size: 10 bits
    /// - Factor: 20
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_daily_angle_tr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[34..44].load_le::<u16>();
        
        let factor = 20_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantValveDailyAngleTr
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_daily_angle_tr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 20_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[34..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveOdometer
    ///
    /// - Min: 0
    /// - Max: 500000
    /// - Unit: "degrees"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_odometer(&self) -> f32 {
        self.vcfront_coolant_valve_odometer_raw()
    }
    
    /// Get raw value of VCFRONT_coolantValveOdometer
    ///
    /// - Start bit: 24
    /// - Signal size: 10 bits
    /// - Factor: 500
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_odometer_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..34].load_le::<u16>();
        
        let factor = 500_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantValveOdometer
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_odometer(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 500000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 500_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[24..34].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveRadBypass
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_rad_bypass(&self) -> Id381vcfrontLogging1HzVcfrontCoolantValveRadBypass {
        match self.vcfront_coolant_valve_rad_bypass_raw() {
            127 => Id381vcfrontLogging1HzVcfrontCoolantValveRadBypass::Sna,
            x => Id381vcfrontLogging1HzVcfrontCoolantValveRadBypass::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantValveRadBypass
    ///
    /// - Start bit: 56
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_rad_bypass_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantValveRadBypass
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_rad_bypass(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveRecalCount
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_recal_count(&self) -> u16 {
        self.vcfront_coolant_valve_recal_count_raw()
    }
    
    /// Get raw value of VCFRONT_coolantValveRecalCount
    ///
    /// - Start bit: 28
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_recal_count_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[28..44].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantValveRecalCount
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_recal_count(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[28..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveRecalReason
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_recal_reason(&self) -> Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason {
        match self.vcfront_coolant_valve_recal_reason_raw() {
            3 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::CalibrationFaultNoTravel,
            2 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::GeneralFault,
            1 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::MaxTravel,
            5 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::MotorFeedbackInterrupted,
            6 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::NvramLoss,
            4 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::SelfTest,
            7 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::SystemLevelFaultResponse,
            0 => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::Undefined,
            x => Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_coolantValveRecalReason
    ///
    /// - Start bit: 5
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_recal_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[5..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_coolantValveRecalReason
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_recal_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveWindupEstL
    ///
    /// - Min: 0
    /// - Max: 126
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_windup_est_l(&self) -> f32 {
        self.vcfront_coolant_valve_windup_est_l_raw()
    }
    
    /// Get raw value of VCFRONT_coolantValveWindupEstL
    ///
    /// - Start bit: 44
    /// - Signal size: 6 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_windup_est_l_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..50].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantValveWindupEstL
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_windup_est_l(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 126_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[44..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_coolantValveWindupEstR
    ///
    /// - Min: 0
    /// - Max: 126
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_coolant_valve_windup_est_r(&self) -> f32 {
        self.vcfront_coolant_valve_windup_est_r_raw()
    }
    
    /// Get raw value of VCFRONT_coolantValveWindupEstR
    ///
    /// - Start bit: 50
    /// - Signal size: 6 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_coolant_valve_windup_est_r_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[50..56].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_coolantValveWindupEstR
    #[inline(always)]
    pub fn set_vcfront_coolant_valve_windup_est_r(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 126_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[50..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_currentPositionHCML
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "Steps"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_current_position_hcml(&self) -> u16 {
        self.vcfront_current_position_hcml_raw()
    }
    
    /// Get raw value of VCFRONT_currentPositionHCML
    ///
    /// - Start bit: 26
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_current_position_hcml_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[26..36].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_currentPositionHCML
    #[inline(always)]
    pub fn set_vcfront_current_position_hcml(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[26..36].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_currentPositionHCMR
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: "Steps"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_current_position_hcmr(&self) -> u16 {
        self.vcfront_current_position_hcmr_raw()
    }
    
    /// Get raw value of VCFRONT_currentPositionHCMR
    ///
    /// - Start bit: 36
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_current_position_hcmr_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[36..46].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_currentPositionHCMR
    #[inline(always)]
    pub fn set_vcfront_current_position_hcmr(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[36..46].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_cycleModelConverged
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_cycle_model_converged(&self) -> bool {
        self.vcfront_cycle_model_converged_raw()
    }
    
    /// Get raw value of VCFRONT_cycleModelConverged
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_cycle_model_converged_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_cycleModelConverged
    #[inline(always)]
    pub fn set_vcfront_cycle_model_converged(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_diDissipation
    ///
    /// - Min: 0
    /// - Max: 20000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_di_dissipation(&self) -> f32 {
        self.vcfront_di_dissipation_raw()
    }
    
    /// Get raw value of VCFRONT_diDissipation
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_di_dissipation_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_diDissipation
    #[inline(always)]
    pub fn set_vcfront_di_dissipation(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_dischargePressureLimit
    ///
    /// - Min: 0
    /// - Max: 26
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_discharge_pressure_limit(&self) -> f32 {
        self.vcfront_discharge_pressure_limit_raw()
    }
    
    /// Get raw value of VCFRONT_dischargePressureLimit
    ///
    /// - Start bit: 48
    /// - Signal size: 7 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_discharge_pressure_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..55].load_le::<u8>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_dischargePressureLimit
    #[inline(always)]
    pub fn set_vcfront_discharge_pressure_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..55].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_dischargePressureTarget
    ///
    /// - Min: 0
    /// - Max: 26
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_discharge_pressure_target(&self) -> f32 {
        self.vcfront_discharge_pressure_target_raw()
    }
    
    /// Get raw value of VCFRONT_dischargePressureTarget
    ///
    /// - Start bit: 8
    /// - Signal size: 7 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_discharge_pressure_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..15].load_le::<u8>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_dischargePressureTarget
    #[inline(always)]
    pub fn set_vcfront_discharge_pressure_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 26_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_drlMode
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_drl_mode(&self) -> Id381vcfrontLogging1HzVcfrontDrlMode {
        match self.vcfront_drl_mode_raw() {
            2 => Id381vcfrontLogging1HzVcfrontDrlMode::DrlModeDrl,
            0 => Id381vcfrontLogging1HzVcfrontDrlMode::DrlModeOff,
            1 => Id381vcfrontLogging1HzVcfrontDrlMode::DrlModePosition,
            x => Id381vcfrontLogging1HzVcfrontDrlMode::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_drlMode
    ///
    /// - Start bit: 5
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_drl_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[5..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_drlMode
    #[inline(always)]
    pub fn set_vcfront_drl_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estCompPower
    ///
    /// - Min: 0
    /// - Max: 12750
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_comp_power(&self) -> f32 {
        self.vcfront_est_comp_power_raw()
    }
    
    /// Get raw value of VCFRONT_estCompPower
    ///
    /// - Start bit: 35
    /// - Signal size: 8 bits
    /// - Factor: 50
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_comp_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[35..43].load_le::<u8>();
        
        let factor = 50_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estCompPower
    #[inline(always)]
    pub fn set_vcfront_est_comp_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 12750_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 50_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[35..43].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estCompRefrigMassflow
    ///
    /// - Min: 0
    /// - Max: 251
    /// - Unit: "g/s"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_comp_refrig_massflow(&self) -> f32 {
        self.vcfront_est_comp_refrig_massflow_raw()
    }
    
    /// Get raw value of VCFRONT_estCompRefrigMassflow
    ///
    /// - Start bit: 17
    /// - Signal size: 6 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_comp_refrig_massflow_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[17..23].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estCompRefrigMassflow
    #[inline(always)]
    pub fn set_vcfront_est_comp_refrig_massflow(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 251_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[17..23].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estCompressorRpm
    ///
    /// - Min: 0
    /// - Max: 25200
    /// - Unit: "rpm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_compressor_rpm(&self) -> f32 {
        self.vcfront_est_compressor_rpm_raw()
    }
    
    /// Get raw value of VCFRONT_estCompressorRpm
    ///
    /// - Start bit: 48
    /// - Signal size: 6 bits
    /// - Factor: 400
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_compressor_rpm_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..54].load_le::<u8>();
        
        let factor = 400_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estCompressorRpm
    #[inline(always)]
    pub fn set_vcfront_est_compressor_rpm(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25200_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 400_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..54].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estPressureDisch
    ///
    /// - Min: 0
    /// - Max: 31.75
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_pressure_disch(&self) -> f32 {
        self.vcfront_est_pressure_disch_raw()
    }
    
    /// Get raw value of VCFRONT_estPressureDisch
    ///
    /// - Start bit: 19
    /// - Signal size: 7 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_pressure_disch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[19..26].load_le::<u8>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estPressureDisch
    #[inline(always)]
    pub fn set_vcfront_est_pressure_disch(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 31.75_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[19..26].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estPressureLiq
    ///
    /// - Min: 0
    /// - Max: 31.75
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_pressure_liq(&self) -> f32 {
        self.vcfront_est_pressure_liq_raw()
    }
    
    /// Get raw value of VCFRONT_estPressureLiq
    ///
    /// - Start bit: 5
    /// - Signal size: 7 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_pressure_liq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[5..12].load_le::<u8>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estPressureLiq
    #[inline(always)]
    pub fn set_vcfront_est_pressure_liq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 31.75_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[5..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estPressureSuct
    ///
    /// - Min: 0
    /// - Max: 11.5
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_pressure_suct(&self) -> f32 {
        self.vcfront_est_pressure_suct_raw()
    }
    
    /// Get raw value of VCFRONT_estPressureSuct
    ///
    /// - Start bit: 12
    /// - Signal size: 7 bits
    /// - Factor: 0.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_pressure_suct_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[12..19].load_le::<u8>();
        
        let factor = 0.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estPressureSuct
    #[inline(always)]
    pub fn set_vcfront_est_pressure_suct(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 11.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[12..19].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estQLift
    ///
    /// - Min: 0
    /// - Max: 12700
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_q_lift(&self) -> f32 {
        self.vcfront_est_q_lift_raw()
    }
    
    /// Get raw value of VCFRONT_estQLift
    ///
    /// - Start bit: 54
    /// - Signal size: 7 bits
    /// - Factor: 100
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_est_q_lift_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[54..61].load_le::<u8>();
        
        let factor = 100_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estQLift
    #[inline(always)]
    pub fn set_vcfront_est_q_lift(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 12700_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 100_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[54..61].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estTempDisch
    ///
    /// - Min: -34
    /// - Max: 170
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_temp_disch(&self) -> f32 {
        self.vcfront_est_temp_disch_raw()
    }
    
    /// Get raw value of VCFRONT_estTempDisch
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.8
    /// - Offset: 68.8
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_est_temp_disch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.8_f32;
        let offset = 68.8_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estTempDisch
    #[inline(always)]
    pub fn set_vcfront_est_temp_disch(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -34_f32 || 170_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.8_f32;
        let offset = 68.8_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estTempLiq
    ///
    /// - Min: -34
    /// - Max: 170
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_temp_liq(&self) -> f32 {
        self.vcfront_est_temp_liq_raw()
    }
    
    /// Get raw value of VCFRONT_estTempLiq
    ///
    /// - Start bit: 26
    /// - Signal size: 8 bits
    /// - Factor: 0.8
    /// - Offset: 68.8
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_est_temp_liq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[26..34].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.8_f32;
        let offset = 68.8_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estTempLiq
    #[inline(always)]
    pub fn set_vcfront_est_temp_liq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -34_f32 || 170_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.8_f32;
        let offset = 68.8_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[26..34].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_estTempSuct
    ///
    /// - Min: -30
    /// - Max: 33
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_est_temp_suct(&self) -> f32 {
        self.vcfront_est_temp_suct_raw()
    }
    
    /// Get raw value of VCFRONT_estTempSuct
    ///
    /// - Start bit: 34
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 2
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_est_temp_suct_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[34..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = 2_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_estTempSuct
    #[inline(always)]
    pub fn set_vcfront_est_temp_suct(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -30_f32 || 33_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = 2_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[34..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapDisabledLowPsCutout
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_disabled_low_ps_cutout(&self) -> bool {
        self.vcfront_evap_disabled_low_ps_cutout_raw()
    }
    
    /// Get raw value of VCFRONT_evapDisabledLowPsCutout
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_evap_disabled_low_ps_cutout_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_evapDisabledLowPsCutout
    #[inline(always)]
    pub fn set_vcfront_evap_disabled_low_ps_cutout(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapExvCalibFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_exv_calib_failed(&self) -> bool {
        self.vcfront_evap_exv_calib_failed_raw()
    }
    
    /// Get raw value of VCFRONT_evapExvCalibFailed
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_evap_exv_calib_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_evapExvCalibFailed
    #[inline(always)]
    pub fn set_vcfront_evap_exv_calib_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[57..58].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapExvCalibOffset
    ///
    /// - Min: -510
    /// - Max: 510
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_exv_calib_offset(&self) -> f32 {
        self.vcfront_evap_exv_calib_offset_raw()
    }
    
    /// Get raw value of VCFRONT_evapExvCalibOffset
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_evap_exv_calib_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_evapExvCalibOffset
    #[inline(always)]
    pub fn set_vcfront_evap_exv_calib_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -510_f32 || 510_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapExvRange
    ///
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_exv_range(&self) -> f32 {
        self.vcfront_evap_exv_range_raw()
    }
    
    /// Get raw value of VCFRONT_evapExvRange
    ///
    /// - Start bit: 14
    /// - Signal size: 9 bits
    /// - Factor: 3
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_evap_exv_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[14..23].load_le::<u16>();
        
        let factor = 3_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_evapExvRange
    #[inline(always)]
    pub fn set_vcfront_evap_exv_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 3_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[14..23].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapFdFrwrdTarget
    ///
    /// - Min: 0
    /// - Max: 10100
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_fd_frwrd_target(&self) -> f32 {
        self.vcfront_evap_fd_frwrd_target_raw()
    }
    
    /// Get raw value of VCFRONT_evapFdFrwrdTarget
    ///
    /// - Start bit: 28
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_evap_fd_frwrd_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..35].load_le::<u8>();
        
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_evapFdFrwrdTarget
    #[inline(always)]
    pub fn set_vcfront_evap_fd_frwrd_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[28..35].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapFdFrwrdTargetMinimum
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_fd_frwrd_target_minimum(&self) -> f32 {
        self.vcfront_evap_fd_frwrd_target_minimum_raw()
    }
    
    /// Get raw value of VCFRONT_evapFdFrwrdTargetMinimum
    ///
    /// - Start bit: 49
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_evap_fd_frwrd_target_minimum_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[49..56].load_le::<u8>();
        
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_evapFdFrwrdTargetMinimum
    #[inline(always)]
    pub fn set_vcfront_evap_fd_frwrd_target_minimum(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[49..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_evapFdbk
    ///
    /// - Min: -5000
    /// - Max: 5000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_evap_fdbk(&self) -> f32 {
        self.vcfront_evap_fdbk_raw()
    }
    
    /// Get raw value of VCFRONT_evapFdbk
    ///
    /// - Start bit: 35
    /// - Signal size: 7 bits
    /// - Factor: 80
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_evap_fdbk_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[35..42].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 80_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_evapFdbk
    #[inline(always)]
    pub fn set_vcfront_evap_fdbk(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -5000_f32 || 5000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 80_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[35..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_exteriorQuietModeAllowed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_exterior_quiet_mode_allowed(&self) -> bool {
        self.vcfront_exterior_quiet_mode_allowed_raw()
    }
    
    /// Get raw value of VCFRONT_exteriorQuietModeAllowed
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_exterior_quiet_mode_allowed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_exteriorQuietModeAllowed
    #[inline(always)]
    pub fn set_vcfront_exterior_quiet_mode_allowed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_exteriorQuietModeEnabled
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_exterior_quiet_mode_enabled(&self) -> bool {
        self.vcfront_exterior_quiet_mode_enabled_raw()
    }
    
    /// Get raw value of VCFRONT_exteriorQuietModeEnabled
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_exterior_quiet_mode_enabled_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_exteriorQuietModeEnabled
    #[inline(always)]
    pub fn set_vcfront_exterior_quiet_mode_enabled(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fanControlFeedfwdActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fan_control_feedfwd_active(&self) -> bool {
        self.vcfront_fan_control_feedfwd_active_raw()
    }
    
    /// Get raw value of VCFRONT_fanControlFeedfwdActive
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fan_control_feedfwd_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_fanControlFeedfwdActive
    #[inline(always)]
    pub fn set_vcfront_fan_control_feedfwd_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[49..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fanControlRadCanCool
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fan_control_rad_can_cool(&self) -> bool {
        self.vcfront_fan_control_rad_can_cool_raw()
    }
    
    /// Get raw value of VCFRONT_fanControlRadCanCool
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fan_control_rad_can_cool_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_fanControlRadCanCool
    #[inline(always)]
    pub fn set_vcfront_fan_control_rad_can_cool(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[48..49].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fanControlRadiatorInletT
    ///
    /// - Min: -20
    /// - Max: 90
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fan_control_radiator_inlet_t(&self) -> f32 {
        self.vcfront_fan_control_radiator_inlet_t_raw()
    }
    
    /// Get raw value of VCFRONT_fanControlRadiatorInletT
    ///
    /// - Start bit: 57
    /// - Signal size: 6 bits
    /// - Factor: 1.8
    /// - Offset: 36
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_fan_control_radiator_inlet_t_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[57..63].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1.8_f32;
        let offset = 36_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_fanControlRadiatorInletT
    #[inline(always)]
    pub fn set_vcfront_fan_control_radiator_inlet_t(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 90_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1.8_f32;
        let offset = 36_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[57..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fanControlRadiatorUa
    ///
    /// - Min: 0
    /// - Max: 1000
    /// - Unit: "W/C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fan_control_radiator_ua(&self) -> f32 {
        self.vcfront_fan_control_radiator_ua_raw()
    }
    
    /// Get raw value of VCFRONT_fanControlRadiatorUa
    ///
    /// - Start bit: 50
    /// - Signal size: 7 bits
    /// - Factor: 8
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fan_control_radiator_ua_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[50..57].load_le::<u8>();
        
        let factor = 8_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_fanControlRadiatorUa
    #[inline(always)]
    pub fn set_vcfront_fan_control_radiator_ua(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 8_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[50..57].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fanDemandCondenser
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fan_demand_condenser(&self) -> u8 {
        self.vcfront_fan_demand_condenser_raw()
    }
    
    /// Get raw value of VCFRONT_fanDemandCondenser
    ///
    /// - Start bit: 14
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fan_demand_condenser_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_fanDemandCondenser
    #[inline(always)]
    pub fn set_vcfront_fan_demand_condenser(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..21].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_fanDemandRadiator
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_fan_demand_radiator(&self) -> u8 {
        self.vcfront_fan_demand_radiator_raw()
    }
    
    /// Get raw value of VCFRONT_fanDemandRadiator
    ///
    /// - Start bit: 21
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_fan_demand_radiator_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[21..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_fanDemandRadiator
    #[inline(always)]
    pub fn set_vcfront_fan_demand_radiator(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[21..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedBackDuctTempControll
    ///
    /// - Min: -100
    /// - Max: 100
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feed_back_duct_temp_controll(&self) -> f32 {
        self.vcfront_feed_back_duct_temp_controll_raw()
    }
    
    /// Get raw value of VCFRONT_feedBackDuctTempControll
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -100
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feed_back_duct_temp_controll_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -100_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_feedBackDuctTempControll
    #[inline(always)]
    pub fn set_vcfront_feed_back_duct_temp_controll(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -100_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -100_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedBackEvapTempControll
    ///
    /// - Min: -0.5
    /// - Max: 0.5
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feed_back_evap_temp_controll(&self) -> f32 {
        self.vcfront_feed_back_evap_temp_controll_raw()
    }
    
    /// Get raw value of VCFRONT_feedBackEvapTempControll
    ///
    /// - Start bit: 24
    /// - Signal size: 7 bits
    /// - Factor: 0.01
    /// - Offset: -0.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feed_back_evap_temp_controll_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..31].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = -0.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_feedBackEvapTempControll
    #[inline(always)]
    pub fn set_vcfront_feed_back_evap_temp_controll(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -0.5_f32 || 0.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.01_f32;
        let offset = -0.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..31].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedFwdFanDemand
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feed_fwd_fan_demand(&self) -> u8 {
        self.vcfront_feed_fwd_fan_demand_raw()
    }
    
    /// Get raw value of VCFRONT_feedFwdFanDemand
    ///
    /// - Start bit: 35
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feed_fwd_fan_demand_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[35..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_feedFwdFanDemand
    #[inline(always)]
    pub fn set_vcfront_feed_fwd_fan_demand(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[35..42].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedFwdMDotCabinCondense
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feed_fwd_m_dot_cabin_condense(&self) -> f32 {
        self.vcfront_feed_fwd_m_dot_cabin_condense_raw()
    }
    
    /// Get raw value of VCFRONT_feedFwdMDotCabinCondense
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feed_fwd_m_dot_cabin_condense_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_feedFwdMDotCabinCondense
    #[inline(always)]
    pub fn set_vcfront_feed_fwd_m_dot_cabin_condense(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedFwdMDotEvaporator
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feed_fwd_m_dot_evaporator(&self) -> f32 {
        self.vcfront_feed_fwd_m_dot_evaporator_raw()
    }
    
    /// Get raw value of VCFRONT_feedFwdMDotEvaporator
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.005
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feed_fwd_m_dot_evaporator_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        let factor = 0.005_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_feedFwdMDotEvaporator
    #[inline(always)]
    pub fn set_vcfront_feed_fwd_m_dot_evaporator(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.005_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedFwdPumpDemand
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feed_fwd_pump_demand(&self) -> u8 {
        self.vcfront_feed_fwd_pump_demand_raw()
    }
    
    /// Get raw value of VCFRONT_feedFwdPumpDemand
    ///
    /// - Start bit: 42
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feed_fwd_pump_demand_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[42..49].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_feedFwdPumpDemand
    #[inline(always)]
    pub fn set_vcfront_feed_fwd_pump_demand(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[42..49].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_feedfwdLoadCoolingDomina
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_feedfwd_load_cooling_domina(&self) -> bool {
        self.vcfront_feedfwd_load_cooling_domina_raw()
    }
    
    /// Get raw value of VCFRONT_feedfwdLoadCoolingDomina
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_feedfwd_load_cooling_domina_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_feedfwdLoadCoolingDomina
    #[inline(always)]
    pub fn set_vcfront_feedfwd_load_cooling_domina(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[59..60].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_homelinkRegionCode
    ///
    /// - Min: 0
    /// - Max: 9
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_homelink_region_code(&self) -> Id381vcfrontLogging1HzVcfrontHomelinkRegionCode {
        match self.vcfront_homelink_region_code_raw() {
            5 => Id381vcfrontLogging1HzVcfrontHomelinkRegionCode::HomelinkRegionCodeAmericas,
            9 => Id381vcfrontLogging1HzVcfrontHomelinkRegionCode::HomelinkRegionCodeChina,
            1 => Id381vcfrontLogging1HzVcfrontHomelinkRegionCode::HomelinkRegionCodeEurope,
            8 => Id381vcfrontLogging1HzVcfrontHomelinkRegionCode::HomelinkRegionCodeRestOfWorld,
            0 => Id381vcfrontLogging1HzVcfrontHomelinkRegionCode::HomelinkRegionCodeUnknown,
            x => Id381vcfrontLogging1HzVcfrontHomelinkRegionCode::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_homelinkRegionCode
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_homelink_region_code_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_homelinkRegionCode
    #[inline(always)]
    pub fn set_vcfront_homelink_region_code(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 9_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpAmbientSource
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_ambient_source(&self) -> bool {
        self.vcfront_hp_ambient_source_raw()
    }
    
    /// Get raw value of VCFRONT_hpAmbientSource
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_ambient_source_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpAmbientSource
    #[inline(always)]
    pub fn set_vcfront_hp_ambient_source(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[6..7].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpAtSteadyState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_at_steady_state(&self) -> bool {
        self.vcfront_hp_at_steady_state_raw()
    }
    
    /// Get raw value of VCFRONT_hpAtSteadyState
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_at_steady_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpAtSteadyState
    #[inline(always)]
    pub fn set_vcfront_hp_at_steady_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[50..51].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBattOverTempHvacDisabl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_batt_over_temp_hvac_disabl(&self) -> bool {
        self.vcfront_hp_batt_over_temp_hvac_disabl_raw()
    }
    
    /// Get raw value of VCFRONT_hpBattOverTempHvacDisabl
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_batt_over_temp_hvac_disabl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBattOverTempHvacDisabl
    #[inline(always)]
    pub fn set_vcfront_hp_batt_over_temp_hvac_disabl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[38..39].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBattStagTarget
    ///
    /// - Min: -40
    /// - Max: 80
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_batt_stag_target(&self) -> f32 {
        self.vcfront_hp_batt_stag_target_raw()
    }
    
    /// Get raw value of VCFRONT_hpBattStagTarget
    ///
    /// - Start bit: 28
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_batt_stag_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..35].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_hpBattStagTarget
    #[inline(always)]
    pub fn set_vcfront_hp_batt_stag_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 80_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[28..35].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBatteryCool
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_battery_cool(&self) -> bool {
        self.vcfront_hp_battery_cool_raw()
    }
    
    /// Get raw value of VCFRONT_hpBatteryCool
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBatteryCool
    #[inline(always)]
    pub fn set_vcfront_hp_battery_cool(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[19..20].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBatteryCoolCabinConden
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_cabin_conden(&self) -> bool {
        self.vcfront_hp_battery_cool_cabin_conden_raw()
    }
    
    /// Get raw value of VCFRONT_hpBatteryCoolCabinConden
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_cabin_conden_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBatteryCoolCabinConden
    #[inline(always)]
    pub fn set_vcfront_hp_battery_cool_cabin_conden(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[20..21].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBatteryCoolCabinReheat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_cabin_reheat(&self) -> bool {
        self.vcfront_hp_battery_cool_cabin_reheat_raw()
    }
    
    /// Get raw value of VCFRONT_hpBatteryCoolCabinReheat
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_cabin_reheat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBatteryCoolCabinReheat
    #[inline(always)]
    pub fn set_vcfront_hp_battery_cool_cabin_reheat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[21..22].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBatteryCoolEvaporator
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_evaporator(&self) -> bool {
        self.vcfront_hp_battery_cool_evaporator_raw()
    }
    
    /// Get raw value of VCFRONT_hpBatteryCoolEvaporator
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_battery_cool_evaporator_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBatteryCoolEvaporator
    #[inline(always)]
    pub fn set_vcfront_hp_battery_cool_evaporator(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[22..23].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBatteryHeatAmbientSour
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_battery_heat_ambient_sour(&self) -> bool {
        self.vcfront_hp_battery_heat_ambient_sour_raw()
    }
    
    /// Get raw value of VCFRONT_hpBatteryHeatAmbientSour
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_battery_heat_ambient_sour_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBatteryHeatAmbientSour
    #[inline(always)]
    pub fn set_vcfront_hp_battery_heat_ambient_sour(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[17..18].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpBatteryHeatCOP1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_battery_heat_cop1(&self) -> bool {
        self.vcfront_hp_battery_heat_cop1_raw()
    }
    
    /// Get raw value of VCFRONT_hpBatteryHeatCOP1
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_battery_heat_cop1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpBatteryHeatCOP1
    #[inline(always)]
    pub fn set_vcfront_hp_battery_heat_cop1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[18..19].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCOP
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cop(&self) -> f32 {
        self.vcfront_hp_cop_raw()
    }
    
    /// Get raw value of VCFRONT_hpCOP
    ///
    /// - Start bit: 22
    /// - Signal size: 6 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cop_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[22..28].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_hpCOP
    #[inline(always)]
    pub fn set_vcfront_hp_cop(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[22..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinCoolEvaporator
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_cool_evaporator(&self) -> bool {
        self.vcfront_hp_cabin_cool_evaporator_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinCoolEvaporator
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_cool_evaporator_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinCoolEvaporator
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_cool_evaporator(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[15..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinCoolEvaporatorReh
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_cool_evaporator_reh(&self) -> bool {
        self.vcfront_hp_cabin_cool_evaporator_reh_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinCoolEvaporatorReh
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_cool_evaporator_reh_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinCoolEvaporatorReh
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_cool_evaporator_reh(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatAmbientSource
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_ambient_source(&self) -> bool {
        self.vcfront_hp_cabin_heat_ambient_source_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatAmbientSource
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_ambient_source_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatAmbientSource
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_ambient_source(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[8..9].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatBatteryCoolRe
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_battery_cool_re(&self) -> bool {
        self.vcfront_hp_cabin_heat_battery_cool_re_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatBatteryCoolRe
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_battery_cool_re_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatBatteryCoolRe
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_battery_cool_re(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[14..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatBatteryHeatRe
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_battery_heat_re(&self) -> bool {
        self.vcfront_hp_cabin_heat_battery_heat_re_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatBatteryHeatRe
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_battery_heat_re_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatBatteryHeatRe
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_battery_heat_re(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[13..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatBlend
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_blend(&self) -> bool {
        self.vcfront_hp_cabin_heat_blend_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatBlend
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_blend_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatBlend
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_blend(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[11..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatCOP1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_cop1(&self) -> bool {
        self.vcfront_hp_cabin_heat_cop1_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatCOP1
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_cop1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatCOP1
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_cop1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[12..13].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatReheatAmbient
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_reheat_ambient(&self) -> bool {
        self.vcfront_hp_cabin_heat_reheat_ambient_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatReheatAmbient
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_reheat_ambient_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatReheatAmbient
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_reheat_ambient(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[10..11].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatReheatScaveng
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_reheat_scaveng(&self) -> bool {
        self.vcfront_hp_cabin_heat_reheat_scaveng_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatReheatScaveng
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_reheat_scaveng_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatReheatScaveng
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_reheat_scaveng(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[9..10].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCabinHeatScavengeOnly
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_scavenge_only(&self) -> bool {
        self.vcfront_hp_cabin_heat_scavenge_only_raw()
    }
    
    /// Get raw value of VCFRONT_hpCabinHeatScavengeOnly
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_cabin_heat_scavenge_only_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpCabinHeatScavengeOnly
    #[inline(always)]
    pub fn set_vcfront_hp_cabin_heat_scavenge_only(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[7..8].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCompPowerIndex
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_comp_power_index(&self) -> u8 {
        self.vcfront_hp_comp_power_index_raw()
    }
    
    /// Get raw value of VCFRONT_hpCompPowerIndex
    ///
    /// - Start bit: 43
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_comp_power_index_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[43..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hpCompPowerIndex
    #[inline(always)]
    pub fn set_vcfront_hp_comp_power_index(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[43..50].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpCompPowerIndexFiltered
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: "-"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_comp_power_index_filtered(&self) -> u8 {
        self.vcfront_hp_comp_power_index_filtered_raw()
    }
    
    /// Get raw value of VCFRONT_hpCompPowerIndexFiltered
    ///
    /// - Start bit: 56
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_comp_power_index_filtered_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hpCompPowerIndexFiltered
    #[inline(always)]
    pub fn set_vcfront_hp_comp_power_index_filtered(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpDiagLouverCalib
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_diag_louver_calib(&self) -> bool {
        self.vcfront_hp_diag_louver_calib_raw()
    }
    
    /// Get raw value of VCFRONT_hpDiagLouverCalib
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_diag_louver_calib_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpDiagLouverCalib
    #[inline(always)]
    pub fn set_vcfront_hp_diag_louver_calib(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[39..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpForceScavenge
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_force_scavenge(&self) -> bool {
        self.vcfront_hp_force_scavenge_raw()
    }
    
    /// Get raw value of VCFRONT_hpForceScavenge
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_force_scavenge_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpForceScavenge
    #[inline(always)]
    pub fn set_vcfront_hp_force_scavenge(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpGeneral
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_general(&self) -> bool {
        self.vcfront_hp_general_raw()
    }
    
    /// Get raw value of VCFRONT_hpGeneral
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_general_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpGeneral
    #[inline(always)]
    pub fn set_vcfront_hp_general(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpMode
    ///
    /// - Min: 0
    /// - Max: 19
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_mode(&self) -> Id381vcfrontLogging1HzVcfrontHpMode {
        match self.vcfront_hp_mode_raw() {
            2 => Id381vcfrontLogging1HzVcfrontHpMode::AmbientSource,
            15 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryCool,
            17 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryCoolCabinCondenser,
            16 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryCoolCabinCondenserReheat,
            18 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryCoolCabinReheat,
            19 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryCoolEvaporator,
            13 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryHeatAmbientSource,
            14 => Id381vcfrontLogging1HzVcfrontHpMode::BatteryHeatCop1,
            11 => Id381vcfrontLogging1HzVcfrontHpMode::CabinCoolEvaporator,
            12 => Id381vcfrontLogging1HzVcfrontHpMode::CabinCoolEvaporatorReheat,
            4 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatAmbientSource,
            10 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatBatteryCoolReheat,
            9 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatBatteryHeatReheatAmbientSource,
            7 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatBlend,
            8 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatCop1,
            6 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatReheatAmbientSource,
            5 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatReheatScavenge,
            3 => Id381vcfrontLogging1HzVcfrontHpMode::CabinHeatScavengeOnly,
            1 => Id381vcfrontLogging1HzVcfrontHpMode::General,
            0 => Id381vcfrontLogging1HzVcfrontHpMode::None,
            x => Id381vcfrontLogging1HzVcfrontHpMode::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_hpMode
    ///
    /// - Start bit: 10
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[10..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hpMode
    #[inline(always)]
    pub fn set_vcfront_hp_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 19_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[10..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpPotentialLowRefrig
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_potential_low_refrig(&self) -> bool {
        self.vcfront_hp_potential_low_refrig_raw()
    }
    
    /// Get raw value of VCFRONT_hpPotentialLowRefrig
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_potential_low_refrig_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_hpPotentialLowRefrig
    #[inline(always)]
    pub fn set_vcfront_hp_potential_low_refrig(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[61..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpRefrigerantPurgeState
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_refrigerant_purge_state(&self) -> Id381vcfrontLogging1HzVcfrontHpRefrigerantPurgeState {
        match self.vcfront_hp_refrigerant_purge_state_raw() {
            2 => Id381vcfrontLogging1HzVcfrontHpRefrigerantPurgeState::Complete,
            1 => Id381vcfrontLogging1HzVcfrontHpRefrigerantPurgeState::EvapPurge,
            0 => Id381vcfrontLogging1HzVcfrontHpRefrigerantPurgeState::Idle,
            x => Id381vcfrontLogging1HzVcfrontHpRefrigerantPurgeState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_hpRefrigerantPurgeState
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_refrigerant_purge_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hpRefrigerantPurgeState
    #[inline(always)]
    pub fn set_vcfront_hp_refrigerant_purge_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[62..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_hpSubcoolTarget
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_hp_subcool_target(&self) -> u8 {
        self.vcfront_hp_subcool_target_raw()
    }
    
    /// Get raw value of VCFRONT_hpSubcoolTarget
    ///
    /// - Start bit: 12
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_hp_subcool_target_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[12..17].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_hpSubcoolTarget
    #[inline(always)]
    pub fn set_vcfront_hp_subcool_target(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[12..17].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lccActiveCoolTarget
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lcc_active_cool_target(&self) -> u8 {
        self.vcfront_lcc_active_cool_target_raw()
    }
    
    /// Get raw value of VCFRONT_lccActiveCoolTarget
    ///
    /// - Start bit: 16
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_lcc_active_cool_target_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_lccActiveCoolTarget
    #[inline(always)]
    pub fn set_vcfront_lcc_active_cool_target(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..23].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lccExvCalibFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lcc_exv_calib_failed(&self) -> bool {
        self.vcfront_lcc_exv_calib_failed_raw()
    }
    
    /// Get raw value of VCFRONT_lccExvCalibFailed
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_lcc_exv_calib_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_lccExvCalibFailed
    #[inline(always)]
    pub fn set_vcfront_lcc_exv_calib_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[59..60].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lccExvCalibOffset
    ///
    /// - Min: -510
    /// - Max: 510
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lcc_exv_calib_offset(&self) -> f32 {
        self.vcfront_lcc_exv_calib_offset_raw()
    }
    
    /// Get raw value of VCFRONT_lccExvCalibOffset
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_lcc_exv_calib_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_lccExvCalibOffset
    #[inline(always)]
    pub fn set_vcfront_lcc_exv_calib_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -510_f32 || 510_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lccExvRange
    ///
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lcc_exv_range(&self) -> f32 {
        self.vcfront_lcc_exv_range_raw()
    }
    
    /// Get raw value of VCFRONT_lccExvRange
    ///
    /// - Start bit: 32
    /// - Signal size: 9 bits
    /// - Factor: 3
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_lcc_exv_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..41].load_le::<u16>();
        
        let factor = 3_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_lccExvRange
    #[inline(always)]
    pub fn set_vcfront_lcc_exv_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 3_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[32..41].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lccInletTempEstimate
    ///
    /// - Min: -40
    /// - Max: 85
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lcc_inlet_temp_estimate(&self) -> i8 {
        self.vcfront_lcc_inlet_temp_estimate_raw()
    }
    
    /// Get raw value of VCFRONT_lccInletTempEstimate
    ///
    /// - Start bit: 19
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_lcc_inlet_temp_estimate_raw(&self) -> i8 {
        let signal = self.raw.view_bits::<LocalBits>()[19..27].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of VCFRONT_lccInletTempEstimate
    #[inline(always)]
    pub fn set_vcfront_lcc_inlet_temp_estimate(&mut self, value: i8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_i8 || 85_i8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[19..27].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lccPassiveHeatPower
    ///
    /// - Min: 0
    /// - Max: 15000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_lcc_passive_heat_power(&self) -> f32 {
        self.vcfront_lcc_passive_heat_power_raw()
    }
    
    /// Get raw value of VCFRONT_lccPassiveHeatPower
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 60
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_lcc_passive_heat_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        let factor = 60_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_lccPassiveHeatPower
    #[inline(always)]
    pub fn set_vcfront_lcc_passive_heat_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 15000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 60_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lowSideLiftEnergyDrive
    ///
    /// - Min: 0
    /// - Max: 19000
    /// - Unit: "Wh"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_low_side_lift_energy_drive(&self) -> f32 {
        self.vcfront_low_side_lift_energy_drive_raw()
    }
    
    /// Get raw value of VCFRONT_lowSideLiftEnergyDrive
    ///
    /// - Start bit: 49
    /// - Signal size: 7 bits
    /// - Factor: 150
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_low_side_lift_energy_drive_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[49..56].load_le::<u8>();
        
        let factor = 150_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_lowSideLiftEnergyDrive
    #[inline(always)]
    pub fn set_vcfront_low_side_lift_energy_drive(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 19000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 150_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[49..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_lowSideWattsLift
    ///
    /// - Min: 0
    /// - Max: 7600
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_low_side_watts_lift(&self) -> f32 {
        self.vcfront_low_side_watts_lift_raw()
    }
    
    /// Get raw value of VCFRONT_lowSideWattsLift
    ///
    /// - Start bit: 56
    /// - Signal size: 7 bits
    /// - Factor: 60
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_low_side_watts_lift_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..63].load_le::<u8>();
        
        let factor = 60_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_lowSideWattsLift
    #[inline(always)]
    pub fn set_vcfront_low_side_watts_lift(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 7600_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 60_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_maxAllowedEvapPowerInSer
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_max_allowed_evap_power_in_ser(&self) -> f32 {
        self.vcfront_max_allowed_evap_power_in_ser_raw()
    }
    
    /// Get raw value of VCFRONT_maxAllowedEvapPowerInSer
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 40
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_max_allowed_evap_power_in_ser_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 40_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_maxAllowedEvapPowerInSer
    #[inline(always)]
    pub fn set_vcfront_max_allowed_evap_power_in_ser(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 40_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_maxChillerCoolingPower
    ///
    /// - Min: 0
    /// - Max: 20000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_max_chiller_cooling_power(&self) -> f32 {
        self.vcfront_max_chiller_cooling_power_raw()
    }
    
    /// Get raw value of VCFRONT_maxChillerCoolingPower
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 100
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_max_chiller_cooling_power_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        let factor = 100_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_maxChillerCoolingPower
    #[inline(always)]
    pub fn set_vcfront_max_chiller_cooling_power(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 100_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_maxCompressorRPMAllowed
    ///
    /// - Min: 0
    /// - Max: 11430
    /// - Unit: "rpm"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_max_compressor_rpm_allowed(&self) -> f32 {
        self.vcfront_max_compressor_rpm_allowed_raw()
    }
    
    /// Get raw value of VCFRONT_maxCompressorRPMAllowed
    ///
    /// - Start bit: 56
    /// - Signal size: 7 bits
    /// - Factor: 90
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_max_compressor_rpm_allowed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[56..63].load_le::<u8>();
        
        let factor = 90_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_maxCompressorRPMAllowed
    #[inline(always)]
    pub fn set_vcfront_max_compressor_rpm_allowed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 11430_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 90_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[56..63].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_minAllowedChillerPowerIn
    ///
    /// - Min: 0
    /// - Max: 10000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_min_allowed_chiller_power_in(&self) -> f32 {
        self.vcfront_min_allowed_chiller_power_in_raw()
    }
    
    /// Get raw value of VCFRONT_minAllowedChillerPowerIn
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 40
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_min_allowed_chiller_power_in_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..56].load_le::<u8>();
        
        let factor = 40_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_minAllowedChillerPowerIn
    #[inline(always)]
    pub fn set_vcfront_min_allowed_chiller_power_in(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10000_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 40_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..56].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_minAllowedSuctionPressur
    ///
    /// - Min: 0
    /// - Max: 2.5
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_min_allowed_suction_pressur(&self) -> f32 {
        self.vcfront_min_allowed_suction_pressur_raw()
    }
    
    /// Get raw value of VCFRONT_minAllowedSuctionPressur
    ///
    /// - Start bit: 48
    /// - Signal size: 7 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_min_allowed_suction_pressur_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..55].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_minAllowedSuctionPressur
    #[inline(always)]
    pub fn set_vcfront_min_allowed_suction_pressur(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.5_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..55].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_minFlowPDCont
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_min_flow_pd_cont(&self) -> f32 {
        self.vcfront_min_flow_pd_cont_raw()
    }
    
    /// Get raw value of VCFRONT_minFlowPDCont
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_min_flow_pd_cont_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_minFlowPDCont
    #[inline(always)]
    pub fn set_vcfront_min_flow_pd_cont(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_modeDesired
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_mode_desired(&self) -> Id381vcfrontLogging1HzVcfrontModeDesired {
        match self.vcfront_mode_desired_raw() {
            3 => Id381vcfrontLogging1HzVcfrontModeDesired::AmbientSource,
            2 => Id381vcfrontLogging1HzVcfrontModeDesired::Blend,
            1 => Id381vcfrontLogging1HzVcfrontModeDesired::Parallel,
            0 => Id381vcfrontLogging1HzVcfrontModeDesired::Series,
            x => Id381vcfrontLogging1HzVcfrontModeDesired::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_modeDesired
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_mode_desired_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_modeDesired
    #[inline(always)]
    pub fn set_vcfront_mode_desired(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_modeTransitionID
    ///
    /// - Min: 0
    /// - Max: 40
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_mode_transition_id(&self) -> Id381vcfrontLogging1HzVcfrontModeTransitionId {
        match self.vcfront_mode_transition_id_raw() {
            23 => Id381vcfrontLogging1HzVcfrontModeTransitionId::EnterAmbientsource,
            24 => Id381vcfrontLogging1HzVcfrontModeTransitionId::ExitAmbientsource,
            20 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Init,
            21 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Override,
            6 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel2DriveBatteryWantsHeat,
            7 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel3DriveBatteryWantsCool,
            8 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel4DriveBatteryNeedsCool,
            11 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel5ChargeBatteryWantsHeat,
            12 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel6ChargeBatteryWantsCool,
            15 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel7FastChargeBatteryWantsCool,
            16 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel8FastChargeBatteryWantsHeat,
            19 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Parallel9DriveBatteryThermalLimiting,
            0 => Id381vcfrontLogging1HzVcfrontModeTransitionId::ParallelF1NoFlowRequest,
            33 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par1DriveBattNeedsActiveCoolingEvapDisabled,
            34 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par2DrivePtNeedsActiveCooling,
            35 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par3DriveChillerPassivelyCoolsBatt,
            36 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par4DriveCannotPassivelyCoolBatt,
            37 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par5DriveBattAboveHotStagnationTemp,
            38 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par6FcBattNeedsActiveCoolingEvapDisabled,
            39 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par7FcBattNeedsActiveCoolingEvapEnabled,
            40 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Par8ChargeBattAbovePassiveTarget,
            3 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series1DriveBatteryWantsCool,
            4 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series2DriveBatteryNeedsHeat,
            5 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series3DriveBatteryWantsHeat,
            9 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series4ChargeBatteryNeedsHeat,
            10 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series5ChargeBatteryWantsHeat,
            13 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series6FastChargeBatteryNeedsHeat,
            14 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series7FastChargeBatteryWantsCool,
            17 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series8PreConditioningBatteryNeedsHeat,
            18 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Series9DriveDriveUnitThermalLimiting,
            1 => Id381vcfrontLogging1HzVcfrontModeTransitionId::SeriesF2FaultPumps,
            2 => Id381vcfrontLogging1HzVcfrontModeTransitionId::SeriesF3FaultTempSensors,
            25 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser1DriveBattNeedsActiveCoolingEvapEnabled,
            26 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser2DriveBattBelowHotStagnationTemp,
            27 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser3DriveChillerPassivelyCools,
            28 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser4DriveRadPassivelyCoolsBatt,
            29 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser5FcBattHeatingNeeded,
            30 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser6FcBattNeedsActiveCoolingEvapDisabled,
            31 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser7FcBattNeedsActiveCoolingEvapEnabled,
            32 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Ser8ChargeBattBelowPassiveTarget,
            22 => Id381vcfrontLogging1HzVcfrontModeTransitionId::Undefined,
            x => Id381vcfrontLogging1HzVcfrontModeTransitionId::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_modeTransitionID
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_mode_transition_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_modeTransitionID
    #[inline(always)]
    pub fn set_vcfront_mode_transition_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 40_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..14].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_modelLoadCoolingDominant
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_model_load_cooling_dominant(&self) -> bool {
        self.vcfront_model_load_cooling_dominant_raw()
    }
    
    /// Get raw value of VCFRONT_modelLoadCoolingDominant
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_model_load_cooling_dominant_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_modelLoadCoolingDominant
    #[inline(always)]
    pub fn set_vcfront_model_load_cooling_dominant(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[60..61].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_passiveCoolingState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_passive_cooling_state(&self) -> Id381vcfrontLogging1HzVcfrontPassiveCoolingState {
        match self.vcfront_passive_cooling_state_raw() {
            3 => Id381vcfrontLogging1HzVcfrontPassiveCoolingState::CannotCoolBattery,
            2 => Id381vcfrontLogging1HzVcfrontPassiveCoolingState::ChillerAndRadCoolSeriesLoop,
            1 => Id381vcfrontLogging1HzVcfrontPassiveCoolingState::ChillerCoolsParallelBattLoop,
            0 => Id381vcfrontLogging1HzVcfrontPassiveCoolingState::ChillerCoolsSeriesLoop,
            x => Id381vcfrontLogging1HzVcfrontPassiveCoolingState::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_passiveCoolingState
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_passive_cooling_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_passiveCoolingState
    #[inline(always)]
    pub fn set_vcfront_passive_cooling_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[56..58].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_passiveDemandRadBypass
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_passive_demand_rad_bypass(&self) -> u8 {
        self.vcfront_passive_demand_rad_bypass_raw()
    }
    
    /// Get raw value of VCFRONT_passiveDemandRadBypass
    ///
    /// - Start bit: 8
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_passive_demand_rad_bypass_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_passiveDemandRadBypass
    #[inline(always)]
    pub fn set_vcfront_passive_demand_rad_bypass(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..15].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_passiveSeriesRegOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_passive_series_reg_on(&self) -> bool {
        self.vcfront_passive_series_reg_on_raw()
    }
    
    /// Get raw value of VCFRONT_passiveSeriesRegOn
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_passive_series_reg_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_passiveSeriesRegOn
    #[inline(always)]
    pub fn set_vcfront_passive_series_reg_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[5..6].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pressureRefrigDischEst
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pressure_refrig_disch_est(&self) -> u8 {
        self.vcfront_pressure_refrig_disch_est_raw()
    }
    
    /// Get raw value of VCFRONT_pressureRefrigDischEst
    ///
    /// - Start bit: 24
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pressure_refrig_disch_est_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_pressureRefrigDischEst
    #[inline(always)]
    pub fn set_vcfront_pressure_refrig_disch_est(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..29].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pressureRefrigSuctionEst
    ///
    /// - Min: 0
    /// - Max: 14.36
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pressure_refrig_suction_est(&self) -> f32 {
        self.vcfront_pressure_refrig_suction_est_raw()
    }
    
    /// Get raw value of VCFRONT_pressureRefrigSuctionEst
    ///
    /// - Start bit: 51
    /// - Signal size: 7 bits
    /// - Factor: 0.12
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pressure_refrig_suction_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[51..58].load_le::<u8>();
        
        let factor = 0.12_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pressureRefrigSuctionEst
    #[inline(always)]
    pub fn set_vcfront_pressure_refrig_suction_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 14.36_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.12_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[51..58].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_ptLoopWorthCooling
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pt_loop_worth_cooling(&self) -> bool {
        self.vcfront_pt_loop_worth_cooling_raw()
    }
    
    /// Get raw value of VCFRONT_ptLoopWorthCooling
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pt_loop_worth_cooling_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_ptLoopWorthCooling
    #[inline(always)]
    pub fn set_vcfront_pt_loop_worth_cooling(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[16..17].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pumpBatteryFETTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump_battery_fet_temp(&self) -> Id381vcfrontLogging1HzVcfrontPumpBatteryFetTemp {
        match self.vcfront_pump_battery_fet_temp_raw() {
            255 => Id381vcfrontLogging1HzVcfrontPumpBatteryFetTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontPumpBatteryFetTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pumpBatteryFETTemp
    ///
    /// - Start bit: 36
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump_battery_fet_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[36..44].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pumpBatteryFETTemp
    #[inline(always)]
    pub fn set_vcfront_pump_battery_fet_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[36..44].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_pumpPowertrainFETTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_pump_powertrain_fet_temp(&self) -> Id381vcfrontLogging1HzVcfrontPumpPowertrainFetTemp {
        match self.vcfront_pump_powertrain_fet_temp_raw() {
            255 => Id381vcfrontLogging1HzVcfrontPumpPowertrainFetTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontPumpPowertrainFetTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_pumpPowertrainFETTemp
    ///
    /// - Start bit: 44
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_pump_powertrain_fet_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[44..52].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_pumpPowertrainFETTemp
    #[inline(always)]
    pub fn set_vcfront_pump_powertrain_fet_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[44..52].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radActiveRejectEstimate
    ///
    /// - Min: 0
    /// - Max: 30000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rad_active_reject_estimate(&self) -> u16 {
        self.vcfront_rad_active_reject_estimate_raw()
    }
    
    /// Get raw value of VCFRONT_radActiveRejectEstimate
    ///
    /// - Start bit: 49
    /// - Signal size: 15 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rad_active_reject_estimate_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[49..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_radActiveRejectEstimate
    #[inline(always)]
    pub fn set_vcfront_rad_active_reject_estimate(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 30000_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[49..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radPassiveRejectEstimate
    ///
    /// - Min: 0
    /// - Max: 15000
    /// - Unit: "W"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_rad_passive_reject_estimate(&self) -> u16 {
        self.vcfront_rad_passive_reject_estimate_raw()
    }
    
    /// Get raw value of VCFRONT_radPassiveRejectEstimate
    ///
    /// - Start bit: 5
    /// - Signal size: 14 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_rad_passive_reject_estimate_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<LocalBits>()[5..19].load_le::<u16>();
        
        signal
    }
    
    /// Set value of VCFRONT_radPassiveRejectEstimate
    #[inline(always)]
    pub fn set_vcfront_rad_passive_reject_estimate(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 15000_u16 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[5..19].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radiatorFanFETTemp
    ///
    /// - Min: -40
    /// - Max: 150
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_radiator_fan_fet_temp(&self) -> Id381vcfrontLogging1HzVcfrontRadiatorFanFetTemp {
        match self.vcfront_radiator_fan_fet_temp_raw() {
            255 => Id381vcfrontLogging1HzVcfrontRadiatorFanFetTemp::Sna,
            x => Id381vcfrontLogging1HzVcfrontRadiatorFanFetTemp::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_radiatorFanFETTemp
    ///
    /// - Start bit: 52
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_radiator_fan_fet_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[52..60].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_radiatorFanFETTemp
    #[inline(always)]
    pub fn set_vcfront_radiator_fan_fet_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 150_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[52..60].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_radiatorFanRunReason
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_radiator_fan_run_reason(&self) -> Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason {
        match self.vcfront_radiator_fan_run_reason_raw() {
            1 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::ActiveManager,
            2 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::AmbientSniff,
            5 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::CoastMode,
            4 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::HeatPump,
            6 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::MinOnGlobal,
            7 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::MinOnNvh,
            0 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::None,
            3 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::NvhMasking,
            8 => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::Uds,
            x => Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_radiatorFanRunReason
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_radiator_fan_run_reason_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_radiatorFanRunReason
    #[inline(always)]
    pub fn set_vcfront_radiator_fan_run_reason(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 8_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[60..64].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_recircExvCalibFailed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_recirc_exv_calib_failed(&self) -> bool {
        self.vcfront_recirc_exv_calib_failed_raw()
    }
    
    /// Get raw value of VCFRONT_recircExvCalibFailed
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_recirc_exv_calib_failed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_recircExvCalibFailed
    #[inline(always)]
    pub fn set_vcfront_recirc_exv_calib_failed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[58..59].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_recircExvCalibOffset
    ///
    /// - Min: -510
    /// - Max: 510
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_recirc_exv_calib_offset(&self) -> f32 {
        self.vcfront_recirc_exv_calib_offset_raw()
    }
    
    /// Get raw value of VCFRONT_recircExvCalibOffset
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_recirc_exv_calib_offset_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_recircExvCalibOffset
    #[inline(always)]
    pub fn set_vcfront_recirc_exv_calib_offset(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -510_f32 || 510_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_recircExvRange
    ///
    /// - Min: 0
    /// - Max: 1500
    /// - Unit: "ticks"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_recirc_exv_range(&self) -> f32 {
        self.vcfront_recirc_exv_range_raw()
    }
    
    /// Get raw value of VCFRONT_recircExvRange
    ///
    /// - Start bit: 23
    /// - Signal size: 9 bits
    /// - Factor: 3
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_recirc_exv_range_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[23..32].load_le::<u16>();
        
        let factor = 3_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_recircExvRange
    #[inline(always)]
    pub fn set_vcfront_recirc_exv_range(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 3_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[23..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_subcoolActual
    ///
    /// - Min: -10
    /// - Max: 40
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_subcool_actual(&self) -> f32 {
        self.vcfront_subcool_actual_raw()
    }
    
    /// Get raw value of VCFRONT_subcoolActual
    ///
    /// - Start bit: 5
    /// - Signal size: 7 bits
    /// - Factor: 0.4
    /// - Offset: 15.2
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn vcfront_subcool_actual_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[5..12].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.4_f32;
        let offset = 15.2_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_subcoolActual
    #[inline(always)]
    pub fn set_vcfront_subcool_actual(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10_f32 || 40_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.4_f32;
        let offset = 15.2_f32;
        let value = ((value - offset) / factor) as i8;
        
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<LocalBits>()[5..12].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_suctionPressureTarget
    ///
    /// - Min: 0
    /// - Max: 8
    /// - Unit: "bar"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_suction_pressure_target(&self) -> f32 {
        self.vcfront_suction_pressure_target_raw()
    }
    
    /// Get raw value of VCFRONT_suctionPressureTarget
    ///
    /// - Start bit: 32
    /// - Signal size: 6 bits
    /// - Factor: 0.15
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_suction_pressure_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[32..38].load_le::<u8>();
        
        let factor = 0.15_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_suctionPressureTarget
    #[inline(always)]
    pub fn set_vcfront_suction_pressure_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 8_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.15_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[32..38].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_suctionSuperheatEstPsSNA
    ///
    /// - Min: 0
    /// - Max: 30
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_suction_superheat_est_ps_sna(&self) -> f32 {
        self.vcfront_suction_superheat_est_ps_sna_raw()
    }
    
    /// Get raw value of VCFRONT_suctionSuperheatEstPsSNA
    ///
    /// - Start bit: 58
    /// - Signal size: 4 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_suction_superheat_est_ps_sna_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[58..62].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_suctionSuperheatEstPsSNA
    #[inline(always)]
    pub fn set_vcfront_suction_superheat_est_ps_sna(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 30_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[58..62].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_suctionSuperheatEstTsSNA
    ///
    /// - Min: 0
    /// - Max: 30
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_suction_superheat_est_ts_sna(&self) -> f32 {
        self.vcfront_suction_superheat_est_ts_sna_raw()
    }
    
    /// Get raw value of VCFRONT_suctionSuperheatEstTsSNA
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_suction_superheat_est_ts_sna_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..28].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_suctionSuperheatEstTsSNA
    #[inline(always)]
    pub fn set_vcfront_suction_superheat_est_ts_sna(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 30_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..28].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_targetBatActiveCool
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_target_bat_active_cool(&self) -> u8 {
        self.vcfront_target_bat_active_cool_raw()
    }
    
    /// Get raw value of VCFRONT_targetBatActiveCool
    ///
    /// - Start bit: 32
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_target_bat_active_cool_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..39].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_targetBatActiveCool
    #[inline(always)]
    pub fn set_vcfront_target_bat_active_cool(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..39].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_targetBatActiveHeat
    ///
    /// - Min: -40
    /// - Max: 60
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_target_bat_active_heat(&self) -> f32 {
        self.vcfront_target_bat_active_heat_raw()
    }
    
    /// Get raw value of VCFRONT_targetBatActiveHeat
    ///
    /// - Start bit: 48
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_target_bat_active_heat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..55].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_targetBatActiveHeat
    #[inline(always)]
    pub fn set_vcfront_target_bat_active_heat(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 60_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[48..55].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_targetBatPassive
    ///
    /// - Min: -20
    /// - Max: 80
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_target_bat_passive(&self) -> f32 {
        self.vcfront_target_bat_passive_raw()
    }
    
    /// Get raw value of VCFRONT_targetBatPassive
    ///
    /// - Start bit: 40
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: -20
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_target_bat_passive_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[40..47].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -20_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_targetBatPassive
    #[inline(always)]
    pub fn set_vcfront_target_bat_passive(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 80_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -20_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[40..47].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_targetPTActiveCool
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_target_pt_active_cool(&self) -> f32 {
        self.vcfront_target_pt_active_cool_raw()
    }
    
    /// Get raw value of VCFRONT_targetPTActiveCool
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_target_pt_active_cool_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_targetPTActiveCool
    #[inline(always)]
    pub fn set_vcfront_target_pt_active_cool(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_targetPTPassive
    ///
    /// - Min: -40
    /// - Max: 120
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_target_pt_passive(&self) -> f32 {
        self.vcfront_target_pt_passive_raw()
    }
    
    /// Get raw value of VCFRONT_targetPTPassive
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_target_pt_passive_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_targetPTPassive
    #[inline(always)]
    pub fn set_vcfront_target_pt_passive(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 120_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tempRefrigDischargeEst
    ///
    /// - Min: 0
    /// - Max: 125
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_temp_refrig_discharge_est(&self) -> f32 {
        self.vcfront_temp_refrig_discharge_est_raw()
    }
    
    /// Get raw value of VCFRONT_tempRefrigDischargeEst
    ///
    /// - Start bit: 29
    /// - Signal size: 6 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_temp_refrig_discharge_est_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[29..35].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_tempRefrigDischargeEst
    #[inline(always)]
    pub fn set_vcfront_temp_refrig_discharge_est(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 125_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[29..35].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tempRefrigSuction
    ///
    /// - Min: -40
    /// - Max: 85
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_temp_refrig_suction(&self) -> Id381vcfrontLogging1HzVcfrontTempRefrigSuction {
        match self.vcfront_temp_refrig_suction_raw() {
            255 => Id381vcfrontLogging1HzVcfrontTempRefrigSuction::Sna,
            x => Id381vcfrontLogging1HzVcfrontTempRefrigSuction::Other(x),
        }
    }
    
    /// Get raw value of VCFRONT_tempRefrigSuction
    ///
    /// - Start bit: 28
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_temp_refrig_suction_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[28..36].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_tempRefrigSuction
    #[inline(always)]
    pub fn set_vcfront_temp_refrig_suction(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 85_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<LocalBits>()[28..36].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_tempRefrigSuctionEst
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: "C"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_temp_refrig_suction_est(&self) -> u8 {
        self.vcfront_temp_refrig_suction_est_raw()
    }
    
    /// Get raw value of VCFRONT_tempRefrigSuctionEst
    ///
    /// - Start bit: 32
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_temp_refrig_suction_est_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VCFRONT_tempRefrigSuctionEst
    #[inline(always)]
    pub fn set_vcfront_temp_refrig_suction_est(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..38].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_totalLoadCoolingDominant
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_total_load_cooling_dominant(&self) -> bool {
        self.vcfront_total_load_cooling_dominant_raw()
    }
    
    /// Get raw value of VCFRONT_totalLoadCoolingDominant
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_total_load_cooling_dominant_raw(&self) -> bool {
        let signal = self.raw.view_bits::<LocalBits>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VCFRONT_totalLoadCoolingDominant
    #[inline(always)]
    pub fn set_vcfront_total_load_cooling_dominant(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<LocalBits>()[58..59].store_le(value);
        Ok(())
    }
    
    /// VCFRONT_wiperCycles
    ///
    /// - Min: 0
    /// - Max: 6553500
    /// - Unit: "Cycles"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn vcfront_wiper_cycles(&self) -> f32 {
        self.vcfront_wiper_cycles_raw()
    }
    
    /// Get raw value of VCFRONT_wiperCycles
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 100
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vcfront_wiper_cycles_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<LocalBits>()[48..64].load_le::<u16>();
        
        let factor = 100_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VCFRONT_wiperCycles
    #[inline(always)]
    pub fn set_vcfront_wiper_cycles(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 6553500_f32 < value { return Err(CanError::ParameterOutOfRange{ message_id: 897 }); }
        let factor = 100_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<LocalBits>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id381vcfrontLogging1Hz {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id381vcfrontLogging1Hz
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vcfront_logging1_hz_index = u.int_in_range(0..=19)?;
        let vcfront_cc_qdot_actual = 0_f32;
        let vcfront_cc_qdot_fd_frwrd_target = 0_f32;
        let vcfront_cc_qdot_fdbk = -5000_f32;
        let vcfront_cmp_discharge_superheat = -10_f32;
        let vcfront_di_qdot_a = 0_f32;
        let vcfront_hcml_blade_temp = -60_f32;
        let vcfront_hcml_diffuse_temp = -60_f32;
        let vcfront_hcml_high_beam_temp = -60_f32;
        let vcfront_hcml_low_beam_spot_temp = -60_f32;
        let vcfront_hcml_turn_temp = -60_f32;
        let vcfront_hcmr_blade_temp = -60_f32;
        let vcfront_hcmr_diffuse_temp = -60_f32;
        let vcfront_hcmr_high_beam_temp = -60_f32;
        let vcfront_hcmr_low_beam_spot_temp = -60_f32;
        let vcfront_hcmr_turn_temp = -60_f32;
        let vcfront_p_discharge_controller_outp = 0_f32;
        let vcfront_p_suction_controller_output = 0_f32;
        let vcfront_ambient_colder_than_batt = u.int_in_range(0..=1)? == 1;
        let vcfront_ambient_sourcing_available = u.int_in_range(0..=1)? == 1;
        let vcfront_ambient_sourcing_disabled = u.int_in_range(0..=1)? == 1;
        let vcfront_batt_dissipation = 0_f32;
        let vcfront_batt_loop_worth_cooling = u.int_in_range(0..=1)? == 1;
        let vcfront_batt_over_stag_upper_limit = u.int_in_range(0..=1)? == 1;
        let vcfront_batt_under_stag_upper_limit = u.int_in_range(0..=1)? == 1;
        let vcfront_cabin_heat_energy_during_dri = 0_f32;
        let vcfront_calibrated_position_hcml = u.int_in_range(0..=1023)?;
        let vcfront_calibrated_position_hcmr = u.int_in_range(0..=1023)?;
        let vcfront_cc_left_exv_calib_failed = u.int_in_range(0..=1)? == 1;
        let vcfront_cc_left_exv_calib_offset = -510_f32;
        let vcfront_cc_left_exv_range = 0_f32;
        let vcfront_cc_right_exv_calib_failed = u.int_in_range(0..=1)? == 1;
        let vcfront_cc_right_exv_calib_offset = -510_f32;
        let vcfront_cc_right_exv_range = 0_f32;
        let vcfront_chiller_exv_calib_failed = u.int_in_range(0..=1)? == 1;
        let vcfront_chiller_exv_calib_offset = -510_f32;
        let vcfront_chiller_exv_range = 0_f32;
        let vcfront_chiller_inlet_temp_estimate = u.int_in_range(-40..=85)?;
        let vcfront_chiller_lift_disabled_low_ps = u.int_in_range(0..=1)? == 1;
        let vcfront_chiller_passive_cool_power = 0_f32;
        let vcfront_comp_energy_during_drive = 0_f32;
        let vcfront_condenser_pressure_limit = 10_f32;
        let vcfront_coolant_level_voltage = 0_f32;
        let vcfront_coolant_valve_angle_drift = -127_f32;
        let vcfront_coolant_valve_count_range = 375_f32;
        let vcfront_coolant_valve_daily_angle_tr = 0_f32;
        let vcfront_coolant_valve_odometer = 0_f32;
        let vcfront_coolant_valve_rad_bypass = u.int_in_range(0..=100)?;
        let vcfront_coolant_valve_recal_count = u.int_in_range(0..=65535)?;
        let vcfront_coolant_valve_recal_reason = u.int_in_range(0..=7)?;
        let vcfront_coolant_valve_windup_est_l = 0_f32;
        let vcfront_coolant_valve_windup_est_r = 0_f32;
        let vcfront_current_position_hcml = u.int_in_range(0..=1023)?;
        let vcfront_current_position_hcmr = u.int_in_range(0..=1023)?;
        let vcfront_cycle_model_converged = u.int_in_range(0..=1)? == 1;
        let vcfront_di_dissipation = 0_f32;
        let vcfront_discharge_pressure_limit = 0_f32;
        let vcfront_discharge_pressure_target = 0_f32;
        let vcfront_drl_mode = u.int_in_range(0..=2)?;
        let vcfront_est_comp_power = 0_f32;
        let vcfront_est_comp_refrig_massflow = 0_f32;
        let vcfront_est_compressor_rpm = 0_f32;
        let vcfront_est_pressure_disch = 0_f32;
        let vcfront_est_pressure_liq = 0_f32;
        let vcfront_est_pressure_suct = 0_f32;
        let vcfront_est_q_lift = 0_f32;
        let vcfront_est_temp_disch = -34_f32;
        let vcfront_est_temp_liq = -34_f32;
        let vcfront_est_temp_suct = -30_f32;
        let vcfront_evap_disabled_low_ps_cutout = u.int_in_range(0..=1)? == 1;
        let vcfront_evap_exv_calib_failed = u.int_in_range(0..=1)? == 1;
        let vcfront_evap_exv_calib_offset = -510_f32;
        let vcfront_evap_exv_range = 0_f32;
        let vcfront_evap_fd_frwrd_target = 0_f32;
        let vcfront_evap_fd_frwrd_target_minimum = 0_f32;
        let vcfront_evap_fdbk = -5000_f32;
        let vcfront_exterior_quiet_mode_allowed = u.int_in_range(0..=1)? == 1;
        let vcfront_exterior_quiet_mode_enabled = u.int_in_range(0..=1)? == 1;
        let vcfront_fan_control_feedfwd_active = u.int_in_range(0..=1)? == 1;
        let vcfront_fan_control_rad_can_cool = u.int_in_range(0..=1)? == 1;
        let vcfront_fan_control_radiator_inlet_t = -20_f32;
        let vcfront_fan_control_radiator_ua = 0_f32;
        let vcfront_fan_demand_condenser = u.int_in_range(0..=100)?;
        let vcfront_fan_demand_radiator = u.int_in_range(0..=100)?;
        let vcfront_feed_back_duct_temp_controll = -100_f32;
        let vcfront_feed_back_evap_temp_controll = -0.5_f32;
        let vcfront_feed_fwd_fan_demand = u.int_in_range(0..=100)?;
        let vcfront_feed_fwd_m_dot_cabin_condense = 0_f32;
        let vcfront_feed_fwd_m_dot_evaporator = 0_f32;
        let vcfront_feed_fwd_pump_demand = u.int_in_range(0..=100)?;
        let vcfront_feedfwd_load_cooling_domina = u.int_in_range(0..=1)? == 1;
        let vcfront_homelink_region_code = u.int_in_range(0..=9)?;
        let vcfront_hp_ambient_source = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_at_steady_state = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_batt_over_temp_hvac_disabl = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_batt_stag_target = -40_f32;
        let vcfront_hp_battery_cool = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_battery_cool_cabin_conden = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_battery_cool_cabin_reheat = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_battery_cool_evaporator = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_battery_heat_ambient_sour = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_battery_heat_cop1 = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cop = 0_f32;
        let vcfront_hp_cabin_cool_evaporator = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_cool_evaporator_reh = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_ambient_source = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_battery_cool_re = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_battery_heat_re = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_blend = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_cop1 = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_reheat_ambient = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_reheat_scaveng = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_cabin_heat_scavenge_only = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_comp_power_index = u.int_in_range(0..=127)?;
        let vcfront_hp_comp_power_index_filtered = u.int_in_range(0..=127)?;
        let vcfront_hp_diag_louver_calib = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_force_scavenge = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_general = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_mode = u.int_in_range(0..=19)?;
        let vcfront_hp_potential_low_refrig = u.int_in_range(0..=1)? == 1;
        let vcfront_hp_refrigerant_purge_state = u.int_in_range(0..=2)?;
        let vcfront_hp_subcool_target = u.int_in_range(0..=31)?;
        let vcfront_lcc_active_cool_target = u.int_in_range(0..=100)?;
        let vcfront_lcc_exv_calib_failed = u.int_in_range(0..=1)? == 1;
        let vcfront_lcc_exv_calib_offset = -510_f32;
        let vcfront_lcc_exv_range = 0_f32;
        let vcfront_lcc_inlet_temp_estimate = u.int_in_range(-40..=85)?;
        let vcfront_lcc_passive_heat_power = 0_f32;
        let vcfront_low_side_lift_energy_drive = 0_f32;
        let vcfront_low_side_watts_lift = 0_f32;
        let vcfront_max_allowed_evap_power_in_ser = 0_f32;
        let vcfront_max_chiller_cooling_power = 0_f32;
        let vcfront_max_compressor_rpm_allowed = 0_f32;
        let vcfront_min_allowed_chiller_power_in = 0_f32;
        let vcfront_min_allowed_suction_pressur = 0_f32;
        let vcfront_min_flow_pd_cont = 0_f32;
        let vcfront_mode_desired = u.int_in_range(0..=3)?;
        let vcfront_mode_transition_id = u.int_in_range(0..=40)?;
        let vcfront_model_load_cooling_dominant = u.int_in_range(0..=1)? == 1;
        let vcfront_passive_cooling_state = u.int_in_range(0..=3)?;
        let vcfront_passive_demand_rad_bypass = u.int_in_range(0..=100)?;
        let vcfront_passive_series_reg_on = u.int_in_range(0..=1)? == 1;
        let vcfront_pressure_refrig_disch_est = u.int_in_range(0..=31)?;
        let vcfront_pressure_refrig_suction_est = 0_f32;
        let vcfront_pt_loop_worth_cooling = u.int_in_range(0..=1)? == 1;
        let vcfront_pump_battery_fet_temp = -40_f32;
        let vcfront_pump_powertrain_fet_temp = -40_f32;
        let vcfront_rad_active_reject_estimate = u.int_in_range(0..=30000)?;
        let vcfront_rad_passive_reject_estimate = u.int_in_range(0..=15000)?;
        let vcfront_radiator_fan_fet_temp = -40_f32;
        let vcfront_radiator_fan_run_reason = u.int_in_range(0..=8)?;
        let vcfront_recirc_exv_calib_failed = u.int_in_range(0..=1)? == 1;
        let vcfront_recirc_exv_calib_offset = -510_f32;
        let vcfront_recirc_exv_range = 0_f32;
        let vcfront_subcool_actual = -10_f32;
        let vcfront_suction_pressure_target = 0_f32;
        let vcfront_suction_superheat_est_ps_sna = 0_f32;
        let vcfront_suction_superheat_est_ts_sna = 0_f32;
        let vcfront_target_bat_active_cool = u.int_in_range(0..=100)?;
        let vcfront_target_bat_active_heat = -40_f32;
        let vcfront_target_bat_passive = -20_f32;
        let vcfront_target_pt_active_cool = -40_f32;
        let vcfront_target_pt_passive = -40_f32;
        let vcfront_temp_refrig_discharge_est = 0_f32;
        let vcfront_temp_refrig_suction = -40_f32;
        let vcfront_temp_refrig_suction_est = u.int_in_range(0..=63)?;
        let vcfront_total_load_cooling_dominant = u.int_in_range(0..=1)? == 1;
        let vcfront_wiper_cycles = 0_f32;
        Id381vcfrontLogging1Hz::new(vcfront_logging1_hz_index,vcfront_cc_qdot_actual,vcfront_cc_qdot_fd_frwrd_target,vcfront_cc_qdot_fdbk,vcfront_cmp_discharge_superheat,vcfront_di_qdot_a,vcfront_hcml_blade_temp,vcfront_hcml_diffuse_temp,vcfront_hcml_high_beam_temp,vcfront_hcml_low_beam_spot_temp,vcfront_hcml_turn_temp,vcfront_hcmr_blade_temp,vcfront_hcmr_diffuse_temp,vcfront_hcmr_high_beam_temp,vcfront_hcmr_low_beam_spot_temp,vcfront_hcmr_turn_temp,vcfront_p_discharge_controller_outp,vcfront_p_suction_controller_output,vcfront_ambient_colder_than_batt,vcfront_ambient_sourcing_available,vcfront_ambient_sourcing_disabled,vcfront_batt_dissipation,vcfront_batt_loop_worth_cooling,vcfront_batt_over_stag_upper_limit,vcfront_batt_under_stag_upper_limit,vcfront_cabin_heat_energy_during_dri,vcfront_calibrated_position_hcml,vcfront_calibrated_position_hcmr,vcfront_cc_left_exv_calib_failed,vcfront_cc_left_exv_calib_offset,vcfront_cc_left_exv_range,vcfront_cc_right_exv_calib_failed,vcfront_cc_right_exv_calib_offset,vcfront_cc_right_exv_range,vcfront_chiller_exv_calib_failed,vcfront_chiller_exv_calib_offset,vcfront_chiller_exv_range,vcfront_chiller_inlet_temp_estimate,vcfront_chiller_lift_disabled_low_ps,vcfront_chiller_passive_cool_power,vcfront_comp_energy_during_drive,vcfront_condenser_pressure_limit,vcfront_coolant_level_voltage,vcfront_coolant_valve_angle_drift,vcfront_coolant_valve_count_range,vcfront_coolant_valve_daily_angle_tr,vcfront_coolant_valve_odometer,vcfront_coolant_valve_rad_bypass,vcfront_coolant_valve_recal_count,vcfront_coolant_valve_recal_reason,vcfront_coolant_valve_windup_est_l,vcfront_coolant_valve_windup_est_r,vcfront_current_position_hcml,vcfront_current_position_hcmr,vcfront_cycle_model_converged,vcfront_di_dissipation,vcfront_discharge_pressure_limit,vcfront_discharge_pressure_target,vcfront_drl_mode,vcfront_est_comp_power,vcfront_est_comp_refrig_massflow,vcfront_est_compressor_rpm,vcfront_est_pressure_disch,vcfront_est_pressure_liq,vcfront_est_pressure_suct,vcfront_est_q_lift,vcfront_est_temp_disch,vcfront_est_temp_liq,vcfront_est_temp_suct,vcfront_evap_disabled_low_ps_cutout,vcfront_evap_exv_calib_failed,vcfront_evap_exv_calib_offset,vcfront_evap_exv_range,vcfront_evap_fd_frwrd_target,vcfront_evap_fd_frwrd_target_minimum,vcfront_evap_fdbk,vcfront_exterior_quiet_mode_allowed,vcfront_exterior_quiet_mode_enabled,vcfront_fan_control_feedfwd_active,vcfront_fan_control_rad_can_cool,vcfront_fan_control_radiator_inlet_t,vcfront_fan_control_radiator_ua,vcfront_fan_demand_condenser,vcfront_fan_demand_radiator,vcfront_feed_back_duct_temp_controll,vcfront_feed_back_evap_temp_controll,vcfront_feed_fwd_fan_demand,vcfront_feed_fwd_m_dot_cabin_condense,vcfront_feed_fwd_m_dot_evaporator,vcfront_feed_fwd_pump_demand,vcfront_feedfwd_load_cooling_domina,vcfront_homelink_region_code,vcfront_hp_ambient_source,vcfront_hp_at_steady_state,vcfront_hp_batt_over_temp_hvac_disabl,vcfront_hp_batt_stag_target,vcfront_hp_battery_cool,vcfront_hp_battery_cool_cabin_conden,vcfront_hp_battery_cool_cabin_reheat,vcfront_hp_battery_cool_evaporator,vcfront_hp_battery_heat_ambient_sour,vcfront_hp_battery_heat_cop1,vcfront_hp_cop,vcfront_hp_cabin_cool_evaporator,vcfront_hp_cabin_cool_evaporator_reh,vcfront_hp_cabin_heat_ambient_source,vcfront_hp_cabin_heat_battery_cool_re,vcfront_hp_cabin_heat_battery_heat_re,vcfront_hp_cabin_heat_blend,vcfront_hp_cabin_heat_cop1,vcfront_hp_cabin_heat_reheat_ambient,vcfront_hp_cabin_heat_reheat_scaveng,vcfront_hp_cabin_heat_scavenge_only,vcfront_hp_comp_power_index,vcfront_hp_comp_power_index_filtered,vcfront_hp_diag_louver_calib,vcfront_hp_force_scavenge,vcfront_hp_general,vcfront_hp_mode,vcfront_hp_potential_low_refrig,vcfront_hp_refrigerant_purge_state,vcfront_hp_subcool_target,vcfront_lcc_active_cool_target,vcfront_lcc_exv_calib_failed,vcfront_lcc_exv_calib_offset,vcfront_lcc_exv_range,vcfront_lcc_inlet_temp_estimate,vcfront_lcc_passive_heat_power,vcfront_low_side_lift_energy_drive,vcfront_low_side_watts_lift,vcfront_max_allowed_evap_power_in_ser,vcfront_max_chiller_cooling_power,vcfront_max_compressor_rpm_allowed,vcfront_min_allowed_chiller_power_in,vcfront_min_allowed_suction_pressur,vcfront_min_flow_pd_cont,vcfront_mode_desired,vcfront_mode_transition_id,vcfront_model_load_cooling_dominant,vcfront_passive_cooling_state,vcfront_passive_demand_rad_bypass,vcfront_passive_series_reg_on,vcfront_pressure_refrig_disch_est,vcfront_pressure_refrig_suction_est,vcfront_pt_loop_worth_cooling,vcfront_pump_battery_fet_temp,vcfront_pump_powertrain_fet_temp,vcfront_rad_active_reject_estimate,vcfront_rad_passive_reject_estimate,vcfront_radiator_fan_fet_temp,vcfront_radiator_fan_run_reason,vcfront_recirc_exv_calib_failed,vcfront_recirc_exv_calib_offset,vcfront_recirc_exv_range,vcfront_subcool_actual,vcfront_suction_pressure_target,vcfront_suction_superheat_est_ps_sna,vcfront_suction_superheat_est_ts_sna,vcfront_target_bat_active_cool,vcfront_target_bat_active_heat,vcfront_target_bat_passive,vcfront_target_pt_active_cool,vcfront_target_pt_passive,vcfront_temp_refrig_discharge_est,vcfront_temp_refrig_suction,vcfront_temp_refrig_suction_est,vcfront_total_load_cooling_dominant,vcfront_wiper_cycles).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for VCFRONT_logging1HzIndex
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontLogging1HzIndex {
    BodyControl,
    Coolant,
    Coolant2,
    CoolantValve,
    End,
    FanDemandCondenserAndFetTemps,
    HcmlLedTemps,
    HcmrLedTemps,
    HeadlampAim,
    Homelink,
    HpArbitration,
    HpControlLoopAndState,
    HpCycleModel,
    HpDataAndAccumulators,
    HpDissipationAndPower,
    HpExvCalibration,
    HpExvRange,
    HpModeOptionsAndEstimates,
    HpModeSelectAndEstimates,
    HpPressureControl,
    HpTempsAndDemands,
    Other(u8),
}
/// Defined values for VCFRONT_HCML_bladeTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmlBladeTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCML_diffuseTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmlDiffuseTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCML_highBeamTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmlHighBeamTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCML_lowBeamSpotTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmlLowBeamSpotTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCML_turnTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmlTurnTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCMR_bladeTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmrBladeTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCMR_diffuseTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmrDiffuseTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCMR_highBeamTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmrHighBeamTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCMR_lowBeamSpotTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmrLowBeamSpotTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_HCMR_turnTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHcmrTurnTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_coolantValveCountRange
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontCoolantValveCountRange {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_coolantValveRadBypass
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontCoolantValveRadBypass {
    Sna,
    Other(u8),
}
/// Defined values for VCFRONT_coolantValveRecalReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontCoolantValveRecalReason {
    CalibrationFaultNoTravel,
    GeneralFault,
    MaxTravel,
    MotorFeedbackInterrupted,
    NvramLoss,
    SelfTest,
    SystemLevelFaultResponse,
    Undefined,
    Other(u8),
}
/// Defined values for VCFRONT_drlMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontDrlMode {
    DrlModeDrl,
    DrlModeOff,
    DrlModePosition,
    Other(u8),
}
/// Defined values for VCFRONT_homelinkRegionCode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHomelinkRegionCode {
    HomelinkRegionCodeAmericas,
    HomelinkRegionCodeChina,
    HomelinkRegionCodeEurope,
    HomelinkRegionCodeRestOfWorld,
    HomelinkRegionCodeUnknown,
    Other(u8),
}
/// Defined values for VCFRONT_hpMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHpMode {
    AmbientSource,
    BatteryCool,
    BatteryCoolCabinCondenser,
    BatteryCoolCabinCondenserReheat,
    BatteryCoolCabinReheat,
    BatteryCoolEvaporator,
    BatteryHeatAmbientSource,
    BatteryHeatCop1,
    CabinCoolEvaporator,
    CabinCoolEvaporatorReheat,
    CabinHeatAmbientSource,
    CabinHeatBatteryCoolReheat,
    CabinHeatBatteryHeatReheatAmbientSource,
    CabinHeatBlend,
    CabinHeatCop1,
    CabinHeatReheatAmbientSource,
    CabinHeatReheatScavenge,
    CabinHeatScavengeOnly,
    General,
    None,
    Other(u8),
}
/// Defined values for VCFRONT_hpRefrigerantPurgeState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontHpRefrigerantPurgeState {
    Complete,
    EvapPurge,
    Idle,
    Other(u8),
}
/// Defined values for VCFRONT_modeDesired
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontModeDesired {
    AmbientSource,
    Blend,
    Parallel,
    Series,
    Other(u8),
}
/// Defined values for VCFRONT_modeTransitionID
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontModeTransitionId {
    EnterAmbientsource,
    ExitAmbientsource,
    Init,
    Override,
    Parallel2DriveBatteryWantsHeat,
    Parallel3DriveBatteryWantsCool,
    Parallel4DriveBatteryNeedsCool,
    Parallel5ChargeBatteryWantsHeat,
    Parallel6ChargeBatteryWantsCool,
    Parallel7FastChargeBatteryWantsCool,
    Parallel8FastChargeBatteryWantsHeat,
    Parallel9DriveBatteryThermalLimiting,
    ParallelF1NoFlowRequest,
    Par1DriveBattNeedsActiveCoolingEvapDisabled,
    Par2DrivePtNeedsActiveCooling,
    Par3DriveChillerPassivelyCoolsBatt,
    Par4DriveCannotPassivelyCoolBatt,
    Par5DriveBattAboveHotStagnationTemp,
    Par6FcBattNeedsActiveCoolingEvapDisabled,
    Par7FcBattNeedsActiveCoolingEvapEnabled,
    Par8ChargeBattAbovePassiveTarget,
    Series1DriveBatteryWantsCool,
    Series2DriveBatteryNeedsHeat,
    Series3DriveBatteryWantsHeat,
    Series4ChargeBatteryNeedsHeat,
    Series5ChargeBatteryWantsHeat,
    Series6FastChargeBatteryNeedsHeat,
    Series7FastChargeBatteryWantsCool,
    Series8PreConditioningBatteryNeedsHeat,
    Series9DriveDriveUnitThermalLimiting,
    SeriesF2FaultPumps,
    SeriesF3FaultTempSensors,
    Ser1DriveBattNeedsActiveCoolingEvapEnabled,
    Ser2DriveBattBelowHotStagnationTemp,
    Ser3DriveChillerPassivelyCools,
    Ser4DriveRadPassivelyCoolsBatt,
    Ser5FcBattHeatingNeeded,
    Ser6FcBattNeedsActiveCoolingEvapDisabled,
    Ser7FcBattNeedsActiveCoolingEvapEnabled,
    Ser8ChargeBattBelowPassiveTarget,
    Undefined,
    Other(u8),
}
/// Defined values for VCFRONT_passiveCoolingState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontPassiveCoolingState {
    CannotCoolBattery,
    ChillerAndRadCoolSeriesLoop,
    ChillerCoolsParallelBattLoop,
    ChillerCoolsSeriesLoop,
    Other(u8),
}
/// Defined values for VCFRONT_pumpBatteryFETTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontPumpBatteryFetTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_pumpPowertrainFETTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontPumpPowertrainFetTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_radiatorFanFETTemp
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontRadiatorFanFetTemp {
    Sna,
    Other(f32),
}
/// Defined values for VCFRONT_radiatorFanRunReason
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontRadiatorFanRunReason {
    ActiveManager,
    AmbientSniff,
    CoastMode,
    HeatPump,
    MinOnGlobal,
    MinOnNvh,
    None,
    NvhMasking,
    Uds,
    Other(u8),
}
/// Defined values for VCFRONT_tempRefrigSuction
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Id381vcfrontLogging1HzVcfrontTempRefrigSuction {
    Sna,
    Other(f32),
}

/// ID318SystemTimeUTC
///
/// - ID: 792 (0x318)
/// - Size: 8 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id318SystemTimeUtc {
    raw: [u8; 8],
}

impl Id318SystemTimeUtc {
    pub const MESSAGE_ID: u32 = 792;
    
    /// Construct new ID318SystemTimeUTC from values
    pub fn new(ut_cyear318: u8, ut_cmonth318: u8, ut_cseconds318: u8, ut_chour318: u8, ut_cday318: u8, ut_cminutes318: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ut_cyear318(ut_cyear318)?;
        res.set_ut_cmonth318(ut_cmonth318)?;
        res.set_ut_cseconds318(ut_cseconds318)?;
        res.set_ut_chour318(ut_chour318)?;
        res.set_ut_cday318(ut_cday318)?;
        res.set_ut_cminutes318(ut_cminutes318)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UTCyear318
    ///
    /// Year
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "yr"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ut_cyear318(&self) -> u8 {
        self.ut_cyear318_raw()
    }
    
    /// Get raw value of UTCyear318
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ut_cyear318_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UTCyear318
    #[inline(always)]
    pub fn set_ut_cyear318(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 792 }); }
        self.raw.view_bits_mut::<LocalBits>()[0..8].store_le(value);
        Ok(())
    }
    
    /// UTCmonth318
    ///
    /// Month
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "mo"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ut_cmonth318(&self) -> u8 {
        self.ut_cmonth318_raw()
    }
    
    /// Get raw value of UTCmonth318
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ut_cmonth318_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UTCmonth318
    #[inline(always)]
    pub fn set_ut_cmonth318(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 792 }); }
        self.raw.view_bits_mut::<LocalBits>()[8..16].store_le(value);
        Ok(())
    }
    
    /// UTCseconds318
    ///
    /// Seconds
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "sec"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ut_cseconds318(&self) -> u8 {
        self.ut_cseconds318_raw()
    }
    
    /// Get raw value of UTCseconds318
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ut_cseconds318_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UTCseconds318
    #[inline(always)]
    pub fn set_ut_cseconds318(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 792 }); }
        self.raw.view_bits_mut::<LocalBits>()[16..24].store_le(value);
        Ok(())
    }
    
    /// UTChour318
    ///
    /// Hour
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "hr"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ut_chour318(&self) -> u8 {
        self.ut_chour318_raw()
    }
    
    /// Get raw value of UTChour318
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ut_chour318_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UTChour318
    #[inline(always)]
    pub fn set_ut_chour318(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 792 }); }
        self.raw.view_bits_mut::<LocalBits>()[24..32].store_le(value);
        Ok(())
    }
    
    /// UTCday318
    ///
    /// Day
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "dy"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ut_cday318(&self) -> u8 {
        self.ut_cday318_raw()
    }
    
    /// Get raw value of UTCday318
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ut_cday318_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UTCday318
    #[inline(always)]
    pub fn set_ut_cday318(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 792 }); }
        self.raw.view_bits_mut::<LocalBits>()[32..40].store_le(value);
        Ok(())
    }
    
    /// UTCminutes318
    ///
    /// Minute
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "min"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn ut_cminutes318(&self) -> u8 {
        self.ut_cminutes318_raw()
    }
    
    /// Get raw value of UTCminutes318
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ut_cminutes318_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<LocalBits>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UTCminutes318
    #[inline(always)]
    pub fn set_ut_cminutes318(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value { return Err(CanError::ParameterOutOfRange{ message_id: 792 }); }
        self.raw.view_bits_mut::<LocalBits>()[40..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Id318SystemTimeUtc {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Id318SystemTimeUtc
{
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ut_cyear318 = u.int_in_range(0..=0)?;
        let ut_cmonth318 = u.int_in_range(0..=0)?;
        let ut_cseconds318 = u.int_in_range(0..=0)?;
        let ut_chour318 = u.int_in_range(0..=0)?;
        let ut_cday318 = u.int_in_range(0..=0)?;
        let ut_cminutes318 = u.int_in_range(0..=0)?;
        Id318SystemTimeUtc::new(ut_cyear318,ut_cmonth318,ut_cseconds318,ut_chour318,ut_cday318,ut_cminutes318).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ID528UnixTime
///
/// - ID: 1320 (0x528)
/// - Size: 4 bytes
/// - Transmitter: VehicleBus
#[derive(Clone, Copy)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Id528UnixTime {
    raw: [u8; 4],
}

impl Id528UnixTime {
    pub const MESSAGE_ID: u32 = 1320;
    
    /// Construct new ID528UnixTime from values
    pub fn new(unix_time_seconds528: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_unix_time_seconds528(unix_time_seconds528)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }
    
    /// UnixTimeSeconds528
    ///
    /// Unix Time
    ///
    /// - Min: 0
    /// - Max: 4294970000
    /// - Unit: "sec"
    /// - Receivers: Receiver
    #[inline(always)]
    pub fn unix_time_seconds528(&self) -> u32 {
        self.unix_time_seconds528_raw()
    }
    
    /// Get raw value of UnixTimeSeconds528
    ///
    /// - Start bit: 7
    /// - Signal size: 32 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn unix_time_seconds528_raw(&self) -> u32 {
